// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc.proto

package co.anode.anodium;

public final class Rpc {
  private Rpc() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  /**
   * <pre>
   *`AddressType` has to be one of:
   *- `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)
   *- `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)
   * </pre>
   *
   * Protobuf enum {@code co.anode.anodium.AddressType}
   */
  public enum AddressType
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <code>WITNESS_PUBKEY_HASH = 0;</code>
     */
    WITNESS_PUBKEY_HASH(0),
    /**
     * <code>NESTED_PUBKEY_HASH = 1;</code>
     */
    NESTED_PUBKEY_HASH(1),
    /**
     * <code>UNUSED_WITNESS_PUBKEY_HASH = 2;</code>
     */
    UNUSED_WITNESS_PUBKEY_HASH(2),
    /**
     * <code>UNUSED_NESTED_PUBKEY_HASH = 3;</code>
     */
    UNUSED_NESTED_PUBKEY_HASH(3),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>WITNESS_PUBKEY_HASH = 0;</code>
     */
    public static final int WITNESS_PUBKEY_HASH_VALUE = 0;
    /**
     * <code>NESTED_PUBKEY_HASH = 1;</code>
     */
    public static final int NESTED_PUBKEY_HASH_VALUE = 1;
    /**
     * <code>UNUSED_WITNESS_PUBKEY_HASH = 2;</code>
     */
    public static final int UNUSED_WITNESS_PUBKEY_HASH_VALUE = 2;
    /**
     * <code>UNUSED_NESTED_PUBKEY_HASH = 3;</code>
     */
    public static final int UNUSED_NESTED_PUBKEY_HASH_VALUE = 3;


    @java.lang.Override
    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AddressType valueOf(int value) {
      return forNumber(value);
    }

    public static AddressType forNumber(int value) {
      switch (value) {
        case 0: return WITNESS_PUBKEY_HASH;
        case 1: return NESTED_PUBKEY_HASH;
        case 2: return UNUSED_WITNESS_PUBKEY_HASH;
        case 3: return UNUSED_NESTED_PUBKEY_HASH;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AddressType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        AddressType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<AddressType>() {
            @java.lang.Override
            public AddressType findValueByNumber(int number) {
              return AddressType.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return AddressTypeVerifier.INSTANCE;
    }

    private static final class AddressTypeVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new AddressTypeVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return AddressType.forNumber(number) != null;
            }
          };

    private final int value;

    private AddressType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:co.anode.anodium.AddressType)
  }

  /**
   * Protobuf enum {@code co.anode.anodium.CommitmentType}
   */
  public enum CommitmentType
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <pre>
     *A channel using the legacy commitment format having tweaked to_remote
     *keys.
     * </pre>
     *
     * <code>LEGACY = 0;</code>
     */
    LEGACY(0),
    /**
     * <pre>
     *A channel that uses the modern commitment format where the key in the
     *output of the remote party does not change each state. This makes back
     *up and recovery easier as when the channel is closed, the funds go
     *directly to that key.
     * </pre>
     *
     * <code>STATIC_REMOTE_KEY = 1;</code>
     */
    STATIC_REMOTE_KEY(1),
    /**
     * <pre>
     *A channel that uses a commitment format that has anchor outputs on the
     *commitments, allowing fee bumping after a force close transaction has
     *been broadcast.
     * </pre>
     *
     * <code>ANCHORS = 2;</code>
     */
    ANCHORS(2),
    /**
     * <pre>
     *Returned when the commitment type isn't known or unavailable.
     * </pre>
     *
     * <code>UNKNOWN_COMMITMENT_TYPE = 999;</code>
     */
    UNKNOWN_COMMITMENT_TYPE(999),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     *A channel using the legacy commitment format having tweaked to_remote
     *keys.
     * </pre>
     *
     * <code>LEGACY = 0;</code>
     */
    public static final int LEGACY_VALUE = 0;
    /**
     * <pre>
     *A channel that uses the modern commitment format where the key in the
     *output of the remote party does not change each state. This makes back
     *up and recovery easier as when the channel is closed, the funds go
     *directly to that key.
     * </pre>
     *
     * <code>STATIC_REMOTE_KEY = 1;</code>
     */
    public static final int STATIC_REMOTE_KEY_VALUE = 1;
    /**
     * <pre>
     *A channel that uses a commitment format that has anchor outputs on the
     *commitments, allowing fee bumping after a force close transaction has
     *been broadcast.
     * </pre>
     *
     * <code>ANCHORS = 2;</code>
     */
    public static final int ANCHORS_VALUE = 2;
    /**
     * <pre>
     *Returned when the commitment type isn't known or unavailable.
     * </pre>
     *
     * <code>UNKNOWN_COMMITMENT_TYPE = 999;</code>
     */
    public static final int UNKNOWN_COMMITMENT_TYPE_VALUE = 999;


    @java.lang.Override
    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static CommitmentType valueOf(int value) {
      return forNumber(value);
    }

    public static CommitmentType forNumber(int value) {
      switch (value) {
        case 0: return LEGACY;
        case 1: return STATIC_REMOTE_KEY;
        case 2: return ANCHORS;
        case 999: return UNKNOWN_COMMITMENT_TYPE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<CommitmentType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        CommitmentType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<CommitmentType>() {
            @java.lang.Override
            public CommitmentType findValueByNumber(int number) {
              return CommitmentType.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return CommitmentTypeVerifier.INSTANCE;
    }

    private static final class CommitmentTypeVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new CommitmentTypeVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return CommitmentType.forNumber(number) != null;
            }
          };

    private final int value;

    private CommitmentType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:co.anode.anodium.CommitmentType)
  }

  /**
   * Protobuf enum {@code co.anode.anodium.Initiator}
   */
  public enum Initiator
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <code>INITIATOR_UNKNOWN = 0;</code>
     */
    INITIATOR_UNKNOWN(0),
    /**
     * <code>INITIATOR_LOCAL = 1;</code>
     */
    INITIATOR_LOCAL(1),
    /**
     * <code>INITIATOR_REMOTE = 2;</code>
     */
    INITIATOR_REMOTE(2),
    /**
     * <code>INITIATOR_BOTH = 3;</code>
     */
    INITIATOR_BOTH(3),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>INITIATOR_UNKNOWN = 0;</code>
     */
    public static final int INITIATOR_UNKNOWN_VALUE = 0;
    /**
     * <code>INITIATOR_LOCAL = 1;</code>
     */
    public static final int INITIATOR_LOCAL_VALUE = 1;
    /**
     * <code>INITIATOR_REMOTE = 2;</code>
     */
    public static final int INITIATOR_REMOTE_VALUE = 2;
    /**
     * <code>INITIATOR_BOTH = 3;</code>
     */
    public static final int INITIATOR_BOTH_VALUE = 3;


    @java.lang.Override
    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static Initiator valueOf(int value) {
      return forNumber(value);
    }

    public static Initiator forNumber(int value) {
      switch (value) {
        case 0: return INITIATOR_UNKNOWN;
        case 1: return INITIATOR_LOCAL;
        case 2: return INITIATOR_REMOTE;
        case 3: return INITIATOR_BOTH;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<Initiator>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        Initiator> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<Initiator>() {
            @java.lang.Override
            public Initiator findValueByNumber(int number) {
              return Initiator.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return InitiatorVerifier.INSTANCE;
    }

    private static final class InitiatorVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new InitiatorVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return Initiator.forNumber(number) != null;
            }
          };

    private final int value;

    private Initiator(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:co.anode.anodium.Initiator)
  }

  /**
   * Protobuf enum {@code co.anode.anodium.ResolutionType}
   */
  public enum ResolutionType
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <code>TYPE_UNKNOWN = 0;</code>
     */
    TYPE_UNKNOWN(0),
    /**
     * <pre>
     * We resolved an anchor output.
     * </pre>
     *
     * <code>ANCHOR = 1;</code>
     */
    ANCHOR(1),
    /**
     * <pre>
     *We are resolving an incoming htlc on chain. This if this htlc is
     *claimed, we swept the incoming htlc with the preimage. If it is timed
     *out, our peer swept the timeout path.
     * </pre>
     *
     * <code>INCOMING_HTLC = 2;</code>
     */
    INCOMING_HTLC(2),
    /**
     * <pre>
     *We are resolving an outgoing htlc on chain. If this htlc is claimed,
     *the remote party swept the htlc with the preimage. If it is timed out,
     *we swept it with the timeout path.
     * </pre>
     *
     * <code>OUTGOING_HTLC = 3;</code>
     */
    OUTGOING_HTLC(3),
    /**
     * <pre>
     * We force closed and need to sweep our time locked commitment output.
     * </pre>
     *
     * <code>COMMIT = 4;</code>
     */
    COMMIT(4),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>TYPE_UNKNOWN = 0;</code>
     */
    public static final int TYPE_UNKNOWN_VALUE = 0;
    /**
     * <pre>
     * We resolved an anchor output.
     * </pre>
     *
     * <code>ANCHOR = 1;</code>
     */
    public static final int ANCHOR_VALUE = 1;
    /**
     * <pre>
     *We are resolving an incoming htlc on chain. This if this htlc is
     *claimed, we swept the incoming htlc with the preimage. If it is timed
     *out, our peer swept the timeout path.
     * </pre>
     *
     * <code>INCOMING_HTLC = 2;</code>
     */
    public static final int INCOMING_HTLC_VALUE = 2;
    /**
     * <pre>
     *We are resolving an outgoing htlc on chain. If this htlc is claimed,
     *the remote party swept the htlc with the preimage. If it is timed out,
     *we swept it with the timeout path.
     * </pre>
     *
     * <code>OUTGOING_HTLC = 3;</code>
     */
    public static final int OUTGOING_HTLC_VALUE = 3;
    /**
     * <pre>
     * We force closed and need to sweep our time locked commitment output.
     * </pre>
     *
     * <code>COMMIT = 4;</code>
     */
    public static final int COMMIT_VALUE = 4;


    @java.lang.Override
    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ResolutionType valueOf(int value) {
      return forNumber(value);
    }

    public static ResolutionType forNumber(int value) {
      switch (value) {
        case 0: return TYPE_UNKNOWN;
        case 1: return ANCHOR;
        case 2: return INCOMING_HTLC;
        case 3: return OUTGOING_HTLC;
        case 4: return COMMIT;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ResolutionType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ResolutionType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ResolutionType>() {
            @java.lang.Override
            public ResolutionType findValueByNumber(int number) {
              return ResolutionType.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return ResolutionTypeVerifier.INSTANCE;
    }

    private static final class ResolutionTypeVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new ResolutionTypeVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return ResolutionType.forNumber(number) != null;
            }
          };

    private final int value;

    private ResolutionType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:co.anode.anodium.ResolutionType)
  }

  /**
   * Protobuf enum {@code co.anode.anodium.ResolutionOutcome}
   */
  public enum ResolutionOutcome
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <pre>
     * Outcome unknown.
     * </pre>
     *
     * <code>OUTCOME_UNKNOWN = 0;</code>
     */
    OUTCOME_UNKNOWN(0),
    /**
     * <pre>
     * An output was claimed on chain.
     * </pre>
     *
     * <code>CLAIMED = 1;</code>
     */
    CLAIMED(1),
    /**
     * <pre>
     * An output was left unclaimed on chain.
     * </pre>
     *
     * <code>UNCLAIMED = 2;</code>
     */
    UNCLAIMED(2),
    /**
     * <pre>
     *ResolverOutcomeAbandoned indicates that an output that we did not
     *claim on chain, for example an anchor that we did not sweep and a
     *third party claimed on chain, or a htlc that we could not decode
     *so left unclaimed.
     * </pre>
     *
     * <code>ABANDONED = 3;</code>
     */
    ABANDONED(3),
    /**
     * <pre>
     *If we force closed our channel, our htlcs need to be claimed in two
     *stages. This outcome represents the broadcast of a timeout or success
     *transaction for this two stage htlc claim.
     * </pre>
     *
     * <code>FIRST_STAGE = 4;</code>
     */
    FIRST_STAGE(4),
    /**
     * <pre>
     * A htlc was timed out on chain.
     * </pre>
     *
     * <code>TIMEOUT = 5;</code>
     */
    TIMEOUT(5),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Outcome unknown.
     * </pre>
     *
     * <code>OUTCOME_UNKNOWN = 0;</code>
     */
    public static final int OUTCOME_UNKNOWN_VALUE = 0;
    /**
     * <pre>
     * An output was claimed on chain.
     * </pre>
     *
     * <code>CLAIMED = 1;</code>
     */
    public static final int CLAIMED_VALUE = 1;
    /**
     * <pre>
     * An output was left unclaimed on chain.
     * </pre>
     *
     * <code>UNCLAIMED = 2;</code>
     */
    public static final int UNCLAIMED_VALUE = 2;
    /**
     * <pre>
     *ResolverOutcomeAbandoned indicates that an output that we did not
     *claim on chain, for example an anchor that we did not sweep and a
     *third party claimed on chain, or a htlc that we could not decode
     *so left unclaimed.
     * </pre>
     *
     * <code>ABANDONED = 3;</code>
     */
    public static final int ABANDONED_VALUE = 3;
    /**
     * <pre>
     *If we force closed our channel, our htlcs need to be claimed in two
     *stages. This outcome represents the broadcast of a timeout or success
     *transaction for this two stage htlc claim.
     * </pre>
     *
     * <code>FIRST_STAGE = 4;</code>
     */
    public static final int FIRST_STAGE_VALUE = 4;
    /**
     * <pre>
     * A htlc was timed out on chain.
     * </pre>
     *
     * <code>TIMEOUT = 5;</code>
     */
    public static final int TIMEOUT_VALUE = 5;


    @java.lang.Override
    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ResolutionOutcome valueOf(int value) {
      return forNumber(value);
    }

    public static ResolutionOutcome forNumber(int value) {
      switch (value) {
        case 0: return OUTCOME_UNKNOWN;
        case 1: return CLAIMED;
        case 2: return UNCLAIMED;
        case 3: return ABANDONED;
        case 4: return FIRST_STAGE;
        case 5: return TIMEOUT;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ResolutionOutcome>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ResolutionOutcome> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ResolutionOutcome>() {
            @java.lang.Override
            public ResolutionOutcome findValueByNumber(int number) {
              return ResolutionOutcome.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return ResolutionOutcomeVerifier.INSTANCE;
    }

    private static final class ResolutionOutcomeVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new ResolutionOutcomeVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return ResolutionOutcome.forNumber(number) != null;
            }
          };

    private final int value;

    private ResolutionOutcome(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:co.anode.anodium.ResolutionOutcome)
  }

  /**
   * Protobuf enum {@code co.anode.anodium.NodeMetricType}
   */
  public enum NodeMetricType
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <code>UNKNOWN = 0;</code>
     */
    UNKNOWN(0),
    /**
     * <code>BETWEENNESS_CENTRALITY = 1;</code>
     */
    BETWEENNESS_CENTRALITY(1),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>UNKNOWN = 0;</code>
     */
    public static final int UNKNOWN_VALUE = 0;
    /**
     * <code>BETWEENNESS_CENTRALITY = 1;</code>
     */
    public static final int BETWEENNESS_CENTRALITY_VALUE = 1;


    @java.lang.Override
    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static NodeMetricType valueOf(int value) {
      return forNumber(value);
    }

    public static NodeMetricType forNumber(int value) {
      switch (value) {
        case 0: return UNKNOWN;
        case 1: return BETWEENNESS_CENTRALITY;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<NodeMetricType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        NodeMetricType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<NodeMetricType>() {
            @java.lang.Override
            public NodeMetricType findValueByNumber(int number) {
              return NodeMetricType.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return NodeMetricTypeVerifier.INSTANCE;
    }

    private static final class NodeMetricTypeVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new NodeMetricTypeVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return NodeMetricType.forNumber(number) != null;
            }
          };

    private final int value;

    private NodeMetricType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:co.anode.anodium.NodeMetricType)
  }

  /**
   * Protobuf enum {@code co.anode.anodium.InvoiceHTLCState}
   */
  public enum InvoiceHTLCState
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <code>ACCEPTED = 0;</code>
     */
    ACCEPTED(0),
    /**
     * <code>SETTLED = 1;</code>
     */
    SETTLED(1),
    /**
     * <code>CANCELED = 2;</code>
     */
    CANCELED(2),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>ACCEPTED = 0;</code>
     */
    public static final int ACCEPTED_VALUE = 0;
    /**
     * <code>SETTLED = 1;</code>
     */
    public static final int SETTLED_VALUE = 1;
    /**
     * <code>CANCELED = 2;</code>
     */
    public static final int CANCELED_VALUE = 2;


    @java.lang.Override
    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static InvoiceHTLCState valueOf(int value) {
      return forNumber(value);
    }

    public static InvoiceHTLCState forNumber(int value) {
      switch (value) {
        case 0: return ACCEPTED;
        case 1: return SETTLED;
        case 2: return CANCELED;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<InvoiceHTLCState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        InvoiceHTLCState> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<InvoiceHTLCState>() {
            @java.lang.Override
            public InvoiceHTLCState findValueByNumber(int number) {
              return InvoiceHTLCState.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return InvoiceHTLCStateVerifier.INSTANCE;
    }

    private static final class InvoiceHTLCStateVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new InvoiceHTLCStateVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return InvoiceHTLCState.forNumber(number) != null;
            }
          };

    private final int value;

    private InvoiceHTLCState(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:co.anode.anodium.InvoiceHTLCState)
  }

  /**
   * Protobuf enum {@code co.anode.anodium.PaymentFailureReason}
   */
  public enum PaymentFailureReason
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <pre>
     *Payment isn't failed (yet).
     * </pre>
     *
     * <code>FAILURE_REASON_NONE = 0;</code>
     */
    FAILURE_REASON_NONE(0),
    /**
     * <pre>
     *There are more routes to try, but the payment timeout was exceeded.
     * </pre>
     *
     * <code>FAILURE_REASON_TIMEOUT = 1;</code>
     */
    FAILURE_REASON_TIMEOUT(1),
    /**
     * <pre>
     *All possible routes were tried and failed permanently. Or were no
     *routes to the destination at all.
     * </pre>
     *
     * <code>FAILURE_REASON_NO_ROUTE = 2;</code>
     */
    FAILURE_REASON_NO_ROUTE(2),
    /**
     * <pre>
     *A non-recoverable error has occured.
     * </pre>
     *
     * <code>FAILURE_REASON_ERROR = 3;</code>
     */
    FAILURE_REASON_ERROR(3),
    /**
     * <pre>
     *Payment details incorrect (unknown hash, invalid amt or
     *invalid final cltv delta)
     * </pre>
     *
     * <code>FAILURE_REASON_INCORRECT_PAYMENT_DETAILS = 4;</code>
     */
    FAILURE_REASON_INCORRECT_PAYMENT_DETAILS(4),
    /**
     * <pre>
     *Insufficient local balance.
     * </pre>
     *
     * <code>FAILURE_REASON_INSUFFICIENT_BALANCE = 5;</code>
     */
    FAILURE_REASON_INSUFFICIENT_BALANCE(5),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     *Payment isn't failed (yet).
     * </pre>
     *
     * <code>FAILURE_REASON_NONE = 0;</code>
     */
    public static final int FAILURE_REASON_NONE_VALUE = 0;
    /**
     * <pre>
     *There are more routes to try, but the payment timeout was exceeded.
     * </pre>
     *
     * <code>FAILURE_REASON_TIMEOUT = 1;</code>
     */
    public static final int FAILURE_REASON_TIMEOUT_VALUE = 1;
    /**
     * <pre>
     *All possible routes were tried and failed permanently. Or were no
     *routes to the destination at all.
     * </pre>
     *
     * <code>FAILURE_REASON_NO_ROUTE = 2;</code>
     */
    public static final int FAILURE_REASON_NO_ROUTE_VALUE = 2;
    /**
     * <pre>
     *A non-recoverable error has occured.
     * </pre>
     *
     * <code>FAILURE_REASON_ERROR = 3;</code>
     */
    public static final int FAILURE_REASON_ERROR_VALUE = 3;
    /**
     * <pre>
     *Payment details incorrect (unknown hash, invalid amt or
     *invalid final cltv delta)
     * </pre>
     *
     * <code>FAILURE_REASON_INCORRECT_PAYMENT_DETAILS = 4;</code>
     */
    public static final int FAILURE_REASON_INCORRECT_PAYMENT_DETAILS_VALUE = 4;
    /**
     * <pre>
     *Insufficient local balance.
     * </pre>
     *
     * <code>FAILURE_REASON_INSUFFICIENT_BALANCE = 5;</code>
     */
    public static final int FAILURE_REASON_INSUFFICIENT_BALANCE_VALUE = 5;


    @java.lang.Override
    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static PaymentFailureReason valueOf(int value) {
      return forNumber(value);
    }

    public static PaymentFailureReason forNumber(int value) {
      switch (value) {
        case 0: return FAILURE_REASON_NONE;
        case 1: return FAILURE_REASON_TIMEOUT;
        case 2: return FAILURE_REASON_NO_ROUTE;
        case 3: return FAILURE_REASON_ERROR;
        case 4: return FAILURE_REASON_INCORRECT_PAYMENT_DETAILS;
        case 5: return FAILURE_REASON_INSUFFICIENT_BALANCE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<PaymentFailureReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        PaymentFailureReason> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<PaymentFailureReason>() {
            @java.lang.Override
            public PaymentFailureReason findValueByNumber(int number) {
              return PaymentFailureReason.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return PaymentFailureReasonVerifier.INSTANCE;
    }

    private static final class PaymentFailureReasonVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new PaymentFailureReasonVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return PaymentFailureReason.forNumber(number) != null;
            }
          };

    private final int value;

    private PaymentFailureReason(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:co.anode.anodium.PaymentFailureReason)
  }

  /**
   * Protobuf enum {@code co.anode.anodium.FeatureBit}
   */
  public enum FeatureBit
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <code>DATALOSS_PROTECT_REQ = 0;</code>
     */
    DATALOSS_PROTECT_REQ(0),
    /**
     * <code>DATALOSS_PROTECT_OPT = 1;</code>
     */
    DATALOSS_PROTECT_OPT(1),
    /**
     * <code>INITIAL_ROUING_SYNC = 3;</code>
     */
    INITIAL_ROUING_SYNC(3),
    /**
     * <code>UPFRONT_SHUTDOWN_SCRIPT_REQ = 4;</code>
     */
    UPFRONT_SHUTDOWN_SCRIPT_REQ(4),
    /**
     * <code>UPFRONT_SHUTDOWN_SCRIPT_OPT = 5;</code>
     */
    UPFRONT_SHUTDOWN_SCRIPT_OPT(5),
    /**
     * <code>GOSSIP_QUERIES_REQ = 6;</code>
     */
    GOSSIP_QUERIES_REQ(6),
    /**
     * <code>GOSSIP_QUERIES_OPT = 7;</code>
     */
    GOSSIP_QUERIES_OPT(7),
    /**
     * <code>TLV_ONION_REQ = 8;</code>
     */
    TLV_ONION_REQ(8),
    /**
     * <code>TLV_ONION_OPT = 9;</code>
     */
    TLV_ONION_OPT(9),
    /**
     * <code>EXT_GOSSIP_QUERIES_REQ = 10;</code>
     */
    EXT_GOSSIP_QUERIES_REQ(10),
    /**
     * <code>EXT_GOSSIP_QUERIES_OPT = 11;</code>
     */
    EXT_GOSSIP_QUERIES_OPT(11),
    /**
     * <code>STATIC_REMOTE_KEY_REQ = 12;</code>
     */
    STATIC_REMOTE_KEY_REQ(12),
    /**
     * <code>STATIC_REMOTE_KEY_OPT = 13;</code>
     */
    STATIC_REMOTE_KEY_OPT(13),
    /**
     * <code>PAYMENT_ADDR_REQ = 14;</code>
     */
    PAYMENT_ADDR_REQ(14),
    /**
     * <code>PAYMENT_ADDR_OPT = 15;</code>
     */
    PAYMENT_ADDR_OPT(15),
    /**
     * <code>MPP_REQ = 16;</code>
     */
    MPP_REQ(16),
    /**
     * <code>MPP_OPT = 17;</code>
     */
    MPP_OPT(17),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>DATALOSS_PROTECT_REQ = 0;</code>
     */
    public static final int DATALOSS_PROTECT_REQ_VALUE = 0;
    /**
     * <code>DATALOSS_PROTECT_OPT = 1;</code>
     */
    public static final int DATALOSS_PROTECT_OPT_VALUE = 1;
    /**
     * <code>INITIAL_ROUING_SYNC = 3;</code>
     */
    public static final int INITIAL_ROUING_SYNC_VALUE = 3;
    /**
     * <code>UPFRONT_SHUTDOWN_SCRIPT_REQ = 4;</code>
     */
    public static final int UPFRONT_SHUTDOWN_SCRIPT_REQ_VALUE = 4;
    /**
     * <code>UPFRONT_SHUTDOWN_SCRIPT_OPT = 5;</code>
     */
    public static final int UPFRONT_SHUTDOWN_SCRIPT_OPT_VALUE = 5;
    /**
     * <code>GOSSIP_QUERIES_REQ = 6;</code>
     */
    public static final int GOSSIP_QUERIES_REQ_VALUE = 6;
    /**
     * <code>GOSSIP_QUERIES_OPT = 7;</code>
     */
    public static final int GOSSIP_QUERIES_OPT_VALUE = 7;
    /**
     * <code>TLV_ONION_REQ = 8;</code>
     */
    public static final int TLV_ONION_REQ_VALUE = 8;
    /**
     * <code>TLV_ONION_OPT = 9;</code>
     */
    public static final int TLV_ONION_OPT_VALUE = 9;
    /**
     * <code>EXT_GOSSIP_QUERIES_REQ = 10;</code>
     */
    public static final int EXT_GOSSIP_QUERIES_REQ_VALUE = 10;
    /**
     * <code>EXT_GOSSIP_QUERIES_OPT = 11;</code>
     */
    public static final int EXT_GOSSIP_QUERIES_OPT_VALUE = 11;
    /**
     * <code>STATIC_REMOTE_KEY_REQ = 12;</code>
     */
    public static final int STATIC_REMOTE_KEY_REQ_VALUE = 12;
    /**
     * <code>STATIC_REMOTE_KEY_OPT = 13;</code>
     */
    public static final int STATIC_REMOTE_KEY_OPT_VALUE = 13;
    /**
     * <code>PAYMENT_ADDR_REQ = 14;</code>
     */
    public static final int PAYMENT_ADDR_REQ_VALUE = 14;
    /**
     * <code>PAYMENT_ADDR_OPT = 15;</code>
     */
    public static final int PAYMENT_ADDR_OPT_VALUE = 15;
    /**
     * <code>MPP_REQ = 16;</code>
     */
    public static final int MPP_REQ_VALUE = 16;
    /**
     * <code>MPP_OPT = 17;</code>
     */
    public static final int MPP_OPT_VALUE = 17;


    @java.lang.Override
    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static FeatureBit valueOf(int value) {
      return forNumber(value);
    }

    public static FeatureBit forNumber(int value) {
      switch (value) {
        case 0: return DATALOSS_PROTECT_REQ;
        case 1: return DATALOSS_PROTECT_OPT;
        case 3: return INITIAL_ROUING_SYNC;
        case 4: return UPFRONT_SHUTDOWN_SCRIPT_REQ;
        case 5: return UPFRONT_SHUTDOWN_SCRIPT_OPT;
        case 6: return GOSSIP_QUERIES_REQ;
        case 7: return GOSSIP_QUERIES_OPT;
        case 8: return TLV_ONION_REQ;
        case 9: return TLV_ONION_OPT;
        case 10: return EXT_GOSSIP_QUERIES_REQ;
        case 11: return EXT_GOSSIP_QUERIES_OPT;
        case 12: return STATIC_REMOTE_KEY_REQ;
        case 13: return STATIC_REMOTE_KEY_OPT;
        case 14: return PAYMENT_ADDR_REQ;
        case 15: return PAYMENT_ADDR_OPT;
        case 16: return MPP_REQ;
        case 17: return MPP_OPT;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<FeatureBit>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        FeatureBit> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<FeatureBit>() {
            @java.lang.Override
            public FeatureBit findValueByNumber(int number) {
              return FeatureBit.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return FeatureBitVerifier.INSTANCE;
    }

    private static final class FeatureBitVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new FeatureBitVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return FeatureBit.forNumber(number) != null;
            }
          };

    private final int value;

    private FeatureBit(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:co.anode.anodium.FeatureBit)
  }

  public interface UtxoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.Utxo)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The type of address
     * </pre>
     *
     * <code>.co.anode.anodium.AddressType address_type = 1;</code>
     * @return The enum numeric value on the wire for addressType.
     */
    int getAddressTypeValue();
    /**
     * <pre>
     * The type of address
     * </pre>
     *
     * <code>.co.anode.anodium.AddressType address_type = 1;</code>
     * @return The addressType.
     */
    co.anode.anodium.Rpc.AddressType getAddressType();

    /**
     * <pre>
     * The address
     * </pre>
     *
     * <code>string address = 2;</code>
     * @return The address.
     */
    java.lang.String getAddress();
    /**
     * <pre>
     * The address
     * </pre>
     *
     * <code>string address = 2;</code>
     * @return The bytes for address.
     */
    com.google.protobuf.ByteString
        getAddressBytes();

    /**
     * <pre>
     * The value of the unspent coin in satoshis
     * </pre>
     *
     * <code>int64 amount_sat = 3;</code>
     * @return The amountSat.
     */
    long getAmountSat();

    /**
     * <pre>
     * The pkscript in hex
     * </pre>
     *
     * <code>string pk_script = 4;</code>
     * @return The pkScript.
     */
    java.lang.String getPkScript();
    /**
     * <pre>
     * The pkscript in hex
     * </pre>
     *
     * <code>string pk_script = 4;</code>
     * @return The bytes for pkScript.
     */
    com.google.protobuf.ByteString
        getPkScriptBytes();

    /**
     * <pre>
     * The outpoint in format txid:n
     * </pre>
     *
     * <code>.co.anode.anodium.OutPoint outpoint = 5;</code>
     * @return Whether the outpoint field is set.
     */
    boolean hasOutpoint();
    /**
     * <pre>
     * The outpoint in format txid:n
     * </pre>
     *
     * <code>.co.anode.anodium.OutPoint outpoint = 5;</code>
     * @return The outpoint.
     */
    co.anode.anodium.Rpc.OutPoint getOutpoint();

    /**
     * <pre>
     * The number of confirmations for the Utxo
     * </pre>
     *
     * <code>int64 confirmations = 6;</code>
     * @return The confirmations.
     */
    long getConfirmations();
  }
  /**
   * Protobuf type {@code co.anode.anodium.Utxo}
   */
  public  static final class Utxo extends
      com.google.protobuf.GeneratedMessageLite<
          Utxo, Utxo.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.Utxo)
      UtxoOrBuilder {
    private Utxo() {
      address_ = "";
      pkScript_ = "";
    }
    public static final int ADDRESS_TYPE_FIELD_NUMBER = 1;
    private int addressType_;
    /**
     * <pre>
     * The type of address
     * </pre>
     *
     * <code>.co.anode.anodium.AddressType address_type = 1;</code>
     * @return The enum numeric value on the wire for addressType.
     */
    @java.lang.Override
    public int getAddressTypeValue() {
      return addressType_;
    }
    /**
     * <pre>
     * The type of address
     * </pre>
     *
     * <code>.co.anode.anodium.AddressType address_type = 1;</code>
     * @return The addressType.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.AddressType getAddressType() {
      co.anode.anodium.Rpc.AddressType result = co.anode.anodium.Rpc.AddressType.forNumber(addressType_);
      return result == null ? co.anode.anodium.Rpc.AddressType.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * The type of address
     * </pre>
     *
     * <code>.co.anode.anodium.AddressType address_type = 1;</code>
     * @param value The enum numeric value on the wire for addressType to set.
     */
    private void setAddressTypeValue(int value) {
        addressType_ = value;
    }
    /**
     * <pre>
     * The type of address
     * </pre>
     *
     * <code>.co.anode.anodium.AddressType address_type = 1;</code>
     * @param value The addressType to set.
     */
    private void setAddressType(co.anode.anodium.Rpc.AddressType value) {
      addressType_ = value.getNumber();
      
    }
    /**
     * <pre>
     * The type of address
     * </pre>
     *
     * <code>.co.anode.anodium.AddressType address_type = 1;</code>
     */
    private void clearAddressType() {
      
      addressType_ = 0;
    }

    public static final int ADDRESS_FIELD_NUMBER = 2;
    private java.lang.String address_;
    /**
     * <pre>
     * The address
     * </pre>
     *
     * <code>string address = 2;</code>
     * @return The address.
     */
    @java.lang.Override
    public java.lang.String getAddress() {
      return address_;
    }
    /**
     * <pre>
     * The address
     * </pre>
     *
     * <code>string address = 2;</code>
     * @return The bytes for address.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAddressBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(address_);
    }
    /**
     * <pre>
     * The address
     * </pre>
     *
     * <code>string address = 2;</code>
     * @param value The address to set.
     */
    private void setAddress(
        java.lang.String value) {
      value.getClass();
  
      address_ = value;
    }
    /**
     * <pre>
     * The address
     * </pre>
     *
     * <code>string address = 2;</code>
     */
    private void clearAddress() {
      
      address_ = getDefaultInstance().getAddress();
    }
    /**
     * <pre>
     * The address
     * </pre>
     *
     * <code>string address = 2;</code>
     * @param value The bytes for address to set.
     */
    private void setAddressBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      address_ = value.toStringUtf8();
      
    }

    public static final int AMOUNT_SAT_FIELD_NUMBER = 3;
    private long amountSat_;
    /**
     * <pre>
     * The value of the unspent coin in satoshis
     * </pre>
     *
     * <code>int64 amount_sat = 3;</code>
     * @return The amountSat.
     */
    @java.lang.Override
    public long getAmountSat() {
      return amountSat_;
    }
    /**
     * <pre>
     * The value of the unspent coin in satoshis
     * </pre>
     *
     * <code>int64 amount_sat = 3;</code>
     * @param value The amountSat to set.
     */
    private void setAmountSat(long value) {
      
      amountSat_ = value;
    }
    /**
     * <pre>
     * The value of the unspent coin in satoshis
     * </pre>
     *
     * <code>int64 amount_sat = 3;</code>
     */
    private void clearAmountSat() {
      
      amountSat_ = 0L;
    }

    public static final int PK_SCRIPT_FIELD_NUMBER = 4;
    private java.lang.String pkScript_;
    /**
     * <pre>
     * The pkscript in hex
     * </pre>
     *
     * <code>string pk_script = 4;</code>
     * @return The pkScript.
     */
    @java.lang.Override
    public java.lang.String getPkScript() {
      return pkScript_;
    }
    /**
     * <pre>
     * The pkscript in hex
     * </pre>
     *
     * <code>string pk_script = 4;</code>
     * @return The bytes for pkScript.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPkScriptBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(pkScript_);
    }
    /**
     * <pre>
     * The pkscript in hex
     * </pre>
     *
     * <code>string pk_script = 4;</code>
     * @param value The pkScript to set.
     */
    private void setPkScript(
        java.lang.String value) {
      value.getClass();
  
      pkScript_ = value;
    }
    /**
     * <pre>
     * The pkscript in hex
     * </pre>
     *
     * <code>string pk_script = 4;</code>
     */
    private void clearPkScript() {
      
      pkScript_ = getDefaultInstance().getPkScript();
    }
    /**
     * <pre>
     * The pkscript in hex
     * </pre>
     *
     * <code>string pk_script = 4;</code>
     * @param value The bytes for pkScript to set.
     */
    private void setPkScriptBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      pkScript_ = value.toStringUtf8();
      
    }

    public static final int OUTPOINT_FIELD_NUMBER = 5;
    private co.anode.anodium.Rpc.OutPoint outpoint_;
    /**
     * <pre>
     * The outpoint in format txid:n
     * </pre>
     *
     * <code>.co.anode.anodium.OutPoint outpoint = 5;</code>
     */
    @java.lang.Override
    public boolean hasOutpoint() {
      return outpoint_ != null;
    }
    /**
     * <pre>
     * The outpoint in format txid:n
     * </pre>
     *
     * <code>.co.anode.anodium.OutPoint outpoint = 5;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.OutPoint getOutpoint() {
      return outpoint_ == null ? co.anode.anodium.Rpc.OutPoint.getDefaultInstance() : outpoint_;
    }
    /**
     * <pre>
     * The outpoint in format txid:n
     * </pre>
     *
     * <code>.co.anode.anodium.OutPoint outpoint = 5;</code>
     */
    private void setOutpoint(co.anode.anodium.Rpc.OutPoint value) {
      value.getClass();
  outpoint_ = value;
      
      }
    /**
     * <pre>
     * The outpoint in format txid:n
     * </pre>
     *
     * <code>.co.anode.anodium.OutPoint outpoint = 5;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeOutpoint(co.anode.anodium.Rpc.OutPoint value) {
      value.getClass();
  if (outpoint_ != null &&
          outpoint_ != co.anode.anodium.Rpc.OutPoint.getDefaultInstance()) {
        outpoint_ =
          co.anode.anodium.Rpc.OutPoint.newBuilder(outpoint_).mergeFrom(value).buildPartial();
      } else {
        outpoint_ = value;
      }
      
    }
    /**
     * <pre>
     * The outpoint in format txid:n
     * </pre>
     *
     * <code>.co.anode.anodium.OutPoint outpoint = 5;</code>
     */
    private void clearOutpoint() {  outpoint_ = null;
      
    }

    public static final int CONFIRMATIONS_FIELD_NUMBER = 6;
    private long confirmations_;
    /**
     * <pre>
     * The number of confirmations for the Utxo
     * </pre>
     *
     * <code>int64 confirmations = 6;</code>
     * @return The confirmations.
     */
    @java.lang.Override
    public long getConfirmations() {
      return confirmations_;
    }
    /**
     * <pre>
     * The number of confirmations for the Utxo
     * </pre>
     *
     * <code>int64 confirmations = 6;</code>
     * @param value The confirmations to set.
     */
    private void setConfirmations(long value) {
      
      confirmations_ = value;
    }
    /**
     * <pre>
     * The number of confirmations for the Utxo
     * </pre>
     *
     * <code>int64 confirmations = 6;</code>
     */
    private void clearConfirmations() {
      
      confirmations_ = 0L;
    }

    public static co.anode.anodium.Rpc.Utxo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Utxo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Utxo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Utxo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Utxo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Utxo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Utxo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Utxo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Utxo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Utxo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Utxo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Utxo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.Utxo prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.Utxo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.Utxo, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.Utxo)
        co.anode.anodium.Rpc.UtxoOrBuilder {
      // Construct using co.anode.anodium.Rpc.Utxo.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The type of address
       * </pre>
       *
       * <code>.co.anode.anodium.AddressType address_type = 1;</code>
       * @return The enum numeric value on the wire for addressType.
       */
      @java.lang.Override
      public int getAddressTypeValue() {
        return instance.getAddressTypeValue();
      }
      /**
       * <pre>
       * The type of address
       * </pre>
       *
       * <code>.co.anode.anodium.AddressType address_type = 1;</code>
       * @param value The addressType to set.
       * @return This builder for chaining.
       */
      public Builder setAddressTypeValue(int value) {
        copyOnWrite();
        instance.setAddressTypeValue(value);
        return this;
      }
      /**
       * <pre>
       * The type of address
       * </pre>
       *
       * <code>.co.anode.anodium.AddressType address_type = 1;</code>
       * @return The addressType.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.AddressType getAddressType() {
        return instance.getAddressType();
      }
      /**
       * <pre>
       * The type of address
       * </pre>
       *
       * <code>.co.anode.anodium.AddressType address_type = 1;</code>
       * @param value The enum numeric value on the wire for addressType to set.
       * @return This builder for chaining.
       */
      public Builder setAddressType(co.anode.anodium.Rpc.AddressType value) {
        copyOnWrite();
        instance.setAddressType(value);
        return this;
      }
      /**
       * <pre>
       * The type of address
       * </pre>
       *
       * <code>.co.anode.anodium.AddressType address_type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAddressType() {
        copyOnWrite();
        instance.clearAddressType();
        return this;
      }

      /**
       * <pre>
       * The address
       * </pre>
       *
       * <code>string address = 2;</code>
       * @return The address.
       */
      @java.lang.Override
      public java.lang.String getAddress() {
        return instance.getAddress();
      }
      /**
       * <pre>
       * The address
       * </pre>
       *
       * <code>string address = 2;</code>
       * @return The bytes for address.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getAddressBytes() {
        return instance.getAddressBytes();
      }
      /**
       * <pre>
       * The address
       * </pre>
       *
       * <code>string address = 2;</code>
       * @param value The address to set.
       * @return This builder for chaining.
       */
      public Builder setAddress(
          java.lang.String value) {
        copyOnWrite();
        instance.setAddress(value);
        return this;
      }
      /**
       * <pre>
       * The address
       * </pre>
       *
       * <code>string address = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAddress() {
        copyOnWrite();
        instance.clearAddress();
        return this;
      }
      /**
       * <pre>
       * The address
       * </pre>
       *
       * <code>string address = 2;</code>
       * @param value The bytes for address to set.
       * @return This builder for chaining.
       */
      public Builder setAddressBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setAddressBytes(value);
        return this;
      }

      /**
       * <pre>
       * The value of the unspent coin in satoshis
       * </pre>
       *
       * <code>int64 amount_sat = 3;</code>
       * @return The amountSat.
       */
      @java.lang.Override
      public long getAmountSat() {
        return instance.getAmountSat();
      }
      /**
       * <pre>
       * The value of the unspent coin in satoshis
       * </pre>
       *
       * <code>int64 amount_sat = 3;</code>
       * @param value The amountSat to set.
       * @return This builder for chaining.
       */
      public Builder setAmountSat(long value) {
        copyOnWrite();
        instance.setAmountSat(value);
        return this;
      }
      /**
       * <pre>
       * The value of the unspent coin in satoshis
       * </pre>
       *
       * <code>int64 amount_sat = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmountSat() {
        copyOnWrite();
        instance.clearAmountSat();
        return this;
      }

      /**
       * <pre>
       * The pkscript in hex
       * </pre>
       *
       * <code>string pk_script = 4;</code>
       * @return The pkScript.
       */
      @java.lang.Override
      public java.lang.String getPkScript() {
        return instance.getPkScript();
      }
      /**
       * <pre>
       * The pkscript in hex
       * </pre>
       *
       * <code>string pk_script = 4;</code>
       * @return The bytes for pkScript.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPkScriptBytes() {
        return instance.getPkScriptBytes();
      }
      /**
       * <pre>
       * The pkscript in hex
       * </pre>
       *
       * <code>string pk_script = 4;</code>
       * @param value The pkScript to set.
       * @return This builder for chaining.
       */
      public Builder setPkScript(
          java.lang.String value) {
        copyOnWrite();
        instance.setPkScript(value);
        return this;
      }
      /**
       * <pre>
       * The pkscript in hex
       * </pre>
       *
       * <code>string pk_script = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearPkScript() {
        copyOnWrite();
        instance.clearPkScript();
        return this;
      }
      /**
       * <pre>
       * The pkscript in hex
       * </pre>
       *
       * <code>string pk_script = 4;</code>
       * @param value The bytes for pkScript to set.
       * @return This builder for chaining.
       */
      public Builder setPkScriptBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPkScriptBytes(value);
        return this;
      }

      /**
       * <pre>
       * The outpoint in format txid:n
       * </pre>
       *
       * <code>.co.anode.anodium.OutPoint outpoint = 5;</code>
       */
      @java.lang.Override
      public boolean hasOutpoint() {
        return instance.hasOutpoint();
      }
      /**
       * <pre>
       * The outpoint in format txid:n
       * </pre>
       *
       * <code>.co.anode.anodium.OutPoint outpoint = 5;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.OutPoint getOutpoint() {
        return instance.getOutpoint();
      }
      /**
       * <pre>
       * The outpoint in format txid:n
       * </pre>
       *
       * <code>.co.anode.anodium.OutPoint outpoint = 5;</code>
       */
      public Builder setOutpoint(co.anode.anodium.Rpc.OutPoint value) {
        copyOnWrite();
        instance.setOutpoint(value);
        return this;
        }
      /**
       * <pre>
       * The outpoint in format txid:n
       * </pre>
       *
       * <code>.co.anode.anodium.OutPoint outpoint = 5;</code>
       */
      public Builder setOutpoint(
          co.anode.anodium.Rpc.OutPoint.Builder builderForValue) {
        copyOnWrite();
        instance.setOutpoint(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The outpoint in format txid:n
       * </pre>
       *
       * <code>.co.anode.anodium.OutPoint outpoint = 5;</code>
       */
      public Builder mergeOutpoint(co.anode.anodium.Rpc.OutPoint value) {
        copyOnWrite();
        instance.mergeOutpoint(value);
        return this;
      }
      /**
       * <pre>
       * The outpoint in format txid:n
       * </pre>
       *
       * <code>.co.anode.anodium.OutPoint outpoint = 5;</code>
       */
      public Builder clearOutpoint() {  copyOnWrite();
        instance.clearOutpoint();
        return this;
      }

      /**
       * <pre>
       * The number of confirmations for the Utxo
       * </pre>
       *
       * <code>int64 confirmations = 6;</code>
       * @return The confirmations.
       */
      @java.lang.Override
      public long getConfirmations() {
        return instance.getConfirmations();
      }
      /**
       * <pre>
       * The number of confirmations for the Utxo
       * </pre>
       *
       * <code>int64 confirmations = 6;</code>
       * @param value The confirmations to set.
       * @return This builder for chaining.
       */
      public Builder setConfirmations(long value) {
        copyOnWrite();
        instance.setConfirmations(value);
        return this;
      }
      /**
       * <pre>
       * The number of confirmations for the Utxo
       * </pre>
       *
       * <code>int64 confirmations = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearConfirmations() {
        copyOnWrite();
        instance.clearConfirmations();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.Utxo)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.Utxo();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "addressType_",
              "address_",
              "amountSat_",
              "pkScript_",
              "outpoint_",
              "confirmations_",
            };
            java.lang.String info =
                "\u0000\u0006\u0000\u0000\u0001\u0006\u0006\u0000\u0000\u0000\u0001\f\u0002\u0208" +
                "\u0003\u0002\u0004\u0208\u0005\t\u0006\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.Utxo> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.Utxo.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.Utxo>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.Utxo)
    private static final co.anode.anodium.Rpc.Utxo DEFAULT_INSTANCE;
    static {
      Utxo defaultInstance = new Utxo();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Utxo.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.Utxo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Utxo> PARSER;

    public static com.google.protobuf.Parser<Utxo> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TransactionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.Transaction)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The transaction hash
     * </pre>
     *
     * <code>string tx_hash = 1;</code>
     * @return The txHash.
     */
    java.lang.String getTxHash();
    /**
     * <pre>
     * The transaction hash
     * </pre>
     *
     * <code>string tx_hash = 1;</code>
     * @return The bytes for txHash.
     */
    com.google.protobuf.ByteString
        getTxHashBytes();

    /**
     * <pre>
     * The transaction amount, denominated in satoshis
     * </pre>
     *
     * <code>int64 amount = 2;</code>
     * @return The amount.
     */
    long getAmount();

    /**
     * <pre>
     * The number of confirmations
     * </pre>
     *
     * <code>int32 num_confirmations = 3;</code>
     * @return The numConfirmations.
     */
    int getNumConfirmations();

    /**
     * <pre>
     * The hash of the block this transaction was included in
     * </pre>
     *
     * <code>string block_hash = 4;</code>
     * @return The blockHash.
     */
    java.lang.String getBlockHash();
    /**
     * <pre>
     * The hash of the block this transaction was included in
     * </pre>
     *
     * <code>string block_hash = 4;</code>
     * @return The bytes for blockHash.
     */
    com.google.protobuf.ByteString
        getBlockHashBytes();

    /**
     * <pre>
     * The height of the block this transaction was included in
     * </pre>
     *
     * <code>int32 block_height = 5;</code>
     * @return The blockHeight.
     */
    int getBlockHeight();

    /**
     * <pre>
     * Timestamp of this transaction
     * </pre>
     *
     * <code>int64 time_stamp = 6;</code>
     * @return The timeStamp.
     */
    long getTimeStamp();

    /**
     * <pre>
     * Fees paid for this transaction
     * </pre>
     *
     * <code>int64 total_fees = 7;</code>
     * @return The totalFees.
     */
    long getTotalFees();

    /**
     * <pre>
     * Addresses that received funds for this transaction
     * </pre>
     *
     * <code>repeated string dest_addresses = 8;</code>
     * @return A list containing the destAddresses.
     */
    java.util.List<java.lang.String>
        getDestAddressesList();
    /**
     * <pre>
     * Addresses that received funds for this transaction
     * </pre>
     *
     * <code>repeated string dest_addresses = 8;</code>
     * @return The count of destAddresses.
     */
    int getDestAddressesCount();
    /**
     * <pre>
     * Addresses that received funds for this transaction
     * </pre>
     *
     * <code>repeated string dest_addresses = 8;</code>
     * @param index The index of the element to return.
     * @return The destAddresses at the given index.
     */
    java.lang.String getDestAddresses(int index);
    /**
     * <pre>
     * Addresses that received funds for this transaction
     * </pre>
     *
     * <code>repeated string dest_addresses = 8;</code>
     * @param index The index of the element to return.
     * @return The destAddresses at the given index.
     */
    com.google.protobuf.ByteString
        getDestAddressesBytes(int index);

    /**
     * <pre>
     * The raw transaction hex.
     * </pre>
     *
     * <code>string raw_tx_hex = 9;</code>
     * @return The rawTxHex.
     */
    java.lang.String getRawTxHex();
    /**
     * <pre>
     * The raw transaction hex.
     * </pre>
     *
     * <code>string raw_tx_hex = 9;</code>
     * @return The bytes for rawTxHex.
     */
    com.google.protobuf.ByteString
        getRawTxHexBytes();

    /**
     * <pre>
     * A label that was optionally set on transaction broadcast.
     * </pre>
     *
     * <code>string label = 10;</code>
     * @return The label.
     */
    java.lang.String getLabel();
    /**
     * <pre>
     * A label that was optionally set on transaction broadcast.
     * </pre>
     *
     * <code>string label = 10;</code>
     * @return The bytes for label.
     */
    com.google.protobuf.ByteString
        getLabelBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.Transaction}
   */
  public  static final class Transaction extends
      com.google.protobuf.GeneratedMessageLite<
          Transaction, Transaction.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.Transaction)
      TransactionOrBuilder {
    private Transaction() {
      txHash_ = "";
      blockHash_ = "";
      destAddresses_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
      rawTxHex_ = "";
      label_ = "";
    }
    public static final int TX_HASH_FIELD_NUMBER = 1;
    private java.lang.String txHash_;
    /**
     * <pre>
     * The transaction hash
     * </pre>
     *
     * <code>string tx_hash = 1;</code>
     * @return The txHash.
     */
    @java.lang.Override
    public java.lang.String getTxHash() {
      return txHash_;
    }
    /**
     * <pre>
     * The transaction hash
     * </pre>
     *
     * <code>string tx_hash = 1;</code>
     * @return The bytes for txHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTxHashBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(txHash_);
    }
    /**
     * <pre>
     * The transaction hash
     * </pre>
     *
     * <code>string tx_hash = 1;</code>
     * @param value The txHash to set.
     */
    private void setTxHash(
        java.lang.String value) {
      value.getClass();
  
      txHash_ = value;
    }
    /**
     * <pre>
     * The transaction hash
     * </pre>
     *
     * <code>string tx_hash = 1;</code>
     */
    private void clearTxHash() {
      
      txHash_ = getDefaultInstance().getTxHash();
    }
    /**
     * <pre>
     * The transaction hash
     * </pre>
     *
     * <code>string tx_hash = 1;</code>
     * @param value The bytes for txHash to set.
     */
    private void setTxHashBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      txHash_ = value.toStringUtf8();
      
    }

    public static final int AMOUNT_FIELD_NUMBER = 2;
    private long amount_;
    /**
     * <pre>
     * The transaction amount, denominated in satoshis
     * </pre>
     *
     * <code>int64 amount = 2;</code>
     * @return The amount.
     */
    @java.lang.Override
    public long getAmount() {
      return amount_;
    }
    /**
     * <pre>
     * The transaction amount, denominated in satoshis
     * </pre>
     *
     * <code>int64 amount = 2;</code>
     * @param value The amount to set.
     */
    private void setAmount(long value) {
      
      amount_ = value;
    }
    /**
     * <pre>
     * The transaction amount, denominated in satoshis
     * </pre>
     *
     * <code>int64 amount = 2;</code>
     */
    private void clearAmount() {
      
      amount_ = 0L;
    }

    public static final int NUM_CONFIRMATIONS_FIELD_NUMBER = 3;
    private int numConfirmations_;
    /**
     * <pre>
     * The number of confirmations
     * </pre>
     *
     * <code>int32 num_confirmations = 3;</code>
     * @return The numConfirmations.
     */
    @java.lang.Override
    public int getNumConfirmations() {
      return numConfirmations_;
    }
    /**
     * <pre>
     * The number of confirmations
     * </pre>
     *
     * <code>int32 num_confirmations = 3;</code>
     * @param value The numConfirmations to set.
     */
    private void setNumConfirmations(int value) {
      
      numConfirmations_ = value;
    }
    /**
     * <pre>
     * The number of confirmations
     * </pre>
     *
     * <code>int32 num_confirmations = 3;</code>
     */
    private void clearNumConfirmations() {
      
      numConfirmations_ = 0;
    }

    public static final int BLOCK_HASH_FIELD_NUMBER = 4;
    private java.lang.String blockHash_;
    /**
     * <pre>
     * The hash of the block this transaction was included in
     * </pre>
     *
     * <code>string block_hash = 4;</code>
     * @return The blockHash.
     */
    @java.lang.Override
    public java.lang.String getBlockHash() {
      return blockHash_;
    }
    /**
     * <pre>
     * The hash of the block this transaction was included in
     * </pre>
     *
     * <code>string block_hash = 4;</code>
     * @return The bytes for blockHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getBlockHashBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(blockHash_);
    }
    /**
     * <pre>
     * The hash of the block this transaction was included in
     * </pre>
     *
     * <code>string block_hash = 4;</code>
     * @param value The blockHash to set.
     */
    private void setBlockHash(
        java.lang.String value) {
      value.getClass();
  
      blockHash_ = value;
    }
    /**
     * <pre>
     * The hash of the block this transaction was included in
     * </pre>
     *
     * <code>string block_hash = 4;</code>
     */
    private void clearBlockHash() {
      
      blockHash_ = getDefaultInstance().getBlockHash();
    }
    /**
     * <pre>
     * The hash of the block this transaction was included in
     * </pre>
     *
     * <code>string block_hash = 4;</code>
     * @param value The bytes for blockHash to set.
     */
    private void setBlockHashBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      blockHash_ = value.toStringUtf8();
      
    }

    public static final int BLOCK_HEIGHT_FIELD_NUMBER = 5;
    private int blockHeight_;
    /**
     * <pre>
     * The height of the block this transaction was included in
     * </pre>
     *
     * <code>int32 block_height = 5;</code>
     * @return The blockHeight.
     */
    @java.lang.Override
    public int getBlockHeight() {
      return blockHeight_;
    }
    /**
     * <pre>
     * The height of the block this transaction was included in
     * </pre>
     *
     * <code>int32 block_height = 5;</code>
     * @param value The blockHeight to set.
     */
    private void setBlockHeight(int value) {
      
      blockHeight_ = value;
    }
    /**
     * <pre>
     * The height of the block this transaction was included in
     * </pre>
     *
     * <code>int32 block_height = 5;</code>
     */
    private void clearBlockHeight() {
      
      blockHeight_ = 0;
    }

    public static final int TIME_STAMP_FIELD_NUMBER = 6;
    private long timeStamp_;
    /**
     * <pre>
     * Timestamp of this transaction
     * </pre>
     *
     * <code>int64 time_stamp = 6;</code>
     * @return The timeStamp.
     */
    @java.lang.Override
    public long getTimeStamp() {
      return timeStamp_;
    }
    /**
     * <pre>
     * Timestamp of this transaction
     * </pre>
     *
     * <code>int64 time_stamp = 6;</code>
     * @param value The timeStamp to set.
     */
    private void setTimeStamp(long value) {
      
      timeStamp_ = value;
    }
    /**
     * <pre>
     * Timestamp of this transaction
     * </pre>
     *
     * <code>int64 time_stamp = 6;</code>
     */
    private void clearTimeStamp() {
      
      timeStamp_ = 0L;
    }

    public static final int TOTAL_FEES_FIELD_NUMBER = 7;
    private long totalFees_;
    /**
     * <pre>
     * Fees paid for this transaction
     * </pre>
     *
     * <code>int64 total_fees = 7;</code>
     * @return The totalFees.
     */
    @java.lang.Override
    public long getTotalFees() {
      return totalFees_;
    }
    /**
     * <pre>
     * Fees paid for this transaction
     * </pre>
     *
     * <code>int64 total_fees = 7;</code>
     * @param value The totalFees to set.
     */
    private void setTotalFees(long value) {
      
      totalFees_ = value;
    }
    /**
     * <pre>
     * Fees paid for this transaction
     * </pre>
     *
     * <code>int64 total_fees = 7;</code>
     */
    private void clearTotalFees() {
      
      totalFees_ = 0L;
    }

    public static final int DEST_ADDRESSES_FIELD_NUMBER = 8;
    private com.google.protobuf.Internal.ProtobufList<java.lang.String> destAddresses_;
    /**
     * <pre>
     * Addresses that received funds for this transaction
     * </pre>
     *
     * <code>repeated string dest_addresses = 8;</code>
     * @return A list containing the destAddresses.
     */
    @java.lang.Override
    public java.util.List<java.lang.String> getDestAddressesList() {
      return destAddresses_;
    }
    /**
     * <pre>
     * Addresses that received funds for this transaction
     * </pre>
     *
     * <code>repeated string dest_addresses = 8;</code>
     * @return The count of destAddresses.
     */
    @java.lang.Override
    public int getDestAddressesCount() {
      return destAddresses_.size();
    }
    /**
     * <pre>
     * Addresses that received funds for this transaction
     * </pre>
     *
     * <code>repeated string dest_addresses = 8;</code>
     * @param index The index of the element to return.
     * @return The destAddresses at the given index.
     */
    @java.lang.Override
    public java.lang.String getDestAddresses(int index) {
      return destAddresses_.get(index);
    }
    /**
     * <pre>
     * Addresses that received funds for this transaction
     * </pre>
     *
     * <code>repeated string dest_addresses = 8;</code>
     * @param index The index of the value to return.
     * @return The bytes of the destAddresses at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDestAddressesBytes(int index) {
      return com.google.protobuf.ByteString.copyFromUtf8(
          destAddresses_.get(index));
    }
    private void ensureDestAddressesIsMutable() {
      com.google.protobuf.Internal.ProtobufList<java.lang.String> tmp =
          destAddresses_;  if (!tmp.isModifiable()) {
        destAddresses_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * Addresses that received funds for this transaction
     * </pre>
     *
     * <code>repeated string dest_addresses = 8;</code>
     * @param index The index to set the value at.
     * @param value The destAddresses to set.
     */
    private void setDestAddresses(
        int index, java.lang.String value) {
      value.getClass();
  ensureDestAddressesIsMutable();
      destAddresses_.set(index, value);
    }
    /**
     * <pre>
     * Addresses that received funds for this transaction
     * </pre>
     *
     * <code>repeated string dest_addresses = 8;</code>
     * @param value The destAddresses to add.
     */
    private void addDestAddresses(
        java.lang.String value) {
      value.getClass();
  ensureDestAddressesIsMutable();
      destAddresses_.add(value);
    }
    /**
     * <pre>
     * Addresses that received funds for this transaction
     * </pre>
     *
     * <code>repeated string dest_addresses = 8;</code>
     * @param values The destAddresses to add.
     */
    private void addAllDestAddresses(
        java.lang.Iterable<java.lang.String> values) {
      ensureDestAddressesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, destAddresses_);
    }
    /**
     * <pre>
     * Addresses that received funds for this transaction
     * </pre>
     *
     * <code>repeated string dest_addresses = 8;</code>
     */
    private void clearDestAddresses() {
      destAddresses_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    /**
     * <pre>
     * Addresses that received funds for this transaction
     * </pre>
     *
     * <code>repeated string dest_addresses = 8;</code>
     * @param value The bytes of the destAddresses to add.
     */
    private void addDestAddressesBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      ensureDestAddressesIsMutable();
      destAddresses_.add(value.toStringUtf8());
    }

    public static final int RAW_TX_HEX_FIELD_NUMBER = 9;
    private java.lang.String rawTxHex_;
    /**
     * <pre>
     * The raw transaction hex.
     * </pre>
     *
     * <code>string raw_tx_hex = 9;</code>
     * @return The rawTxHex.
     */
    @java.lang.Override
    public java.lang.String getRawTxHex() {
      return rawTxHex_;
    }
    /**
     * <pre>
     * The raw transaction hex.
     * </pre>
     *
     * <code>string raw_tx_hex = 9;</code>
     * @return The bytes for rawTxHex.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRawTxHexBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(rawTxHex_);
    }
    /**
     * <pre>
     * The raw transaction hex.
     * </pre>
     *
     * <code>string raw_tx_hex = 9;</code>
     * @param value The rawTxHex to set.
     */
    private void setRawTxHex(
        java.lang.String value) {
      value.getClass();
  
      rawTxHex_ = value;
    }
    /**
     * <pre>
     * The raw transaction hex.
     * </pre>
     *
     * <code>string raw_tx_hex = 9;</code>
     */
    private void clearRawTxHex() {
      
      rawTxHex_ = getDefaultInstance().getRawTxHex();
    }
    /**
     * <pre>
     * The raw transaction hex.
     * </pre>
     *
     * <code>string raw_tx_hex = 9;</code>
     * @param value The bytes for rawTxHex to set.
     */
    private void setRawTxHexBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      rawTxHex_ = value.toStringUtf8();
      
    }

    public static final int LABEL_FIELD_NUMBER = 10;
    private java.lang.String label_;
    /**
     * <pre>
     * A label that was optionally set on transaction broadcast.
     * </pre>
     *
     * <code>string label = 10;</code>
     * @return The label.
     */
    @java.lang.Override
    public java.lang.String getLabel() {
      return label_;
    }
    /**
     * <pre>
     * A label that was optionally set on transaction broadcast.
     * </pre>
     *
     * <code>string label = 10;</code>
     * @return The bytes for label.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLabelBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(label_);
    }
    /**
     * <pre>
     * A label that was optionally set on transaction broadcast.
     * </pre>
     *
     * <code>string label = 10;</code>
     * @param value The label to set.
     */
    private void setLabel(
        java.lang.String value) {
      value.getClass();
  
      label_ = value;
    }
    /**
     * <pre>
     * A label that was optionally set on transaction broadcast.
     * </pre>
     *
     * <code>string label = 10;</code>
     */
    private void clearLabel() {
      
      label_ = getDefaultInstance().getLabel();
    }
    /**
     * <pre>
     * A label that was optionally set on transaction broadcast.
     * </pre>
     *
     * <code>string label = 10;</code>
     * @param value The bytes for label to set.
     */
    private void setLabelBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      label_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.Transaction parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Transaction parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Transaction parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Transaction parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Transaction parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Transaction parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Transaction parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Transaction parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Transaction parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Transaction parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Transaction parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Transaction parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.Transaction prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.Transaction}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.Transaction, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.Transaction)
        co.anode.anodium.Rpc.TransactionOrBuilder {
      // Construct using co.anode.anodium.Rpc.Transaction.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The transaction hash
       * </pre>
       *
       * <code>string tx_hash = 1;</code>
       * @return The txHash.
       */
      @java.lang.Override
      public java.lang.String getTxHash() {
        return instance.getTxHash();
      }
      /**
       * <pre>
       * The transaction hash
       * </pre>
       *
       * <code>string tx_hash = 1;</code>
       * @return The bytes for txHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getTxHashBytes() {
        return instance.getTxHashBytes();
      }
      /**
       * <pre>
       * The transaction hash
       * </pre>
       *
       * <code>string tx_hash = 1;</code>
       * @param value The txHash to set.
       * @return This builder for chaining.
       */
      public Builder setTxHash(
          java.lang.String value) {
        copyOnWrite();
        instance.setTxHash(value);
        return this;
      }
      /**
       * <pre>
       * The transaction hash
       * </pre>
       *
       * <code>string tx_hash = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTxHash() {
        copyOnWrite();
        instance.clearTxHash();
        return this;
      }
      /**
       * <pre>
       * The transaction hash
       * </pre>
       *
       * <code>string tx_hash = 1;</code>
       * @param value The bytes for txHash to set.
       * @return This builder for chaining.
       */
      public Builder setTxHashBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTxHashBytes(value);
        return this;
      }

      /**
       * <pre>
       * The transaction amount, denominated in satoshis
       * </pre>
       *
       * <code>int64 amount = 2;</code>
       * @return The amount.
       */
      @java.lang.Override
      public long getAmount() {
        return instance.getAmount();
      }
      /**
       * <pre>
       * The transaction amount, denominated in satoshis
       * </pre>
       *
       * <code>int64 amount = 2;</code>
       * @param value The amount to set.
       * @return This builder for chaining.
       */
      public Builder setAmount(long value) {
        copyOnWrite();
        instance.setAmount(value);
        return this;
      }
      /**
       * <pre>
       * The transaction amount, denominated in satoshis
       * </pre>
       *
       * <code>int64 amount = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmount() {
        copyOnWrite();
        instance.clearAmount();
        return this;
      }

      /**
       * <pre>
       * The number of confirmations
       * </pre>
       *
       * <code>int32 num_confirmations = 3;</code>
       * @return The numConfirmations.
       */
      @java.lang.Override
      public int getNumConfirmations() {
        return instance.getNumConfirmations();
      }
      /**
       * <pre>
       * The number of confirmations
       * </pre>
       *
       * <code>int32 num_confirmations = 3;</code>
       * @param value The numConfirmations to set.
       * @return This builder for chaining.
       */
      public Builder setNumConfirmations(int value) {
        copyOnWrite();
        instance.setNumConfirmations(value);
        return this;
      }
      /**
       * <pre>
       * The number of confirmations
       * </pre>
       *
       * <code>int32 num_confirmations = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumConfirmations() {
        copyOnWrite();
        instance.clearNumConfirmations();
        return this;
      }

      /**
       * <pre>
       * The hash of the block this transaction was included in
       * </pre>
       *
       * <code>string block_hash = 4;</code>
       * @return The blockHash.
       */
      @java.lang.Override
      public java.lang.String getBlockHash() {
        return instance.getBlockHash();
      }
      /**
       * <pre>
       * The hash of the block this transaction was included in
       * </pre>
       *
       * <code>string block_hash = 4;</code>
       * @return The bytes for blockHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getBlockHashBytes() {
        return instance.getBlockHashBytes();
      }
      /**
       * <pre>
       * The hash of the block this transaction was included in
       * </pre>
       *
       * <code>string block_hash = 4;</code>
       * @param value The blockHash to set.
       * @return This builder for chaining.
       */
      public Builder setBlockHash(
          java.lang.String value) {
        copyOnWrite();
        instance.setBlockHash(value);
        return this;
      }
      /**
       * <pre>
       * The hash of the block this transaction was included in
       * </pre>
       *
       * <code>string block_hash = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearBlockHash() {
        copyOnWrite();
        instance.clearBlockHash();
        return this;
      }
      /**
       * <pre>
       * The hash of the block this transaction was included in
       * </pre>
       *
       * <code>string block_hash = 4;</code>
       * @param value The bytes for blockHash to set.
       * @return This builder for chaining.
       */
      public Builder setBlockHashBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setBlockHashBytes(value);
        return this;
      }

      /**
       * <pre>
       * The height of the block this transaction was included in
       * </pre>
       *
       * <code>int32 block_height = 5;</code>
       * @return The blockHeight.
       */
      @java.lang.Override
      public int getBlockHeight() {
        return instance.getBlockHeight();
      }
      /**
       * <pre>
       * The height of the block this transaction was included in
       * </pre>
       *
       * <code>int32 block_height = 5;</code>
       * @param value The blockHeight to set.
       * @return This builder for chaining.
       */
      public Builder setBlockHeight(int value) {
        copyOnWrite();
        instance.setBlockHeight(value);
        return this;
      }
      /**
       * <pre>
       * The height of the block this transaction was included in
       * </pre>
       *
       * <code>int32 block_height = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearBlockHeight() {
        copyOnWrite();
        instance.clearBlockHeight();
        return this;
      }

      /**
       * <pre>
       * Timestamp of this transaction
       * </pre>
       *
       * <code>int64 time_stamp = 6;</code>
       * @return The timeStamp.
       */
      @java.lang.Override
      public long getTimeStamp() {
        return instance.getTimeStamp();
      }
      /**
       * <pre>
       * Timestamp of this transaction
       * </pre>
       *
       * <code>int64 time_stamp = 6;</code>
       * @param value The timeStamp to set.
       * @return This builder for chaining.
       */
      public Builder setTimeStamp(long value) {
        copyOnWrite();
        instance.setTimeStamp(value);
        return this;
      }
      /**
       * <pre>
       * Timestamp of this transaction
       * </pre>
       *
       * <code>int64 time_stamp = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimeStamp() {
        copyOnWrite();
        instance.clearTimeStamp();
        return this;
      }

      /**
       * <pre>
       * Fees paid for this transaction
       * </pre>
       *
       * <code>int64 total_fees = 7;</code>
       * @return The totalFees.
       */
      @java.lang.Override
      public long getTotalFees() {
        return instance.getTotalFees();
      }
      /**
       * <pre>
       * Fees paid for this transaction
       * </pre>
       *
       * <code>int64 total_fees = 7;</code>
       * @param value The totalFees to set.
       * @return This builder for chaining.
       */
      public Builder setTotalFees(long value) {
        copyOnWrite();
        instance.setTotalFees(value);
        return this;
      }
      /**
       * <pre>
       * Fees paid for this transaction
       * </pre>
       *
       * <code>int64 total_fees = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearTotalFees() {
        copyOnWrite();
        instance.clearTotalFees();
        return this;
      }

      /**
       * <pre>
       * Addresses that received funds for this transaction
       * </pre>
       *
       * <code>repeated string dest_addresses = 8;</code>
       * @return A list containing the destAddresses.
       */
      @java.lang.Override
      public java.util.List<java.lang.String>
          getDestAddressesList() {
        return java.util.Collections.unmodifiableList(
            instance.getDestAddressesList());
      }
      /**
       * <pre>
       * Addresses that received funds for this transaction
       * </pre>
       *
       * <code>repeated string dest_addresses = 8;</code>
       * @return The count of destAddresses.
       */
      @java.lang.Override
      public int getDestAddressesCount() {
        return instance.getDestAddressesCount();
      }
      /**
       * <pre>
       * Addresses that received funds for this transaction
       * </pre>
       *
       * <code>repeated string dest_addresses = 8;</code>
       * @param index The index of the element to return.
       * @return The destAddresses at the given index.
       */
      @java.lang.Override
      public java.lang.String getDestAddresses(int index) {
        return instance.getDestAddresses(index);
      }
      /**
       * <pre>
       * Addresses that received funds for this transaction
       * </pre>
       *
       * <code>repeated string dest_addresses = 8;</code>
       * @param index The index of the value to return.
       * @return The bytes of the destAddresses at the given index.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getDestAddressesBytes(int index) {
        return instance.getDestAddressesBytes(index);
      }
      /**
       * <pre>
       * Addresses that received funds for this transaction
       * </pre>
       *
       * <code>repeated string dest_addresses = 8;</code>
       * @param index The index to set the value at.
       * @param value The destAddresses to set.
       * @return This builder for chaining.
       */
      public Builder setDestAddresses(
          int index, java.lang.String value) {
        copyOnWrite();
        instance.setDestAddresses(index, value);
        return this;
      }
      /**
       * <pre>
       * Addresses that received funds for this transaction
       * </pre>
       *
       * <code>repeated string dest_addresses = 8;</code>
       * @param value The destAddresses to add.
       * @return This builder for chaining.
       */
      public Builder addDestAddresses(
          java.lang.String value) {
        copyOnWrite();
        instance.addDestAddresses(value);
        return this;
      }
      /**
       * <pre>
       * Addresses that received funds for this transaction
       * </pre>
       *
       * <code>repeated string dest_addresses = 8;</code>
       * @param values The destAddresses to add.
       * @return This builder for chaining.
       */
      public Builder addAllDestAddresses(
          java.lang.Iterable<java.lang.String> values) {
        copyOnWrite();
        instance.addAllDestAddresses(values);
        return this;
      }
      /**
       * <pre>
       * Addresses that received funds for this transaction
       * </pre>
       *
       * <code>repeated string dest_addresses = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearDestAddresses() {
        copyOnWrite();
        instance.clearDestAddresses();
        return this;
      }
      /**
       * <pre>
       * Addresses that received funds for this transaction
       * </pre>
       *
       * <code>repeated string dest_addresses = 8;</code>
       * @param value The bytes of the destAddresses to add.
       * @return This builder for chaining.
       */
      public Builder addDestAddressesBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addDestAddressesBytes(value);
        return this;
      }

      /**
       * <pre>
       * The raw transaction hex.
       * </pre>
       *
       * <code>string raw_tx_hex = 9;</code>
       * @return The rawTxHex.
       */
      @java.lang.Override
      public java.lang.String getRawTxHex() {
        return instance.getRawTxHex();
      }
      /**
       * <pre>
       * The raw transaction hex.
       * </pre>
       *
       * <code>string raw_tx_hex = 9;</code>
       * @return The bytes for rawTxHex.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getRawTxHexBytes() {
        return instance.getRawTxHexBytes();
      }
      /**
       * <pre>
       * The raw transaction hex.
       * </pre>
       *
       * <code>string raw_tx_hex = 9;</code>
       * @param value The rawTxHex to set.
       * @return This builder for chaining.
       */
      public Builder setRawTxHex(
          java.lang.String value) {
        copyOnWrite();
        instance.setRawTxHex(value);
        return this;
      }
      /**
       * <pre>
       * The raw transaction hex.
       * </pre>
       *
       * <code>string raw_tx_hex = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearRawTxHex() {
        copyOnWrite();
        instance.clearRawTxHex();
        return this;
      }
      /**
       * <pre>
       * The raw transaction hex.
       * </pre>
       *
       * <code>string raw_tx_hex = 9;</code>
       * @param value The bytes for rawTxHex to set.
       * @return This builder for chaining.
       */
      public Builder setRawTxHexBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setRawTxHexBytes(value);
        return this;
      }

      /**
       * <pre>
       * A label that was optionally set on transaction broadcast.
       * </pre>
       *
       * <code>string label = 10;</code>
       * @return The label.
       */
      @java.lang.Override
      public java.lang.String getLabel() {
        return instance.getLabel();
      }
      /**
       * <pre>
       * A label that was optionally set on transaction broadcast.
       * </pre>
       *
       * <code>string label = 10;</code>
       * @return The bytes for label.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getLabelBytes() {
        return instance.getLabelBytes();
      }
      /**
       * <pre>
       * A label that was optionally set on transaction broadcast.
       * </pre>
       *
       * <code>string label = 10;</code>
       * @param value The label to set.
       * @return This builder for chaining.
       */
      public Builder setLabel(
          java.lang.String value) {
        copyOnWrite();
        instance.setLabel(value);
        return this;
      }
      /**
       * <pre>
       * A label that was optionally set on transaction broadcast.
       * </pre>
       *
       * <code>string label = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearLabel() {
        copyOnWrite();
        instance.clearLabel();
        return this;
      }
      /**
       * <pre>
       * A label that was optionally set on transaction broadcast.
       * </pre>
       *
       * <code>string label = 10;</code>
       * @param value The bytes for label to set.
       * @return This builder for chaining.
       */
      public Builder setLabelBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLabelBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.Transaction)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.Transaction();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "txHash_",
              "amount_",
              "numConfirmations_",
              "blockHash_",
              "blockHeight_",
              "timeStamp_",
              "totalFees_",
              "destAddresses_",
              "rawTxHex_",
              "label_",
            };
            java.lang.String info =
                "\u0000\n\u0000\u0000\u0001\n\n\u0000\u0001\u0000\u0001\u0208\u0002\u0002\u0003\u0004" +
                "\u0004\u0208\u0005\u0004\u0006\u0002\u0007\u0002\b\u021a\t\u0208\n\u0208";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.Transaction> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.Transaction.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.Transaction>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.Transaction)
    private static final co.anode.anodium.Rpc.Transaction DEFAULT_INSTANCE;
    static {
      Transaction defaultInstance = new Transaction();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Transaction.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.Transaction getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Transaction> PARSER;

    public static com.google.protobuf.Parser<Transaction> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface GetTransactionsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.GetTransactionsRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The height from which to list transactions, inclusive. If this value is
     *greater than end_height, transactions will be read in reverse.
     * </pre>
     *
     * <code>int32 start_height = 1;</code>
     * @return The startHeight.
     */
    int getStartHeight();

    /**
     * <pre>
     *The height until which to list transactions, inclusive. To include
     *unconfirmed transactions, this value should be set to -1, which will
     *return transactions from start_height until the current chain tip and
     *unconfirmed transactions. If no end_height is provided, the call will
     *default to this option.
     * </pre>
     *
     * <code>int32 end_height = 2;</code>
     * @return The endHeight.
     */
    int getEndHeight();
  }
  /**
   * Protobuf type {@code co.anode.anodium.GetTransactionsRequest}
   */
  public  static final class GetTransactionsRequest extends
      com.google.protobuf.GeneratedMessageLite<
          GetTransactionsRequest, GetTransactionsRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.GetTransactionsRequest)
      GetTransactionsRequestOrBuilder {
    private GetTransactionsRequest() {
    }
    public static final int START_HEIGHT_FIELD_NUMBER = 1;
    private int startHeight_;
    /**
     * <pre>
     *The height from which to list transactions, inclusive. If this value is
     *greater than end_height, transactions will be read in reverse.
     * </pre>
     *
     * <code>int32 start_height = 1;</code>
     * @return The startHeight.
     */
    @java.lang.Override
    public int getStartHeight() {
      return startHeight_;
    }
    /**
     * <pre>
     *The height from which to list transactions, inclusive. If this value is
     *greater than end_height, transactions will be read in reverse.
     * </pre>
     *
     * <code>int32 start_height = 1;</code>
     * @param value The startHeight to set.
     */
    private void setStartHeight(int value) {
      
      startHeight_ = value;
    }
    /**
     * <pre>
     *The height from which to list transactions, inclusive. If this value is
     *greater than end_height, transactions will be read in reverse.
     * </pre>
     *
     * <code>int32 start_height = 1;</code>
     */
    private void clearStartHeight() {
      
      startHeight_ = 0;
    }

    public static final int END_HEIGHT_FIELD_NUMBER = 2;
    private int endHeight_;
    /**
     * <pre>
     *The height until which to list transactions, inclusive. To include
     *unconfirmed transactions, this value should be set to -1, which will
     *return transactions from start_height until the current chain tip and
     *unconfirmed transactions. If no end_height is provided, the call will
     *default to this option.
     * </pre>
     *
     * <code>int32 end_height = 2;</code>
     * @return The endHeight.
     */
    @java.lang.Override
    public int getEndHeight() {
      return endHeight_;
    }
    /**
     * <pre>
     *The height until which to list transactions, inclusive. To include
     *unconfirmed transactions, this value should be set to -1, which will
     *return transactions from start_height until the current chain tip and
     *unconfirmed transactions. If no end_height is provided, the call will
     *default to this option.
     * </pre>
     *
     * <code>int32 end_height = 2;</code>
     * @param value The endHeight to set.
     */
    private void setEndHeight(int value) {
      
      endHeight_ = value;
    }
    /**
     * <pre>
     *The height until which to list transactions, inclusive. To include
     *unconfirmed transactions, this value should be set to -1, which will
     *return transactions from start_height until the current chain tip and
     *unconfirmed transactions. If no end_height is provided, the call will
     *default to this option.
     * </pre>
     *
     * <code>int32 end_height = 2;</code>
     */
    private void clearEndHeight() {
      
      endHeight_ = 0;
    }

    public static co.anode.anodium.Rpc.GetTransactionsRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetTransactionsRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetTransactionsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetTransactionsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetTransactionsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetTransactionsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetTransactionsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetTransactionsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetTransactionsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetTransactionsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetTransactionsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetTransactionsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.GetTransactionsRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.GetTransactionsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.GetTransactionsRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.GetTransactionsRequest)
        co.anode.anodium.Rpc.GetTransactionsRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.GetTransactionsRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The height from which to list transactions, inclusive. If this value is
       *greater than end_height, transactions will be read in reverse.
       * </pre>
       *
       * <code>int32 start_height = 1;</code>
       * @return The startHeight.
       */
      @java.lang.Override
      public int getStartHeight() {
        return instance.getStartHeight();
      }
      /**
       * <pre>
       *The height from which to list transactions, inclusive. If this value is
       *greater than end_height, transactions will be read in reverse.
       * </pre>
       *
       * <code>int32 start_height = 1;</code>
       * @param value The startHeight to set.
       * @return This builder for chaining.
       */
      public Builder setStartHeight(int value) {
        copyOnWrite();
        instance.setStartHeight(value);
        return this;
      }
      /**
       * <pre>
       *The height from which to list transactions, inclusive. If this value is
       *greater than end_height, transactions will be read in reverse.
       * </pre>
       *
       * <code>int32 start_height = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearStartHeight() {
        copyOnWrite();
        instance.clearStartHeight();
        return this;
      }

      /**
       * <pre>
       *The height until which to list transactions, inclusive. To include
       *unconfirmed transactions, this value should be set to -1, which will
       *return transactions from start_height until the current chain tip and
       *unconfirmed transactions. If no end_height is provided, the call will
       *default to this option.
       * </pre>
       *
       * <code>int32 end_height = 2;</code>
       * @return The endHeight.
       */
      @java.lang.Override
      public int getEndHeight() {
        return instance.getEndHeight();
      }
      /**
       * <pre>
       *The height until which to list transactions, inclusive. To include
       *unconfirmed transactions, this value should be set to -1, which will
       *return transactions from start_height until the current chain tip and
       *unconfirmed transactions. If no end_height is provided, the call will
       *default to this option.
       * </pre>
       *
       * <code>int32 end_height = 2;</code>
       * @param value The endHeight to set.
       * @return This builder for chaining.
       */
      public Builder setEndHeight(int value) {
        copyOnWrite();
        instance.setEndHeight(value);
        return this;
      }
      /**
       * <pre>
       *The height until which to list transactions, inclusive. To include
       *unconfirmed transactions, this value should be set to -1, which will
       *return transactions from start_height until the current chain tip and
       *unconfirmed transactions. If no end_height is provided, the call will
       *default to this option.
       * </pre>
       *
       * <code>int32 end_height = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearEndHeight() {
        copyOnWrite();
        instance.clearEndHeight();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.GetTransactionsRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.GetTransactionsRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "startHeight_",
              "endHeight_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0004\u0002\u0004" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.GetTransactionsRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.GetTransactionsRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.GetTransactionsRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.GetTransactionsRequest)
    private static final co.anode.anodium.Rpc.GetTransactionsRequest DEFAULT_INSTANCE;
    static {
      GetTransactionsRequest defaultInstance = new GetTransactionsRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        GetTransactionsRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.GetTransactionsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<GetTransactionsRequest> PARSER;

    public static com.google.protobuf.Parser<GetTransactionsRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TransactionDetailsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.TransactionDetails)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The list of transactions relevant to the wallet.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
     */
    java.util.List<co.anode.anodium.Rpc.Transaction> 
        getTransactionsList();
    /**
     * <pre>
     * The list of transactions relevant to the wallet.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
     */
    co.anode.anodium.Rpc.Transaction getTransactions(int index);
    /**
     * <pre>
     * The list of transactions relevant to the wallet.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
     */
    int getTransactionsCount();
  }
  /**
   * Protobuf type {@code co.anode.anodium.TransactionDetails}
   */
  public  static final class TransactionDetails extends
      com.google.protobuf.GeneratedMessageLite<
          TransactionDetails, TransactionDetails.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.TransactionDetails)
      TransactionDetailsOrBuilder {
    private TransactionDetails() {
      transactions_ = emptyProtobufList();
    }
    public static final int TRANSACTIONS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Transaction> transactions_;
    /**
     * <pre>
     * The list of transactions relevant to the wallet.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.Transaction> getTransactionsList() {
      return transactions_;
    }
    /**
     * <pre>
     * The list of transactions relevant to the wallet.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.TransactionOrBuilder> 
        getTransactionsOrBuilderList() {
      return transactions_;
    }
    /**
     * <pre>
     * The list of transactions relevant to the wallet.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
     */
    @java.lang.Override
    public int getTransactionsCount() {
      return transactions_.size();
    }
    /**
     * <pre>
     * The list of transactions relevant to the wallet.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Transaction getTransactions(int index) {
      return transactions_.get(index);
    }
    /**
     * <pre>
     * The list of transactions relevant to the wallet.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
     */
    public co.anode.anodium.Rpc.TransactionOrBuilder getTransactionsOrBuilder(
        int index) {
      return transactions_.get(index);
    }
    private void ensureTransactionsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Transaction> tmp = transactions_;
      if (!tmp.isModifiable()) {
        transactions_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * The list of transactions relevant to the wallet.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
     */
    private void setTransactions(
        int index, co.anode.anodium.Rpc.Transaction value) {
      value.getClass();
  ensureTransactionsIsMutable();
      transactions_.set(index, value);
    }
    /**
     * <pre>
     * The list of transactions relevant to the wallet.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
     */
    private void addTransactions(co.anode.anodium.Rpc.Transaction value) {
      value.getClass();
  ensureTransactionsIsMutable();
      transactions_.add(value);
    }
    /**
     * <pre>
     * The list of transactions relevant to the wallet.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
     */
    private void addTransactions(
        int index, co.anode.anodium.Rpc.Transaction value) {
      value.getClass();
  ensureTransactionsIsMutable();
      transactions_.add(index, value);
    }
    /**
     * <pre>
     * The list of transactions relevant to the wallet.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
     */
    private void addAllTransactions(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.Transaction> values) {
      ensureTransactionsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, transactions_);
    }
    /**
     * <pre>
     * The list of transactions relevant to the wallet.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
     */
    private void clearTransactions() {
      transactions_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The list of transactions relevant to the wallet.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
     */
    private void removeTransactions(int index) {
      ensureTransactionsIsMutable();
      transactions_.remove(index);
    }

    public static co.anode.anodium.Rpc.TransactionDetails parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.TransactionDetails parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.TransactionDetails parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.TransactionDetails parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.TransactionDetails parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.TransactionDetails parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.TransactionDetails parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.TransactionDetails parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.TransactionDetails parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.TransactionDetails parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.TransactionDetails parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.TransactionDetails parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.TransactionDetails prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.TransactionDetails}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.TransactionDetails, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.TransactionDetails)
        co.anode.anodium.Rpc.TransactionDetailsOrBuilder {
      // Construct using co.anode.anodium.Rpc.TransactionDetails.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The list of transactions relevant to the wallet.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.Transaction> getTransactionsList() {
        return java.util.Collections.unmodifiableList(
            instance.getTransactionsList());
      }
      /**
       * <pre>
       * The list of transactions relevant to the wallet.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
       */
      @java.lang.Override
      public int getTransactionsCount() {
        return instance.getTransactionsCount();
      }/**
       * <pre>
       * The list of transactions relevant to the wallet.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Transaction getTransactions(int index) {
        return instance.getTransactions(index);
      }
      /**
       * <pre>
       * The list of transactions relevant to the wallet.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
       */
      public Builder setTransactions(
          int index, co.anode.anodium.Rpc.Transaction value) {
        copyOnWrite();
        instance.setTransactions(index, value);
        return this;
      }
      /**
       * <pre>
       * The list of transactions relevant to the wallet.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
       */
      public Builder setTransactions(
          int index, co.anode.anodium.Rpc.Transaction.Builder builderForValue) {
        copyOnWrite();
        instance.setTransactions(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of transactions relevant to the wallet.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
       */
      public Builder addTransactions(co.anode.anodium.Rpc.Transaction value) {
        copyOnWrite();
        instance.addTransactions(value);
        return this;
      }
      /**
       * <pre>
       * The list of transactions relevant to the wallet.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
       */
      public Builder addTransactions(
          int index, co.anode.anodium.Rpc.Transaction value) {
        copyOnWrite();
        instance.addTransactions(index, value);
        return this;
      }
      /**
       * <pre>
       * The list of transactions relevant to the wallet.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
       */
      public Builder addTransactions(
          co.anode.anodium.Rpc.Transaction.Builder builderForValue) {
        copyOnWrite();
        instance.addTransactions(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of transactions relevant to the wallet.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
       */
      public Builder addTransactions(
          int index, co.anode.anodium.Rpc.Transaction.Builder builderForValue) {
        copyOnWrite();
        instance.addTransactions(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of transactions relevant to the wallet.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
       */
      public Builder addAllTransactions(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.Transaction> values) {
        copyOnWrite();
        instance.addAllTransactions(values);
        return this;
      }
      /**
       * <pre>
       * The list of transactions relevant to the wallet.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
       */
      public Builder clearTransactions() {
        copyOnWrite();
        instance.clearTransactions();
        return this;
      }
      /**
       * <pre>
       * The list of transactions relevant to the wallet.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Transaction transactions = 1;</code>
       */
      public Builder removeTransactions(int index) {
        copyOnWrite();
        instance.removeTransactions(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.TransactionDetails)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.TransactionDetails();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "transactions_",
              co.anode.anodium.Rpc.Transaction.class,
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0000\u0001\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.TransactionDetails> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.TransactionDetails.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.TransactionDetails>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.TransactionDetails)
    private static final co.anode.anodium.Rpc.TransactionDetails DEFAULT_INSTANCE;
    static {
      TransactionDetails defaultInstance = new TransactionDetails();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TransactionDetails.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.TransactionDetails getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TransactionDetails> PARSER;

    public static com.google.protobuf.Parser<TransactionDetails> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FeeLimitOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.FeeLimit)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The fee limit expressed as a fixed amount of satoshis.
     *The fields fixed and fixed_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 fixed = 1;</code>
     * @return Whether the fixed field is set.
     */
    boolean hasFixed();
    /**
     * <pre>
     *The fee limit expressed as a fixed amount of satoshis.
     *The fields fixed and fixed_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 fixed = 1;</code>
     * @return The fixed.
     */
    long getFixed();

    /**
     * <pre>
     *The fee limit expressed as a fixed amount of millisatoshis.
     *The fields fixed and fixed_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 fixed_msat = 3;</code>
     * @return Whether the fixedMsat field is set.
     */
    boolean hasFixedMsat();
    /**
     * <pre>
     *The fee limit expressed as a fixed amount of millisatoshis.
     *The fields fixed and fixed_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 fixed_msat = 3;</code>
     * @return The fixedMsat.
     */
    long getFixedMsat();

    /**
     * <pre>
     * The fee limit expressed as a percentage of the payment amount.
     * </pre>
     *
     * <code>int64 percent = 2;</code>
     * @return Whether the percent field is set.
     */
    boolean hasPercent();
    /**
     * <pre>
     * The fee limit expressed as a percentage of the payment amount.
     * </pre>
     *
     * <code>int64 percent = 2;</code>
     * @return The percent.
     */
    long getPercent();

    public co.anode.anodium.Rpc.FeeLimit.LimitCase getLimitCase();
  }
  /**
   * Protobuf type {@code co.anode.anodium.FeeLimit}
   */
  public  static final class FeeLimit extends
      com.google.protobuf.GeneratedMessageLite<
          FeeLimit, FeeLimit.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.FeeLimit)
      FeeLimitOrBuilder {
    private FeeLimit() {
    }
    private int limitCase_ = 0;
    private java.lang.Object limit_;
    public enum LimitCase {
      FIXED(1),
      FIXED_MSAT(3),
      PERCENT(2),
      LIMIT_NOT_SET(0);
      private final int value;
      private LimitCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static LimitCase valueOf(int value) {
        return forNumber(value);
      }

      public static LimitCase forNumber(int value) {
        switch (value) {
          case 1: return FIXED;
          case 3: return FIXED_MSAT;
          case 2: return PERCENT;
          case 0: return LIMIT_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    @java.lang.Override
    public LimitCase
    getLimitCase() {
      return LimitCase.forNumber(
          limitCase_);
    }

    private void clearLimit() {
      limitCase_ = 0;
      limit_ = null;
    }

    public static final int FIXED_FIELD_NUMBER = 1;
    /**
     * <pre>
     *The fee limit expressed as a fixed amount of satoshis.
     *The fields fixed and fixed_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 fixed = 1;</code>
     * @return Whether the fixed field is set.
     */
    @java.lang.Override
    public boolean hasFixed() {
      return limitCase_ == 1;
    }
    /**
     * <pre>
     *The fee limit expressed as a fixed amount of satoshis.
     *The fields fixed and fixed_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 fixed = 1;</code>
     * @return The fixed.
     */
    @java.lang.Override
    public long getFixed() {
      if (limitCase_ == 1) {
        return (java.lang.Long) limit_;
      }
      return 0L;
    }
    /**
     * <pre>
     *The fee limit expressed as a fixed amount of satoshis.
     *The fields fixed and fixed_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 fixed = 1;</code>
     * @param value The fixed to set.
     */
    private void setFixed(long value) {
      limitCase_ = 1;
      limit_ = value;
    }
    /**
     * <pre>
     *The fee limit expressed as a fixed amount of satoshis.
     *The fields fixed and fixed_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 fixed = 1;</code>
     */
    private void clearFixed() {
      if (limitCase_ == 1) {
        limitCase_ = 0;
        limit_ = null;
      }
    }

    public static final int FIXED_MSAT_FIELD_NUMBER = 3;
    /**
     * <pre>
     *The fee limit expressed as a fixed amount of millisatoshis.
     *The fields fixed and fixed_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 fixed_msat = 3;</code>
     * @return Whether the fixedMsat field is set.
     */
    @java.lang.Override
    public boolean hasFixedMsat() {
      return limitCase_ == 3;
    }
    /**
     * <pre>
     *The fee limit expressed as a fixed amount of millisatoshis.
     *The fields fixed and fixed_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 fixed_msat = 3;</code>
     * @return The fixedMsat.
     */
    @java.lang.Override
    public long getFixedMsat() {
      if (limitCase_ == 3) {
        return (java.lang.Long) limit_;
      }
      return 0L;
    }
    /**
     * <pre>
     *The fee limit expressed as a fixed amount of millisatoshis.
     *The fields fixed and fixed_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 fixed_msat = 3;</code>
     * @param value The fixedMsat to set.
     */
    private void setFixedMsat(long value) {
      limitCase_ = 3;
      limit_ = value;
    }
    /**
     * <pre>
     *The fee limit expressed as a fixed amount of millisatoshis.
     *The fields fixed and fixed_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 fixed_msat = 3;</code>
     */
    private void clearFixedMsat() {
      if (limitCase_ == 3) {
        limitCase_ = 0;
        limit_ = null;
      }
    }

    public static final int PERCENT_FIELD_NUMBER = 2;
    /**
     * <pre>
     * The fee limit expressed as a percentage of the payment amount.
     * </pre>
     *
     * <code>int64 percent = 2;</code>
     * @return Whether the percent field is set.
     */
    @java.lang.Override
    public boolean hasPercent() {
      return limitCase_ == 2;
    }
    /**
     * <pre>
     * The fee limit expressed as a percentage of the payment amount.
     * </pre>
     *
     * <code>int64 percent = 2;</code>
     * @return The percent.
     */
    @java.lang.Override
    public long getPercent() {
      if (limitCase_ == 2) {
        return (java.lang.Long) limit_;
      }
      return 0L;
    }
    /**
     * <pre>
     * The fee limit expressed as a percentage of the payment amount.
     * </pre>
     *
     * <code>int64 percent = 2;</code>
     * @param value The percent to set.
     */
    private void setPercent(long value) {
      limitCase_ = 2;
      limit_ = value;
    }
    /**
     * <pre>
     * The fee limit expressed as a percentage of the payment amount.
     * </pre>
     *
     * <code>int64 percent = 2;</code>
     */
    private void clearPercent() {
      if (limitCase_ == 2) {
        limitCase_ = 0;
        limit_ = null;
      }
    }

    public static co.anode.anodium.Rpc.FeeLimit parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FeeLimit parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FeeLimit parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FeeLimit parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FeeLimit parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FeeLimit parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FeeLimit parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FeeLimit parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FeeLimit parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FeeLimit parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FeeLimit parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FeeLimit parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.FeeLimit prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.FeeLimit}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.FeeLimit, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.FeeLimit)
        co.anode.anodium.Rpc.FeeLimitOrBuilder {
      // Construct using co.anode.anodium.Rpc.FeeLimit.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }

      @java.lang.Override
      public LimitCase
          getLimitCase() {
        return instance.getLimitCase();
      }

      public Builder clearLimit() {
        copyOnWrite();
        instance.clearLimit();
        return this;
      }


      /**
       * <pre>
       *The fee limit expressed as a fixed amount of satoshis.
       *The fields fixed and fixed_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 fixed = 1;</code>
       * @return Whether the fixed field is set.
       */
      @java.lang.Override
      public boolean hasFixed() {
        return instance.hasFixed();
      }
      /**
       * <pre>
       *The fee limit expressed as a fixed amount of satoshis.
       *The fields fixed and fixed_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 fixed = 1;</code>
       * @return The fixed.
       */
      @java.lang.Override
      public long getFixed() {
        return instance.getFixed();
      }
      /**
       * <pre>
       *The fee limit expressed as a fixed amount of satoshis.
       *The fields fixed and fixed_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 fixed = 1;</code>
       * @param value The fixed to set.
       * @return This builder for chaining.
       */
      public Builder setFixed(long value) {
        copyOnWrite();
        instance.setFixed(value);
        return this;
      }
      /**
       * <pre>
       *The fee limit expressed as a fixed amount of satoshis.
       *The fields fixed and fixed_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 fixed = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearFixed() {
        copyOnWrite();
        instance.clearFixed();
        return this;
      }

      /**
       * <pre>
       *The fee limit expressed as a fixed amount of millisatoshis.
       *The fields fixed and fixed_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 fixed_msat = 3;</code>
       * @return Whether the fixedMsat field is set.
       */
      @java.lang.Override
      public boolean hasFixedMsat() {
        return instance.hasFixedMsat();
      }
      /**
       * <pre>
       *The fee limit expressed as a fixed amount of millisatoshis.
       *The fields fixed and fixed_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 fixed_msat = 3;</code>
       * @return The fixedMsat.
       */
      @java.lang.Override
      public long getFixedMsat() {
        return instance.getFixedMsat();
      }
      /**
       * <pre>
       *The fee limit expressed as a fixed amount of millisatoshis.
       *The fields fixed and fixed_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 fixed_msat = 3;</code>
       * @param value The fixedMsat to set.
       * @return This builder for chaining.
       */
      public Builder setFixedMsat(long value) {
        copyOnWrite();
        instance.setFixedMsat(value);
        return this;
      }
      /**
       * <pre>
       *The fee limit expressed as a fixed amount of millisatoshis.
       *The fields fixed and fixed_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 fixed_msat = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearFixedMsat() {
        copyOnWrite();
        instance.clearFixedMsat();
        return this;
      }

      /**
       * <pre>
       * The fee limit expressed as a percentage of the payment amount.
       * </pre>
       *
       * <code>int64 percent = 2;</code>
       * @return Whether the percent field is set.
       */
      @java.lang.Override
      public boolean hasPercent() {
        return instance.hasPercent();
      }
      /**
       * <pre>
       * The fee limit expressed as a percentage of the payment amount.
       * </pre>
       *
       * <code>int64 percent = 2;</code>
       * @return The percent.
       */
      @java.lang.Override
      public long getPercent() {
        return instance.getPercent();
      }
      /**
       * <pre>
       * The fee limit expressed as a percentage of the payment amount.
       * </pre>
       *
       * <code>int64 percent = 2;</code>
       * @param value The percent to set.
       * @return This builder for chaining.
       */
      public Builder setPercent(long value) {
        copyOnWrite();
        instance.setPercent(value);
        return this;
      }
      /**
       * <pre>
       * The fee limit expressed as a percentage of the payment amount.
       * </pre>
       *
       * <code>int64 percent = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPercent() {
        copyOnWrite();
        instance.clearPercent();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.FeeLimit)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.FeeLimit();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "limit_",
              "limitCase_",
            };
            java.lang.String info =
                "\u0000\u0003\u0001\u0000\u0001\u0003\u0003\u0000\u0000\u0000\u00015\u0000\u00025" +
                "\u0000\u00035\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.FeeLimit> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.FeeLimit.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.FeeLimit>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.FeeLimit)
    private static final co.anode.anodium.Rpc.FeeLimit DEFAULT_INSTANCE;
    static {
      FeeLimit defaultInstance = new FeeLimit();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        FeeLimit.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.FeeLimit getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FeeLimit> PARSER;

    public static com.google.protobuf.Parser<FeeLimit> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SendRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.SendRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The identity pubkey of the payment recipient. When using REST, this field
     *must be encoded as base64.
     * </pre>
     *
     * <code>bytes dest = 1;</code>
     * @return The dest.
     */
    com.google.protobuf.ByteString getDest();

    /**
     * <pre>
     *The hex-encoded identity pubkey of the payment recipient. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string dest_string = 2 [deprecated = true];</code>
     * @return The destString.
     */
    @java.lang.Deprecated java.lang.String getDestString();
    /**
     * <pre>
     *The hex-encoded identity pubkey of the payment recipient. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string dest_string = 2 [deprecated = true];</code>
     * @return The bytes for destString.
     */
    @java.lang.Deprecated com.google.protobuf.ByteString
        getDestStringBytes();

    /**
     * <pre>
     *The amount to send expressed in satoshis.
     *The fields amt and amt_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 amt = 3;</code>
     * @return The amt.
     */
    long getAmt();

    /**
     * <pre>
     *The amount to send expressed in millisatoshis.
     *The fields amt and amt_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 amt_msat = 12;</code>
     * @return The amtMsat.
     */
    long getAmtMsat();

    /**
     * <pre>
     *The hash to use within the payment's HTLC. When using REST, this field
     *must be encoded as base64.
     * </pre>
     *
     * <code>bytes payment_hash = 4;</code>
     * @return The paymentHash.
     */
    com.google.protobuf.ByteString getPaymentHash();

    /**
     * <pre>
     *The hex-encoded hash to use within the payment's HTLC. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string payment_hash_string = 5 [deprecated = true];</code>
     * @return The paymentHashString.
     */
    @java.lang.Deprecated java.lang.String getPaymentHashString();
    /**
     * <pre>
     *The hex-encoded hash to use within the payment's HTLC. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string payment_hash_string = 5 [deprecated = true];</code>
     * @return The bytes for paymentHashString.
     */
    @java.lang.Deprecated com.google.protobuf.ByteString
        getPaymentHashStringBytes();

    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 6;</code>
     * @return The paymentRequest.
     */
    java.lang.String getPaymentRequest();
    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 6;</code>
     * @return The bytes for paymentRequest.
     */
    com.google.protobuf.ByteString
        getPaymentRequestBytes();

    /**
     * <pre>
     *The CLTV delta from the current height that should be used to set the
     *timelock for the final hop.
     * </pre>
     *
     * <code>int32 final_cltv_delta = 7;</code>
     * @return The finalCltvDelta.
     */
    int getFinalCltvDelta();

    /**
     * <pre>
     *The maximum number of satoshis that will be paid as a fee of the payment.
     *This value can be represented either as a percentage of the amount being
     *sent, or as a fixed amount of the maximum fee the user is willing the pay to
     *send the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.FeeLimit fee_limit = 8;</code>
     * @return Whether the feeLimit field is set.
     */
    boolean hasFeeLimit();
    /**
     * <pre>
     *The maximum number of satoshis that will be paid as a fee of the payment.
     *This value can be represented either as a percentage of the amount being
     *sent, or as a fixed amount of the maximum fee the user is willing the pay to
     *send the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.FeeLimit fee_limit = 8;</code>
     * @return The feeLimit.
     */
    co.anode.anodium.Rpc.FeeLimit getFeeLimit();

    /**
     * <pre>
     *The channel id of the channel that must be taken to the first hop. If zero,
     *any channel may be used.
     * </pre>
     *
     * <code>uint64 outgoing_chan_id = 9 [jstype = JS_STRING];</code>
     * @return The outgoingChanId.
     */
    long getOutgoingChanId();

    /**
     * <pre>
     *The pubkey of the last hop of the route. If empty, any hop may be used.
     * </pre>
     *
     * <code>bytes last_hop_pubkey = 13;</code>
     * @return The lastHopPubkey.
     */
    com.google.protobuf.ByteString getLastHopPubkey();

    /**
     * <pre>
     *An optional maximum total time lock for the route. This should not exceed
     *lnd's `--max-cltv-expiry` setting. If zero, then the value of
     *`--max-cltv-expiry` is enforced.
     * </pre>
     *
     * <code>uint32 cltv_limit = 10;</code>
     * @return The cltvLimit.
     */
    int getCltvLimit();

    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. Record types are
     *required to be in the custom range &gt;= 65536. When using REST, the values
     *must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 11;</code>
     */
    int getDestCustomRecordsCount();
    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. Record types are
     *required to be in the custom range &gt;= 65536. When using REST, the values
     *must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 11;</code>
     */
    boolean containsDestCustomRecords(
        long key);
    /**
     * Use {@link #getDestCustomRecordsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Long, com.google.protobuf.ByteString>
    getDestCustomRecords();
    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. Record types are
     *required to be in the custom range &gt;= 65536. When using REST, the values
     *must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 11;</code>
     */
    java.util.Map<java.lang.Long, com.google.protobuf.ByteString>
    getDestCustomRecordsMap();
    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. Record types are
     *required to be in the custom range &gt;= 65536. When using REST, the values
     *must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 11;</code>
     */

    com.google.protobuf.ByteString getDestCustomRecordsOrDefault(
        long key,
        com.google.protobuf.ByteString defaultValue);
    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. Record types are
     *required to be in the custom range &gt;= 65536. When using REST, the values
     *must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 11;</code>
     */

    com.google.protobuf.ByteString getDestCustomRecordsOrThrow(
        long key);

    /**
     * <pre>
     * If set, circular payments to self are permitted.
     * </pre>
     *
     * <code>bool allow_self_payment = 14;</code>
     * @return The allowSelfPayment.
     */
    boolean getAllowSelfPayment();

    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
     * @return A list containing the destFeatures.
     */
    java.util.List<co.anode.anodium.Rpc.FeatureBit> getDestFeaturesList();
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
     * @return The count of destFeatures.
     */
    int getDestFeaturesCount();
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
     * @param index The index of the element to return.
     * @return The destFeatures at the given index.
     */
    co.anode.anodium.Rpc.FeatureBit getDestFeatures(int index);
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
     * @return A list containing the enum numeric values on the wire for destFeatures.
     */
    java.util.List<java.lang.Integer>
    getDestFeaturesValueList();
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
     * @param index The index of the value to return.
     * @return The enum numeric value on the wire of destFeatures at the given index.
     */
    int getDestFeaturesValue(int index);
  }
  /**
   * Protobuf type {@code co.anode.anodium.SendRequest}
   */
  public  static final class SendRequest extends
      com.google.protobuf.GeneratedMessageLite<
          SendRequest, SendRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.SendRequest)
      SendRequestOrBuilder {
    private SendRequest() {
      dest_ = com.google.protobuf.ByteString.EMPTY;
      destString_ = "";
      paymentHash_ = com.google.protobuf.ByteString.EMPTY;
      paymentHashString_ = "";
      paymentRequest_ = "";
      lastHopPubkey_ = com.google.protobuf.ByteString.EMPTY;
      destFeatures_ = emptyIntList();
    }
    public static final int DEST_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString dest_;
    /**
     * <pre>
     *The identity pubkey of the payment recipient. When using REST, this field
     *must be encoded as base64.
     * </pre>
     *
     * <code>bytes dest = 1;</code>
     * @return The dest.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getDest() {
      return dest_;
    }
    /**
     * <pre>
     *The identity pubkey of the payment recipient. When using REST, this field
     *must be encoded as base64.
     * </pre>
     *
     * <code>bytes dest = 1;</code>
     * @param value The dest to set.
     */
    private void setDest(com.google.protobuf.ByteString value) {
      value.getClass();
  
      dest_ = value;
    }
    /**
     * <pre>
     *The identity pubkey of the payment recipient. When using REST, this field
     *must be encoded as base64.
     * </pre>
     *
     * <code>bytes dest = 1;</code>
     */
    private void clearDest() {
      
      dest_ = getDefaultInstance().getDest();
    }

    public static final int DEST_STRING_FIELD_NUMBER = 2;
    private java.lang.String destString_;
    /**
     * <pre>
     *The hex-encoded identity pubkey of the payment recipient. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string dest_string = 2 [deprecated = true];</code>
     * @return The destString.
     */
    @java.lang.Override
    @java.lang.Deprecated public java.lang.String getDestString() {
      return destString_;
    }
    /**
     * <pre>
     *The hex-encoded identity pubkey of the payment recipient. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string dest_string = 2 [deprecated = true];</code>
     * @return The bytes for destString.
     */
    @java.lang.Override
    @java.lang.Deprecated public com.google.protobuf.ByteString
        getDestStringBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(destString_);
    }
    /**
     * <pre>
     *The hex-encoded identity pubkey of the payment recipient. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string dest_string = 2 [deprecated = true];</code>
     * @param value The destString to set.
     */
    private void setDestString(
        java.lang.String value) {
      value.getClass();
  
      destString_ = value;
    }
    /**
     * <pre>
     *The hex-encoded identity pubkey of the payment recipient. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string dest_string = 2 [deprecated = true];</code>
     */
    private void clearDestString() {
      
      destString_ = getDefaultInstance().getDestString();
    }
    /**
     * <pre>
     *The hex-encoded identity pubkey of the payment recipient. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string dest_string = 2 [deprecated = true];</code>
     * @param value The bytes for destString to set.
     */
    private void setDestStringBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      destString_ = value.toStringUtf8();
      
    }

    public static final int AMT_FIELD_NUMBER = 3;
    private long amt_;
    /**
     * <pre>
     *The amount to send expressed in satoshis.
     *The fields amt and amt_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 amt = 3;</code>
     * @return The amt.
     */
    @java.lang.Override
    public long getAmt() {
      return amt_;
    }
    /**
     * <pre>
     *The amount to send expressed in satoshis.
     *The fields amt and amt_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 amt = 3;</code>
     * @param value The amt to set.
     */
    private void setAmt(long value) {
      
      amt_ = value;
    }
    /**
     * <pre>
     *The amount to send expressed in satoshis.
     *The fields amt and amt_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 amt = 3;</code>
     */
    private void clearAmt() {
      
      amt_ = 0L;
    }

    public static final int AMT_MSAT_FIELD_NUMBER = 12;
    private long amtMsat_;
    /**
     * <pre>
     *The amount to send expressed in millisatoshis.
     *The fields amt and amt_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 amt_msat = 12;</code>
     * @return The amtMsat.
     */
    @java.lang.Override
    public long getAmtMsat() {
      return amtMsat_;
    }
    /**
     * <pre>
     *The amount to send expressed in millisatoshis.
     *The fields amt and amt_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 amt_msat = 12;</code>
     * @param value The amtMsat to set.
     */
    private void setAmtMsat(long value) {
      
      amtMsat_ = value;
    }
    /**
     * <pre>
     *The amount to send expressed in millisatoshis.
     *The fields amt and amt_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 amt_msat = 12;</code>
     */
    private void clearAmtMsat() {
      
      amtMsat_ = 0L;
    }

    public static final int PAYMENT_HASH_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString paymentHash_;
    /**
     * <pre>
     *The hash to use within the payment's HTLC. When using REST, this field
     *must be encoded as base64.
     * </pre>
     *
     * <code>bytes payment_hash = 4;</code>
     * @return The paymentHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPaymentHash() {
      return paymentHash_;
    }
    /**
     * <pre>
     *The hash to use within the payment's HTLC. When using REST, this field
     *must be encoded as base64.
     * </pre>
     *
     * <code>bytes payment_hash = 4;</code>
     * @param value The paymentHash to set.
     */
    private void setPaymentHash(com.google.protobuf.ByteString value) {
      value.getClass();
  
      paymentHash_ = value;
    }
    /**
     * <pre>
     *The hash to use within the payment's HTLC. When using REST, this field
     *must be encoded as base64.
     * </pre>
     *
     * <code>bytes payment_hash = 4;</code>
     */
    private void clearPaymentHash() {
      
      paymentHash_ = getDefaultInstance().getPaymentHash();
    }

    public static final int PAYMENT_HASH_STRING_FIELD_NUMBER = 5;
    private java.lang.String paymentHashString_;
    /**
     * <pre>
     *The hex-encoded hash to use within the payment's HTLC. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string payment_hash_string = 5 [deprecated = true];</code>
     * @return The paymentHashString.
     */
    @java.lang.Override
    @java.lang.Deprecated public java.lang.String getPaymentHashString() {
      return paymentHashString_;
    }
    /**
     * <pre>
     *The hex-encoded hash to use within the payment's HTLC. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string payment_hash_string = 5 [deprecated = true];</code>
     * @return The bytes for paymentHashString.
     */
    @java.lang.Override
    @java.lang.Deprecated public com.google.protobuf.ByteString
        getPaymentHashStringBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(paymentHashString_);
    }
    /**
     * <pre>
     *The hex-encoded hash to use within the payment's HTLC. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string payment_hash_string = 5 [deprecated = true];</code>
     * @param value The paymentHashString to set.
     */
    private void setPaymentHashString(
        java.lang.String value) {
      value.getClass();
  
      paymentHashString_ = value;
    }
    /**
     * <pre>
     *The hex-encoded hash to use within the payment's HTLC. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string payment_hash_string = 5 [deprecated = true];</code>
     */
    private void clearPaymentHashString() {
      
      paymentHashString_ = getDefaultInstance().getPaymentHashString();
    }
    /**
     * <pre>
     *The hex-encoded hash to use within the payment's HTLC. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string payment_hash_string = 5 [deprecated = true];</code>
     * @param value The bytes for paymentHashString to set.
     */
    private void setPaymentHashStringBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      paymentHashString_ = value.toStringUtf8();
      
    }

    public static final int PAYMENT_REQUEST_FIELD_NUMBER = 6;
    private java.lang.String paymentRequest_;
    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 6;</code>
     * @return The paymentRequest.
     */
    @java.lang.Override
    public java.lang.String getPaymentRequest() {
      return paymentRequest_;
    }
    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 6;</code>
     * @return The bytes for paymentRequest.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPaymentRequestBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(paymentRequest_);
    }
    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 6;</code>
     * @param value The paymentRequest to set.
     */
    private void setPaymentRequest(
        java.lang.String value) {
      value.getClass();
  
      paymentRequest_ = value;
    }
    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 6;</code>
     */
    private void clearPaymentRequest() {
      
      paymentRequest_ = getDefaultInstance().getPaymentRequest();
    }
    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 6;</code>
     * @param value The bytes for paymentRequest to set.
     */
    private void setPaymentRequestBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      paymentRequest_ = value.toStringUtf8();
      
    }

    public static final int FINAL_CLTV_DELTA_FIELD_NUMBER = 7;
    private int finalCltvDelta_;
    /**
     * <pre>
     *The CLTV delta from the current height that should be used to set the
     *timelock for the final hop.
     * </pre>
     *
     * <code>int32 final_cltv_delta = 7;</code>
     * @return The finalCltvDelta.
     */
    @java.lang.Override
    public int getFinalCltvDelta() {
      return finalCltvDelta_;
    }
    /**
     * <pre>
     *The CLTV delta from the current height that should be used to set the
     *timelock for the final hop.
     * </pre>
     *
     * <code>int32 final_cltv_delta = 7;</code>
     * @param value The finalCltvDelta to set.
     */
    private void setFinalCltvDelta(int value) {
      
      finalCltvDelta_ = value;
    }
    /**
     * <pre>
     *The CLTV delta from the current height that should be used to set the
     *timelock for the final hop.
     * </pre>
     *
     * <code>int32 final_cltv_delta = 7;</code>
     */
    private void clearFinalCltvDelta() {
      
      finalCltvDelta_ = 0;
    }

    public static final int FEE_LIMIT_FIELD_NUMBER = 8;
    private co.anode.anodium.Rpc.FeeLimit feeLimit_;
    /**
     * <pre>
     *The maximum number of satoshis that will be paid as a fee of the payment.
     *This value can be represented either as a percentage of the amount being
     *sent, or as a fixed amount of the maximum fee the user is willing the pay to
     *send the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.FeeLimit fee_limit = 8;</code>
     */
    @java.lang.Override
    public boolean hasFeeLimit() {
      return feeLimit_ != null;
    }
    /**
     * <pre>
     *The maximum number of satoshis that will be paid as a fee of the payment.
     *This value can be represented either as a percentage of the amount being
     *sent, or as a fixed amount of the maximum fee the user is willing the pay to
     *send the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.FeeLimit fee_limit = 8;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.FeeLimit getFeeLimit() {
      return feeLimit_ == null ? co.anode.anodium.Rpc.FeeLimit.getDefaultInstance() : feeLimit_;
    }
    /**
     * <pre>
     *The maximum number of satoshis that will be paid as a fee of the payment.
     *This value can be represented either as a percentage of the amount being
     *sent, or as a fixed amount of the maximum fee the user is willing the pay to
     *send the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.FeeLimit fee_limit = 8;</code>
     */
    private void setFeeLimit(co.anode.anodium.Rpc.FeeLimit value) {
      value.getClass();
  feeLimit_ = value;
      
      }
    /**
     * <pre>
     *The maximum number of satoshis that will be paid as a fee of the payment.
     *This value can be represented either as a percentage of the amount being
     *sent, or as a fixed amount of the maximum fee the user is willing the pay to
     *send the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.FeeLimit fee_limit = 8;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeFeeLimit(co.anode.anodium.Rpc.FeeLimit value) {
      value.getClass();
  if (feeLimit_ != null &&
          feeLimit_ != co.anode.anodium.Rpc.FeeLimit.getDefaultInstance()) {
        feeLimit_ =
          co.anode.anodium.Rpc.FeeLimit.newBuilder(feeLimit_).mergeFrom(value).buildPartial();
      } else {
        feeLimit_ = value;
      }
      
    }
    /**
     * <pre>
     *The maximum number of satoshis that will be paid as a fee of the payment.
     *This value can be represented either as a percentage of the amount being
     *sent, or as a fixed amount of the maximum fee the user is willing the pay to
     *send the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.FeeLimit fee_limit = 8;</code>
     */
    private void clearFeeLimit() {  feeLimit_ = null;
      
    }

    public static final int OUTGOING_CHAN_ID_FIELD_NUMBER = 9;
    private long outgoingChanId_;
    /**
     * <pre>
     *The channel id of the channel that must be taken to the first hop. If zero,
     *any channel may be used.
     * </pre>
     *
     * <code>uint64 outgoing_chan_id = 9 [jstype = JS_STRING];</code>
     * @return The outgoingChanId.
     */
    @java.lang.Override
    public long getOutgoingChanId() {
      return outgoingChanId_;
    }
    /**
     * <pre>
     *The channel id of the channel that must be taken to the first hop. If zero,
     *any channel may be used.
     * </pre>
     *
     * <code>uint64 outgoing_chan_id = 9 [jstype = JS_STRING];</code>
     * @param value The outgoingChanId to set.
     */
    private void setOutgoingChanId(long value) {
      
      outgoingChanId_ = value;
    }
    /**
     * <pre>
     *The channel id of the channel that must be taken to the first hop. If zero,
     *any channel may be used.
     * </pre>
     *
     * <code>uint64 outgoing_chan_id = 9 [jstype = JS_STRING];</code>
     */
    private void clearOutgoingChanId() {
      
      outgoingChanId_ = 0L;
    }

    public static final int LAST_HOP_PUBKEY_FIELD_NUMBER = 13;
    private com.google.protobuf.ByteString lastHopPubkey_;
    /**
     * <pre>
     *The pubkey of the last hop of the route. If empty, any hop may be used.
     * </pre>
     *
     * <code>bytes last_hop_pubkey = 13;</code>
     * @return The lastHopPubkey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getLastHopPubkey() {
      return lastHopPubkey_;
    }
    /**
     * <pre>
     *The pubkey of the last hop of the route. If empty, any hop may be used.
     * </pre>
     *
     * <code>bytes last_hop_pubkey = 13;</code>
     * @param value The lastHopPubkey to set.
     */
    private void setLastHopPubkey(com.google.protobuf.ByteString value) {
      value.getClass();
  
      lastHopPubkey_ = value;
    }
    /**
     * <pre>
     *The pubkey of the last hop of the route. If empty, any hop may be used.
     * </pre>
     *
     * <code>bytes last_hop_pubkey = 13;</code>
     */
    private void clearLastHopPubkey() {
      
      lastHopPubkey_ = getDefaultInstance().getLastHopPubkey();
    }

    public static final int CLTV_LIMIT_FIELD_NUMBER = 10;
    private int cltvLimit_;
    /**
     * <pre>
     *An optional maximum total time lock for the route. This should not exceed
     *lnd's `--max-cltv-expiry` setting. If zero, then the value of
     *`--max-cltv-expiry` is enforced.
     * </pre>
     *
     * <code>uint32 cltv_limit = 10;</code>
     * @return The cltvLimit.
     */
    @java.lang.Override
    public int getCltvLimit() {
      return cltvLimit_;
    }
    /**
     * <pre>
     *An optional maximum total time lock for the route. This should not exceed
     *lnd's `--max-cltv-expiry` setting. If zero, then the value of
     *`--max-cltv-expiry` is enforced.
     * </pre>
     *
     * <code>uint32 cltv_limit = 10;</code>
     * @param value The cltvLimit to set.
     */
    private void setCltvLimit(int value) {
      
      cltvLimit_ = value;
    }
    /**
     * <pre>
     *An optional maximum total time lock for the route. This should not exceed
     *lnd's `--max-cltv-expiry` setting. If zero, then the value of
     *`--max-cltv-expiry` is enforced.
     * </pre>
     *
     * <code>uint32 cltv_limit = 10;</code>
     */
    private void clearCltvLimit() {
      
      cltvLimit_ = 0;
    }

    public static final int DEST_CUSTOM_RECORDS_FIELD_NUMBER = 11;
    private static final class DestCustomRecordsDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Long, com.google.protobuf.ByteString> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Long, com.google.protobuf.ByteString>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.UINT64,
                  0L,
                  com.google.protobuf.WireFormat.FieldType.BYTES,
                  com.google.protobuf.ByteString.EMPTY);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Long, com.google.protobuf.ByteString> destCustomRecords_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Long, com.google.protobuf.ByteString>
    internalGetDestCustomRecords() {
      return destCustomRecords_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Long, com.google.protobuf.ByteString>
    internalGetMutableDestCustomRecords() {
      if (!destCustomRecords_.isMutable()) {
        destCustomRecords_ = destCustomRecords_.mutableCopy();
      }
      return destCustomRecords_;
    }
    @java.lang.Override

    public int getDestCustomRecordsCount() {
      return internalGetDestCustomRecords().size();
    }
    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. Record types are
     *required to be in the custom range &gt;= 65536. When using REST, the values
     *must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 11;</code>
     */
    @java.lang.Override

    public boolean containsDestCustomRecords(
        long key) {
      
      return internalGetDestCustomRecords().containsKey(key);
    }
    /**
     * Use {@link #getDestCustomRecordsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getDestCustomRecords() {
      return getDestCustomRecordsMap();
    }
    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. Record types are
     *required to be in the custom range &gt;= 65536. When using REST, the values
     *must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 11;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getDestCustomRecordsMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetDestCustomRecords());
    }
    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. Record types are
     *required to be in the custom range &gt;= 65536. When using REST, the values
     *must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 11;</code>
     */
    @java.lang.Override

    public com.google.protobuf.ByteString getDestCustomRecordsOrDefault(
        long key,
        com.google.protobuf.ByteString defaultValue) {
      
      java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
          internalGetDestCustomRecords();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. Record types are
     *required to be in the custom range &gt;= 65536. When using REST, the values
     *must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 11;</code>
     */
    @java.lang.Override

    public com.google.protobuf.ByteString getDestCustomRecordsOrThrow(
        long key) {
      
      java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
          internalGetDestCustomRecords();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. Record types are
     *required to be in the custom range &gt;= 65536. When using REST, the values
     *must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 11;</code>
     */
    private java.util.Map<java.lang.Long, com.google.protobuf.ByteString>
    getMutableDestCustomRecordsMap() {
      return internalGetMutableDestCustomRecords();
    }

    public static final int ALLOW_SELF_PAYMENT_FIELD_NUMBER = 14;
    private boolean allowSelfPayment_;
    /**
     * <pre>
     * If set, circular payments to self are permitted.
     * </pre>
     *
     * <code>bool allow_self_payment = 14;</code>
     * @return The allowSelfPayment.
     */
    @java.lang.Override
    public boolean getAllowSelfPayment() {
      return allowSelfPayment_;
    }
    /**
     * <pre>
     * If set, circular payments to self are permitted.
     * </pre>
     *
     * <code>bool allow_self_payment = 14;</code>
     * @param value The allowSelfPayment to set.
     */
    private void setAllowSelfPayment(boolean value) {
      
      allowSelfPayment_ = value;
    }
    /**
     * <pre>
     * If set, circular payments to self are permitted.
     * </pre>
     *
     * <code>bool allow_self_payment = 14;</code>
     */
    private void clearAllowSelfPayment() {
      
      allowSelfPayment_ = false;
    }

    public static final int DEST_FEATURES_FIELD_NUMBER = 15;
    private com.google.protobuf.Internal.IntList destFeatures_;
    private static final com.google.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, co.anode.anodium.Rpc.FeatureBit> destFeatures_converter_ =
            new com.google.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, co.anode.anodium.Rpc.FeatureBit>() {
              @java.lang.Override
              public co.anode.anodium.Rpc.FeatureBit convert(java.lang.Integer from) {
                co.anode.anodium.Rpc.FeatureBit result = co.anode.anodium.Rpc.FeatureBit.forNumber(from);
                return result == null ? co.anode.anodium.Rpc.FeatureBit.UNRECOGNIZED : result;
              }
            };
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
     * @return A list containing the destFeatures.
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.FeatureBit> getDestFeaturesList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, co.anode.anodium.Rpc.FeatureBit>(destFeatures_, destFeatures_converter_);
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
     * @return The count of destFeatures.
     */
    @java.lang.Override
    public int getDestFeaturesCount() {
      return destFeatures_.size();
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
     * @param index The index of the element to return.
     * @return The destFeatures at the given index.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.FeatureBit getDestFeatures(int index) {
      return destFeatures_converter_.convert(destFeatures_.getInt(index));
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
     * @return A list containing the enum numeric values on the wire for destFeatures.
     */
    @java.lang.Override
    public java.util.List<java.lang.Integer>
    getDestFeaturesValueList() {
      return destFeatures_;
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
     * @param index The index of the value to return.
     * @return The enum numeric value on the wire of destFeatures at the given index.
     */
    @java.lang.Override
    public int getDestFeaturesValue(int index) {
      return destFeatures_.getInt(index);
    }
    private int destFeaturesMemoizedSerializedSize;
    private void ensureDestFeaturesIsMutable() {
      com.google.protobuf.Internal.IntList tmp = destFeatures_;
      if (!tmp.isModifiable()) {
        destFeatures_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
      }
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
     * @param index The index to set the value at.
     * @param value The destFeatures to set.
     */
    private void setDestFeatures(
        int index, co.anode.anodium.Rpc.FeatureBit value) {
      value.getClass();
  ensureDestFeaturesIsMutable();
      destFeatures_.setInt(index, value.getNumber());
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
     * @param value The destFeatures to add.
     */
    private void addDestFeatures(co.anode.anodium.Rpc.FeatureBit value) {
      value.getClass();
  ensureDestFeaturesIsMutable();
      destFeatures_.addInt(value.getNumber());
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
     * @param values The destFeatures to add.
     */
    private void addAllDestFeatures(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.FeatureBit> values) {
      ensureDestFeaturesIsMutable();
      for (co.anode.anodium.Rpc.FeatureBit value : values) {
        destFeatures_.addInt(value.getNumber());
      }
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
     */
    private void clearDestFeatures() {
      destFeatures_ = emptyIntList();
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
     * @param value The enum numeric value on the wire for destFeatures to set.
     */
    private void setDestFeaturesValue(
        int index, int value) {
      ensureDestFeaturesIsMutable();
      destFeatures_.setInt(index, value);
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
     * @param value The enum numeric value on the wire for destFeatures to add.
     */
    private void addDestFeaturesValue(int value) {
      ensureDestFeaturesIsMutable();
      destFeatures_.addInt(value);
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
     * @param values The enum numeric values on the wire for destFeatures to add.
     */
    private void addAllDestFeaturesValue(
        java.lang.Iterable<java.lang.Integer> values) {
      ensureDestFeaturesIsMutable();
      for (int value : values) {
        destFeatures_.addInt(value);
      }
    }

    public static co.anode.anodium.Rpc.SendRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.SendRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.SendRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.SendRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.SendRequest)
        co.anode.anodium.Rpc.SendRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.SendRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The identity pubkey of the payment recipient. When using REST, this field
       *must be encoded as base64.
       * </pre>
       *
       * <code>bytes dest = 1;</code>
       * @return The dest.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getDest() {
        return instance.getDest();
      }
      /**
       * <pre>
       *The identity pubkey of the payment recipient. When using REST, this field
       *must be encoded as base64.
       * </pre>
       *
       * <code>bytes dest = 1;</code>
       * @param value The dest to set.
       * @return This builder for chaining.
       */
      public Builder setDest(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setDest(value);
        return this;
      }
      /**
       * <pre>
       *The identity pubkey of the payment recipient. When using REST, this field
       *must be encoded as base64.
       * </pre>
       *
       * <code>bytes dest = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearDest() {
        copyOnWrite();
        instance.clearDest();
        return this;
      }

      /**
       * <pre>
       *The hex-encoded identity pubkey of the payment recipient. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string dest_string = 2 [deprecated = true];</code>
       * @return The destString.
       */
      @java.lang.Override
      @java.lang.Deprecated public java.lang.String getDestString() {
        return instance.getDestString();
      }
      /**
       * <pre>
       *The hex-encoded identity pubkey of the payment recipient. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string dest_string = 2 [deprecated = true];</code>
       * @return The bytes for destString.
       */
      @java.lang.Override
      @java.lang.Deprecated public com.google.protobuf.ByteString
          getDestStringBytes() {
        return instance.getDestStringBytes();
      }
      /**
       * <pre>
       *The hex-encoded identity pubkey of the payment recipient. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string dest_string = 2 [deprecated = true];</code>
       * @param value The destString to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setDestString(
          java.lang.String value) {
        copyOnWrite();
        instance.setDestString(value);
        return this;
      }
      /**
       * <pre>
       *The hex-encoded identity pubkey of the payment recipient. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string dest_string = 2 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearDestString() {
        copyOnWrite();
        instance.clearDestString();
        return this;
      }
      /**
       * <pre>
       *The hex-encoded identity pubkey of the payment recipient. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string dest_string = 2 [deprecated = true];</code>
       * @param value The bytes for destString to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setDestStringBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setDestStringBytes(value);
        return this;
      }

      /**
       * <pre>
       *The amount to send expressed in satoshis.
       *The fields amt and amt_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 amt = 3;</code>
       * @return The amt.
       */
      @java.lang.Override
      public long getAmt() {
        return instance.getAmt();
      }
      /**
       * <pre>
       *The amount to send expressed in satoshis.
       *The fields amt and amt_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 amt = 3;</code>
       * @param value The amt to set.
       * @return This builder for chaining.
       */
      public Builder setAmt(long value) {
        copyOnWrite();
        instance.setAmt(value);
        return this;
      }
      /**
       * <pre>
       *The amount to send expressed in satoshis.
       *The fields amt and amt_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 amt = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmt() {
        copyOnWrite();
        instance.clearAmt();
        return this;
      }

      /**
       * <pre>
       *The amount to send expressed in millisatoshis.
       *The fields amt and amt_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 amt_msat = 12;</code>
       * @return The amtMsat.
       */
      @java.lang.Override
      public long getAmtMsat() {
        return instance.getAmtMsat();
      }
      /**
       * <pre>
       *The amount to send expressed in millisatoshis.
       *The fields amt and amt_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 amt_msat = 12;</code>
       * @param value The amtMsat to set.
       * @return This builder for chaining.
       */
      public Builder setAmtMsat(long value) {
        copyOnWrite();
        instance.setAmtMsat(value);
        return this;
      }
      /**
       * <pre>
       *The amount to send expressed in millisatoshis.
       *The fields amt and amt_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 amt_msat = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmtMsat() {
        copyOnWrite();
        instance.clearAmtMsat();
        return this;
      }

      /**
       * <pre>
       *The hash to use within the payment's HTLC. When using REST, this field
       *must be encoded as base64.
       * </pre>
       *
       * <code>bytes payment_hash = 4;</code>
       * @return The paymentHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPaymentHash() {
        return instance.getPaymentHash();
      }
      /**
       * <pre>
       *The hash to use within the payment's HTLC. When using REST, this field
       *must be encoded as base64.
       * </pre>
       *
       * <code>bytes payment_hash = 4;</code>
       * @param value The paymentHash to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPaymentHash(value);
        return this;
      }
      /**
       * <pre>
       *The hash to use within the payment's HTLC. When using REST, this field
       *must be encoded as base64.
       * </pre>
       *
       * <code>bytes payment_hash = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaymentHash() {
        copyOnWrite();
        instance.clearPaymentHash();
        return this;
      }

      /**
       * <pre>
       *The hex-encoded hash to use within the payment's HTLC. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string payment_hash_string = 5 [deprecated = true];</code>
       * @return The paymentHashString.
       */
      @java.lang.Override
      @java.lang.Deprecated public java.lang.String getPaymentHashString() {
        return instance.getPaymentHashString();
      }
      /**
       * <pre>
       *The hex-encoded hash to use within the payment's HTLC. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string payment_hash_string = 5 [deprecated = true];</code>
       * @return The bytes for paymentHashString.
       */
      @java.lang.Override
      @java.lang.Deprecated public com.google.protobuf.ByteString
          getPaymentHashStringBytes() {
        return instance.getPaymentHashStringBytes();
      }
      /**
       * <pre>
       *The hex-encoded hash to use within the payment's HTLC. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string payment_hash_string = 5 [deprecated = true];</code>
       * @param value The paymentHashString to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setPaymentHashString(
          java.lang.String value) {
        copyOnWrite();
        instance.setPaymentHashString(value);
        return this;
      }
      /**
       * <pre>
       *The hex-encoded hash to use within the payment's HTLC. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string payment_hash_string = 5 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearPaymentHashString() {
        copyOnWrite();
        instance.clearPaymentHashString();
        return this;
      }
      /**
       * <pre>
       *The hex-encoded hash to use within the payment's HTLC. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string payment_hash_string = 5 [deprecated = true];</code>
       * @param value The bytes for paymentHashString to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setPaymentHashStringBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPaymentHashStringBytes(value);
        return this;
      }

      /**
       * <pre>
       *A bare-bones invoice for a payment within the Lightning Network. With the
       *details of the invoice, the sender has all the data necessary to send a
       *payment to the recipient.
       * </pre>
       *
       * <code>string payment_request = 6;</code>
       * @return The paymentRequest.
       */
      @java.lang.Override
      public java.lang.String getPaymentRequest() {
        return instance.getPaymentRequest();
      }
      /**
       * <pre>
       *A bare-bones invoice for a payment within the Lightning Network. With the
       *details of the invoice, the sender has all the data necessary to send a
       *payment to the recipient.
       * </pre>
       *
       * <code>string payment_request = 6;</code>
       * @return The bytes for paymentRequest.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPaymentRequestBytes() {
        return instance.getPaymentRequestBytes();
      }
      /**
       * <pre>
       *A bare-bones invoice for a payment within the Lightning Network. With the
       *details of the invoice, the sender has all the data necessary to send a
       *payment to the recipient.
       * </pre>
       *
       * <code>string payment_request = 6;</code>
       * @param value The paymentRequest to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentRequest(
          java.lang.String value) {
        copyOnWrite();
        instance.setPaymentRequest(value);
        return this;
      }
      /**
       * <pre>
       *A bare-bones invoice for a payment within the Lightning Network. With the
       *details of the invoice, the sender has all the data necessary to send a
       *payment to the recipient.
       * </pre>
       *
       * <code>string payment_request = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaymentRequest() {
        copyOnWrite();
        instance.clearPaymentRequest();
        return this;
      }
      /**
       * <pre>
       *A bare-bones invoice for a payment within the Lightning Network. With the
       *details of the invoice, the sender has all the data necessary to send a
       *payment to the recipient.
       * </pre>
       *
       * <code>string payment_request = 6;</code>
       * @param value The bytes for paymentRequest to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentRequestBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPaymentRequestBytes(value);
        return this;
      }

      /**
       * <pre>
       *The CLTV delta from the current height that should be used to set the
       *timelock for the final hop.
       * </pre>
       *
       * <code>int32 final_cltv_delta = 7;</code>
       * @return The finalCltvDelta.
       */
      @java.lang.Override
      public int getFinalCltvDelta() {
        return instance.getFinalCltvDelta();
      }
      /**
       * <pre>
       *The CLTV delta from the current height that should be used to set the
       *timelock for the final hop.
       * </pre>
       *
       * <code>int32 final_cltv_delta = 7;</code>
       * @param value The finalCltvDelta to set.
       * @return This builder for chaining.
       */
      public Builder setFinalCltvDelta(int value) {
        copyOnWrite();
        instance.setFinalCltvDelta(value);
        return this;
      }
      /**
       * <pre>
       *The CLTV delta from the current height that should be used to set the
       *timelock for the final hop.
       * </pre>
       *
       * <code>int32 final_cltv_delta = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearFinalCltvDelta() {
        copyOnWrite();
        instance.clearFinalCltvDelta();
        return this;
      }

      /**
       * <pre>
       *The maximum number of satoshis that will be paid as a fee of the payment.
       *This value can be represented either as a percentage of the amount being
       *sent, or as a fixed amount of the maximum fee the user is willing the pay to
       *send the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.FeeLimit fee_limit = 8;</code>
       */
      @java.lang.Override
      public boolean hasFeeLimit() {
        return instance.hasFeeLimit();
      }
      /**
       * <pre>
       *The maximum number of satoshis that will be paid as a fee of the payment.
       *This value can be represented either as a percentage of the amount being
       *sent, or as a fixed amount of the maximum fee the user is willing the pay to
       *send the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.FeeLimit fee_limit = 8;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.FeeLimit getFeeLimit() {
        return instance.getFeeLimit();
      }
      /**
       * <pre>
       *The maximum number of satoshis that will be paid as a fee of the payment.
       *This value can be represented either as a percentage of the amount being
       *sent, or as a fixed amount of the maximum fee the user is willing the pay to
       *send the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.FeeLimit fee_limit = 8;</code>
       */
      public Builder setFeeLimit(co.anode.anodium.Rpc.FeeLimit value) {
        copyOnWrite();
        instance.setFeeLimit(value);
        return this;
        }
      /**
       * <pre>
       *The maximum number of satoshis that will be paid as a fee of the payment.
       *This value can be represented either as a percentage of the amount being
       *sent, or as a fixed amount of the maximum fee the user is willing the pay to
       *send the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.FeeLimit fee_limit = 8;</code>
       */
      public Builder setFeeLimit(
          co.anode.anodium.Rpc.FeeLimit.Builder builderForValue) {
        copyOnWrite();
        instance.setFeeLimit(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *The maximum number of satoshis that will be paid as a fee of the payment.
       *This value can be represented either as a percentage of the amount being
       *sent, or as a fixed amount of the maximum fee the user is willing the pay to
       *send the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.FeeLimit fee_limit = 8;</code>
       */
      public Builder mergeFeeLimit(co.anode.anodium.Rpc.FeeLimit value) {
        copyOnWrite();
        instance.mergeFeeLimit(value);
        return this;
      }
      /**
       * <pre>
       *The maximum number of satoshis that will be paid as a fee of the payment.
       *This value can be represented either as a percentage of the amount being
       *sent, or as a fixed amount of the maximum fee the user is willing the pay to
       *send the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.FeeLimit fee_limit = 8;</code>
       */
      public Builder clearFeeLimit() {  copyOnWrite();
        instance.clearFeeLimit();
        return this;
      }

      /**
       * <pre>
       *The channel id of the channel that must be taken to the first hop. If zero,
       *any channel may be used.
       * </pre>
       *
       * <code>uint64 outgoing_chan_id = 9 [jstype = JS_STRING];</code>
       * @return The outgoingChanId.
       */
      @java.lang.Override
      public long getOutgoingChanId() {
        return instance.getOutgoingChanId();
      }
      /**
       * <pre>
       *The channel id of the channel that must be taken to the first hop. If zero,
       *any channel may be used.
       * </pre>
       *
       * <code>uint64 outgoing_chan_id = 9 [jstype = JS_STRING];</code>
       * @param value The outgoingChanId to set.
       * @return This builder for chaining.
       */
      public Builder setOutgoingChanId(long value) {
        copyOnWrite();
        instance.setOutgoingChanId(value);
        return this;
      }
      /**
       * <pre>
       *The channel id of the channel that must be taken to the first hop. If zero,
       *any channel may be used.
       * </pre>
       *
       * <code>uint64 outgoing_chan_id = 9 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearOutgoingChanId() {
        copyOnWrite();
        instance.clearOutgoingChanId();
        return this;
      }

      /**
       * <pre>
       *The pubkey of the last hop of the route. If empty, any hop may be used.
       * </pre>
       *
       * <code>bytes last_hop_pubkey = 13;</code>
       * @return The lastHopPubkey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getLastHopPubkey() {
        return instance.getLastHopPubkey();
      }
      /**
       * <pre>
       *The pubkey of the last hop of the route. If empty, any hop may be used.
       * </pre>
       *
       * <code>bytes last_hop_pubkey = 13;</code>
       * @param value The lastHopPubkey to set.
       * @return This builder for chaining.
       */
      public Builder setLastHopPubkey(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLastHopPubkey(value);
        return this;
      }
      /**
       * <pre>
       *The pubkey of the last hop of the route. If empty, any hop may be used.
       * </pre>
       *
       * <code>bytes last_hop_pubkey = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearLastHopPubkey() {
        copyOnWrite();
        instance.clearLastHopPubkey();
        return this;
      }

      /**
       * <pre>
       *An optional maximum total time lock for the route. This should not exceed
       *lnd's `--max-cltv-expiry` setting. If zero, then the value of
       *`--max-cltv-expiry` is enforced.
       * </pre>
       *
       * <code>uint32 cltv_limit = 10;</code>
       * @return The cltvLimit.
       */
      @java.lang.Override
      public int getCltvLimit() {
        return instance.getCltvLimit();
      }
      /**
       * <pre>
       *An optional maximum total time lock for the route. This should not exceed
       *lnd's `--max-cltv-expiry` setting. If zero, then the value of
       *`--max-cltv-expiry` is enforced.
       * </pre>
       *
       * <code>uint32 cltv_limit = 10;</code>
       * @param value The cltvLimit to set.
       * @return This builder for chaining.
       */
      public Builder setCltvLimit(int value) {
        copyOnWrite();
        instance.setCltvLimit(value);
        return this;
      }
      /**
       * <pre>
       *An optional maximum total time lock for the route. This should not exceed
       *lnd's `--max-cltv-expiry` setting. If zero, then the value of
       *`--max-cltv-expiry` is enforced.
       * </pre>
       *
       * <code>uint32 cltv_limit = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearCltvLimit() {
        copyOnWrite();
        instance.clearCltvLimit();
        return this;
      }

      @java.lang.Override

      public int getDestCustomRecordsCount() {
        return instance.getDestCustomRecordsMap().size();
      }
      /**
       * <pre>
       *An optional field that can be used to pass an arbitrary set of TLV records
       *to a peer which understands the new records. This can be used to pass
       *application specific data during the payment attempt. Record types are
       *required to be in the custom range &gt;= 65536. When using REST, the values
       *must be encoded as base64.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; dest_custom_records = 11;</code>
       */
      @java.lang.Override

      public boolean containsDestCustomRecords(
          long key) {
        
        return instance.getDestCustomRecordsMap().containsKey(key);
      }

      public Builder clearDestCustomRecords() {
        copyOnWrite();
        instance.getMutableDestCustomRecordsMap().clear();
        return this;
      }
      /**
       * <pre>
       *An optional field that can be used to pass an arbitrary set of TLV records
       *to a peer which understands the new records. This can be used to pass
       *application specific data during the payment attempt. Record types are
       *required to be in the custom range &gt;= 65536. When using REST, the values
       *must be encoded as base64.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; dest_custom_records = 11;</code>
       */

      public Builder removeDestCustomRecords(
          long key) {
        
        copyOnWrite();
        instance.getMutableDestCustomRecordsMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getDestCustomRecordsMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getDestCustomRecords() {
        return getDestCustomRecordsMap();
      }
      /**
       * <pre>
       *An optional field that can be used to pass an arbitrary set of TLV records
       *to a peer which understands the new records. This can be used to pass
       *application specific data during the payment attempt. Record types are
       *required to be in the custom range &gt;= 65536. When using REST, the values
       *must be encoded as base64.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; dest_custom_records = 11;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getDestCustomRecordsMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getDestCustomRecordsMap());
      }
      /**
       * <pre>
       *An optional field that can be used to pass an arbitrary set of TLV records
       *to a peer which understands the new records. This can be used to pass
       *application specific data during the payment attempt. Record types are
       *required to be in the custom range &gt;= 65536. When using REST, the values
       *must be encoded as base64.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; dest_custom_records = 11;</code>
       */
      @java.lang.Override

      public com.google.protobuf.ByteString getDestCustomRecordsOrDefault(
          long key,
          com.google.protobuf.ByteString defaultValue) {
        
        java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
            instance.getDestCustomRecordsMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       *An optional field that can be used to pass an arbitrary set of TLV records
       *to a peer which understands the new records. This can be used to pass
       *application specific data during the payment attempt. Record types are
       *required to be in the custom range &gt;= 65536. When using REST, the values
       *must be encoded as base64.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; dest_custom_records = 11;</code>
       */
      @java.lang.Override

      public com.google.protobuf.ByteString getDestCustomRecordsOrThrow(
          long key) {
        
        java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
            instance.getDestCustomRecordsMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       *An optional field that can be used to pass an arbitrary set of TLV records
       *to a peer which understands the new records. This can be used to pass
       *application specific data during the payment attempt. Record types are
       *required to be in the custom range &gt;= 65536. When using REST, the values
       *must be encoded as base64.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; dest_custom_records = 11;</code>
       */
      public Builder putDestCustomRecords(
          long key,
          com.google.protobuf.ByteString value) {
        
        value.getClass();
        copyOnWrite();
        instance.getMutableDestCustomRecordsMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       *An optional field that can be used to pass an arbitrary set of TLV records
       *to a peer which understands the new records. This can be used to pass
       *application specific data during the payment attempt. Record types are
       *required to be in the custom range &gt;= 65536. When using REST, the values
       *must be encoded as base64.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; dest_custom_records = 11;</code>
       */
      public Builder putAllDestCustomRecords(
          java.util.Map<java.lang.Long, com.google.protobuf.ByteString> values) {
        copyOnWrite();
        instance.getMutableDestCustomRecordsMap().putAll(values);
        return this;
      }

      /**
       * <pre>
       * If set, circular payments to self are permitted.
       * </pre>
       *
       * <code>bool allow_self_payment = 14;</code>
       * @return The allowSelfPayment.
       */
      @java.lang.Override
      public boolean getAllowSelfPayment() {
        return instance.getAllowSelfPayment();
      }
      /**
       * <pre>
       * If set, circular payments to self are permitted.
       * </pre>
       *
       * <code>bool allow_self_payment = 14;</code>
       * @param value The allowSelfPayment to set.
       * @return This builder for chaining.
       */
      public Builder setAllowSelfPayment(boolean value) {
        copyOnWrite();
        instance.setAllowSelfPayment(value);
        return this;
      }
      /**
       * <pre>
       * If set, circular payments to self are permitted.
       * </pre>
       *
       * <code>bool allow_self_payment = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearAllowSelfPayment() {
        copyOnWrite();
        instance.clearAllowSelfPayment();
        return this;
      }

      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
       * @return A list containing the destFeatures.
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.FeatureBit> getDestFeaturesList() {
        return instance.getDestFeaturesList();
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
       * @return The count of destFeatures.
       */
      @java.lang.Override
      public int getDestFeaturesCount() {
        return instance.getDestFeaturesCount();
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
       * @param index The index of the element to return.
       * @return The destFeatures at the given index.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.FeatureBit getDestFeatures(int index) {
        return instance.getDestFeatures(index);
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
       * @param index The index to set the value at.
       * @param value The destFeatures to set.
       * @return This builder for chaining.
       */
      public Builder setDestFeatures(
          int index, co.anode.anodium.Rpc.FeatureBit value) {
        copyOnWrite();
        instance.setDestFeatures(index, value);
        return this;
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
       * @param value The destFeatures to add.
       * @return This builder for chaining.
       */
      public Builder addDestFeatures(co.anode.anodium.Rpc.FeatureBit value) {
        copyOnWrite();
        instance.addDestFeatures(value);
        return this;
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
       * @param values The destFeatures to add.
       * @return This builder for chaining.
       */
      public Builder addAllDestFeatures(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.FeatureBit> values) {
        copyOnWrite();
        instance.addAllDestFeatures(values);  return this;
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
       * @return This builder for chaining.
       */
      public Builder clearDestFeatures() {
        copyOnWrite();
        instance.clearDestFeatures();
        return this;
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
       * @return A list containing the enum numeric values on the wire for destFeatures.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
      getDestFeaturesValueList() {
        return java.util.Collections.unmodifiableList(
            instance.getDestFeaturesValueList());
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
       * @param index The index of the value to return.
       * @return The enum numeric value on the wire of destFeatures at the given index.
       */
      @java.lang.Override
      public int getDestFeaturesValue(int index) {
        return instance.getDestFeaturesValue(index);
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
       * @param index The index to set the value at.
       * @param value The enum numeric value on the wire for destFeatures to set.
       * @return This builder for chaining.
       */
      public Builder setDestFeaturesValue(
          int index, int value) {
        copyOnWrite();
        instance.setDestFeaturesValue(index, value);
        return this;
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
       * @param value The enum numeric value on the wire for destFeatures to add.
       * @return This builder for chaining.
       */
      public Builder addDestFeaturesValue(int value) {
        instance.addDestFeaturesValue(value);
        return this;
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 15;</code>
       * @param values The enum numeric values on the wire for destFeatures to add.
       * @return This builder for chaining.
       */
      public Builder addAllDestFeaturesValue(
          java.lang.Iterable<java.lang.Integer> values) {
        copyOnWrite();
        instance.addAllDestFeaturesValue(values);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.SendRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.SendRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "dest_",
              "destString_",
              "amt_",
              "paymentHash_",
              "paymentHashString_",
              "paymentRequest_",
              "finalCltvDelta_",
              "feeLimit_",
              "outgoingChanId_",
              "cltvLimit_",
              "destCustomRecords_",
              DestCustomRecordsDefaultEntryHolder.defaultEntry,
              "amtMsat_",
              "lastHopPubkey_",
              "allowSelfPayment_",
              "destFeatures_",
            };
            java.lang.String info =
                "\u0000\u000f\u0000\u0000\u0001\u000f\u000f\u0001\u0001\u0000\u0001\n\u0002\u0208" +
                "\u0003\u0002\u0004\n\u0005\u0208\u0006\u0208\u0007\u0004\b\t\t\u0003\n\u000b\u000b" +
                "2\f\u0002\r\n\u000e\u0007\u000f,";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.SendRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.SendRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.SendRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.SendRequest)
    private static final co.anode.anodium.Rpc.SendRequest DEFAULT_INSTANCE;
    static {
      SendRequest defaultInstance = new SendRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        SendRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.SendRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SendRequest> PARSER;

    public static com.google.protobuf.Parser<SendRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SendResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.SendResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>string payment_error = 1;</code>
     * @return The paymentError.
     */
    java.lang.String getPaymentError();
    /**
     * <code>string payment_error = 1;</code>
     * @return The bytes for paymentError.
     */
    com.google.protobuf.ByteString
        getPaymentErrorBytes();

    /**
     * <code>bytes payment_preimage = 2;</code>
     * @return The paymentPreimage.
     */
    com.google.protobuf.ByteString getPaymentPreimage();

    /**
     * <code>.co.anode.anodium.Route payment_route = 3;</code>
     * @return Whether the paymentRoute field is set.
     */
    boolean hasPaymentRoute();
    /**
     * <code>.co.anode.anodium.Route payment_route = 3;</code>
     * @return The paymentRoute.
     */
    co.anode.anodium.Rpc.Route getPaymentRoute();

    /**
     * <code>bytes payment_hash = 4;</code>
     * @return The paymentHash.
     */
    com.google.protobuf.ByteString getPaymentHash();
  }
  /**
   * Protobuf type {@code co.anode.anodium.SendResponse}
   */
  public  static final class SendResponse extends
      com.google.protobuf.GeneratedMessageLite<
          SendResponse, SendResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.SendResponse)
      SendResponseOrBuilder {
    private SendResponse() {
      paymentError_ = "";
      paymentPreimage_ = com.google.protobuf.ByteString.EMPTY;
      paymentHash_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int PAYMENT_ERROR_FIELD_NUMBER = 1;
    private java.lang.String paymentError_;
    /**
     * <code>string payment_error = 1;</code>
     * @return The paymentError.
     */
    @java.lang.Override
    public java.lang.String getPaymentError() {
      return paymentError_;
    }
    /**
     * <code>string payment_error = 1;</code>
     * @return The bytes for paymentError.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPaymentErrorBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(paymentError_);
    }
    /**
     * <code>string payment_error = 1;</code>
     * @param value The paymentError to set.
     */
    private void setPaymentError(
        java.lang.String value) {
      value.getClass();
  
      paymentError_ = value;
    }
    /**
     * <code>string payment_error = 1;</code>
     */
    private void clearPaymentError() {
      
      paymentError_ = getDefaultInstance().getPaymentError();
    }
    /**
     * <code>string payment_error = 1;</code>
     * @param value The bytes for paymentError to set.
     */
    private void setPaymentErrorBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      paymentError_ = value.toStringUtf8();
      
    }

    public static final int PAYMENT_PREIMAGE_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString paymentPreimage_;
    /**
     * <code>bytes payment_preimage = 2;</code>
     * @return The paymentPreimage.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPaymentPreimage() {
      return paymentPreimage_;
    }
    /**
     * <code>bytes payment_preimage = 2;</code>
     * @param value The paymentPreimage to set.
     */
    private void setPaymentPreimage(com.google.protobuf.ByteString value) {
      value.getClass();
  
      paymentPreimage_ = value;
    }
    /**
     * <code>bytes payment_preimage = 2;</code>
     */
    private void clearPaymentPreimage() {
      
      paymentPreimage_ = getDefaultInstance().getPaymentPreimage();
    }

    public static final int PAYMENT_ROUTE_FIELD_NUMBER = 3;
    private co.anode.anodium.Rpc.Route paymentRoute_;
    /**
     * <code>.co.anode.anodium.Route payment_route = 3;</code>
     */
    @java.lang.Override
    public boolean hasPaymentRoute() {
      return paymentRoute_ != null;
    }
    /**
     * <code>.co.anode.anodium.Route payment_route = 3;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Route getPaymentRoute() {
      return paymentRoute_ == null ? co.anode.anodium.Rpc.Route.getDefaultInstance() : paymentRoute_;
    }
    /**
     * <code>.co.anode.anodium.Route payment_route = 3;</code>
     */
    private void setPaymentRoute(co.anode.anodium.Rpc.Route value) {
      value.getClass();
  paymentRoute_ = value;
      
      }
    /**
     * <code>.co.anode.anodium.Route payment_route = 3;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergePaymentRoute(co.anode.anodium.Rpc.Route value) {
      value.getClass();
  if (paymentRoute_ != null &&
          paymentRoute_ != co.anode.anodium.Rpc.Route.getDefaultInstance()) {
        paymentRoute_ =
          co.anode.anodium.Rpc.Route.newBuilder(paymentRoute_).mergeFrom(value).buildPartial();
      } else {
        paymentRoute_ = value;
      }
      
    }
    /**
     * <code>.co.anode.anodium.Route payment_route = 3;</code>
     */
    private void clearPaymentRoute() {  paymentRoute_ = null;
      
    }

    public static final int PAYMENT_HASH_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString paymentHash_;
    /**
     * <code>bytes payment_hash = 4;</code>
     * @return The paymentHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPaymentHash() {
      return paymentHash_;
    }
    /**
     * <code>bytes payment_hash = 4;</code>
     * @param value The paymentHash to set.
     */
    private void setPaymentHash(com.google.protobuf.ByteString value) {
      value.getClass();
  
      paymentHash_ = value;
    }
    /**
     * <code>bytes payment_hash = 4;</code>
     */
    private void clearPaymentHash() {
      
      paymentHash_ = getDefaultInstance().getPaymentHash();
    }

    public static co.anode.anodium.Rpc.SendResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.SendResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.SendResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.SendResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.SendResponse)
        co.anode.anodium.Rpc.SendResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.SendResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>string payment_error = 1;</code>
       * @return The paymentError.
       */
      @java.lang.Override
      public java.lang.String getPaymentError() {
        return instance.getPaymentError();
      }
      /**
       * <code>string payment_error = 1;</code>
       * @return The bytes for paymentError.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPaymentErrorBytes() {
        return instance.getPaymentErrorBytes();
      }
      /**
       * <code>string payment_error = 1;</code>
       * @param value The paymentError to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentError(
          java.lang.String value) {
        copyOnWrite();
        instance.setPaymentError(value);
        return this;
      }
      /**
       * <code>string payment_error = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaymentError() {
        copyOnWrite();
        instance.clearPaymentError();
        return this;
      }
      /**
       * <code>string payment_error = 1;</code>
       * @param value The bytes for paymentError to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentErrorBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPaymentErrorBytes(value);
        return this;
      }

      /**
       * <code>bytes payment_preimage = 2;</code>
       * @return The paymentPreimage.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPaymentPreimage() {
        return instance.getPaymentPreimage();
      }
      /**
       * <code>bytes payment_preimage = 2;</code>
       * @param value The paymentPreimage to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentPreimage(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPaymentPreimage(value);
        return this;
      }
      /**
       * <code>bytes payment_preimage = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaymentPreimage() {
        copyOnWrite();
        instance.clearPaymentPreimage();
        return this;
      }

      /**
       * <code>.co.anode.anodium.Route payment_route = 3;</code>
       */
      @java.lang.Override
      public boolean hasPaymentRoute() {
        return instance.hasPaymentRoute();
      }
      /**
       * <code>.co.anode.anodium.Route payment_route = 3;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Route getPaymentRoute() {
        return instance.getPaymentRoute();
      }
      /**
       * <code>.co.anode.anodium.Route payment_route = 3;</code>
       */
      public Builder setPaymentRoute(co.anode.anodium.Rpc.Route value) {
        copyOnWrite();
        instance.setPaymentRoute(value);
        return this;
        }
      /**
       * <code>.co.anode.anodium.Route payment_route = 3;</code>
       */
      public Builder setPaymentRoute(
          co.anode.anodium.Rpc.Route.Builder builderForValue) {
        copyOnWrite();
        instance.setPaymentRoute(builderForValue.build());
        return this;
      }
      /**
       * <code>.co.anode.anodium.Route payment_route = 3;</code>
       */
      public Builder mergePaymentRoute(co.anode.anodium.Rpc.Route value) {
        copyOnWrite();
        instance.mergePaymentRoute(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.Route payment_route = 3;</code>
       */
      public Builder clearPaymentRoute() {  copyOnWrite();
        instance.clearPaymentRoute();
        return this;
      }

      /**
       * <code>bytes payment_hash = 4;</code>
       * @return The paymentHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPaymentHash() {
        return instance.getPaymentHash();
      }
      /**
       * <code>bytes payment_hash = 4;</code>
       * @param value The paymentHash to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPaymentHash(value);
        return this;
      }
      /**
       * <code>bytes payment_hash = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaymentHash() {
        copyOnWrite();
        instance.clearPaymentHash();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.SendResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.SendResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "paymentError_",
              "paymentPreimage_",
              "paymentRoute_",
              "paymentHash_",
            };
            java.lang.String info =
                "\u0000\u0004\u0000\u0000\u0001\u0004\u0004\u0000\u0000\u0000\u0001\u0208\u0002\n" +
                "\u0003\t\u0004\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.SendResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.SendResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.SendResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.SendResponse)
    private static final co.anode.anodium.Rpc.SendResponse DEFAULT_INSTANCE;
    static {
      SendResponse defaultInstance = new SendResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        SendResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.SendResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SendResponse> PARSER;

    public static com.google.protobuf.Parser<SendResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SendToRouteRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.SendToRouteRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The payment hash to use for the HTLC. When using REST, this field must be
     *encoded as base64.
     * </pre>
     *
     * <code>bytes payment_hash = 1;</code>
     * @return The paymentHash.
     */
    com.google.protobuf.ByteString getPaymentHash();

    /**
     * <pre>
     *An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string payment_hash_string = 2 [deprecated = true];</code>
     * @return The paymentHashString.
     */
    @java.lang.Deprecated java.lang.String getPaymentHashString();
    /**
     * <pre>
     *An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string payment_hash_string = 2 [deprecated = true];</code>
     * @return The bytes for paymentHashString.
     */
    @java.lang.Deprecated com.google.protobuf.ByteString
        getPaymentHashStringBytes();

    /**
     * <pre>
     * Route that should be used to attempt to complete the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.Route route = 4;</code>
     * @return Whether the route field is set.
     */
    boolean hasRoute();
    /**
     * <pre>
     * Route that should be used to attempt to complete the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.Route route = 4;</code>
     * @return The route.
     */
    co.anode.anodium.Rpc.Route getRoute();
  }
  /**
   * Protobuf type {@code co.anode.anodium.SendToRouteRequest}
   */
  public  static final class SendToRouteRequest extends
      com.google.protobuf.GeneratedMessageLite<
          SendToRouteRequest, SendToRouteRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.SendToRouteRequest)
      SendToRouteRequestOrBuilder {
    private SendToRouteRequest() {
      paymentHash_ = com.google.protobuf.ByteString.EMPTY;
      paymentHashString_ = "";
    }
    public static final int PAYMENT_HASH_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString paymentHash_;
    /**
     * <pre>
     *The payment hash to use for the HTLC. When using REST, this field must be
     *encoded as base64.
     * </pre>
     *
     * <code>bytes payment_hash = 1;</code>
     * @return The paymentHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPaymentHash() {
      return paymentHash_;
    }
    /**
     * <pre>
     *The payment hash to use for the HTLC. When using REST, this field must be
     *encoded as base64.
     * </pre>
     *
     * <code>bytes payment_hash = 1;</code>
     * @param value The paymentHash to set.
     */
    private void setPaymentHash(com.google.protobuf.ByteString value) {
      value.getClass();
  
      paymentHash_ = value;
    }
    /**
     * <pre>
     *The payment hash to use for the HTLC. When using REST, this field must be
     *encoded as base64.
     * </pre>
     *
     * <code>bytes payment_hash = 1;</code>
     */
    private void clearPaymentHash() {
      
      paymentHash_ = getDefaultInstance().getPaymentHash();
    }

    public static final int PAYMENT_HASH_STRING_FIELD_NUMBER = 2;
    private java.lang.String paymentHashString_;
    /**
     * <pre>
     *An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string payment_hash_string = 2 [deprecated = true];</code>
     * @return The paymentHashString.
     */
    @java.lang.Override
    @java.lang.Deprecated public java.lang.String getPaymentHashString() {
      return paymentHashString_;
    }
    /**
     * <pre>
     *An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string payment_hash_string = 2 [deprecated = true];</code>
     * @return The bytes for paymentHashString.
     */
    @java.lang.Override
    @java.lang.Deprecated public com.google.protobuf.ByteString
        getPaymentHashStringBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(paymentHashString_);
    }
    /**
     * <pre>
     *An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string payment_hash_string = 2 [deprecated = true];</code>
     * @param value The paymentHashString to set.
     */
    private void setPaymentHashString(
        java.lang.String value) {
      value.getClass();
  
      paymentHashString_ = value;
    }
    /**
     * <pre>
     *An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string payment_hash_string = 2 [deprecated = true];</code>
     */
    private void clearPaymentHashString() {
      
      paymentHashString_ = getDefaultInstance().getPaymentHashString();
    }
    /**
     * <pre>
     *An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string payment_hash_string = 2 [deprecated = true];</code>
     * @param value The bytes for paymentHashString to set.
     */
    private void setPaymentHashStringBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      paymentHashString_ = value.toStringUtf8();
      
    }

    public static final int ROUTE_FIELD_NUMBER = 4;
    private co.anode.anodium.Rpc.Route route_;
    /**
     * <pre>
     * Route that should be used to attempt to complete the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.Route route = 4;</code>
     */
    @java.lang.Override
    public boolean hasRoute() {
      return route_ != null;
    }
    /**
     * <pre>
     * Route that should be used to attempt to complete the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.Route route = 4;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Route getRoute() {
      return route_ == null ? co.anode.anodium.Rpc.Route.getDefaultInstance() : route_;
    }
    /**
     * <pre>
     * Route that should be used to attempt to complete the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.Route route = 4;</code>
     */
    private void setRoute(co.anode.anodium.Rpc.Route value) {
      value.getClass();
  route_ = value;
      
      }
    /**
     * <pre>
     * Route that should be used to attempt to complete the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.Route route = 4;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeRoute(co.anode.anodium.Rpc.Route value) {
      value.getClass();
  if (route_ != null &&
          route_ != co.anode.anodium.Rpc.Route.getDefaultInstance()) {
        route_ =
          co.anode.anodium.Rpc.Route.newBuilder(route_).mergeFrom(value).buildPartial();
      } else {
        route_ = value;
      }
      
    }
    /**
     * <pre>
     * Route that should be used to attempt to complete the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.Route route = 4;</code>
     */
    private void clearRoute() {  route_ = null;
      
    }

    public static co.anode.anodium.Rpc.SendToRouteRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendToRouteRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendToRouteRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendToRouteRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendToRouteRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendToRouteRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendToRouteRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendToRouteRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendToRouteRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendToRouteRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendToRouteRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendToRouteRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.SendToRouteRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.SendToRouteRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.SendToRouteRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.SendToRouteRequest)
        co.anode.anodium.Rpc.SendToRouteRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.SendToRouteRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The payment hash to use for the HTLC. When using REST, this field must be
       *encoded as base64.
       * </pre>
       *
       * <code>bytes payment_hash = 1;</code>
       * @return The paymentHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPaymentHash() {
        return instance.getPaymentHash();
      }
      /**
       * <pre>
       *The payment hash to use for the HTLC. When using REST, this field must be
       *encoded as base64.
       * </pre>
       *
       * <code>bytes payment_hash = 1;</code>
       * @param value The paymentHash to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPaymentHash(value);
        return this;
      }
      /**
       * <pre>
       *The payment hash to use for the HTLC. When using REST, this field must be
       *encoded as base64.
       * </pre>
       *
       * <code>bytes payment_hash = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaymentHash() {
        copyOnWrite();
        instance.clearPaymentHash();
        return this;
      }

      /**
       * <pre>
       *An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string payment_hash_string = 2 [deprecated = true];</code>
       * @return The paymentHashString.
       */
      @java.lang.Override
      @java.lang.Deprecated public java.lang.String getPaymentHashString() {
        return instance.getPaymentHashString();
      }
      /**
       * <pre>
       *An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string payment_hash_string = 2 [deprecated = true];</code>
       * @return The bytes for paymentHashString.
       */
      @java.lang.Override
      @java.lang.Deprecated public com.google.protobuf.ByteString
          getPaymentHashStringBytes() {
        return instance.getPaymentHashStringBytes();
      }
      /**
       * <pre>
       *An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string payment_hash_string = 2 [deprecated = true];</code>
       * @param value The paymentHashString to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setPaymentHashString(
          java.lang.String value) {
        copyOnWrite();
        instance.setPaymentHashString(value);
        return this;
      }
      /**
       * <pre>
       *An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string payment_hash_string = 2 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearPaymentHashString() {
        copyOnWrite();
        instance.clearPaymentHashString();
        return this;
      }
      /**
       * <pre>
       *An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string payment_hash_string = 2 [deprecated = true];</code>
       * @param value The bytes for paymentHashString to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setPaymentHashStringBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPaymentHashStringBytes(value);
        return this;
      }

      /**
       * <pre>
       * Route that should be used to attempt to complete the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.Route route = 4;</code>
       */
      @java.lang.Override
      public boolean hasRoute() {
        return instance.hasRoute();
      }
      /**
       * <pre>
       * Route that should be used to attempt to complete the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.Route route = 4;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Route getRoute() {
        return instance.getRoute();
      }
      /**
       * <pre>
       * Route that should be used to attempt to complete the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.Route route = 4;</code>
       */
      public Builder setRoute(co.anode.anodium.Rpc.Route value) {
        copyOnWrite();
        instance.setRoute(value);
        return this;
        }
      /**
       * <pre>
       * Route that should be used to attempt to complete the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.Route route = 4;</code>
       */
      public Builder setRoute(
          co.anode.anodium.Rpc.Route.Builder builderForValue) {
        copyOnWrite();
        instance.setRoute(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Route that should be used to attempt to complete the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.Route route = 4;</code>
       */
      public Builder mergeRoute(co.anode.anodium.Rpc.Route value) {
        copyOnWrite();
        instance.mergeRoute(value);
        return this;
      }
      /**
       * <pre>
       * Route that should be used to attempt to complete the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.Route route = 4;</code>
       */
      public Builder clearRoute() {  copyOnWrite();
        instance.clearRoute();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.SendToRouteRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.SendToRouteRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "paymentHash_",
              "paymentHashString_",
              "route_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0004\u0003\u0000\u0000\u0000\u0001\n\u0002\u0208" +
                "\u0004\t";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.SendToRouteRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.SendToRouteRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.SendToRouteRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.SendToRouteRequest)
    private static final co.anode.anodium.Rpc.SendToRouteRequest DEFAULT_INSTANCE;
    static {
      SendToRouteRequest defaultInstance = new SendToRouteRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        SendToRouteRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.SendToRouteRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SendToRouteRequest> PARSER;

    public static com.google.protobuf.Parser<SendToRouteRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelAcceptRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelAcceptRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The pubkey of the node that wishes to open an inbound channel.
     * </pre>
     *
     * <code>bytes node_pubkey = 1;</code>
     * @return The nodePubkey.
     */
    com.google.protobuf.ByteString getNodePubkey();

    /**
     * <pre>
     * The hash of the genesis block that the proposed channel resides in.
     * </pre>
     *
     * <code>bytes chain_hash = 2;</code>
     * @return The chainHash.
     */
    com.google.protobuf.ByteString getChainHash();

    /**
     * <pre>
     * The pending channel id.
     * </pre>
     *
     * <code>bytes pending_chan_id = 3;</code>
     * @return The pendingChanId.
     */
    com.google.protobuf.ByteString getPendingChanId();

    /**
     * <pre>
     * The funding amount in satoshis that initiator wishes to use in the
     * channel.
     * </pre>
     *
     * <code>uint64 funding_amt = 4;</code>
     * @return The fundingAmt.
     */
    long getFundingAmt();

    /**
     * <pre>
     * The push amount of the proposed channel in millisatoshis.
     * </pre>
     *
     * <code>uint64 push_amt = 5;</code>
     * @return The pushAmt.
     */
    long getPushAmt();

    /**
     * <pre>
     * The dust limit of the initiator's commitment tx.
     * </pre>
     *
     * <code>uint64 dust_limit = 6;</code>
     * @return The dustLimit.
     */
    long getDustLimit();

    /**
     * <pre>
     * The maximum amount of coins in millisatoshis that can be pending in this
     * channel.
     * </pre>
     *
     * <code>uint64 max_value_in_flight = 7;</code>
     * @return The maxValueInFlight.
     */
    long getMaxValueInFlight();

    /**
     * <pre>
     * The minimum amount of satoshis the initiator requires us to have at all
     * times.
     * </pre>
     *
     * <code>uint64 channel_reserve = 8;</code>
     * @return The channelReserve.
     */
    long getChannelReserve();

    /**
     * <pre>
     * The smallest HTLC in millisatoshis that the initiator will accept.
     * </pre>
     *
     * <code>uint64 min_htlc = 9;</code>
     * @return The minHtlc.
     */
    long getMinHtlc();

    /**
     * <pre>
     * The initial fee rate that the initiator suggests for both commitment
     * transactions.
     * </pre>
     *
     * <code>uint64 fee_per_kw = 10;</code>
     * @return The feePerKw.
     */
    long getFeePerKw();

    /**
     * <pre>
     *The number of blocks to use for the relative time lock in the pay-to-self
     *output of both commitment transactions.
     * </pre>
     *
     * <code>uint32 csv_delay = 11;</code>
     * @return The csvDelay.
     */
    int getCsvDelay();

    /**
     * <pre>
     * The total number of incoming HTLC's that the initiator will accept.
     * </pre>
     *
     * <code>uint32 max_accepted_htlcs = 12;</code>
     * @return The maxAcceptedHtlcs.
     */
    int getMaxAcceptedHtlcs();

    /**
     * <pre>
     * A bit-field which the initiator uses to specify proposed channel
     * behavior.
     * </pre>
     *
     * <code>uint32 channel_flags = 13;</code>
     * @return The channelFlags.
     */
    int getChannelFlags();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChannelAcceptRequest}
   */
  public  static final class ChannelAcceptRequest extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelAcceptRequest, ChannelAcceptRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelAcceptRequest)
      ChannelAcceptRequestOrBuilder {
    private ChannelAcceptRequest() {
      nodePubkey_ = com.google.protobuf.ByteString.EMPTY;
      chainHash_ = com.google.protobuf.ByteString.EMPTY;
      pendingChanId_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int NODE_PUBKEY_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString nodePubkey_;
    /**
     * <pre>
     * The pubkey of the node that wishes to open an inbound channel.
     * </pre>
     *
     * <code>bytes node_pubkey = 1;</code>
     * @return The nodePubkey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getNodePubkey() {
      return nodePubkey_;
    }
    /**
     * <pre>
     * The pubkey of the node that wishes to open an inbound channel.
     * </pre>
     *
     * <code>bytes node_pubkey = 1;</code>
     * @param value The nodePubkey to set.
     */
    private void setNodePubkey(com.google.protobuf.ByteString value) {
      value.getClass();
  
      nodePubkey_ = value;
    }
    /**
     * <pre>
     * The pubkey of the node that wishes to open an inbound channel.
     * </pre>
     *
     * <code>bytes node_pubkey = 1;</code>
     */
    private void clearNodePubkey() {
      
      nodePubkey_ = getDefaultInstance().getNodePubkey();
    }

    public static final int CHAIN_HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString chainHash_;
    /**
     * <pre>
     * The hash of the genesis block that the proposed channel resides in.
     * </pre>
     *
     * <code>bytes chain_hash = 2;</code>
     * @return The chainHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getChainHash() {
      return chainHash_;
    }
    /**
     * <pre>
     * The hash of the genesis block that the proposed channel resides in.
     * </pre>
     *
     * <code>bytes chain_hash = 2;</code>
     * @param value The chainHash to set.
     */
    private void setChainHash(com.google.protobuf.ByteString value) {
      value.getClass();
  
      chainHash_ = value;
    }
    /**
     * <pre>
     * The hash of the genesis block that the proposed channel resides in.
     * </pre>
     *
     * <code>bytes chain_hash = 2;</code>
     */
    private void clearChainHash() {
      
      chainHash_ = getDefaultInstance().getChainHash();
    }

    public static final int PENDING_CHAN_ID_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString pendingChanId_;
    /**
     * <pre>
     * The pending channel id.
     * </pre>
     *
     * <code>bytes pending_chan_id = 3;</code>
     * @return The pendingChanId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPendingChanId() {
      return pendingChanId_;
    }
    /**
     * <pre>
     * The pending channel id.
     * </pre>
     *
     * <code>bytes pending_chan_id = 3;</code>
     * @param value The pendingChanId to set.
     */
    private void setPendingChanId(com.google.protobuf.ByteString value) {
      value.getClass();
  
      pendingChanId_ = value;
    }
    /**
     * <pre>
     * The pending channel id.
     * </pre>
     *
     * <code>bytes pending_chan_id = 3;</code>
     */
    private void clearPendingChanId() {
      
      pendingChanId_ = getDefaultInstance().getPendingChanId();
    }

    public static final int FUNDING_AMT_FIELD_NUMBER = 4;
    private long fundingAmt_;
    /**
     * <pre>
     * The funding amount in satoshis that initiator wishes to use in the
     * channel.
     * </pre>
     *
     * <code>uint64 funding_amt = 4;</code>
     * @return The fundingAmt.
     */
    @java.lang.Override
    public long getFundingAmt() {
      return fundingAmt_;
    }
    /**
     * <pre>
     * The funding amount in satoshis that initiator wishes to use in the
     * channel.
     * </pre>
     *
     * <code>uint64 funding_amt = 4;</code>
     * @param value The fundingAmt to set.
     */
    private void setFundingAmt(long value) {
      
      fundingAmt_ = value;
    }
    /**
     * <pre>
     * The funding amount in satoshis that initiator wishes to use in the
     * channel.
     * </pre>
     *
     * <code>uint64 funding_amt = 4;</code>
     */
    private void clearFundingAmt() {
      
      fundingAmt_ = 0L;
    }

    public static final int PUSH_AMT_FIELD_NUMBER = 5;
    private long pushAmt_;
    /**
     * <pre>
     * The push amount of the proposed channel in millisatoshis.
     * </pre>
     *
     * <code>uint64 push_amt = 5;</code>
     * @return The pushAmt.
     */
    @java.lang.Override
    public long getPushAmt() {
      return pushAmt_;
    }
    /**
     * <pre>
     * The push amount of the proposed channel in millisatoshis.
     * </pre>
     *
     * <code>uint64 push_amt = 5;</code>
     * @param value The pushAmt to set.
     */
    private void setPushAmt(long value) {
      
      pushAmt_ = value;
    }
    /**
     * <pre>
     * The push amount of the proposed channel in millisatoshis.
     * </pre>
     *
     * <code>uint64 push_amt = 5;</code>
     */
    private void clearPushAmt() {
      
      pushAmt_ = 0L;
    }

    public static final int DUST_LIMIT_FIELD_NUMBER = 6;
    private long dustLimit_;
    /**
     * <pre>
     * The dust limit of the initiator's commitment tx.
     * </pre>
     *
     * <code>uint64 dust_limit = 6;</code>
     * @return The dustLimit.
     */
    @java.lang.Override
    public long getDustLimit() {
      return dustLimit_;
    }
    /**
     * <pre>
     * The dust limit of the initiator's commitment tx.
     * </pre>
     *
     * <code>uint64 dust_limit = 6;</code>
     * @param value The dustLimit to set.
     */
    private void setDustLimit(long value) {
      
      dustLimit_ = value;
    }
    /**
     * <pre>
     * The dust limit of the initiator's commitment tx.
     * </pre>
     *
     * <code>uint64 dust_limit = 6;</code>
     */
    private void clearDustLimit() {
      
      dustLimit_ = 0L;
    }

    public static final int MAX_VALUE_IN_FLIGHT_FIELD_NUMBER = 7;
    private long maxValueInFlight_;
    /**
     * <pre>
     * The maximum amount of coins in millisatoshis that can be pending in this
     * channel.
     * </pre>
     *
     * <code>uint64 max_value_in_flight = 7;</code>
     * @return The maxValueInFlight.
     */
    @java.lang.Override
    public long getMaxValueInFlight() {
      return maxValueInFlight_;
    }
    /**
     * <pre>
     * The maximum amount of coins in millisatoshis that can be pending in this
     * channel.
     * </pre>
     *
     * <code>uint64 max_value_in_flight = 7;</code>
     * @param value The maxValueInFlight to set.
     */
    private void setMaxValueInFlight(long value) {
      
      maxValueInFlight_ = value;
    }
    /**
     * <pre>
     * The maximum amount of coins in millisatoshis that can be pending in this
     * channel.
     * </pre>
     *
     * <code>uint64 max_value_in_flight = 7;</code>
     */
    private void clearMaxValueInFlight() {
      
      maxValueInFlight_ = 0L;
    }

    public static final int CHANNEL_RESERVE_FIELD_NUMBER = 8;
    private long channelReserve_;
    /**
     * <pre>
     * The minimum amount of satoshis the initiator requires us to have at all
     * times.
     * </pre>
     *
     * <code>uint64 channel_reserve = 8;</code>
     * @return The channelReserve.
     */
    @java.lang.Override
    public long getChannelReserve() {
      return channelReserve_;
    }
    /**
     * <pre>
     * The minimum amount of satoshis the initiator requires us to have at all
     * times.
     * </pre>
     *
     * <code>uint64 channel_reserve = 8;</code>
     * @param value The channelReserve to set.
     */
    private void setChannelReserve(long value) {
      
      channelReserve_ = value;
    }
    /**
     * <pre>
     * The minimum amount of satoshis the initiator requires us to have at all
     * times.
     * </pre>
     *
     * <code>uint64 channel_reserve = 8;</code>
     */
    private void clearChannelReserve() {
      
      channelReserve_ = 0L;
    }

    public static final int MIN_HTLC_FIELD_NUMBER = 9;
    private long minHtlc_;
    /**
     * <pre>
     * The smallest HTLC in millisatoshis that the initiator will accept.
     * </pre>
     *
     * <code>uint64 min_htlc = 9;</code>
     * @return The minHtlc.
     */
    @java.lang.Override
    public long getMinHtlc() {
      return minHtlc_;
    }
    /**
     * <pre>
     * The smallest HTLC in millisatoshis that the initiator will accept.
     * </pre>
     *
     * <code>uint64 min_htlc = 9;</code>
     * @param value The minHtlc to set.
     */
    private void setMinHtlc(long value) {
      
      minHtlc_ = value;
    }
    /**
     * <pre>
     * The smallest HTLC in millisatoshis that the initiator will accept.
     * </pre>
     *
     * <code>uint64 min_htlc = 9;</code>
     */
    private void clearMinHtlc() {
      
      minHtlc_ = 0L;
    }

    public static final int FEE_PER_KW_FIELD_NUMBER = 10;
    private long feePerKw_;
    /**
     * <pre>
     * The initial fee rate that the initiator suggests for both commitment
     * transactions.
     * </pre>
     *
     * <code>uint64 fee_per_kw = 10;</code>
     * @return The feePerKw.
     */
    @java.lang.Override
    public long getFeePerKw() {
      return feePerKw_;
    }
    /**
     * <pre>
     * The initial fee rate that the initiator suggests for both commitment
     * transactions.
     * </pre>
     *
     * <code>uint64 fee_per_kw = 10;</code>
     * @param value The feePerKw to set.
     */
    private void setFeePerKw(long value) {
      
      feePerKw_ = value;
    }
    /**
     * <pre>
     * The initial fee rate that the initiator suggests for both commitment
     * transactions.
     * </pre>
     *
     * <code>uint64 fee_per_kw = 10;</code>
     */
    private void clearFeePerKw() {
      
      feePerKw_ = 0L;
    }

    public static final int CSV_DELAY_FIELD_NUMBER = 11;
    private int csvDelay_;
    /**
     * <pre>
     *The number of blocks to use for the relative time lock in the pay-to-self
     *output of both commitment transactions.
     * </pre>
     *
     * <code>uint32 csv_delay = 11;</code>
     * @return The csvDelay.
     */
    @java.lang.Override
    public int getCsvDelay() {
      return csvDelay_;
    }
    /**
     * <pre>
     *The number of blocks to use for the relative time lock in the pay-to-self
     *output of both commitment transactions.
     * </pre>
     *
     * <code>uint32 csv_delay = 11;</code>
     * @param value The csvDelay to set.
     */
    private void setCsvDelay(int value) {
      
      csvDelay_ = value;
    }
    /**
     * <pre>
     *The number of blocks to use for the relative time lock in the pay-to-self
     *output of both commitment transactions.
     * </pre>
     *
     * <code>uint32 csv_delay = 11;</code>
     */
    private void clearCsvDelay() {
      
      csvDelay_ = 0;
    }

    public static final int MAX_ACCEPTED_HTLCS_FIELD_NUMBER = 12;
    private int maxAcceptedHtlcs_;
    /**
     * <pre>
     * The total number of incoming HTLC's that the initiator will accept.
     * </pre>
     *
     * <code>uint32 max_accepted_htlcs = 12;</code>
     * @return The maxAcceptedHtlcs.
     */
    @java.lang.Override
    public int getMaxAcceptedHtlcs() {
      return maxAcceptedHtlcs_;
    }
    /**
     * <pre>
     * The total number of incoming HTLC's that the initiator will accept.
     * </pre>
     *
     * <code>uint32 max_accepted_htlcs = 12;</code>
     * @param value The maxAcceptedHtlcs to set.
     */
    private void setMaxAcceptedHtlcs(int value) {
      
      maxAcceptedHtlcs_ = value;
    }
    /**
     * <pre>
     * The total number of incoming HTLC's that the initiator will accept.
     * </pre>
     *
     * <code>uint32 max_accepted_htlcs = 12;</code>
     */
    private void clearMaxAcceptedHtlcs() {
      
      maxAcceptedHtlcs_ = 0;
    }

    public static final int CHANNEL_FLAGS_FIELD_NUMBER = 13;
    private int channelFlags_;
    /**
     * <pre>
     * A bit-field which the initiator uses to specify proposed channel
     * behavior.
     * </pre>
     *
     * <code>uint32 channel_flags = 13;</code>
     * @return The channelFlags.
     */
    @java.lang.Override
    public int getChannelFlags() {
      return channelFlags_;
    }
    /**
     * <pre>
     * A bit-field which the initiator uses to specify proposed channel
     * behavior.
     * </pre>
     *
     * <code>uint32 channel_flags = 13;</code>
     * @param value The channelFlags to set.
     */
    private void setChannelFlags(int value) {
      
      channelFlags_ = value;
    }
    /**
     * <pre>
     * A bit-field which the initiator uses to specify proposed channel
     * behavior.
     * </pre>
     *
     * <code>uint32 channel_flags = 13;</code>
     */
    private void clearChannelFlags() {
      
      channelFlags_ = 0;
    }

    public static co.anode.anodium.Rpc.ChannelAcceptRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelAcceptRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChannelAcceptRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelAcceptRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelAcceptRequest)
        co.anode.anodium.Rpc.ChannelAcceptRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelAcceptRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The pubkey of the node that wishes to open an inbound channel.
       * </pre>
       *
       * <code>bytes node_pubkey = 1;</code>
       * @return The nodePubkey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getNodePubkey() {
        return instance.getNodePubkey();
      }
      /**
       * <pre>
       * The pubkey of the node that wishes to open an inbound channel.
       * </pre>
       *
       * <code>bytes node_pubkey = 1;</code>
       * @param value The nodePubkey to set.
       * @return This builder for chaining.
       */
      public Builder setNodePubkey(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNodePubkey(value);
        return this;
      }
      /**
       * <pre>
       * The pubkey of the node that wishes to open an inbound channel.
       * </pre>
       *
       * <code>bytes node_pubkey = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearNodePubkey() {
        copyOnWrite();
        instance.clearNodePubkey();
        return this;
      }

      /**
       * <pre>
       * The hash of the genesis block that the proposed channel resides in.
       * </pre>
       *
       * <code>bytes chain_hash = 2;</code>
       * @return The chainHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getChainHash() {
        return instance.getChainHash();
      }
      /**
       * <pre>
       * The hash of the genesis block that the proposed channel resides in.
       * </pre>
       *
       * <code>bytes chain_hash = 2;</code>
       * @param value The chainHash to set.
       * @return This builder for chaining.
       */
      public Builder setChainHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setChainHash(value);
        return this;
      }
      /**
       * <pre>
       * The hash of the genesis block that the proposed channel resides in.
       * </pre>
       *
       * <code>bytes chain_hash = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearChainHash() {
        copyOnWrite();
        instance.clearChainHash();
        return this;
      }

      /**
       * <pre>
       * The pending channel id.
       * </pre>
       *
       * <code>bytes pending_chan_id = 3;</code>
       * @return The pendingChanId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPendingChanId() {
        return instance.getPendingChanId();
      }
      /**
       * <pre>
       * The pending channel id.
       * </pre>
       *
       * <code>bytes pending_chan_id = 3;</code>
       * @param value The pendingChanId to set.
       * @return This builder for chaining.
       */
      public Builder setPendingChanId(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPendingChanId(value);
        return this;
      }
      /**
       * <pre>
       * The pending channel id.
       * </pre>
       *
       * <code>bytes pending_chan_id = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearPendingChanId() {
        copyOnWrite();
        instance.clearPendingChanId();
        return this;
      }

      /**
       * <pre>
       * The funding amount in satoshis that initiator wishes to use in the
       * channel.
       * </pre>
       *
       * <code>uint64 funding_amt = 4;</code>
       * @return The fundingAmt.
       */
      @java.lang.Override
      public long getFundingAmt() {
        return instance.getFundingAmt();
      }
      /**
       * <pre>
       * The funding amount in satoshis that initiator wishes to use in the
       * channel.
       * </pre>
       *
       * <code>uint64 funding_amt = 4;</code>
       * @param value The fundingAmt to set.
       * @return This builder for chaining.
       */
      public Builder setFundingAmt(long value) {
        copyOnWrite();
        instance.setFundingAmt(value);
        return this;
      }
      /**
       * <pre>
       * The funding amount in satoshis that initiator wishes to use in the
       * channel.
       * </pre>
       *
       * <code>uint64 funding_amt = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearFundingAmt() {
        copyOnWrite();
        instance.clearFundingAmt();
        return this;
      }

      /**
       * <pre>
       * The push amount of the proposed channel in millisatoshis.
       * </pre>
       *
       * <code>uint64 push_amt = 5;</code>
       * @return The pushAmt.
       */
      @java.lang.Override
      public long getPushAmt() {
        return instance.getPushAmt();
      }
      /**
       * <pre>
       * The push amount of the proposed channel in millisatoshis.
       * </pre>
       *
       * <code>uint64 push_amt = 5;</code>
       * @param value The pushAmt to set.
       * @return This builder for chaining.
       */
      public Builder setPushAmt(long value) {
        copyOnWrite();
        instance.setPushAmt(value);
        return this;
      }
      /**
       * <pre>
       * The push amount of the proposed channel in millisatoshis.
       * </pre>
       *
       * <code>uint64 push_amt = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearPushAmt() {
        copyOnWrite();
        instance.clearPushAmt();
        return this;
      }

      /**
       * <pre>
       * The dust limit of the initiator's commitment tx.
       * </pre>
       *
       * <code>uint64 dust_limit = 6;</code>
       * @return The dustLimit.
       */
      @java.lang.Override
      public long getDustLimit() {
        return instance.getDustLimit();
      }
      /**
       * <pre>
       * The dust limit of the initiator's commitment tx.
       * </pre>
       *
       * <code>uint64 dust_limit = 6;</code>
       * @param value The dustLimit to set.
       * @return This builder for chaining.
       */
      public Builder setDustLimit(long value) {
        copyOnWrite();
        instance.setDustLimit(value);
        return this;
      }
      /**
       * <pre>
       * The dust limit of the initiator's commitment tx.
       * </pre>
       *
       * <code>uint64 dust_limit = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearDustLimit() {
        copyOnWrite();
        instance.clearDustLimit();
        return this;
      }

      /**
       * <pre>
       * The maximum amount of coins in millisatoshis that can be pending in this
       * channel.
       * </pre>
       *
       * <code>uint64 max_value_in_flight = 7;</code>
       * @return The maxValueInFlight.
       */
      @java.lang.Override
      public long getMaxValueInFlight() {
        return instance.getMaxValueInFlight();
      }
      /**
       * <pre>
       * The maximum amount of coins in millisatoshis that can be pending in this
       * channel.
       * </pre>
       *
       * <code>uint64 max_value_in_flight = 7;</code>
       * @param value The maxValueInFlight to set.
       * @return This builder for chaining.
       */
      public Builder setMaxValueInFlight(long value) {
        copyOnWrite();
        instance.setMaxValueInFlight(value);
        return this;
      }
      /**
       * <pre>
       * The maximum amount of coins in millisatoshis that can be pending in this
       * channel.
       * </pre>
       *
       * <code>uint64 max_value_in_flight = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxValueInFlight() {
        copyOnWrite();
        instance.clearMaxValueInFlight();
        return this;
      }

      /**
       * <pre>
       * The minimum amount of satoshis the initiator requires us to have at all
       * times.
       * </pre>
       *
       * <code>uint64 channel_reserve = 8;</code>
       * @return The channelReserve.
       */
      @java.lang.Override
      public long getChannelReserve() {
        return instance.getChannelReserve();
      }
      /**
       * <pre>
       * The minimum amount of satoshis the initiator requires us to have at all
       * times.
       * </pre>
       *
       * <code>uint64 channel_reserve = 8;</code>
       * @param value The channelReserve to set.
       * @return This builder for chaining.
       */
      public Builder setChannelReserve(long value) {
        copyOnWrite();
        instance.setChannelReserve(value);
        return this;
      }
      /**
       * <pre>
       * The minimum amount of satoshis the initiator requires us to have at all
       * times.
       * </pre>
       *
       * <code>uint64 channel_reserve = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearChannelReserve() {
        copyOnWrite();
        instance.clearChannelReserve();
        return this;
      }

      /**
       * <pre>
       * The smallest HTLC in millisatoshis that the initiator will accept.
       * </pre>
       *
       * <code>uint64 min_htlc = 9;</code>
       * @return The minHtlc.
       */
      @java.lang.Override
      public long getMinHtlc() {
        return instance.getMinHtlc();
      }
      /**
       * <pre>
       * The smallest HTLC in millisatoshis that the initiator will accept.
       * </pre>
       *
       * <code>uint64 min_htlc = 9;</code>
       * @param value The minHtlc to set.
       * @return This builder for chaining.
       */
      public Builder setMinHtlc(long value) {
        copyOnWrite();
        instance.setMinHtlc(value);
        return this;
      }
      /**
       * <pre>
       * The smallest HTLC in millisatoshis that the initiator will accept.
       * </pre>
       *
       * <code>uint64 min_htlc = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinHtlc() {
        copyOnWrite();
        instance.clearMinHtlc();
        return this;
      }

      /**
       * <pre>
       * The initial fee rate that the initiator suggests for both commitment
       * transactions.
       * </pre>
       *
       * <code>uint64 fee_per_kw = 10;</code>
       * @return The feePerKw.
       */
      @java.lang.Override
      public long getFeePerKw() {
        return instance.getFeePerKw();
      }
      /**
       * <pre>
       * The initial fee rate that the initiator suggests for both commitment
       * transactions.
       * </pre>
       *
       * <code>uint64 fee_per_kw = 10;</code>
       * @param value The feePerKw to set.
       * @return This builder for chaining.
       */
      public Builder setFeePerKw(long value) {
        copyOnWrite();
        instance.setFeePerKw(value);
        return this;
      }
      /**
       * <pre>
       * The initial fee rate that the initiator suggests for both commitment
       * transactions.
       * </pre>
       *
       * <code>uint64 fee_per_kw = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearFeePerKw() {
        copyOnWrite();
        instance.clearFeePerKw();
        return this;
      }

      /**
       * <pre>
       *The number of blocks to use for the relative time lock in the pay-to-self
       *output of both commitment transactions.
       * </pre>
       *
       * <code>uint32 csv_delay = 11;</code>
       * @return The csvDelay.
       */
      @java.lang.Override
      public int getCsvDelay() {
        return instance.getCsvDelay();
      }
      /**
       * <pre>
       *The number of blocks to use for the relative time lock in the pay-to-self
       *output of both commitment transactions.
       * </pre>
       *
       * <code>uint32 csv_delay = 11;</code>
       * @param value The csvDelay to set.
       * @return This builder for chaining.
       */
      public Builder setCsvDelay(int value) {
        copyOnWrite();
        instance.setCsvDelay(value);
        return this;
      }
      /**
       * <pre>
       *The number of blocks to use for the relative time lock in the pay-to-self
       *output of both commitment transactions.
       * </pre>
       *
       * <code>uint32 csv_delay = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearCsvDelay() {
        copyOnWrite();
        instance.clearCsvDelay();
        return this;
      }

      /**
       * <pre>
       * The total number of incoming HTLC's that the initiator will accept.
       * </pre>
       *
       * <code>uint32 max_accepted_htlcs = 12;</code>
       * @return The maxAcceptedHtlcs.
       */
      @java.lang.Override
      public int getMaxAcceptedHtlcs() {
        return instance.getMaxAcceptedHtlcs();
      }
      /**
       * <pre>
       * The total number of incoming HTLC's that the initiator will accept.
       * </pre>
       *
       * <code>uint32 max_accepted_htlcs = 12;</code>
       * @param value The maxAcceptedHtlcs to set.
       * @return This builder for chaining.
       */
      public Builder setMaxAcceptedHtlcs(int value) {
        copyOnWrite();
        instance.setMaxAcceptedHtlcs(value);
        return this;
      }
      /**
       * <pre>
       * The total number of incoming HTLC's that the initiator will accept.
       * </pre>
       *
       * <code>uint32 max_accepted_htlcs = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxAcceptedHtlcs() {
        copyOnWrite();
        instance.clearMaxAcceptedHtlcs();
        return this;
      }

      /**
       * <pre>
       * A bit-field which the initiator uses to specify proposed channel
       * behavior.
       * </pre>
       *
       * <code>uint32 channel_flags = 13;</code>
       * @return The channelFlags.
       */
      @java.lang.Override
      public int getChannelFlags() {
        return instance.getChannelFlags();
      }
      /**
       * <pre>
       * A bit-field which the initiator uses to specify proposed channel
       * behavior.
       * </pre>
       *
       * <code>uint32 channel_flags = 13;</code>
       * @param value The channelFlags to set.
       * @return This builder for chaining.
       */
      public Builder setChannelFlags(int value) {
        copyOnWrite();
        instance.setChannelFlags(value);
        return this;
      }
      /**
       * <pre>
       * A bit-field which the initiator uses to specify proposed channel
       * behavior.
       * </pre>
       *
       * <code>uint32 channel_flags = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearChannelFlags() {
        copyOnWrite();
        instance.clearChannelFlags();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelAcceptRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelAcceptRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "nodePubkey_",
              "chainHash_",
              "pendingChanId_",
              "fundingAmt_",
              "pushAmt_",
              "dustLimit_",
              "maxValueInFlight_",
              "channelReserve_",
              "minHtlc_",
              "feePerKw_",
              "csvDelay_",
              "maxAcceptedHtlcs_",
              "channelFlags_",
            };
            java.lang.String info =
                "\u0000\r\u0000\u0000\u0001\r\r\u0000\u0000\u0000\u0001\n\u0002\n\u0003\n\u0004\u0003" +
                "\u0005\u0003\u0006\u0003\u0007\u0003\b\u0003\t\u0003\n\u0003\u000b\u000b\f\u000b" +
                "\r\u000b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelAcceptRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelAcceptRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelAcceptRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelAcceptRequest)
    private static final co.anode.anodium.Rpc.ChannelAcceptRequest DEFAULT_INSTANCE;
    static {
      ChannelAcceptRequest defaultInstance = new ChannelAcceptRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelAcceptRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelAcceptRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelAcceptRequest> PARSER;

    public static com.google.protobuf.Parser<ChannelAcceptRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelAcceptResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelAcceptResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Whether or not the client accepts the channel.
     * </pre>
     *
     * <code>bool accept = 1;</code>
     * @return The accept.
     */
    boolean getAccept();

    /**
     * <pre>
     * The pending channel id to which this response applies.
     * </pre>
     *
     * <code>bytes pending_chan_id = 2;</code>
     * @return The pendingChanId.
     */
    com.google.protobuf.ByteString getPendingChanId();

    /**
     * <pre>
     *An optional error to send the initiating party to indicate why the channel
     *was rejected. This field *should not* contain sensitive information, it will
     *be sent to the initiating party. This field should only be set if accept is
     *false, the channel will be rejected if an error is set with accept=true
     *because the meaning of this response is ambiguous. Limited to 500
     *characters.
     * </pre>
     *
     * <code>string error = 3;</code>
     * @return The error.
     */
    java.lang.String getError();
    /**
     * <pre>
     *An optional error to send the initiating party to indicate why the channel
     *was rejected. This field *should not* contain sensitive information, it will
     *be sent to the initiating party. This field should only be set if accept is
     *false, the channel will be rejected if an error is set with accept=true
     *because the meaning of this response is ambiguous. Limited to 500
     *characters.
     * </pre>
     *
     * <code>string error = 3;</code>
     * @return The bytes for error.
     */
    com.google.protobuf.ByteString
        getErrorBytes();

    /**
     * <pre>
     *The upfront shutdown address to use if the initiating peer supports option
     *upfront shutdown script (see ListPeers for the features supported). Note
     *that the channel open will fail if this value is set for a peer that does
     *not support this feature bit.
     * </pre>
     *
     * <code>string upfront_shutdown = 4;</code>
     * @return The upfrontShutdown.
     */
    java.lang.String getUpfrontShutdown();
    /**
     * <pre>
     *The upfront shutdown address to use if the initiating peer supports option
     *upfront shutdown script (see ListPeers for the features supported). Note
     *that the channel open will fail if this value is set for a peer that does
     *not support this feature bit.
     * </pre>
     *
     * <code>string upfront_shutdown = 4;</code>
     * @return The bytes for upfrontShutdown.
     */
    com.google.protobuf.ByteString
        getUpfrontShutdownBytes();

    /**
     * <pre>
     *The csv delay (in blocks) that we require for the remote party.
     * </pre>
     *
     * <code>uint32 csv_delay = 5;</code>
     * @return The csvDelay.
     */
    int getCsvDelay();

    /**
     * <pre>
     *The reserve amount in satoshis that we require the remote peer to adhere to.
     *We require that the remote peer always have some reserve amount allocated to
     *them so that there is always a disincentive to broadcast old state (if they
     *hold 0 sats on their side of the channel, there is nothing to lose).
     * </pre>
     *
     * <code>uint64 reserve_sat = 6;</code>
     * @return The reserveSat.
     */
    long getReserveSat();

    /**
     * <pre>
     *The maximum amount of funds in millisatoshis that we allow the remote peer
     *to have in outstanding htlcs.
     * </pre>
     *
     * <code>uint64 in_flight_max_msat = 7;</code>
     * @return The inFlightMaxMsat.
     */
    long getInFlightMaxMsat();

    /**
     * <pre>
     *The maximum number of htlcs that the remote peer can offer us.
     * </pre>
     *
     * <code>uint32 max_htlc_count = 8;</code>
     * @return The maxHtlcCount.
     */
    int getMaxHtlcCount();

    /**
     * <pre>
     *The minimum value in millisatoshis for incoming htlcs on the channel.
     * </pre>
     *
     * <code>uint64 min_htlc_in = 9;</code>
     * @return The minHtlcIn.
     */
    long getMinHtlcIn();

    /**
     * <pre>
     *The number of confirmations we require before we consider the channel open.
     * </pre>
     *
     * <code>uint32 min_accept_depth = 10;</code>
     * @return The minAcceptDepth.
     */
    int getMinAcceptDepth();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChannelAcceptResponse}
   */
  public  static final class ChannelAcceptResponse extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelAcceptResponse, ChannelAcceptResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelAcceptResponse)
      ChannelAcceptResponseOrBuilder {
    private ChannelAcceptResponse() {
      pendingChanId_ = com.google.protobuf.ByteString.EMPTY;
      error_ = "";
      upfrontShutdown_ = "";
    }
    public static final int ACCEPT_FIELD_NUMBER = 1;
    private boolean accept_;
    /**
     * <pre>
     * Whether or not the client accepts the channel.
     * </pre>
     *
     * <code>bool accept = 1;</code>
     * @return The accept.
     */
    @java.lang.Override
    public boolean getAccept() {
      return accept_;
    }
    /**
     * <pre>
     * Whether or not the client accepts the channel.
     * </pre>
     *
     * <code>bool accept = 1;</code>
     * @param value The accept to set.
     */
    private void setAccept(boolean value) {
      
      accept_ = value;
    }
    /**
     * <pre>
     * Whether or not the client accepts the channel.
     * </pre>
     *
     * <code>bool accept = 1;</code>
     */
    private void clearAccept() {
      
      accept_ = false;
    }

    public static final int PENDING_CHAN_ID_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString pendingChanId_;
    /**
     * <pre>
     * The pending channel id to which this response applies.
     * </pre>
     *
     * <code>bytes pending_chan_id = 2;</code>
     * @return The pendingChanId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPendingChanId() {
      return pendingChanId_;
    }
    /**
     * <pre>
     * The pending channel id to which this response applies.
     * </pre>
     *
     * <code>bytes pending_chan_id = 2;</code>
     * @param value The pendingChanId to set.
     */
    private void setPendingChanId(com.google.protobuf.ByteString value) {
      value.getClass();
  
      pendingChanId_ = value;
    }
    /**
     * <pre>
     * The pending channel id to which this response applies.
     * </pre>
     *
     * <code>bytes pending_chan_id = 2;</code>
     */
    private void clearPendingChanId() {
      
      pendingChanId_ = getDefaultInstance().getPendingChanId();
    }

    public static final int ERROR_FIELD_NUMBER = 3;
    private java.lang.String error_;
    /**
     * <pre>
     *An optional error to send the initiating party to indicate why the channel
     *was rejected. This field *should not* contain sensitive information, it will
     *be sent to the initiating party. This field should only be set if accept is
     *false, the channel will be rejected if an error is set with accept=true
     *because the meaning of this response is ambiguous. Limited to 500
     *characters.
     * </pre>
     *
     * <code>string error = 3;</code>
     * @return The error.
     */
    @java.lang.Override
    public java.lang.String getError() {
      return error_;
    }
    /**
     * <pre>
     *An optional error to send the initiating party to indicate why the channel
     *was rejected. This field *should not* contain sensitive information, it will
     *be sent to the initiating party. This field should only be set if accept is
     *false, the channel will be rejected if an error is set with accept=true
     *because the meaning of this response is ambiguous. Limited to 500
     *characters.
     * </pre>
     *
     * <code>string error = 3;</code>
     * @return The bytes for error.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getErrorBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(error_);
    }
    /**
     * <pre>
     *An optional error to send the initiating party to indicate why the channel
     *was rejected. This field *should not* contain sensitive information, it will
     *be sent to the initiating party. This field should only be set if accept is
     *false, the channel will be rejected if an error is set with accept=true
     *because the meaning of this response is ambiguous. Limited to 500
     *characters.
     * </pre>
     *
     * <code>string error = 3;</code>
     * @param value The error to set.
     */
    private void setError(
        java.lang.String value) {
      value.getClass();
  
      error_ = value;
    }
    /**
     * <pre>
     *An optional error to send the initiating party to indicate why the channel
     *was rejected. This field *should not* contain sensitive information, it will
     *be sent to the initiating party. This field should only be set if accept is
     *false, the channel will be rejected if an error is set with accept=true
     *because the meaning of this response is ambiguous. Limited to 500
     *characters.
     * </pre>
     *
     * <code>string error = 3;</code>
     */
    private void clearError() {
      
      error_ = getDefaultInstance().getError();
    }
    /**
     * <pre>
     *An optional error to send the initiating party to indicate why the channel
     *was rejected. This field *should not* contain sensitive information, it will
     *be sent to the initiating party. This field should only be set if accept is
     *false, the channel will be rejected if an error is set with accept=true
     *because the meaning of this response is ambiguous. Limited to 500
     *characters.
     * </pre>
     *
     * <code>string error = 3;</code>
     * @param value The bytes for error to set.
     */
    private void setErrorBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      error_ = value.toStringUtf8();
      
    }

    public static final int UPFRONT_SHUTDOWN_FIELD_NUMBER = 4;
    private java.lang.String upfrontShutdown_;
    /**
     * <pre>
     *The upfront shutdown address to use if the initiating peer supports option
     *upfront shutdown script (see ListPeers for the features supported). Note
     *that the channel open will fail if this value is set for a peer that does
     *not support this feature bit.
     * </pre>
     *
     * <code>string upfront_shutdown = 4;</code>
     * @return The upfrontShutdown.
     */
    @java.lang.Override
    public java.lang.String getUpfrontShutdown() {
      return upfrontShutdown_;
    }
    /**
     * <pre>
     *The upfront shutdown address to use if the initiating peer supports option
     *upfront shutdown script (see ListPeers for the features supported). Note
     *that the channel open will fail if this value is set for a peer that does
     *not support this feature bit.
     * </pre>
     *
     * <code>string upfront_shutdown = 4;</code>
     * @return The bytes for upfrontShutdown.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUpfrontShutdownBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(upfrontShutdown_);
    }
    /**
     * <pre>
     *The upfront shutdown address to use if the initiating peer supports option
     *upfront shutdown script (see ListPeers for the features supported). Note
     *that the channel open will fail if this value is set for a peer that does
     *not support this feature bit.
     * </pre>
     *
     * <code>string upfront_shutdown = 4;</code>
     * @param value The upfrontShutdown to set.
     */
    private void setUpfrontShutdown(
        java.lang.String value) {
      value.getClass();
  
      upfrontShutdown_ = value;
    }
    /**
     * <pre>
     *The upfront shutdown address to use if the initiating peer supports option
     *upfront shutdown script (see ListPeers for the features supported). Note
     *that the channel open will fail if this value is set for a peer that does
     *not support this feature bit.
     * </pre>
     *
     * <code>string upfront_shutdown = 4;</code>
     */
    private void clearUpfrontShutdown() {
      
      upfrontShutdown_ = getDefaultInstance().getUpfrontShutdown();
    }
    /**
     * <pre>
     *The upfront shutdown address to use if the initiating peer supports option
     *upfront shutdown script (see ListPeers for the features supported). Note
     *that the channel open will fail if this value is set for a peer that does
     *not support this feature bit.
     * </pre>
     *
     * <code>string upfront_shutdown = 4;</code>
     * @param value The bytes for upfrontShutdown to set.
     */
    private void setUpfrontShutdownBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      upfrontShutdown_ = value.toStringUtf8();
      
    }

    public static final int CSV_DELAY_FIELD_NUMBER = 5;
    private int csvDelay_;
    /**
     * <pre>
     *The csv delay (in blocks) that we require for the remote party.
     * </pre>
     *
     * <code>uint32 csv_delay = 5;</code>
     * @return The csvDelay.
     */
    @java.lang.Override
    public int getCsvDelay() {
      return csvDelay_;
    }
    /**
     * <pre>
     *The csv delay (in blocks) that we require for the remote party.
     * </pre>
     *
     * <code>uint32 csv_delay = 5;</code>
     * @param value The csvDelay to set.
     */
    private void setCsvDelay(int value) {
      
      csvDelay_ = value;
    }
    /**
     * <pre>
     *The csv delay (in blocks) that we require for the remote party.
     * </pre>
     *
     * <code>uint32 csv_delay = 5;</code>
     */
    private void clearCsvDelay() {
      
      csvDelay_ = 0;
    }

    public static final int RESERVE_SAT_FIELD_NUMBER = 6;
    private long reserveSat_;
    /**
     * <pre>
     *The reserve amount in satoshis that we require the remote peer to adhere to.
     *We require that the remote peer always have some reserve amount allocated to
     *them so that there is always a disincentive to broadcast old state (if they
     *hold 0 sats on their side of the channel, there is nothing to lose).
     * </pre>
     *
     * <code>uint64 reserve_sat = 6;</code>
     * @return The reserveSat.
     */
    @java.lang.Override
    public long getReserveSat() {
      return reserveSat_;
    }
    /**
     * <pre>
     *The reserve amount in satoshis that we require the remote peer to adhere to.
     *We require that the remote peer always have some reserve amount allocated to
     *them so that there is always a disincentive to broadcast old state (if they
     *hold 0 sats on their side of the channel, there is nothing to lose).
     * </pre>
     *
     * <code>uint64 reserve_sat = 6;</code>
     * @param value The reserveSat to set.
     */
    private void setReserveSat(long value) {
      
      reserveSat_ = value;
    }
    /**
     * <pre>
     *The reserve amount in satoshis that we require the remote peer to adhere to.
     *We require that the remote peer always have some reserve amount allocated to
     *them so that there is always a disincentive to broadcast old state (if they
     *hold 0 sats on their side of the channel, there is nothing to lose).
     * </pre>
     *
     * <code>uint64 reserve_sat = 6;</code>
     */
    private void clearReserveSat() {
      
      reserveSat_ = 0L;
    }

    public static final int IN_FLIGHT_MAX_MSAT_FIELD_NUMBER = 7;
    private long inFlightMaxMsat_;
    /**
     * <pre>
     *The maximum amount of funds in millisatoshis that we allow the remote peer
     *to have in outstanding htlcs.
     * </pre>
     *
     * <code>uint64 in_flight_max_msat = 7;</code>
     * @return The inFlightMaxMsat.
     */
    @java.lang.Override
    public long getInFlightMaxMsat() {
      return inFlightMaxMsat_;
    }
    /**
     * <pre>
     *The maximum amount of funds in millisatoshis that we allow the remote peer
     *to have in outstanding htlcs.
     * </pre>
     *
     * <code>uint64 in_flight_max_msat = 7;</code>
     * @param value The inFlightMaxMsat to set.
     */
    private void setInFlightMaxMsat(long value) {
      
      inFlightMaxMsat_ = value;
    }
    /**
     * <pre>
     *The maximum amount of funds in millisatoshis that we allow the remote peer
     *to have in outstanding htlcs.
     * </pre>
     *
     * <code>uint64 in_flight_max_msat = 7;</code>
     */
    private void clearInFlightMaxMsat() {
      
      inFlightMaxMsat_ = 0L;
    }

    public static final int MAX_HTLC_COUNT_FIELD_NUMBER = 8;
    private int maxHtlcCount_;
    /**
     * <pre>
     *The maximum number of htlcs that the remote peer can offer us.
     * </pre>
     *
     * <code>uint32 max_htlc_count = 8;</code>
     * @return The maxHtlcCount.
     */
    @java.lang.Override
    public int getMaxHtlcCount() {
      return maxHtlcCount_;
    }
    /**
     * <pre>
     *The maximum number of htlcs that the remote peer can offer us.
     * </pre>
     *
     * <code>uint32 max_htlc_count = 8;</code>
     * @param value The maxHtlcCount to set.
     */
    private void setMaxHtlcCount(int value) {
      
      maxHtlcCount_ = value;
    }
    /**
     * <pre>
     *The maximum number of htlcs that the remote peer can offer us.
     * </pre>
     *
     * <code>uint32 max_htlc_count = 8;</code>
     */
    private void clearMaxHtlcCount() {
      
      maxHtlcCount_ = 0;
    }

    public static final int MIN_HTLC_IN_FIELD_NUMBER = 9;
    private long minHtlcIn_;
    /**
     * <pre>
     *The minimum value in millisatoshis for incoming htlcs on the channel.
     * </pre>
     *
     * <code>uint64 min_htlc_in = 9;</code>
     * @return The minHtlcIn.
     */
    @java.lang.Override
    public long getMinHtlcIn() {
      return minHtlcIn_;
    }
    /**
     * <pre>
     *The minimum value in millisatoshis for incoming htlcs on the channel.
     * </pre>
     *
     * <code>uint64 min_htlc_in = 9;</code>
     * @param value The minHtlcIn to set.
     */
    private void setMinHtlcIn(long value) {
      
      minHtlcIn_ = value;
    }
    /**
     * <pre>
     *The minimum value in millisatoshis for incoming htlcs on the channel.
     * </pre>
     *
     * <code>uint64 min_htlc_in = 9;</code>
     */
    private void clearMinHtlcIn() {
      
      minHtlcIn_ = 0L;
    }

    public static final int MIN_ACCEPT_DEPTH_FIELD_NUMBER = 10;
    private int minAcceptDepth_;
    /**
     * <pre>
     *The number of confirmations we require before we consider the channel open.
     * </pre>
     *
     * <code>uint32 min_accept_depth = 10;</code>
     * @return The minAcceptDepth.
     */
    @java.lang.Override
    public int getMinAcceptDepth() {
      return minAcceptDepth_;
    }
    /**
     * <pre>
     *The number of confirmations we require before we consider the channel open.
     * </pre>
     *
     * <code>uint32 min_accept_depth = 10;</code>
     * @param value The minAcceptDepth to set.
     */
    private void setMinAcceptDepth(int value) {
      
      minAcceptDepth_ = value;
    }
    /**
     * <pre>
     *The number of confirmations we require before we consider the channel open.
     * </pre>
     *
     * <code>uint32 min_accept_depth = 10;</code>
     */
    private void clearMinAcceptDepth() {
      
      minAcceptDepth_ = 0;
    }

    public static co.anode.anodium.Rpc.ChannelAcceptResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelAcceptResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelAcceptResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChannelAcceptResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelAcceptResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelAcceptResponse)
        co.anode.anodium.Rpc.ChannelAcceptResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelAcceptResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Whether or not the client accepts the channel.
       * </pre>
       *
       * <code>bool accept = 1;</code>
       * @return The accept.
       */
      @java.lang.Override
      public boolean getAccept() {
        return instance.getAccept();
      }
      /**
       * <pre>
       * Whether or not the client accepts the channel.
       * </pre>
       *
       * <code>bool accept = 1;</code>
       * @param value The accept to set.
       * @return This builder for chaining.
       */
      public Builder setAccept(boolean value) {
        copyOnWrite();
        instance.setAccept(value);
        return this;
      }
      /**
       * <pre>
       * Whether or not the client accepts the channel.
       * </pre>
       *
       * <code>bool accept = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAccept() {
        copyOnWrite();
        instance.clearAccept();
        return this;
      }

      /**
       * <pre>
       * The pending channel id to which this response applies.
       * </pre>
       *
       * <code>bytes pending_chan_id = 2;</code>
       * @return The pendingChanId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPendingChanId() {
        return instance.getPendingChanId();
      }
      /**
       * <pre>
       * The pending channel id to which this response applies.
       * </pre>
       *
       * <code>bytes pending_chan_id = 2;</code>
       * @param value The pendingChanId to set.
       * @return This builder for chaining.
       */
      public Builder setPendingChanId(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPendingChanId(value);
        return this;
      }
      /**
       * <pre>
       * The pending channel id to which this response applies.
       * </pre>
       *
       * <code>bytes pending_chan_id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPendingChanId() {
        copyOnWrite();
        instance.clearPendingChanId();
        return this;
      }

      /**
       * <pre>
       *An optional error to send the initiating party to indicate why the channel
       *was rejected. This field *should not* contain sensitive information, it will
       *be sent to the initiating party. This field should only be set if accept is
       *false, the channel will be rejected if an error is set with accept=true
       *because the meaning of this response is ambiguous. Limited to 500
       *characters.
       * </pre>
       *
       * <code>string error = 3;</code>
       * @return The error.
       */
      @java.lang.Override
      public java.lang.String getError() {
        return instance.getError();
      }
      /**
       * <pre>
       *An optional error to send the initiating party to indicate why the channel
       *was rejected. This field *should not* contain sensitive information, it will
       *be sent to the initiating party. This field should only be set if accept is
       *false, the channel will be rejected if an error is set with accept=true
       *because the meaning of this response is ambiguous. Limited to 500
       *characters.
       * </pre>
       *
       * <code>string error = 3;</code>
       * @return The bytes for error.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getErrorBytes() {
        return instance.getErrorBytes();
      }
      /**
       * <pre>
       *An optional error to send the initiating party to indicate why the channel
       *was rejected. This field *should not* contain sensitive information, it will
       *be sent to the initiating party. This field should only be set if accept is
       *false, the channel will be rejected if an error is set with accept=true
       *because the meaning of this response is ambiguous. Limited to 500
       *characters.
       * </pre>
       *
       * <code>string error = 3;</code>
       * @param value The error to set.
       * @return This builder for chaining.
       */
      public Builder setError(
          java.lang.String value) {
        copyOnWrite();
        instance.setError(value);
        return this;
      }
      /**
       * <pre>
       *An optional error to send the initiating party to indicate why the channel
       *was rejected. This field *should not* contain sensitive information, it will
       *be sent to the initiating party. This field should only be set if accept is
       *false, the channel will be rejected if an error is set with accept=true
       *because the meaning of this response is ambiguous. Limited to 500
       *characters.
       * </pre>
       *
       * <code>string error = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearError() {
        copyOnWrite();
        instance.clearError();
        return this;
      }
      /**
       * <pre>
       *An optional error to send the initiating party to indicate why the channel
       *was rejected. This field *should not* contain sensitive information, it will
       *be sent to the initiating party. This field should only be set if accept is
       *false, the channel will be rejected if an error is set with accept=true
       *because the meaning of this response is ambiguous. Limited to 500
       *characters.
       * </pre>
       *
       * <code>string error = 3;</code>
       * @param value The bytes for error to set.
       * @return This builder for chaining.
       */
      public Builder setErrorBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setErrorBytes(value);
        return this;
      }

      /**
       * <pre>
       *The upfront shutdown address to use if the initiating peer supports option
       *upfront shutdown script (see ListPeers for the features supported). Note
       *that the channel open will fail if this value is set for a peer that does
       *not support this feature bit.
       * </pre>
       *
       * <code>string upfront_shutdown = 4;</code>
       * @return The upfrontShutdown.
       */
      @java.lang.Override
      public java.lang.String getUpfrontShutdown() {
        return instance.getUpfrontShutdown();
      }
      /**
       * <pre>
       *The upfront shutdown address to use if the initiating peer supports option
       *upfront shutdown script (see ListPeers for the features supported). Note
       *that the channel open will fail if this value is set for a peer that does
       *not support this feature bit.
       * </pre>
       *
       * <code>string upfront_shutdown = 4;</code>
       * @return The bytes for upfrontShutdown.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getUpfrontShutdownBytes() {
        return instance.getUpfrontShutdownBytes();
      }
      /**
       * <pre>
       *The upfront shutdown address to use if the initiating peer supports option
       *upfront shutdown script (see ListPeers for the features supported). Note
       *that the channel open will fail if this value is set for a peer that does
       *not support this feature bit.
       * </pre>
       *
       * <code>string upfront_shutdown = 4;</code>
       * @param value The upfrontShutdown to set.
       * @return This builder for chaining.
       */
      public Builder setUpfrontShutdown(
          java.lang.String value) {
        copyOnWrite();
        instance.setUpfrontShutdown(value);
        return this;
      }
      /**
       * <pre>
       *The upfront shutdown address to use if the initiating peer supports option
       *upfront shutdown script (see ListPeers for the features supported). Note
       *that the channel open will fail if this value is set for a peer that does
       *not support this feature bit.
       * </pre>
       *
       * <code>string upfront_shutdown = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearUpfrontShutdown() {
        copyOnWrite();
        instance.clearUpfrontShutdown();
        return this;
      }
      /**
       * <pre>
       *The upfront shutdown address to use if the initiating peer supports option
       *upfront shutdown script (see ListPeers for the features supported). Note
       *that the channel open will fail if this value is set for a peer that does
       *not support this feature bit.
       * </pre>
       *
       * <code>string upfront_shutdown = 4;</code>
       * @param value The bytes for upfrontShutdown to set.
       * @return This builder for chaining.
       */
      public Builder setUpfrontShutdownBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setUpfrontShutdownBytes(value);
        return this;
      }

      /**
       * <pre>
       *The csv delay (in blocks) that we require for the remote party.
       * </pre>
       *
       * <code>uint32 csv_delay = 5;</code>
       * @return The csvDelay.
       */
      @java.lang.Override
      public int getCsvDelay() {
        return instance.getCsvDelay();
      }
      /**
       * <pre>
       *The csv delay (in blocks) that we require for the remote party.
       * </pre>
       *
       * <code>uint32 csv_delay = 5;</code>
       * @param value The csvDelay to set.
       * @return This builder for chaining.
       */
      public Builder setCsvDelay(int value) {
        copyOnWrite();
        instance.setCsvDelay(value);
        return this;
      }
      /**
       * <pre>
       *The csv delay (in blocks) that we require for the remote party.
       * </pre>
       *
       * <code>uint32 csv_delay = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearCsvDelay() {
        copyOnWrite();
        instance.clearCsvDelay();
        return this;
      }

      /**
       * <pre>
       *The reserve amount in satoshis that we require the remote peer to adhere to.
       *We require that the remote peer always have some reserve amount allocated to
       *them so that there is always a disincentive to broadcast old state (if they
       *hold 0 sats on their side of the channel, there is nothing to lose).
       * </pre>
       *
       * <code>uint64 reserve_sat = 6;</code>
       * @return The reserveSat.
       */
      @java.lang.Override
      public long getReserveSat() {
        return instance.getReserveSat();
      }
      /**
       * <pre>
       *The reserve amount in satoshis that we require the remote peer to adhere to.
       *We require that the remote peer always have some reserve amount allocated to
       *them so that there is always a disincentive to broadcast old state (if they
       *hold 0 sats on their side of the channel, there is nothing to lose).
       * </pre>
       *
       * <code>uint64 reserve_sat = 6;</code>
       * @param value The reserveSat to set.
       * @return This builder for chaining.
       */
      public Builder setReserveSat(long value) {
        copyOnWrite();
        instance.setReserveSat(value);
        return this;
      }
      /**
       * <pre>
       *The reserve amount in satoshis that we require the remote peer to adhere to.
       *We require that the remote peer always have some reserve amount allocated to
       *them so that there is always a disincentive to broadcast old state (if they
       *hold 0 sats on their side of the channel, there is nothing to lose).
       * </pre>
       *
       * <code>uint64 reserve_sat = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearReserveSat() {
        copyOnWrite();
        instance.clearReserveSat();
        return this;
      }

      /**
       * <pre>
       *The maximum amount of funds in millisatoshis that we allow the remote peer
       *to have in outstanding htlcs.
       * </pre>
       *
       * <code>uint64 in_flight_max_msat = 7;</code>
       * @return The inFlightMaxMsat.
       */
      @java.lang.Override
      public long getInFlightMaxMsat() {
        return instance.getInFlightMaxMsat();
      }
      /**
       * <pre>
       *The maximum amount of funds in millisatoshis that we allow the remote peer
       *to have in outstanding htlcs.
       * </pre>
       *
       * <code>uint64 in_flight_max_msat = 7;</code>
       * @param value The inFlightMaxMsat to set.
       * @return This builder for chaining.
       */
      public Builder setInFlightMaxMsat(long value) {
        copyOnWrite();
        instance.setInFlightMaxMsat(value);
        return this;
      }
      /**
       * <pre>
       *The maximum amount of funds in millisatoshis that we allow the remote peer
       *to have in outstanding htlcs.
       * </pre>
       *
       * <code>uint64 in_flight_max_msat = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearInFlightMaxMsat() {
        copyOnWrite();
        instance.clearInFlightMaxMsat();
        return this;
      }

      /**
       * <pre>
       *The maximum number of htlcs that the remote peer can offer us.
       * </pre>
       *
       * <code>uint32 max_htlc_count = 8;</code>
       * @return The maxHtlcCount.
       */
      @java.lang.Override
      public int getMaxHtlcCount() {
        return instance.getMaxHtlcCount();
      }
      /**
       * <pre>
       *The maximum number of htlcs that the remote peer can offer us.
       * </pre>
       *
       * <code>uint32 max_htlc_count = 8;</code>
       * @param value The maxHtlcCount to set.
       * @return This builder for chaining.
       */
      public Builder setMaxHtlcCount(int value) {
        copyOnWrite();
        instance.setMaxHtlcCount(value);
        return this;
      }
      /**
       * <pre>
       *The maximum number of htlcs that the remote peer can offer us.
       * </pre>
       *
       * <code>uint32 max_htlc_count = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxHtlcCount() {
        copyOnWrite();
        instance.clearMaxHtlcCount();
        return this;
      }

      /**
       * <pre>
       *The minimum value in millisatoshis for incoming htlcs on the channel.
       * </pre>
       *
       * <code>uint64 min_htlc_in = 9;</code>
       * @return The minHtlcIn.
       */
      @java.lang.Override
      public long getMinHtlcIn() {
        return instance.getMinHtlcIn();
      }
      /**
       * <pre>
       *The minimum value in millisatoshis for incoming htlcs on the channel.
       * </pre>
       *
       * <code>uint64 min_htlc_in = 9;</code>
       * @param value The minHtlcIn to set.
       * @return This builder for chaining.
       */
      public Builder setMinHtlcIn(long value) {
        copyOnWrite();
        instance.setMinHtlcIn(value);
        return this;
      }
      /**
       * <pre>
       *The minimum value in millisatoshis for incoming htlcs on the channel.
       * </pre>
       *
       * <code>uint64 min_htlc_in = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinHtlcIn() {
        copyOnWrite();
        instance.clearMinHtlcIn();
        return this;
      }

      /**
       * <pre>
       *The number of confirmations we require before we consider the channel open.
       * </pre>
       *
       * <code>uint32 min_accept_depth = 10;</code>
       * @return The minAcceptDepth.
       */
      @java.lang.Override
      public int getMinAcceptDepth() {
        return instance.getMinAcceptDepth();
      }
      /**
       * <pre>
       *The number of confirmations we require before we consider the channel open.
       * </pre>
       *
       * <code>uint32 min_accept_depth = 10;</code>
       * @param value The minAcceptDepth to set.
       * @return This builder for chaining.
       */
      public Builder setMinAcceptDepth(int value) {
        copyOnWrite();
        instance.setMinAcceptDepth(value);
        return this;
      }
      /**
       * <pre>
       *The number of confirmations we require before we consider the channel open.
       * </pre>
       *
       * <code>uint32 min_accept_depth = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinAcceptDepth() {
        copyOnWrite();
        instance.clearMinAcceptDepth();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelAcceptResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelAcceptResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "accept_",
              "pendingChanId_",
              "error_",
              "upfrontShutdown_",
              "csvDelay_",
              "reserveSat_",
              "inFlightMaxMsat_",
              "maxHtlcCount_",
              "minHtlcIn_",
              "minAcceptDepth_",
            };
            java.lang.String info =
                "\u0000\n\u0000\u0000\u0001\n\n\u0000\u0000\u0000\u0001\u0007\u0002\n\u0003\u0208" +
                "\u0004\u0208\u0005\u000b\u0006\u0003\u0007\u0003\b\u000b\t\u0003\n\u000b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelAcceptResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelAcceptResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelAcceptResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelAcceptResponse)
    private static final co.anode.anodium.Rpc.ChannelAcceptResponse DEFAULT_INSTANCE;
    static {
      ChannelAcceptResponse defaultInstance = new ChannelAcceptResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelAcceptResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelAcceptResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelAcceptResponse> PARSER;

    public static com.google.protobuf.Parser<ChannelAcceptResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelPointOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelPoint)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *Txid of the funding transaction. When using REST, this field must be
     *encoded as base64.
     * </pre>
     *
     * <code>bytes funding_txid_bytes = 1;</code>
     * @return Whether the fundingTxidBytes field is set.
     */
    boolean hasFundingTxidBytes();
    /**
     * <pre>
     *Txid of the funding transaction. When using REST, this field must be
     *encoded as base64.
     * </pre>
     *
     * <code>bytes funding_txid_bytes = 1;</code>
     * @return The fundingTxidBytes.
     */
    com.google.protobuf.ByteString getFundingTxidBytes();

    /**
     * <pre>
     *Hex-encoded string representing the byte-reversed hash of the funding
     *transaction.
     * </pre>
     *
     * <code>string funding_txid_str = 2;</code>
     * @return Whether the fundingTxidStr field is set.
     */
    boolean hasFundingTxidStr();
    /**
     * <pre>
     *Hex-encoded string representing the byte-reversed hash of the funding
     *transaction.
     * </pre>
     *
     * <code>string funding_txid_str = 2;</code>
     * @return The fundingTxidStr.
     */
    java.lang.String getFundingTxidStr();
    /**
     * <pre>
     *Hex-encoded string representing the byte-reversed hash of the funding
     *transaction.
     * </pre>
     *
     * <code>string funding_txid_str = 2;</code>
     * @return The bytes for fundingTxidStr.
     */
    com.google.protobuf.ByteString
        getFundingTxidStrBytes();

    /**
     * <pre>
     * The index of the output of the funding transaction
     * </pre>
     *
     * <code>uint32 output_index = 3;</code>
     * @return The outputIndex.
     */
    int getOutputIndex();

    public co.anode.anodium.Rpc.ChannelPoint.FundingTxidCase getFundingTxidCase();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChannelPoint}
   */
  public  static final class ChannelPoint extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelPoint, ChannelPoint.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelPoint)
      ChannelPointOrBuilder {
    private ChannelPoint() {
    }
    private int fundingTxidCase_ = 0;
    private java.lang.Object fundingTxid_;
    public enum FundingTxidCase {
      FUNDING_TXID_BYTES(1),
      FUNDING_TXID_STR(2),
      FUNDINGTXID_NOT_SET(0);
      private final int value;
      private FundingTxidCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static FundingTxidCase valueOf(int value) {
        return forNumber(value);
      }

      public static FundingTxidCase forNumber(int value) {
        switch (value) {
          case 1: return FUNDING_TXID_BYTES;
          case 2: return FUNDING_TXID_STR;
          case 0: return FUNDINGTXID_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    @java.lang.Override
    public FundingTxidCase
    getFundingTxidCase() {
      return FundingTxidCase.forNumber(
          fundingTxidCase_);
    }

    private void clearFundingTxid() {
      fundingTxidCase_ = 0;
      fundingTxid_ = null;
    }

    public static final int FUNDING_TXID_BYTES_FIELD_NUMBER = 1;
    /**
     * <pre>
     *Txid of the funding transaction. When using REST, this field must be
     *encoded as base64.
     * </pre>
     *
     * <code>bytes funding_txid_bytes = 1;</code>
     * @return Whether the fundingTxidBytes field is set.
     */
    @java.lang.Override
    public boolean hasFundingTxidBytes() {
      return fundingTxidCase_ == 1;
    }
    /**
     * <pre>
     *Txid of the funding transaction. When using REST, this field must be
     *encoded as base64.
     * </pre>
     *
     * <code>bytes funding_txid_bytes = 1;</code>
     * @return The fundingTxidBytes.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getFundingTxidBytes() {
      if (fundingTxidCase_ == 1) {
        return (com.google.protobuf.ByteString) fundingTxid_;
      }
      return com.google.protobuf.ByteString.EMPTY;
    }
    /**
     * <pre>
     *Txid of the funding transaction. When using REST, this field must be
     *encoded as base64.
     * </pre>
     *
     * <code>bytes funding_txid_bytes = 1;</code>
     * @param value The fundingTxidBytes to set.
     */
    private void setFundingTxidBytes(com.google.protobuf.ByteString value) {
      value.getClass();
  fundingTxidCase_ = 1;
      fundingTxid_ = value;
    }
    /**
     * <pre>
     *Txid of the funding transaction. When using REST, this field must be
     *encoded as base64.
     * </pre>
     *
     * <code>bytes funding_txid_bytes = 1;</code>
     */
    private void clearFundingTxidBytes() {
      if (fundingTxidCase_ == 1) {
        fundingTxidCase_ = 0;
        fundingTxid_ = null;
      }
    }

    public static final int FUNDING_TXID_STR_FIELD_NUMBER = 2;
    /**
     * <pre>
     *Hex-encoded string representing the byte-reversed hash of the funding
     *transaction.
     * </pre>
     *
     * <code>string funding_txid_str = 2;</code>
     * @return Whether the fundingTxidStr field is set.
     */
    @java.lang.Override
    public boolean hasFundingTxidStr() {
      return fundingTxidCase_ == 2;
    }
    /**
     * <pre>
     *Hex-encoded string representing the byte-reversed hash of the funding
     *transaction.
     * </pre>
     *
     * <code>string funding_txid_str = 2;</code>
     * @return The fundingTxidStr.
     */
    @java.lang.Override
    public java.lang.String getFundingTxidStr() {
      java.lang.String ref = "";
      if (fundingTxidCase_ == 2) {
        ref = (java.lang.String) fundingTxid_;
      }
      return ref;
    }
    /**
     * <pre>
     *Hex-encoded string representing the byte-reversed hash of the funding
     *transaction.
     * </pre>
     *
     * <code>string funding_txid_str = 2;</code>
     * @return The bytes for fundingTxidStr.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFundingTxidStrBytes() {
      java.lang.String ref = "";
      if (fundingTxidCase_ == 2) {
        ref = (java.lang.String) fundingTxid_;
      }
      return com.google.protobuf.ByteString.copyFromUtf8(ref);
    }
    /**
     * <pre>
     *Hex-encoded string representing the byte-reversed hash of the funding
     *transaction.
     * </pre>
     *
     * <code>string funding_txid_str = 2;</code>
     * @param value The fundingTxidStr to set.
     */
    private void setFundingTxidStr(
        java.lang.String value) {
      value.getClass();
  fundingTxidCase_ = 2;
      fundingTxid_ = value;
    }
    /**
     * <pre>
     *Hex-encoded string representing the byte-reversed hash of the funding
     *transaction.
     * </pre>
     *
     * <code>string funding_txid_str = 2;</code>
     */
    private void clearFundingTxidStr() {
      if (fundingTxidCase_ == 2) {
        fundingTxidCase_ = 0;
        fundingTxid_ = null;
      }
    }
    /**
     * <pre>
     *Hex-encoded string representing the byte-reversed hash of the funding
     *transaction.
     * </pre>
     *
     * <code>string funding_txid_str = 2;</code>
     * @param value The bytes for fundingTxidStr to set.
     */
    private void setFundingTxidStrBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      fundingTxid_ = value.toStringUtf8();
      fundingTxidCase_ = 2;
    }

    public static final int OUTPUT_INDEX_FIELD_NUMBER = 3;
    private int outputIndex_;
    /**
     * <pre>
     * The index of the output of the funding transaction
     * </pre>
     *
     * <code>uint32 output_index = 3;</code>
     * @return The outputIndex.
     */
    @java.lang.Override
    public int getOutputIndex() {
      return outputIndex_;
    }
    /**
     * <pre>
     * The index of the output of the funding transaction
     * </pre>
     *
     * <code>uint32 output_index = 3;</code>
     * @param value The outputIndex to set.
     */
    private void setOutputIndex(int value) {
      
      outputIndex_ = value;
    }
    /**
     * <pre>
     * The index of the output of the funding transaction
     * </pre>
     *
     * <code>uint32 output_index = 3;</code>
     */
    private void clearOutputIndex() {
      
      outputIndex_ = 0;
    }

    public static co.anode.anodium.Rpc.ChannelPoint parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelPoint parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelPoint parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelPoint parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelPoint parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelPoint parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelPoint parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelPoint parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelPoint parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelPoint parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelPoint parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelPoint parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelPoint prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChannelPoint}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelPoint, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelPoint)
        co.anode.anodium.Rpc.ChannelPointOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelPoint.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }

      @java.lang.Override
      public FundingTxidCase
          getFundingTxidCase() {
        return instance.getFundingTxidCase();
      }

      public Builder clearFundingTxid() {
        copyOnWrite();
        instance.clearFundingTxid();
        return this;
      }


      /**
       * <pre>
       *Txid of the funding transaction. When using REST, this field must be
       *encoded as base64.
       * </pre>
       *
       * <code>bytes funding_txid_bytes = 1;</code>
       * @return Whether the fundingTxidBytes field is set.
       */
      @java.lang.Override
      public boolean hasFundingTxidBytes() {
        return instance.hasFundingTxidBytes();
      }
      /**
       * <pre>
       *Txid of the funding transaction. When using REST, this field must be
       *encoded as base64.
       * </pre>
       *
       * <code>bytes funding_txid_bytes = 1;</code>
       * @return The fundingTxidBytes.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getFundingTxidBytes() {
        return instance.getFundingTxidBytes();
      }
      /**
       * <pre>
       *Txid of the funding transaction. When using REST, this field must be
       *encoded as base64.
       * </pre>
       *
       * <code>bytes funding_txid_bytes = 1;</code>
       * @param value The fundingTxidBytes to set.
       * @return This builder for chaining.
       */
      public Builder setFundingTxidBytes(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setFundingTxidBytes(value);
        return this;
      }
      /**
       * <pre>
       *Txid of the funding transaction. When using REST, this field must be
       *encoded as base64.
       * </pre>
       *
       * <code>bytes funding_txid_bytes = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearFundingTxidBytes() {
        copyOnWrite();
        instance.clearFundingTxidBytes();
        return this;
      }

      /**
       * <pre>
       *Hex-encoded string representing the byte-reversed hash of the funding
       *transaction.
       * </pre>
       *
       * <code>string funding_txid_str = 2;</code>
       * @return Whether the fundingTxidStr field is set.
       */
      @java.lang.Override
      public boolean hasFundingTxidStr() {
        return instance.hasFundingTxidStr();
      }
      /**
       * <pre>
       *Hex-encoded string representing the byte-reversed hash of the funding
       *transaction.
       * </pre>
       *
       * <code>string funding_txid_str = 2;</code>
       * @return The fundingTxidStr.
       */
      @java.lang.Override
      public java.lang.String getFundingTxidStr() {
        return instance.getFundingTxidStr();
      }
      /**
       * <pre>
       *Hex-encoded string representing the byte-reversed hash of the funding
       *transaction.
       * </pre>
       *
       * <code>string funding_txid_str = 2;</code>
       * @return The bytes for fundingTxidStr.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getFundingTxidStrBytes() {
        return instance.getFundingTxidStrBytes();
      }
      /**
       * <pre>
       *Hex-encoded string representing the byte-reversed hash of the funding
       *transaction.
       * </pre>
       *
       * <code>string funding_txid_str = 2;</code>
       * @param value The fundingTxidStr to set.
       * @return This builder for chaining.
       */
      public Builder setFundingTxidStr(
          java.lang.String value) {
        copyOnWrite();
        instance.setFundingTxidStr(value);
        return this;
      }
      /**
       * <pre>
       *Hex-encoded string representing the byte-reversed hash of the funding
       *transaction.
       * </pre>
       *
       * <code>string funding_txid_str = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearFundingTxidStr() {
        copyOnWrite();
        instance.clearFundingTxidStr();
        return this;
      }
      /**
       * <pre>
       *Hex-encoded string representing the byte-reversed hash of the funding
       *transaction.
       * </pre>
       *
       * <code>string funding_txid_str = 2;</code>
       * @param value The bytes for fundingTxidStr to set.
       * @return This builder for chaining.
       */
      public Builder setFundingTxidStrBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setFundingTxidStrBytes(value);
        return this;
      }

      /**
       * <pre>
       * The index of the output of the funding transaction
       * </pre>
       *
       * <code>uint32 output_index = 3;</code>
       * @return The outputIndex.
       */
      @java.lang.Override
      public int getOutputIndex() {
        return instance.getOutputIndex();
      }
      /**
       * <pre>
       * The index of the output of the funding transaction
       * </pre>
       *
       * <code>uint32 output_index = 3;</code>
       * @param value The outputIndex to set.
       * @return This builder for chaining.
       */
      public Builder setOutputIndex(int value) {
        copyOnWrite();
        instance.setOutputIndex(value);
        return this;
      }
      /**
       * <pre>
       * The index of the output of the funding transaction
       * </pre>
       *
       * <code>uint32 output_index = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearOutputIndex() {
        copyOnWrite();
        instance.clearOutputIndex();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelPoint)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelPoint();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "fundingTxid_",
              "fundingTxidCase_",
              "outputIndex_",
            };
            java.lang.String info =
                "\u0000\u0003\u0001\u0000\u0001\u0003\u0003\u0000\u0000\u0000\u0001=\u0000\u0002\u023b" +
                "\u0000\u0003\u000b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelPoint> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelPoint.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelPoint>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelPoint)
    private static final co.anode.anodium.Rpc.ChannelPoint DEFAULT_INSTANCE;
    static {
      ChannelPoint defaultInstance = new ChannelPoint();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelPoint.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelPoint getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelPoint> PARSER;

    public static com.google.protobuf.Parser<ChannelPoint> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface OutPointOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.OutPoint)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Raw bytes representing the transaction id.
     * </pre>
     *
     * <code>bytes txid_bytes = 1;</code>
     * @return The txidBytes.
     */
    com.google.protobuf.ByteString getTxidBytes();

    /**
     * <pre>
     * Reversed, hex-encoded string representing the transaction id.
     * </pre>
     *
     * <code>string txid_str = 2;</code>
     * @return The txidStr.
     */
    java.lang.String getTxidStr();
    /**
     * <pre>
     * Reversed, hex-encoded string representing the transaction id.
     * </pre>
     *
     * <code>string txid_str = 2;</code>
     * @return The bytes for txidStr.
     */
    com.google.protobuf.ByteString
        getTxidStrBytes();

    /**
     * <pre>
     * The index of the output on the transaction.
     * </pre>
     *
     * <code>uint32 output_index = 3;</code>
     * @return The outputIndex.
     */
    int getOutputIndex();
  }
  /**
   * Protobuf type {@code co.anode.anodium.OutPoint}
   */
  public  static final class OutPoint extends
      com.google.protobuf.GeneratedMessageLite<
          OutPoint, OutPoint.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.OutPoint)
      OutPointOrBuilder {
    private OutPoint() {
      txidBytes_ = com.google.protobuf.ByteString.EMPTY;
      txidStr_ = "";
    }
    public static final int TXID_BYTES_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString txidBytes_;
    /**
     * <pre>
     * Raw bytes representing the transaction id.
     * </pre>
     *
     * <code>bytes txid_bytes = 1;</code>
     * @return The txidBytes.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getTxidBytes() {
      return txidBytes_;
    }
    /**
     * <pre>
     * Raw bytes representing the transaction id.
     * </pre>
     *
     * <code>bytes txid_bytes = 1;</code>
     * @param value The txidBytes to set.
     */
    private void setTxidBytes(com.google.protobuf.ByteString value) {
      value.getClass();
  
      txidBytes_ = value;
    }
    /**
     * <pre>
     * Raw bytes representing the transaction id.
     * </pre>
     *
     * <code>bytes txid_bytes = 1;</code>
     */
    private void clearTxidBytes() {
      
      txidBytes_ = getDefaultInstance().getTxidBytes();
    }

    public static final int TXID_STR_FIELD_NUMBER = 2;
    private java.lang.String txidStr_;
    /**
     * <pre>
     * Reversed, hex-encoded string representing the transaction id.
     * </pre>
     *
     * <code>string txid_str = 2;</code>
     * @return The txidStr.
     */
    @java.lang.Override
    public java.lang.String getTxidStr() {
      return txidStr_;
    }
    /**
     * <pre>
     * Reversed, hex-encoded string representing the transaction id.
     * </pre>
     *
     * <code>string txid_str = 2;</code>
     * @return The bytes for txidStr.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTxidStrBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(txidStr_);
    }
    /**
     * <pre>
     * Reversed, hex-encoded string representing the transaction id.
     * </pre>
     *
     * <code>string txid_str = 2;</code>
     * @param value The txidStr to set.
     */
    private void setTxidStr(
        java.lang.String value) {
      value.getClass();
  
      txidStr_ = value;
    }
    /**
     * <pre>
     * Reversed, hex-encoded string representing the transaction id.
     * </pre>
     *
     * <code>string txid_str = 2;</code>
     */
    private void clearTxidStr() {
      
      txidStr_ = getDefaultInstance().getTxidStr();
    }
    /**
     * <pre>
     * Reversed, hex-encoded string representing the transaction id.
     * </pre>
     *
     * <code>string txid_str = 2;</code>
     * @param value The bytes for txidStr to set.
     */
    private void setTxidStrBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      txidStr_ = value.toStringUtf8();
      
    }

    public static final int OUTPUT_INDEX_FIELD_NUMBER = 3;
    private int outputIndex_;
    /**
     * <pre>
     * The index of the output on the transaction.
     * </pre>
     *
     * <code>uint32 output_index = 3;</code>
     * @return The outputIndex.
     */
    @java.lang.Override
    public int getOutputIndex() {
      return outputIndex_;
    }
    /**
     * <pre>
     * The index of the output on the transaction.
     * </pre>
     *
     * <code>uint32 output_index = 3;</code>
     * @param value The outputIndex to set.
     */
    private void setOutputIndex(int value) {
      
      outputIndex_ = value;
    }
    /**
     * <pre>
     * The index of the output on the transaction.
     * </pre>
     *
     * <code>uint32 output_index = 3;</code>
     */
    private void clearOutputIndex() {
      
      outputIndex_ = 0;
    }

    public static co.anode.anodium.Rpc.OutPoint parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.OutPoint parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.OutPoint parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.OutPoint parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.OutPoint parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.OutPoint parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.OutPoint parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.OutPoint parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.OutPoint parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.OutPoint parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.OutPoint parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.OutPoint parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.OutPoint prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.OutPoint}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.OutPoint, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.OutPoint)
        co.anode.anodium.Rpc.OutPointOrBuilder {
      // Construct using co.anode.anodium.Rpc.OutPoint.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Raw bytes representing the transaction id.
       * </pre>
       *
       * <code>bytes txid_bytes = 1;</code>
       * @return The txidBytes.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getTxidBytes() {
        return instance.getTxidBytes();
      }
      /**
       * <pre>
       * Raw bytes representing the transaction id.
       * </pre>
       *
       * <code>bytes txid_bytes = 1;</code>
       * @param value The txidBytes to set.
       * @return This builder for chaining.
       */
      public Builder setTxidBytes(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTxidBytes(value);
        return this;
      }
      /**
       * <pre>
       * Raw bytes representing the transaction id.
       * </pre>
       *
       * <code>bytes txid_bytes = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTxidBytes() {
        copyOnWrite();
        instance.clearTxidBytes();
        return this;
      }

      /**
       * <pre>
       * Reversed, hex-encoded string representing the transaction id.
       * </pre>
       *
       * <code>string txid_str = 2;</code>
       * @return The txidStr.
       */
      @java.lang.Override
      public java.lang.String getTxidStr() {
        return instance.getTxidStr();
      }
      /**
       * <pre>
       * Reversed, hex-encoded string representing the transaction id.
       * </pre>
       *
       * <code>string txid_str = 2;</code>
       * @return The bytes for txidStr.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getTxidStrBytes() {
        return instance.getTxidStrBytes();
      }
      /**
       * <pre>
       * Reversed, hex-encoded string representing the transaction id.
       * </pre>
       *
       * <code>string txid_str = 2;</code>
       * @param value The txidStr to set.
       * @return This builder for chaining.
       */
      public Builder setTxidStr(
          java.lang.String value) {
        copyOnWrite();
        instance.setTxidStr(value);
        return this;
      }
      /**
       * <pre>
       * Reversed, hex-encoded string representing the transaction id.
       * </pre>
       *
       * <code>string txid_str = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearTxidStr() {
        copyOnWrite();
        instance.clearTxidStr();
        return this;
      }
      /**
       * <pre>
       * Reversed, hex-encoded string representing the transaction id.
       * </pre>
       *
       * <code>string txid_str = 2;</code>
       * @param value The bytes for txidStr to set.
       * @return This builder for chaining.
       */
      public Builder setTxidStrBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTxidStrBytes(value);
        return this;
      }

      /**
       * <pre>
       * The index of the output on the transaction.
       * </pre>
       *
       * <code>uint32 output_index = 3;</code>
       * @return The outputIndex.
       */
      @java.lang.Override
      public int getOutputIndex() {
        return instance.getOutputIndex();
      }
      /**
       * <pre>
       * The index of the output on the transaction.
       * </pre>
       *
       * <code>uint32 output_index = 3;</code>
       * @param value The outputIndex to set.
       * @return This builder for chaining.
       */
      public Builder setOutputIndex(int value) {
        copyOnWrite();
        instance.setOutputIndex(value);
        return this;
      }
      /**
       * <pre>
       * The index of the output on the transaction.
       * </pre>
       *
       * <code>uint32 output_index = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearOutputIndex() {
        copyOnWrite();
        instance.clearOutputIndex();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.OutPoint)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.OutPoint();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "txidBytes_",
              "txidStr_",
              "outputIndex_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0003\u0003\u0000\u0000\u0000\u0001\n\u0002\u0208" +
                "\u0003\u000b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.OutPoint> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.OutPoint.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.OutPoint>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.OutPoint)
    private static final co.anode.anodium.Rpc.OutPoint DEFAULT_INSTANCE;
    static {
      OutPoint defaultInstance = new OutPoint();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        OutPoint.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.OutPoint getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<OutPoint> PARSER;

    public static com.google.protobuf.Parser<OutPoint> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface LightningAddressOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.LightningAddress)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The identity pubkey of the Lightning node
     * </pre>
     *
     * <code>string pubkey = 1;</code>
     * @return The pubkey.
     */
    java.lang.String getPubkey();
    /**
     * <pre>
     * The identity pubkey of the Lightning node
     * </pre>
     *
     * <code>string pubkey = 1;</code>
     * @return The bytes for pubkey.
     */
    com.google.protobuf.ByteString
        getPubkeyBytes();

    /**
     * <pre>
     * The network location of the lightning node, e.g. `69.69.69.69:1337` or
     * `localhost:10011`
     * </pre>
     *
     * <code>string host = 2;</code>
     * @return The host.
     */
    java.lang.String getHost();
    /**
     * <pre>
     * The network location of the lightning node, e.g. `69.69.69.69:1337` or
     * `localhost:10011`
     * </pre>
     *
     * <code>string host = 2;</code>
     * @return The bytes for host.
     */
    com.google.protobuf.ByteString
        getHostBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.LightningAddress}
   */
  public  static final class LightningAddress extends
      com.google.protobuf.GeneratedMessageLite<
          LightningAddress, LightningAddress.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.LightningAddress)
      LightningAddressOrBuilder {
    private LightningAddress() {
      pubkey_ = "";
      host_ = "";
    }
    public static final int PUBKEY_FIELD_NUMBER = 1;
    private java.lang.String pubkey_;
    /**
     * <pre>
     * The identity pubkey of the Lightning node
     * </pre>
     *
     * <code>string pubkey = 1;</code>
     * @return The pubkey.
     */
    @java.lang.Override
    public java.lang.String getPubkey() {
      return pubkey_;
    }
    /**
     * <pre>
     * The identity pubkey of the Lightning node
     * </pre>
     *
     * <code>string pubkey = 1;</code>
     * @return The bytes for pubkey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPubkeyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(pubkey_);
    }
    /**
     * <pre>
     * The identity pubkey of the Lightning node
     * </pre>
     *
     * <code>string pubkey = 1;</code>
     * @param value The pubkey to set.
     */
    private void setPubkey(
        java.lang.String value) {
      value.getClass();
  
      pubkey_ = value;
    }
    /**
     * <pre>
     * The identity pubkey of the Lightning node
     * </pre>
     *
     * <code>string pubkey = 1;</code>
     */
    private void clearPubkey() {
      
      pubkey_ = getDefaultInstance().getPubkey();
    }
    /**
     * <pre>
     * The identity pubkey of the Lightning node
     * </pre>
     *
     * <code>string pubkey = 1;</code>
     * @param value The bytes for pubkey to set.
     */
    private void setPubkeyBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      pubkey_ = value.toStringUtf8();
      
    }

    public static final int HOST_FIELD_NUMBER = 2;
    private java.lang.String host_;
    /**
     * <pre>
     * The network location of the lightning node, e.g. `69.69.69.69:1337` or
     * `localhost:10011`
     * </pre>
     *
     * <code>string host = 2;</code>
     * @return The host.
     */
    @java.lang.Override
    public java.lang.String getHost() {
      return host_;
    }
    /**
     * <pre>
     * The network location of the lightning node, e.g. `69.69.69.69:1337` or
     * `localhost:10011`
     * </pre>
     *
     * <code>string host = 2;</code>
     * @return The bytes for host.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getHostBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(host_);
    }
    /**
     * <pre>
     * The network location of the lightning node, e.g. `69.69.69.69:1337` or
     * `localhost:10011`
     * </pre>
     *
     * <code>string host = 2;</code>
     * @param value The host to set.
     */
    private void setHost(
        java.lang.String value) {
      value.getClass();
  
      host_ = value;
    }
    /**
     * <pre>
     * The network location of the lightning node, e.g. `69.69.69.69:1337` or
     * `localhost:10011`
     * </pre>
     *
     * <code>string host = 2;</code>
     */
    private void clearHost() {
      
      host_ = getDefaultInstance().getHost();
    }
    /**
     * <pre>
     * The network location of the lightning node, e.g. `69.69.69.69:1337` or
     * `localhost:10011`
     * </pre>
     *
     * <code>string host = 2;</code>
     * @param value The bytes for host to set.
     */
    private void setHostBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      host_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.LightningAddress parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.LightningAddress parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.LightningAddress parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.LightningAddress parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.LightningAddress parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.LightningAddress parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.LightningAddress parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.LightningAddress parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.LightningAddress parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.LightningAddress parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.LightningAddress parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.LightningAddress parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.LightningAddress prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.LightningAddress}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.LightningAddress, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.LightningAddress)
        co.anode.anodium.Rpc.LightningAddressOrBuilder {
      // Construct using co.anode.anodium.Rpc.LightningAddress.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The identity pubkey of the Lightning node
       * </pre>
       *
       * <code>string pubkey = 1;</code>
       * @return The pubkey.
       */
      @java.lang.Override
      public java.lang.String getPubkey() {
        return instance.getPubkey();
      }
      /**
       * <pre>
       * The identity pubkey of the Lightning node
       * </pre>
       *
       * <code>string pubkey = 1;</code>
       * @return The bytes for pubkey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPubkeyBytes() {
        return instance.getPubkeyBytes();
      }
      /**
       * <pre>
       * The identity pubkey of the Lightning node
       * </pre>
       *
       * <code>string pubkey = 1;</code>
       * @param value The pubkey to set.
       * @return This builder for chaining.
       */
      public Builder setPubkey(
          java.lang.String value) {
        copyOnWrite();
        instance.setPubkey(value);
        return this;
      }
      /**
       * <pre>
       * The identity pubkey of the Lightning node
       * </pre>
       *
       * <code>string pubkey = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPubkey() {
        copyOnWrite();
        instance.clearPubkey();
        return this;
      }
      /**
       * <pre>
       * The identity pubkey of the Lightning node
       * </pre>
       *
       * <code>string pubkey = 1;</code>
       * @param value The bytes for pubkey to set.
       * @return This builder for chaining.
       */
      public Builder setPubkeyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPubkeyBytes(value);
        return this;
      }

      /**
       * <pre>
       * The network location of the lightning node, e.g. `69.69.69.69:1337` or
       * `localhost:10011`
       * </pre>
       *
       * <code>string host = 2;</code>
       * @return The host.
       */
      @java.lang.Override
      public java.lang.String getHost() {
        return instance.getHost();
      }
      /**
       * <pre>
       * The network location of the lightning node, e.g. `69.69.69.69:1337` or
       * `localhost:10011`
       * </pre>
       *
       * <code>string host = 2;</code>
       * @return The bytes for host.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getHostBytes() {
        return instance.getHostBytes();
      }
      /**
       * <pre>
       * The network location of the lightning node, e.g. `69.69.69.69:1337` or
       * `localhost:10011`
       * </pre>
       *
       * <code>string host = 2;</code>
       * @param value The host to set.
       * @return This builder for chaining.
       */
      public Builder setHost(
          java.lang.String value) {
        copyOnWrite();
        instance.setHost(value);
        return this;
      }
      /**
       * <pre>
       * The network location of the lightning node, e.g. `69.69.69.69:1337` or
       * `localhost:10011`
       * </pre>
       *
       * <code>string host = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearHost() {
        copyOnWrite();
        instance.clearHost();
        return this;
      }
      /**
       * <pre>
       * The network location of the lightning node, e.g. `69.69.69.69:1337` or
       * `localhost:10011`
       * </pre>
       *
       * <code>string host = 2;</code>
       * @param value The bytes for host to set.
       * @return This builder for chaining.
       */
      public Builder setHostBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setHostBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.LightningAddress)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.LightningAddress();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "pubkey_",
              "host_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0208\u0002\u0208" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.LightningAddress> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.LightningAddress.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.LightningAddress>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.LightningAddress)
    private static final co.anode.anodium.Rpc.LightningAddress DEFAULT_INSTANCE;
    static {
      LightningAddress defaultInstance = new LightningAddress();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        LightningAddress.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.LightningAddress getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<LightningAddress> PARSER;

    public static com.google.protobuf.Parser<LightningAddress> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface EstimateFeeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.EstimateFeeRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The map from addresses to amounts for the transaction.
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */
    int getAddrToAmountCount();
    /**
     * <pre>
     * The map from addresses to amounts for the transaction.
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */
    boolean containsAddrToAmount(
        java.lang.String key);
    /**
     * Use {@link #getAddrToAmountMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.Long>
    getAddrToAmount();
    /**
     * <pre>
     * The map from addresses to amounts for the transaction.
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */
    java.util.Map<java.lang.String, java.lang.Long>
    getAddrToAmountMap();
    /**
     * <pre>
     * The map from addresses to amounts for the transaction.
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */

    long getAddrToAmountOrDefault(
        java.lang.String key,
        long defaultValue);
    /**
     * <pre>
     * The map from addresses to amounts for the transaction.
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */

    long getAddrToAmountOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * The target number of blocks that this transaction should be confirmed
     * by.
     * </pre>
     *
     * <code>int32 target_conf = 2;</code>
     * @return The targetConf.
     */
    int getTargetConf();
  }
  /**
   * Protobuf type {@code co.anode.anodium.EstimateFeeRequest}
   */
  public  static final class EstimateFeeRequest extends
      com.google.protobuf.GeneratedMessageLite<
          EstimateFeeRequest, EstimateFeeRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.EstimateFeeRequest)
      EstimateFeeRequestOrBuilder {
    private EstimateFeeRequest() {
    }
    public static final int ADDRTOAMOUNT_FIELD_NUMBER = 1;
    private static final class AddrToAmountDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Long> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Long>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.INT64,
                  0L);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Long> addrToAmount_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Long>
    internalGetAddrToAmount() {
      return addrToAmount_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Long>
    internalGetMutableAddrToAmount() {
      if (!addrToAmount_.isMutable()) {
        addrToAmount_ = addrToAmount_.mutableCopy();
      }
      return addrToAmount_;
    }
    @java.lang.Override

    public int getAddrToAmountCount() {
      return internalGetAddrToAmount().size();
    }
    /**
     * <pre>
     * The map from addresses to amounts for the transaction.
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */
    @java.lang.Override

    public boolean containsAddrToAmount(
        java.lang.String key) {
      key.getClass();
      return internalGetAddrToAmount().containsKey(key);
    }
    /**
     * Use {@link #getAddrToAmountMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Long> getAddrToAmount() {
      return getAddrToAmountMap();
    }
    /**
     * <pre>
     * The map from addresses to amounts for the transaction.
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.Long> getAddrToAmountMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetAddrToAmount());
    }
    /**
     * <pre>
     * The map from addresses to amounts for the transaction.
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */
    @java.lang.Override

    public long getAddrToAmountOrDefault(
        java.lang.String key,
        long defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Long> map =
          internalGetAddrToAmount();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * The map from addresses to amounts for the transaction.
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */
    @java.lang.Override

    public long getAddrToAmountOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Long> map =
          internalGetAddrToAmount();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * The map from addresses to amounts for the transaction.
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */
    private java.util.Map<java.lang.String, java.lang.Long>
    getMutableAddrToAmountMap() {
      return internalGetMutableAddrToAmount();
    }

    public static final int TARGET_CONF_FIELD_NUMBER = 2;
    private int targetConf_;
    /**
     * <pre>
     * The target number of blocks that this transaction should be confirmed
     * by.
     * </pre>
     *
     * <code>int32 target_conf = 2;</code>
     * @return The targetConf.
     */
    @java.lang.Override
    public int getTargetConf() {
      return targetConf_;
    }
    /**
     * <pre>
     * The target number of blocks that this transaction should be confirmed
     * by.
     * </pre>
     *
     * <code>int32 target_conf = 2;</code>
     * @param value The targetConf to set.
     */
    private void setTargetConf(int value) {
      
      targetConf_ = value;
    }
    /**
     * <pre>
     * The target number of blocks that this transaction should be confirmed
     * by.
     * </pre>
     *
     * <code>int32 target_conf = 2;</code>
     */
    private void clearTargetConf() {
      
      targetConf_ = 0;
    }

    public static co.anode.anodium.Rpc.EstimateFeeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.EstimateFeeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.EstimateFeeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.EstimateFeeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.EstimateFeeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.EstimateFeeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.EstimateFeeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.EstimateFeeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.EstimateFeeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.EstimateFeeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.EstimateFeeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.EstimateFeeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.EstimateFeeRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.EstimateFeeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.EstimateFeeRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.EstimateFeeRequest)
        co.anode.anodium.Rpc.EstimateFeeRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.EstimateFeeRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      @java.lang.Override

      public int getAddrToAmountCount() {
        return instance.getAddrToAmountMap().size();
      }
      /**
       * <pre>
       * The map from addresses to amounts for the transaction.
       * </pre>
       *
       * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
       */
      @java.lang.Override

      public boolean containsAddrToAmount(
          java.lang.String key) {
        key.getClass();
        return instance.getAddrToAmountMap().containsKey(key);
      }

      public Builder clearAddrToAmount() {
        copyOnWrite();
        instance.getMutableAddrToAmountMap().clear();
        return this;
      }
      /**
       * <pre>
       * The map from addresses to amounts for the transaction.
       * </pre>
       *
       * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
       */

      public Builder removeAddrToAmount(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableAddrToAmountMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getAddrToAmountMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Long> getAddrToAmount() {
        return getAddrToAmountMap();
      }
      /**
       * <pre>
       * The map from addresses to amounts for the transaction.
       * </pre>
       *
       * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.Long> getAddrToAmountMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getAddrToAmountMap());
      }
      /**
       * <pre>
       * The map from addresses to amounts for the transaction.
       * </pre>
       *
       * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
       */
      @java.lang.Override

      public long getAddrToAmountOrDefault(
          java.lang.String key,
          long defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Long> map =
            instance.getAddrToAmountMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * The map from addresses to amounts for the transaction.
       * </pre>
       *
       * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
       */
      @java.lang.Override

      public long getAddrToAmountOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Long> map =
            instance.getAddrToAmountMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * The map from addresses to amounts for the transaction.
       * </pre>
       *
       * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
       */
      public Builder putAddrToAmount(
          java.lang.String key,
          long value) {
        key.getClass();
        
        copyOnWrite();
        instance.getMutableAddrToAmountMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * The map from addresses to amounts for the transaction.
       * </pre>
       *
       * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
       */
      public Builder putAllAddrToAmount(
          java.util.Map<java.lang.String, java.lang.Long> values) {
        copyOnWrite();
        instance.getMutableAddrToAmountMap().putAll(values);
        return this;
      }

      /**
       * <pre>
       * The target number of blocks that this transaction should be confirmed
       * by.
       * </pre>
       *
       * <code>int32 target_conf = 2;</code>
       * @return The targetConf.
       */
      @java.lang.Override
      public int getTargetConf() {
        return instance.getTargetConf();
      }
      /**
       * <pre>
       * The target number of blocks that this transaction should be confirmed
       * by.
       * </pre>
       *
       * <code>int32 target_conf = 2;</code>
       * @param value The targetConf to set.
       * @return This builder for chaining.
       */
      public Builder setTargetConf(int value) {
        copyOnWrite();
        instance.setTargetConf(value);
        return this;
      }
      /**
       * <pre>
       * The target number of blocks that this transaction should be confirmed
       * by.
       * </pre>
       *
       * <code>int32 target_conf = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearTargetConf() {
        copyOnWrite();
        instance.clearTargetConf();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.EstimateFeeRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.EstimateFeeRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "addrToAmount_",
              AddrToAmountDefaultEntryHolder.defaultEntry,
              "targetConf_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0001\u0000\u0000\u00012\u0002\u0004";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.EstimateFeeRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.EstimateFeeRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.EstimateFeeRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.EstimateFeeRequest)
    private static final co.anode.anodium.Rpc.EstimateFeeRequest DEFAULT_INSTANCE;
    static {
      EstimateFeeRequest defaultInstance = new EstimateFeeRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        EstimateFeeRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.EstimateFeeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<EstimateFeeRequest> PARSER;

    public static com.google.protobuf.Parser<EstimateFeeRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface EstimateFeeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.EstimateFeeResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The total fee in satoshis.
     * </pre>
     *
     * <code>int64 fee_sat = 1;</code>
     * @return The feeSat.
     */
    long getFeeSat();

    /**
     * <pre>
     * The fee rate in satoshi/byte.
     * </pre>
     *
     * <code>int64 feerate_sat_per_byte = 2;</code>
     * @return The feerateSatPerByte.
     */
    long getFeerateSatPerByte();
  }
  /**
   * Protobuf type {@code co.anode.anodium.EstimateFeeResponse}
   */
  public  static final class EstimateFeeResponse extends
      com.google.protobuf.GeneratedMessageLite<
          EstimateFeeResponse, EstimateFeeResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.EstimateFeeResponse)
      EstimateFeeResponseOrBuilder {
    private EstimateFeeResponse() {
    }
    public static final int FEE_SAT_FIELD_NUMBER = 1;
    private long feeSat_;
    /**
     * <pre>
     * The total fee in satoshis.
     * </pre>
     *
     * <code>int64 fee_sat = 1;</code>
     * @return The feeSat.
     */
    @java.lang.Override
    public long getFeeSat() {
      return feeSat_;
    }
    /**
     * <pre>
     * The total fee in satoshis.
     * </pre>
     *
     * <code>int64 fee_sat = 1;</code>
     * @param value The feeSat to set.
     */
    private void setFeeSat(long value) {
      
      feeSat_ = value;
    }
    /**
     * <pre>
     * The total fee in satoshis.
     * </pre>
     *
     * <code>int64 fee_sat = 1;</code>
     */
    private void clearFeeSat() {
      
      feeSat_ = 0L;
    }

    public static final int FEERATE_SAT_PER_BYTE_FIELD_NUMBER = 2;
    private long feerateSatPerByte_;
    /**
     * <pre>
     * The fee rate in satoshi/byte.
     * </pre>
     *
     * <code>int64 feerate_sat_per_byte = 2;</code>
     * @return The feerateSatPerByte.
     */
    @java.lang.Override
    public long getFeerateSatPerByte() {
      return feerateSatPerByte_;
    }
    /**
     * <pre>
     * The fee rate in satoshi/byte.
     * </pre>
     *
     * <code>int64 feerate_sat_per_byte = 2;</code>
     * @param value The feerateSatPerByte to set.
     */
    private void setFeerateSatPerByte(long value) {
      
      feerateSatPerByte_ = value;
    }
    /**
     * <pre>
     * The fee rate in satoshi/byte.
     * </pre>
     *
     * <code>int64 feerate_sat_per_byte = 2;</code>
     */
    private void clearFeerateSatPerByte() {
      
      feerateSatPerByte_ = 0L;
    }

    public static co.anode.anodium.Rpc.EstimateFeeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.EstimateFeeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.EstimateFeeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.EstimateFeeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.EstimateFeeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.EstimateFeeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.EstimateFeeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.EstimateFeeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.EstimateFeeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.EstimateFeeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.EstimateFeeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.EstimateFeeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.EstimateFeeResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.EstimateFeeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.EstimateFeeResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.EstimateFeeResponse)
        co.anode.anodium.Rpc.EstimateFeeResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.EstimateFeeResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The total fee in satoshis.
       * </pre>
       *
       * <code>int64 fee_sat = 1;</code>
       * @return The feeSat.
       */
      @java.lang.Override
      public long getFeeSat() {
        return instance.getFeeSat();
      }
      /**
       * <pre>
       * The total fee in satoshis.
       * </pre>
       *
       * <code>int64 fee_sat = 1;</code>
       * @param value The feeSat to set.
       * @return This builder for chaining.
       */
      public Builder setFeeSat(long value) {
        copyOnWrite();
        instance.setFeeSat(value);
        return this;
      }
      /**
       * <pre>
       * The total fee in satoshis.
       * </pre>
       *
       * <code>int64 fee_sat = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearFeeSat() {
        copyOnWrite();
        instance.clearFeeSat();
        return this;
      }

      /**
       * <pre>
       * The fee rate in satoshi/byte.
       * </pre>
       *
       * <code>int64 feerate_sat_per_byte = 2;</code>
       * @return The feerateSatPerByte.
       */
      @java.lang.Override
      public long getFeerateSatPerByte() {
        return instance.getFeerateSatPerByte();
      }
      /**
       * <pre>
       * The fee rate in satoshi/byte.
       * </pre>
       *
       * <code>int64 feerate_sat_per_byte = 2;</code>
       * @param value The feerateSatPerByte to set.
       * @return This builder for chaining.
       */
      public Builder setFeerateSatPerByte(long value) {
        copyOnWrite();
        instance.setFeerateSatPerByte(value);
        return this;
      }
      /**
       * <pre>
       * The fee rate in satoshi/byte.
       * </pre>
       *
       * <code>int64 feerate_sat_per_byte = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearFeerateSatPerByte() {
        copyOnWrite();
        instance.clearFeerateSatPerByte();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.EstimateFeeResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.EstimateFeeResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "feeSat_",
              "feerateSatPerByte_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0002\u0002\u0002" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.EstimateFeeResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.EstimateFeeResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.EstimateFeeResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.EstimateFeeResponse)
    private static final co.anode.anodium.Rpc.EstimateFeeResponse DEFAULT_INSTANCE;
    static {
      EstimateFeeResponse defaultInstance = new EstimateFeeResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        EstimateFeeResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.EstimateFeeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<EstimateFeeResponse> PARSER;

    public static com.google.protobuf.Parser<EstimateFeeResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SendManyRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.SendManyRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The map from addresses to amounts
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */
    int getAddrToAmountCount();
    /**
     * <pre>
     * The map from addresses to amounts
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */
    boolean containsAddrToAmount(
        java.lang.String key);
    /**
     * Use {@link #getAddrToAmountMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.Long>
    getAddrToAmount();
    /**
     * <pre>
     * The map from addresses to amounts
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */
    java.util.Map<java.lang.String, java.lang.Long>
    getAddrToAmountMap();
    /**
     * <pre>
     * The map from addresses to amounts
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */

    long getAddrToAmountOrDefault(
        java.lang.String key,
        long defaultValue);
    /**
     * <pre>
     * The map from addresses to amounts
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */

    long getAddrToAmountOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * The target number of blocks that this transaction should be confirmed
     * by.
     * </pre>
     *
     * <code>int32 target_conf = 3;</code>
     * @return The targetConf.
     */
    int getTargetConf();

    /**
     * <pre>
     * A manual fee rate set in sat/byte that should be used when crafting the
     * transaction.
     * </pre>
     *
     * <code>int64 sat_per_byte = 5;</code>
     * @return The satPerByte.
     */
    long getSatPerByte();

    /**
     * <pre>
     * An optional label for the transaction, limited to 500 characters.
     * </pre>
     *
     * <code>string label = 6;</code>
     * @return The label.
     */
    java.lang.String getLabel();
    /**
     * <pre>
     * An optional label for the transaction, limited to 500 characters.
     * </pre>
     *
     * <code>string label = 6;</code>
     * @return The bytes for label.
     */
    com.google.protobuf.ByteString
        getLabelBytes();

    /**
     * <pre>
     * The minimum number of confirmations each one of your outputs used for
     * the transaction must satisfy.
     * </pre>
     *
     * <code>int32 min_confs = 7;</code>
     * @return The minConfs.
     */
    int getMinConfs();

    /**
     * <pre>
     * Whether unconfirmed outputs should be used as inputs for the transaction.
     * </pre>
     *
     * <code>bool spend_unconfirmed = 8;</code>
     * @return The spendUnconfirmed.
     */
    boolean getSpendUnconfirmed();
  }
  /**
   * Protobuf type {@code co.anode.anodium.SendManyRequest}
   */
  public  static final class SendManyRequest extends
      com.google.protobuf.GeneratedMessageLite<
          SendManyRequest, SendManyRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.SendManyRequest)
      SendManyRequestOrBuilder {
    private SendManyRequest() {
      label_ = "";
    }
    public static final int ADDRTOAMOUNT_FIELD_NUMBER = 1;
    private static final class AddrToAmountDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Long> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Long>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.INT64,
                  0L);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Long> addrToAmount_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Long>
    internalGetAddrToAmount() {
      return addrToAmount_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Long>
    internalGetMutableAddrToAmount() {
      if (!addrToAmount_.isMutable()) {
        addrToAmount_ = addrToAmount_.mutableCopy();
      }
      return addrToAmount_;
    }
    @java.lang.Override

    public int getAddrToAmountCount() {
      return internalGetAddrToAmount().size();
    }
    /**
     * <pre>
     * The map from addresses to amounts
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */
    @java.lang.Override

    public boolean containsAddrToAmount(
        java.lang.String key) {
      key.getClass();
      return internalGetAddrToAmount().containsKey(key);
    }
    /**
     * Use {@link #getAddrToAmountMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Long> getAddrToAmount() {
      return getAddrToAmountMap();
    }
    /**
     * <pre>
     * The map from addresses to amounts
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.Long> getAddrToAmountMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetAddrToAmount());
    }
    /**
     * <pre>
     * The map from addresses to amounts
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */
    @java.lang.Override

    public long getAddrToAmountOrDefault(
        java.lang.String key,
        long defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Long> map =
          internalGetAddrToAmount();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * The map from addresses to amounts
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */
    @java.lang.Override

    public long getAddrToAmountOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Long> map =
          internalGetAddrToAmount();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * The map from addresses to amounts
     * </pre>
     *
     * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
     */
    private java.util.Map<java.lang.String, java.lang.Long>
    getMutableAddrToAmountMap() {
      return internalGetMutableAddrToAmount();
    }

    public static final int TARGET_CONF_FIELD_NUMBER = 3;
    private int targetConf_;
    /**
     * <pre>
     * The target number of blocks that this transaction should be confirmed
     * by.
     * </pre>
     *
     * <code>int32 target_conf = 3;</code>
     * @return The targetConf.
     */
    @java.lang.Override
    public int getTargetConf() {
      return targetConf_;
    }
    /**
     * <pre>
     * The target number of blocks that this transaction should be confirmed
     * by.
     * </pre>
     *
     * <code>int32 target_conf = 3;</code>
     * @param value The targetConf to set.
     */
    private void setTargetConf(int value) {
      
      targetConf_ = value;
    }
    /**
     * <pre>
     * The target number of blocks that this transaction should be confirmed
     * by.
     * </pre>
     *
     * <code>int32 target_conf = 3;</code>
     */
    private void clearTargetConf() {
      
      targetConf_ = 0;
    }

    public static final int SAT_PER_BYTE_FIELD_NUMBER = 5;
    private long satPerByte_;
    /**
     * <pre>
     * A manual fee rate set in sat/byte that should be used when crafting the
     * transaction.
     * </pre>
     *
     * <code>int64 sat_per_byte = 5;</code>
     * @return The satPerByte.
     */
    @java.lang.Override
    public long getSatPerByte() {
      return satPerByte_;
    }
    /**
     * <pre>
     * A manual fee rate set in sat/byte that should be used when crafting the
     * transaction.
     * </pre>
     *
     * <code>int64 sat_per_byte = 5;</code>
     * @param value The satPerByte to set.
     */
    private void setSatPerByte(long value) {
      
      satPerByte_ = value;
    }
    /**
     * <pre>
     * A manual fee rate set in sat/byte that should be used when crafting the
     * transaction.
     * </pre>
     *
     * <code>int64 sat_per_byte = 5;</code>
     */
    private void clearSatPerByte() {
      
      satPerByte_ = 0L;
    }

    public static final int LABEL_FIELD_NUMBER = 6;
    private java.lang.String label_;
    /**
     * <pre>
     * An optional label for the transaction, limited to 500 characters.
     * </pre>
     *
     * <code>string label = 6;</code>
     * @return The label.
     */
    @java.lang.Override
    public java.lang.String getLabel() {
      return label_;
    }
    /**
     * <pre>
     * An optional label for the transaction, limited to 500 characters.
     * </pre>
     *
     * <code>string label = 6;</code>
     * @return The bytes for label.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLabelBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(label_);
    }
    /**
     * <pre>
     * An optional label for the transaction, limited to 500 characters.
     * </pre>
     *
     * <code>string label = 6;</code>
     * @param value The label to set.
     */
    private void setLabel(
        java.lang.String value) {
      value.getClass();
  
      label_ = value;
    }
    /**
     * <pre>
     * An optional label for the transaction, limited to 500 characters.
     * </pre>
     *
     * <code>string label = 6;</code>
     */
    private void clearLabel() {
      
      label_ = getDefaultInstance().getLabel();
    }
    /**
     * <pre>
     * An optional label for the transaction, limited to 500 characters.
     * </pre>
     *
     * <code>string label = 6;</code>
     * @param value The bytes for label to set.
     */
    private void setLabelBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      label_ = value.toStringUtf8();
      
    }

    public static final int MIN_CONFS_FIELD_NUMBER = 7;
    private int minConfs_;
    /**
     * <pre>
     * The minimum number of confirmations each one of your outputs used for
     * the transaction must satisfy.
     * </pre>
     *
     * <code>int32 min_confs = 7;</code>
     * @return The minConfs.
     */
    @java.lang.Override
    public int getMinConfs() {
      return minConfs_;
    }
    /**
     * <pre>
     * The minimum number of confirmations each one of your outputs used for
     * the transaction must satisfy.
     * </pre>
     *
     * <code>int32 min_confs = 7;</code>
     * @param value The minConfs to set.
     */
    private void setMinConfs(int value) {
      
      minConfs_ = value;
    }
    /**
     * <pre>
     * The minimum number of confirmations each one of your outputs used for
     * the transaction must satisfy.
     * </pre>
     *
     * <code>int32 min_confs = 7;</code>
     */
    private void clearMinConfs() {
      
      minConfs_ = 0;
    }

    public static final int SPEND_UNCONFIRMED_FIELD_NUMBER = 8;
    private boolean spendUnconfirmed_;
    /**
     * <pre>
     * Whether unconfirmed outputs should be used as inputs for the transaction.
     * </pre>
     *
     * <code>bool spend_unconfirmed = 8;</code>
     * @return The spendUnconfirmed.
     */
    @java.lang.Override
    public boolean getSpendUnconfirmed() {
      return spendUnconfirmed_;
    }
    /**
     * <pre>
     * Whether unconfirmed outputs should be used as inputs for the transaction.
     * </pre>
     *
     * <code>bool spend_unconfirmed = 8;</code>
     * @param value The spendUnconfirmed to set.
     */
    private void setSpendUnconfirmed(boolean value) {
      
      spendUnconfirmed_ = value;
    }
    /**
     * <pre>
     * Whether unconfirmed outputs should be used as inputs for the transaction.
     * </pre>
     *
     * <code>bool spend_unconfirmed = 8;</code>
     */
    private void clearSpendUnconfirmed() {
      
      spendUnconfirmed_ = false;
    }

    public static co.anode.anodium.Rpc.SendManyRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendManyRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendManyRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendManyRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendManyRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendManyRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendManyRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendManyRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendManyRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendManyRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendManyRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendManyRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.SendManyRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.SendManyRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.SendManyRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.SendManyRequest)
        co.anode.anodium.Rpc.SendManyRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.SendManyRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      @java.lang.Override

      public int getAddrToAmountCount() {
        return instance.getAddrToAmountMap().size();
      }
      /**
       * <pre>
       * The map from addresses to amounts
       * </pre>
       *
       * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
       */
      @java.lang.Override

      public boolean containsAddrToAmount(
          java.lang.String key) {
        key.getClass();
        return instance.getAddrToAmountMap().containsKey(key);
      }

      public Builder clearAddrToAmount() {
        copyOnWrite();
        instance.getMutableAddrToAmountMap().clear();
        return this;
      }
      /**
       * <pre>
       * The map from addresses to amounts
       * </pre>
       *
       * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
       */

      public Builder removeAddrToAmount(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableAddrToAmountMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getAddrToAmountMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Long> getAddrToAmount() {
        return getAddrToAmountMap();
      }
      /**
       * <pre>
       * The map from addresses to amounts
       * </pre>
       *
       * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.Long> getAddrToAmountMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getAddrToAmountMap());
      }
      /**
       * <pre>
       * The map from addresses to amounts
       * </pre>
       *
       * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
       */
      @java.lang.Override

      public long getAddrToAmountOrDefault(
          java.lang.String key,
          long defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Long> map =
            instance.getAddrToAmountMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * The map from addresses to amounts
       * </pre>
       *
       * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
       */
      @java.lang.Override

      public long getAddrToAmountOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Long> map =
            instance.getAddrToAmountMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * The map from addresses to amounts
       * </pre>
       *
       * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
       */
      public Builder putAddrToAmount(
          java.lang.String key,
          long value) {
        key.getClass();
        
        copyOnWrite();
        instance.getMutableAddrToAmountMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * The map from addresses to amounts
       * </pre>
       *
       * <code>map&lt;string, int64&gt; AddrToAmount = 1;</code>
       */
      public Builder putAllAddrToAmount(
          java.util.Map<java.lang.String, java.lang.Long> values) {
        copyOnWrite();
        instance.getMutableAddrToAmountMap().putAll(values);
        return this;
      }

      /**
       * <pre>
       * The target number of blocks that this transaction should be confirmed
       * by.
       * </pre>
       *
       * <code>int32 target_conf = 3;</code>
       * @return The targetConf.
       */
      @java.lang.Override
      public int getTargetConf() {
        return instance.getTargetConf();
      }
      /**
       * <pre>
       * The target number of blocks that this transaction should be confirmed
       * by.
       * </pre>
       *
       * <code>int32 target_conf = 3;</code>
       * @param value The targetConf to set.
       * @return This builder for chaining.
       */
      public Builder setTargetConf(int value) {
        copyOnWrite();
        instance.setTargetConf(value);
        return this;
      }
      /**
       * <pre>
       * The target number of blocks that this transaction should be confirmed
       * by.
       * </pre>
       *
       * <code>int32 target_conf = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearTargetConf() {
        copyOnWrite();
        instance.clearTargetConf();
        return this;
      }

      /**
       * <pre>
       * A manual fee rate set in sat/byte that should be used when crafting the
       * transaction.
       * </pre>
       *
       * <code>int64 sat_per_byte = 5;</code>
       * @return The satPerByte.
       */
      @java.lang.Override
      public long getSatPerByte() {
        return instance.getSatPerByte();
      }
      /**
       * <pre>
       * A manual fee rate set in sat/byte that should be used when crafting the
       * transaction.
       * </pre>
       *
       * <code>int64 sat_per_byte = 5;</code>
       * @param value The satPerByte to set.
       * @return This builder for chaining.
       */
      public Builder setSatPerByte(long value) {
        copyOnWrite();
        instance.setSatPerByte(value);
        return this;
      }
      /**
       * <pre>
       * A manual fee rate set in sat/byte that should be used when crafting the
       * transaction.
       * </pre>
       *
       * <code>int64 sat_per_byte = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearSatPerByte() {
        copyOnWrite();
        instance.clearSatPerByte();
        return this;
      }

      /**
       * <pre>
       * An optional label for the transaction, limited to 500 characters.
       * </pre>
       *
       * <code>string label = 6;</code>
       * @return The label.
       */
      @java.lang.Override
      public java.lang.String getLabel() {
        return instance.getLabel();
      }
      /**
       * <pre>
       * An optional label for the transaction, limited to 500 characters.
       * </pre>
       *
       * <code>string label = 6;</code>
       * @return The bytes for label.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getLabelBytes() {
        return instance.getLabelBytes();
      }
      /**
       * <pre>
       * An optional label for the transaction, limited to 500 characters.
       * </pre>
       *
       * <code>string label = 6;</code>
       * @param value The label to set.
       * @return This builder for chaining.
       */
      public Builder setLabel(
          java.lang.String value) {
        copyOnWrite();
        instance.setLabel(value);
        return this;
      }
      /**
       * <pre>
       * An optional label for the transaction, limited to 500 characters.
       * </pre>
       *
       * <code>string label = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearLabel() {
        copyOnWrite();
        instance.clearLabel();
        return this;
      }
      /**
       * <pre>
       * An optional label for the transaction, limited to 500 characters.
       * </pre>
       *
       * <code>string label = 6;</code>
       * @param value The bytes for label to set.
       * @return This builder for chaining.
       */
      public Builder setLabelBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLabelBytes(value);
        return this;
      }

      /**
       * <pre>
       * The minimum number of confirmations each one of your outputs used for
       * the transaction must satisfy.
       * </pre>
       *
       * <code>int32 min_confs = 7;</code>
       * @return The minConfs.
       */
      @java.lang.Override
      public int getMinConfs() {
        return instance.getMinConfs();
      }
      /**
       * <pre>
       * The minimum number of confirmations each one of your outputs used for
       * the transaction must satisfy.
       * </pre>
       *
       * <code>int32 min_confs = 7;</code>
       * @param value The minConfs to set.
       * @return This builder for chaining.
       */
      public Builder setMinConfs(int value) {
        copyOnWrite();
        instance.setMinConfs(value);
        return this;
      }
      /**
       * <pre>
       * The minimum number of confirmations each one of your outputs used for
       * the transaction must satisfy.
       * </pre>
       *
       * <code>int32 min_confs = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinConfs() {
        copyOnWrite();
        instance.clearMinConfs();
        return this;
      }

      /**
       * <pre>
       * Whether unconfirmed outputs should be used as inputs for the transaction.
       * </pre>
       *
       * <code>bool spend_unconfirmed = 8;</code>
       * @return The spendUnconfirmed.
       */
      @java.lang.Override
      public boolean getSpendUnconfirmed() {
        return instance.getSpendUnconfirmed();
      }
      /**
       * <pre>
       * Whether unconfirmed outputs should be used as inputs for the transaction.
       * </pre>
       *
       * <code>bool spend_unconfirmed = 8;</code>
       * @param value The spendUnconfirmed to set.
       * @return This builder for chaining.
       */
      public Builder setSpendUnconfirmed(boolean value) {
        copyOnWrite();
        instance.setSpendUnconfirmed(value);
        return this;
      }
      /**
       * <pre>
       * Whether unconfirmed outputs should be used as inputs for the transaction.
       * </pre>
       *
       * <code>bool spend_unconfirmed = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearSpendUnconfirmed() {
        copyOnWrite();
        instance.clearSpendUnconfirmed();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.SendManyRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.SendManyRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "addrToAmount_",
              AddrToAmountDefaultEntryHolder.defaultEntry,
              "targetConf_",
              "satPerByte_",
              "label_",
              "minConfs_",
              "spendUnconfirmed_",
            };
            java.lang.String info =
                "\u0000\u0006\u0000\u0000\u0001\b\u0006\u0001\u0000\u0000\u00012\u0003\u0004\u0005" +
                "\u0002\u0006\u0208\u0007\u0004\b\u0007";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.SendManyRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.SendManyRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.SendManyRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.SendManyRequest)
    private static final co.anode.anodium.Rpc.SendManyRequest DEFAULT_INSTANCE;
    static {
      SendManyRequest defaultInstance = new SendManyRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        SendManyRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.SendManyRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SendManyRequest> PARSER;

    public static com.google.protobuf.Parser<SendManyRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SendManyResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.SendManyResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The id of the transaction
     * </pre>
     *
     * <code>string txid = 1;</code>
     * @return The txid.
     */
    java.lang.String getTxid();
    /**
     * <pre>
     * The id of the transaction
     * </pre>
     *
     * <code>string txid = 1;</code>
     * @return The bytes for txid.
     */
    com.google.protobuf.ByteString
        getTxidBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.SendManyResponse}
   */
  public  static final class SendManyResponse extends
      com.google.protobuf.GeneratedMessageLite<
          SendManyResponse, SendManyResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.SendManyResponse)
      SendManyResponseOrBuilder {
    private SendManyResponse() {
      txid_ = "";
    }
    public static final int TXID_FIELD_NUMBER = 1;
    private java.lang.String txid_;
    /**
     * <pre>
     * The id of the transaction
     * </pre>
     *
     * <code>string txid = 1;</code>
     * @return The txid.
     */
    @java.lang.Override
    public java.lang.String getTxid() {
      return txid_;
    }
    /**
     * <pre>
     * The id of the transaction
     * </pre>
     *
     * <code>string txid = 1;</code>
     * @return The bytes for txid.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTxidBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(txid_);
    }
    /**
     * <pre>
     * The id of the transaction
     * </pre>
     *
     * <code>string txid = 1;</code>
     * @param value The txid to set.
     */
    private void setTxid(
        java.lang.String value) {
      value.getClass();
  
      txid_ = value;
    }
    /**
     * <pre>
     * The id of the transaction
     * </pre>
     *
     * <code>string txid = 1;</code>
     */
    private void clearTxid() {
      
      txid_ = getDefaultInstance().getTxid();
    }
    /**
     * <pre>
     * The id of the transaction
     * </pre>
     *
     * <code>string txid = 1;</code>
     * @param value The bytes for txid to set.
     */
    private void setTxidBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      txid_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.SendManyResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendManyResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendManyResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendManyResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendManyResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendManyResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendManyResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendManyResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendManyResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendManyResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendManyResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendManyResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.SendManyResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.SendManyResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.SendManyResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.SendManyResponse)
        co.anode.anodium.Rpc.SendManyResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.SendManyResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The id of the transaction
       * </pre>
       *
       * <code>string txid = 1;</code>
       * @return The txid.
       */
      @java.lang.Override
      public java.lang.String getTxid() {
        return instance.getTxid();
      }
      /**
       * <pre>
       * The id of the transaction
       * </pre>
       *
       * <code>string txid = 1;</code>
       * @return The bytes for txid.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getTxidBytes() {
        return instance.getTxidBytes();
      }
      /**
       * <pre>
       * The id of the transaction
       * </pre>
       *
       * <code>string txid = 1;</code>
       * @param value The txid to set.
       * @return This builder for chaining.
       */
      public Builder setTxid(
          java.lang.String value) {
        copyOnWrite();
        instance.setTxid(value);
        return this;
      }
      /**
       * <pre>
       * The id of the transaction
       * </pre>
       *
       * <code>string txid = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTxid() {
        copyOnWrite();
        instance.clearTxid();
        return this;
      }
      /**
       * <pre>
       * The id of the transaction
       * </pre>
       *
       * <code>string txid = 1;</code>
       * @param value The bytes for txid to set.
       * @return This builder for chaining.
       */
      public Builder setTxidBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTxidBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.SendManyResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.SendManyResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "txid_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u0208";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.SendManyResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.SendManyResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.SendManyResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.SendManyResponse)
    private static final co.anode.anodium.Rpc.SendManyResponse DEFAULT_INSTANCE;
    static {
      SendManyResponse defaultInstance = new SendManyResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        SendManyResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.SendManyResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SendManyResponse> PARSER;

    public static com.google.protobuf.Parser<SendManyResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SendCoinsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.SendCoinsRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The address to send coins to
     * </pre>
     *
     * <code>string addr = 1;</code>
     * @return The addr.
     */
    java.lang.String getAddr();
    /**
     * <pre>
     * The address to send coins to
     * </pre>
     *
     * <code>string addr = 1;</code>
     * @return The bytes for addr.
     */
    com.google.protobuf.ByteString
        getAddrBytes();

    /**
     * <pre>
     * The amount in satoshis to send
     * </pre>
     *
     * <code>int64 amount = 2;</code>
     * @return The amount.
     */
    long getAmount();

    /**
     * <pre>
     * The target number of blocks that this transaction should be confirmed
     * by.
     * </pre>
     *
     * <code>int32 target_conf = 3;</code>
     * @return The targetConf.
     */
    int getTargetConf();

    /**
     * <pre>
     * A manual fee rate set in sat/byte that should be used when crafting the
     * transaction.
     * </pre>
     *
     * <code>int64 sat_per_byte = 5;</code>
     * @return The satPerByte.
     */
    long getSatPerByte();

    /**
     * <pre>
     *If set, then the amount field will be ignored, and lnd will attempt to
     *send all the coins under control of the internal wallet to the specified
     *address.
     * </pre>
     *
     * <code>bool send_all = 6;</code>
     * @return The sendAll.
     */
    boolean getSendAll();

    /**
     * <pre>
     * An optional label for the transaction, limited to 500 characters.
     * </pre>
     *
     * <code>string label = 7;</code>
     * @return The label.
     */
    java.lang.String getLabel();
    /**
     * <pre>
     * An optional label for the transaction, limited to 500 characters.
     * </pre>
     *
     * <code>string label = 7;</code>
     * @return The bytes for label.
     */
    com.google.protobuf.ByteString
        getLabelBytes();

    /**
     * <pre>
     * The minimum number of confirmations each one of your outputs used for
     * the transaction must satisfy.
     * </pre>
     *
     * <code>int32 min_confs = 8;</code>
     * @return The minConfs.
     */
    int getMinConfs();

    /**
     * <pre>
     * Whether unconfirmed outputs should be used as inputs for the transaction.
     * </pre>
     *
     * <code>bool spend_unconfirmed = 9;</code>
     * @return The spendUnconfirmed.
     */
    boolean getSpendUnconfirmed();
  }
  /**
   * Protobuf type {@code co.anode.anodium.SendCoinsRequest}
   */
  public  static final class SendCoinsRequest extends
      com.google.protobuf.GeneratedMessageLite<
          SendCoinsRequest, SendCoinsRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.SendCoinsRequest)
      SendCoinsRequestOrBuilder {
    private SendCoinsRequest() {
      addr_ = "";
      label_ = "";
    }
    public static final int ADDR_FIELD_NUMBER = 1;
    private java.lang.String addr_;
    /**
     * <pre>
     * The address to send coins to
     * </pre>
     *
     * <code>string addr = 1;</code>
     * @return The addr.
     */
    @java.lang.Override
    public java.lang.String getAddr() {
      return addr_;
    }
    /**
     * <pre>
     * The address to send coins to
     * </pre>
     *
     * <code>string addr = 1;</code>
     * @return The bytes for addr.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAddrBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(addr_);
    }
    /**
     * <pre>
     * The address to send coins to
     * </pre>
     *
     * <code>string addr = 1;</code>
     * @param value The addr to set.
     */
    private void setAddr(
        java.lang.String value) {
      value.getClass();
  
      addr_ = value;
    }
    /**
     * <pre>
     * The address to send coins to
     * </pre>
     *
     * <code>string addr = 1;</code>
     */
    private void clearAddr() {
      
      addr_ = getDefaultInstance().getAddr();
    }
    /**
     * <pre>
     * The address to send coins to
     * </pre>
     *
     * <code>string addr = 1;</code>
     * @param value The bytes for addr to set.
     */
    private void setAddrBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      addr_ = value.toStringUtf8();
      
    }

    public static final int AMOUNT_FIELD_NUMBER = 2;
    private long amount_;
    /**
     * <pre>
     * The amount in satoshis to send
     * </pre>
     *
     * <code>int64 amount = 2;</code>
     * @return The amount.
     */
    @java.lang.Override
    public long getAmount() {
      return amount_;
    }
    /**
     * <pre>
     * The amount in satoshis to send
     * </pre>
     *
     * <code>int64 amount = 2;</code>
     * @param value The amount to set.
     */
    private void setAmount(long value) {
      
      amount_ = value;
    }
    /**
     * <pre>
     * The amount in satoshis to send
     * </pre>
     *
     * <code>int64 amount = 2;</code>
     */
    private void clearAmount() {
      
      amount_ = 0L;
    }

    public static final int TARGET_CONF_FIELD_NUMBER = 3;
    private int targetConf_;
    /**
     * <pre>
     * The target number of blocks that this transaction should be confirmed
     * by.
     * </pre>
     *
     * <code>int32 target_conf = 3;</code>
     * @return The targetConf.
     */
    @java.lang.Override
    public int getTargetConf() {
      return targetConf_;
    }
    /**
     * <pre>
     * The target number of blocks that this transaction should be confirmed
     * by.
     * </pre>
     *
     * <code>int32 target_conf = 3;</code>
     * @param value The targetConf to set.
     */
    private void setTargetConf(int value) {
      
      targetConf_ = value;
    }
    /**
     * <pre>
     * The target number of blocks that this transaction should be confirmed
     * by.
     * </pre>
     *
     * <code>int32 target_conf = 3;</code>
     */
    private void clearTargetConf() {
      
      targetConf_ = 0;
    }

    public static final int SAT_PER_BYTE_FIELD_NUMBER = 5;
    private long satPerByte_;
    /**
     * <pre>
     * A manual fee rate set in sat/byte that should be used when crafting the
     * transaction.
     * </pre>
     *
     * <code>int64 sat_per_byte = 5;</code>
     * @return The satPerByte.
     */
    @java.lang.Override
    public long getSatPerByte() {
      return satPerByte_;
    }
    /**
     * <pre>
     * A manual fee rate set in sat/byte that should be used when crafting the
     * transaction.
     * </pre>
     *
     * <code>int64 sat_per_byte = 5;</code>
     * @param value The satPerByte to set.
     */
    private void setSatPerByte(long value) {
      
      satPerByte_ = value;
    }
    /**
     * <pre>
     * A manual fee rate set in sat/byte that should be used when crafting the
     * transaction.
     * </pre>
     *
     * <code>int64 sat_per_byte = 5;</code>
     */
    private void clearSatPerByte() {
      
      satPerByte_ = 0L;
    }

    public static final int SEND_ALL_FIELD_NUMBER = 6;
    private boolean sendAll_;
    /**
     * <pre>
     *If set, then the amount field will be ignored, and lnd will attempt to
     *send all the coins under control of the internal wallet to the specified
     *address.
     * </pre>
     *
     * <code>bool send_all = 6;</code>
     * @return The sendAll.
     */
    @java.lang.Override
    public boolean getSendAll() {
      return sendAll_;
    }
    /**
     * <pre>
     *If set, then the amount field will be ignored, and lnd will attempt to
     *send all the coins under control of the internal wallet to the specified
     *address.
     * </pre>
     *
     * <code>bool send_all = 6;</code>
     * @param value The sendAll to set.
     */
    private void setSendAll(boolean value) {
      
      sendAll_ = value;
    }
    /**
     * <pre>
     *If set, then the amount field will be ignored, and lnd will attempt to
     *send all the coins under control of the internal wallet to the specified
     *address.
     * </pre>
     *
     * <code>bool send_all = 6;</code>
     */
    private void clearSendAll() {
      
      sendAll_ = false;
    }

    public static final int LABEL_FIELD_NUMBER = 7;
    private java.lang.String label_;
    /**
     * <pre>
     * An optional label for the transaction, limited to 500 characters.
     * </pre>
     *
     * <code>string label = 7;</code>
     * @return The label.
     */
    @java.lang.Override
    public java.lang.String getLabel() {
      return label_;
    }
    /**
     * <pre>
     * An optional label for the transaction, limited to 500 characters.
     * </pre>
     *
     * <code>string label = 7;</code>
     * @return The bytes for label.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLabelBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(label_);
    }
    /**
     * <pre>
     * An optional label for the transaction, limited to 500 characters.
     * </pre>
     *
     * <code>string label = 7;</code>
     * @param value The label to set.
     */
    private void setLabel(
        java.lang.String value) {
      value.getClass();
  
      label_ = value;
    }
    /**
     * <pre>
     * An optional label for the transaction, limited to 500 characters.
     * </pre>
     *
     * <code>string label = 7;</code>
     */
    private void clearLabel() {
      
      label_ = getDefaultInstance().getLabel();
    }
    /**
     * <pre>
     * An optional label for the transaction, limited to 500 characters.
     * </pre>
     *
     * <code>string label = 7;</code>
     * @param value The bytes for label to set.
     */
    private void setLabelBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      label_ = value.toStringUtf8();
      
    }

    public static final int MIN_CONFS_FIELD_NUMBER = 8;
    private int minConfs_;
    /**
     * <pre>
     * The minimum number of confirmations each one of your outputs used for
     * the transaction must satisfy.
     * </pre>
     *
     * <code>int32 min_confs = 8;</code>
     * @return The minConfs.
     */
    @java.lang.Override
    public int getMinConfs() {
      return minConfs_;
    }
    /**
     * <pre>
     * The minimum number of confirmations each one of your outputs used for
     * the transaction must satisfy.
     * </pre>
     *
     * <code>int32 min_confs = 8;</code>
     * @param value The minConfs to set.
     */
    private void setMinConfs(int value) {
      
      minConfs_ = value;
    }
    /**
     * <pre>
     * The minimum number of confirmations each one of your outputs used for
     * the transaction must satisfy.
     * </pre>
     *
     * <code>int32 min_confs = 8;</code>
     */
    private void clearMinConfs() {
      
      minConfs_ = 0;
    }

    public static final int SPEND_UNCONFIRMED_FIELD_NUMBER = 9;
    private boolean spendUnconfirmed_;
    /**
     * <pre>
     * Whether unconfirmed outputs should be used as inputs for the transaction.
     * </pre>
     *
     * <code>bool spend_unconfirmed = 9;</code>
     * @return The spendUnconfirmed.
     */
    @java.lang.Override
    public boolean getSpendUnconfirmed() {
      return spendUnconfirmed_;
    }
    /**
     * <pre>
     * Whether unconfirmed outputs should be used as inputs for the transaction.
     * </pre>
     *
     * <code>bool spend_unconfirmed = 9;</code>
     * @param value The spendUnconfirmed to set.
     */
    private void setSpendUnconfirmed(boolean value) {
      
      spendUnconfirmed_ = value;
    }
    /**
     * <pre>
     * Whether unconfirmed outputs should be used as inputs for the transaction.
     * </pre>
     *
     * <code>bool spend_unconfirmed = 9;</code>
     */
    private void clearSpendUnconfirmed() {
      
      spendUnconfirmed_ = false;
    }

    public static co.anode.anodium.Rpc.SendCoinsRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendCoinsRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendCoinsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendCoinsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendCoinsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendCoinsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendCoinsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendCoinsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendCoinsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendCoinsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendCoinsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendCoinsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.SendCoinsRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.SendCoinsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.SendCoinsRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.SendCoinsRequest)
        co.anode.anodium.Rpc.SendCoinsRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.SendCoinsRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The address to send coins to
       * </pre>
       *
       * <code>string addr = 1;</code>
       * @return The addr.
       */
      @java.lang.Override
      public java.lang.String getAddr() {
        return instance.getAddr();
      }
      /**
       * <pre>
       * The address to send coins to
       * </pre>
       *
       * <code>string addr = 1;</code>
       * @return The bytes for addr.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getAddrBytes() {
        return instance.getAddrBytes();
      }
      /**
       * <pre>
       * The address to send coins to
       * </pre>
       *
       * <code>string addr = 1;</code>
       * @param value The addr to set.
       * @return This builder for chaining.
       */
      public Builder setAddr(
          java.lang.String value) {
        copyOnWrite();
        instance.setAddr(value);
        return this;
      }
      /**
       * <pre>
       * The address to send coins to
       * </pre>
       *
       * <code>string addr = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAddr() {
        copyOnWrite();
        instance.clearAddr();
        return this;
      }
      /**
       * <pre>
       * The address to send coins to
       * </pre>
       *
       * <code>string addr = 1;</code>
       * @param value The bytes for addr to set.
       * @return This builder for chaining.
       */
      public Builder setAddrBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setAddrBytes(value);
        return this;
      }

      /**
       * <pre>
       * The amount in satoshis to send
       * </pre>
       *
       * <code>int64 amount = 2;</code>
       * @return The amount.
       */
      @java.lang.Override
      public long getAmount() {
        return instance.getAmount();
      }
      /**
       * <pre>
       * The amount in satoshis to send
       * </pre>
       *
       * <code>int64 amount = 2;</code>
       * @param value The amount to set.
       * @return This builder for chaining.
       */
      public Builder setAmount(long value) {
        copyOnWrite();
        instance.setAmount(value);
        return this;
      }
      /**
       * <pre>
       * The amount in satoshis to send
       * </pre>
       *
       * <code>int64 amount = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmount() {
        copyOnWrite();
        instance.clearAmount();
        return this;
      }

      /**
       * <pre>
       * The target number of blocks that this transaction should be confirmed
       * by.
       * </pre>
       *
       * <code>int32 target_conf = 3;</code>
       * @return The targetConf.
       */
      @java.lang.Override
      public int getTargetConf() {
        return instance.getTargetConf();
      }
      /**
       * <pre>
       * The target number of blocks that this transaction should be confirmed
       * by.
       * </pre>
       *
       * <code>int32 target_conf = 3;</code>
       * @param value The targetConf to set.
       * @return This builder for chaining.
       */
      public Builder setTargetConf(int value) {
        copyOnWrite();
        instance.setTargetConf(value);
        return this;
      }
      /**
       * <pre>
       * The target number of blocks that this transaction should be confirmed
       * by.
       * </pre>
       *
       * <code>int32 target_conf = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearTargetConf() {
        copyOnWrite();
        instance.clearTargetConf();
        return this;
      }

      /**
       * <pre>
       * A manual fee rate set in sat/byte that should be used when crafting the
       * transaction.
       * </pre>
       *
       * <code>int64 sat_per_byte = 5;</code>
       * @return The satPerByte.
       */
      @java.lang.Override
      public long getSatPerByte() {
        return instance.getSatPerByte();
      }
      /**
       * <pre>
       * A manual fee rate set in sat/byte that should be used when crafting the
       * transaction.
       * </pre>
       *
       * <code>int64 sat_per_byte = 5;</code>
       * @param value The satPerByte to set.
       * @return This builder for chaining.
       */
      public Builder setSatPerByte(long value) {
        copyOnWrite();
        instance.setSatPerByte(value);
        return this;
      }
      /**
       * <pre>
       * A manual fee rate set in sat/byte that should be used when crafting the
       * transaction.
       * </pre>
       *
       * <code>int64 sat_per_byte = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearSatPerByte() {
        copyOnWrite();
        instance.clearSatPerByte();
        return this;
      }

      /**
       * <pre>
       *If set, then the amount field will be ignored, and lnd will attempt to
       *send all the coins under control of the internal wallet to the specified
       *address.
       * </pre>
       *
       * <code>bool send_all = 6;</code>
       * @return The sendAll.
       */
      @java.lang.Override
      public boolean getSendAll() {
        return instance.getSendAll();
      }
      /**
       * <pre>
       *If set, then the amount field will be ignored, and lnd will attempt to
       *send all the coins under control of the internal wallet to the specified
       *address.
       * </pre>
       *
       * <code>bool send_all = 6;</code>
       * @param value The sendAll to set.
       * @return This builder for chaining.
       */
      public Builder setSendAll(boolean value) {
        copyOnWrite();
        instance.setSendAll(value);
        return this;
      }
      /**
       * <pre>
       *If set, then the amount field will be ignored, and lnd will attempt to
       *send all the coins under control of the internal wallet to the specified
       *address.
       * </pre>
       *
       * <code>bool send_all = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearSendAll() {
        copyOnWrite();
        instance.clearSendAll();
        return this;
      }

      /**
       * <pre>
       * An optional label for the transaction, limited to 500 characters.
       * </pre>
       *
       * <code>string label = 7;</code>
       * @return The label.
       */
      @java.lang.Override
      public java.lang.String getLabel() {
        return instance.getLabel();
      }
      /**
       * <pre>
       * An optional label for the transaction, limited to 500 characters.
       * </pre>
       *
       * <code>string label = 7;</code>
       * @return The bytes for label.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getLabelBytes() {
        return instance.getLabelBytes();
      }
      /**
       * <pre>
       * An optional label for the transaction, limited to 500 characters.
       * </pre>
       *
       * <code>string label = 7;</code>
       * @param value The label to set.
       * @return This builder for chaining.
       */
      public Builder setLabel(
          java.lang.String value) {
        copyOnWrite();
        instance.setLabel(value);
        return this;
      }
      /**
       * <pre>
       * An optional label for the transaction, limited to 500 characters.
       * </pre>
       *
       * <code>string label = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearLabel() {
        copyOnWrite();
        instance.clearLabel();
        return this;
      }
      /**
       * <pre>
       * An optional label for the transaction, limited to 500 characters.
       * </pre>
       *
       * <code>string label = 7;</code>
       * @param value The bytes for label to set.
       * @return This builder for chaining.
       */
      public Builder setLabelBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLabelBytes(value);
        return this;
      }

      /**
       * <pre>
       * The minimum number of confirmations each one of your outputs used for
       * the transaction must satisfy.
       * </pre>
       *
       * <code>int32 min_confs = 8;</code>
       * @return The minConfs.
       */
      @java.lang.Override
      public int getMinConfs() {
        return instance.getMinConfs();
      }
      /**
       * <pre>
       * The minimum number of confirmations each one of your outputs used for
       * the transaction must satisfy.
       * </pre>
       *
       * <code>int32 min_confs = 8;</code>
       * @param value The minConfs to set.
       * @return This builder for chaining.
       */
      public Builder setMinConfs(int value) {
        copyOnWrite();
        instance.setMinConfs(value);
        return this;
      }
      /**
       * <pre>
       * The minimum number of confirmations each one of your outputs used for
       * the transaction must satisfy.
       * </pre>
       *
       * <code>int32 min_confs = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinConfs() {
        copyOnWrite();
        instance.clearMinConfs();
        return this;
      }

      /**
       * <pre>
       * Whether unconfirmed outputs should be used as inputs for the transaction.
       * </pre>
       *
       * <code>bool spend_unconfirmed = 9;</code>
       * @return The spendUnconfirmed.
       */
      @java.lang.Override
      public boolean getSpendUnconfirmed() {
        return instance.getSpendUnconfirmed();
      }
      /**
       * <pre>
       * Whether unconfirmed outputs should be used as inputs for the transaction.
       * </pre>
       *
       * <code>bool spend_unconfirmed = 9;</code>
       * @param value The spendUnconfirmed to set.
       * @return This builder for chaining.
       */
      public Builder setSpendUnconfirmed(boolean value) {
        copyOnWrite();
        instance.setSpendUnconfirmed(value);
        return this;
      }
      /**
       * <pre>
       * Whether unconfirmed outputs should be used as inputs for the transaction.
       * </pre>
       *
       * <code>bool spend_unconfirmed = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearSpendUnconfirmed() {
        copyOnWrite();
        instance.clearSpendUnconfirmed();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.SendCoinsRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.SendCoinsRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "addr_",
              "amount_",
              "targetConf_",
              "satPerByte_",
              "sendAll_",
              "label_",
              "minConfs_",
              "spendUnconfirmed_",
            };
            java.lang.String info =
                "\u0000\b\u0000\u0000\u0001\t\b\u0000\u0000\u0000\u0001\u0208\u0002\u0002\u0003\u0004" +
                "\u0005\u0002\u0006\u0007\u0007\u0208\b\u0004\t\u0007";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.SendCoinsRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.SendCoinsRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.SendCoinsRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.SendCoinsRequest)
    private static final co.anode.anodium.Rpc.SendCoinsRequest DEFAULT_INSTANCE;
    static {
      SendCoinsRequest defaultInstance = new SendCoinsRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        SendCoinsRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.SendCoinsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SendCoinsRequest> PARSER;

    public static com.google.protobuf.Parser<SendCoinsRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SendCoinsResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.SendCoinsResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The transaction ID of the transaction
     * </pre>
     *
     * <code>string txid = 1;</code>
     * @return The txid.
     */
    java.lang.String getTxid();
    /**
     * <pre>
     * The transaction ID of the transaction
     * </pre>
     *
     * <code>string txid = 1;</code>
     * @return The bytes for txid.
     */
    com.google.protobuf.ByteString
        getTxidBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.SendCoinsResponse}
   */
  public  static final class SendCoinsResponse extends
      com.google.protobuf.GeneratedMessageLite<
          SendCoinsResponse, SendCoinsResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.SendCoinsResponse)
      SendCoinsResponseOrBuilder {
    private SendCoinsResponse() {
      txid_ = "";
    }
    public static final int TXID_FIELD_NUMBER = 1;
    private java.lang.String txid_;
    /**
     * <pre>
     * The transaction ID of the transaction
     * </pre>
     *
     * <code>string txid = 1;</code>
     * @return The txid.
     */
    @java.lang.Override
    public java.lang.String getTxid() {
      return txid_;
    }
    /**
     * <pre>
     * The transaction ID of the transaction
     * </pre>
     *
     * <code>string txid = 1;</code>
     * @return The bytes for txid.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTxidBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(txid_);
    }
    /**
     * <pre>
     * The transaction ID of the transaction
     * </pre>
     *
     * <code>string txid = 1;</code>
     * @param value The txid to set.
     */
    private void setTxid(
        java.lang.String value) {
      value.getClass();
  
      txid_ = value;
    }
    /**
     * <pre>
     * The transaction ID of the transaction
     * </pre>
     *
     * <code>string txid = 1;</code>
     */
    private void clearTxid() {
      
      txid_ = getDefaultInstance().getTxid();
    }
    /**
     * <pre>
     * The transaction ID of the transaction
     * </pre>
     *
     * <code>string txid = 1;</code>
     * @param value The bytes for txid to set.
     */
    private void setTxidBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      txid_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.SendCoinsResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendCoinsResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendCoinsResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendCoinsResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendCoinsResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SendCoinsResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendCoinsResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendCoinsResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendCoinsResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendCoinsResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SendCoinsResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SendCoinsResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.SendCoinsResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.SendCoinsResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.SendCoinsResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.SendCoinsResponse)
        co.anode.anodium.Rpc.SendCoinsResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.SendCoinsResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The transaction ID of the transaction
       * </pre>
       *
       * <code>string txid = 1;</code>
       * @return The txid.
       */
      @java.lang.Override
      public java.lang.String getTxid() {
        return instance.getTxid();
      }
      /**
       * <pre>
       * The transaction ID of the transaction
       * </pre>
       *
       * <code>string txid = 1;</code>
       * @return The bytes for txid.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getTxidBytes() {
        return instance.getTxidBytes();
      }
      /**
       * <pre>
       * The transaction ID of the transaction
       * </pre>
       *
       * <code>string txid = 1;</code>
       * @param value The txid to set.
       * @return This builder for chaining.
       */
      public Builder setTxid(
          java.lang.String value) {
        copyOnWrite();
        instance.setTxid(value);
        return this;
      }
      /**
       * <pre>
       * The transaction ID of the transaction
       * </pre>
       *
       * <code>string txid = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTxid() {
        copyOnWrite();
        instance.clearTxid();
        return this;
      }
      /**
       * <pre>
       * The transaction ID of the transaction
       * </pre>
       *
       * <code>string txid = 1;</code>
       * @param value The bytes for txid to set.
       * @return This builder for chaining.
       */
      public Builder setTxidBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTxidBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.SendCoinsResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.SendCoinsResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "txid_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u0208";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.SendCoinsResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.SendCoinsResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.SendCoinsResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.SendCoinsResponse)
    private static final co.anode.anodium.Rpc.SendCoinsResponse DEFAULT_INSTANCE;
    static {
      SendCoinsResponse defaultInstance = new SendCoinsResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        SendCoinsResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.SendCoinsResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SendCoinsResponse> PARSER;

    public static com.google.protobuf.Parser<SendCoinsResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ListUnspentRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ListUnspentRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The minimum number of confirmations to be included.
     * </pre>
     *
     * <code>int32 min_confs = 1;</code>
     * @return The minConfs.
     */
    int getMinConfs();

    /**
     * <pre>
     * The maximum number of confirmations to be included.
     * </pre>
     *
     * <code>int32 max_confs = 2;</code>
     * @return The maxConfs.
     */
    int getMaxConfs();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ListUnspentRequest}
   */
  public  static final class ListUnspentRequest extends
      com.google.protobuf.GeneratedMessageLite<
          ListUnspentRequest, ListUnspentRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ListUnspentRequest)
      ListUnspentRequestOrBuilder {
    private ListUnspentRequest() {
    }
    public static final int MIN_CONFS_FIELD_NUMBER = 1;
    private int minConfs_;
    /**
     * <pre>
     * The minimum number of confirmations to be included.
     * </pre>
     *
     * <code>int32 min_confs = 1;</code>
     * @return The minConfs.
     */
    @java.lang.Override
    public int getMinConfs() {
      return minConfs_;
    }
    /**
     * <pre>
     * The minimum number of confirmations to be included.
     * </pre>
     *
     * <code>int32 min_confs = 1;</code>
     * @param value The minConfs to set.
     */
    private void setMinConfs(int value) {
      
      minConfs_ = value;
    }
    /**
     * <pre>
     * The minimum number of confirmations to be included.
     * </pre>
     *
     * <code>int32 min_confs = 1;</code>
     */
    private void clearMinConfs() {
      
      minConfs_ = 0;
    }

    public static final int MAX_CONFS_FIELD_NUMBER = 2;
    private int maxConfs_;
    /**
     * <pre>
     * The maximum number of confirmations to be included.
     * </pre>
     *
     * <code>int32 max_confs = 2;</code>
     * @return The maxConfs.
     */
    @java.lang.Override
    public int getMaxConfs() {
      return maxConfs_;
    }
    /**
     * <pre>
     * The maximum number of confirmations to be included.
     * </pre>
     *
     * <code>int32 max_confs = 2;</code>
     * @param value The maxConfs to set.
     */
    private void setMaxConfs(int value) {
      
      maxConfs_ = value;
    }
    /**
     * <pre>
     * The maximum number of confirmations to be included.
     * </pre>
     *
     * <code>int32 max_confs = 2;</code>
     */
    private void clearMaxConfs() {
      
      maxConfs_ = 0;
    }

    public static co.anode.anodium.Rpc.ListUnspentRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListUnspentRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListUnspentRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListUnspentRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListUnspentRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListUnspentRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListUnspentRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListUnspentRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListUnspentRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListUnspentRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListUnspentRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListUnspentRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ListUnspentRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ListUnspentRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ListUnspentRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ListUnspentRequest)
        co.anode.anodium.Rpc.ListUnspentRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.ListUnspentRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The minimum number of confirmations to be included.
       * </pre>
       *
       * <code>int32 min_confs = 1;</code>
       * @return The minConfs.
       */
      @java.lang.Override
      public int getMinConfs() {
        return instance.getMinConfs();
      }
      /**
       * <pre>
       * The minimum number of confirmations to be included.
       * </pre>
       *
       * <code>int32 min_confs = 1;</code>
       * @param value The minConfs to set.
       * @return This builder for chaining.
       */
      public Builder setMinConfs(int value) {
        copyOnWrite();
        instance.setMinConfs(value);
        return this;
      }
      /**
       * <pre>
       * The minimum number of confirmations to be included.
       * </pre>
       *
       * <code>int32 min_confs = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinConfs() {
        copyOnWrite();
        instance.clearMinConfs();
        return this;
      }

      /**
       * <pre>
       * The maximum number of confirmations to be included.
       * </pre>
       *
       * <code>int32 max_confs = 2;</code>
       * @return The maxConfs.
       */
      @java.lang.Override
      public int getMaxConfs() {
        return instance.getMaxConfs();
      }
      /**
       * <pre>
       * The maximum number of confirmations to be included.
       * </pre>
       *
       * <code>int32 max_confs = 2;</code>
       * @param value The maxConfs to set.
       * @return This builder for chaining.
       */
      public Builder setMaxConfs(int value) {
        copyOnWrite();
        instance.setMaxConfs(value);
        return this;
      }
      /**
       * <pre>
       * The maximum number of confirmations to be included.
       * </pre>
       *
       * <code>int32 max_confs = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxConfs() {
        copyOnWrite();
        instance.clearMaxConfs();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ListUnspentRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ListUnspentRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "minConfs_",
              "maxConfs_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0004\u0002\u0004" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ListUnspentRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ListUnspentRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ListUnspentRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ListUnspentRequest)
    private static final co.anode.anodium.Rpc.ListUnspentRequest DEFAULT_INSTANCE;
    static {
      ListUnspentRequest defaultInstance = new ListUnspentRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ListUnspentRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ListUnspentRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ListUnspentRequest> PARSER;

    public static com.google.protobuf.Parser<ListUnspentRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ListUnspentResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ListUnspentResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * A list of utxos
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
     */
    java.util.List<co.anode.anodium.Rpc.Utxo> 
        getUtxosList();
    /**
     * <pre>
     * A list of utxos
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
     */
    co.anode.anodium.Rpc.Utxo getUtxos(int index);
    /**
     * <pre>
     * A list of utxos
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
     */
    int getUtxosCount();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ListUnspentResponse}
   */
  public  static final class ListUnspentResponse extends
      com.google.protobuf.GeneratedMessageLite<
          ListUnspentResponse, ListUnspentResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ListUnspentResponse)
      ListUnspentResponseOrBuilder {
    private ListUnspentResponse() {
      utxos_ = emptyProtobufList();
    }
    public static final int UTXOS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Utxo> utxos_;
    /**
     * <pre>
     * A list of utxos
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.Utxo> getUtxosList() {
      return utxos_;
    }
    /**
     * <pre>
     * A list of utxos
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.UtxoOrBuilder> 
        getUtxosOrBuilderList() {
      return utxos_;
    }
    /**
     * <pre>
     * A list of utxos
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
     */
    @java.lang.Override
    public int getUtxosCount() {
      return utxos_.size();
    }
    /**
     * <pre>
     * A list of utxos
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Utxo getUtxos(int index) {
      return utxos_.get(index);
    }
    /**
     * <pre>
     * A list of utxos
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
     */
    public co.anode.anodium.Rpc.UtxoOrBuilder getUtxosOrBuilder(
        int index) {
      return utxos_.get(index);
    }
    private void ensureUtxosIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Utxo> tmp = utxos_;
      if (!tmp.isModifiable()) {
        utxos_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * A list of utxos
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
     */
    private void setUtxos(
        int index, co.anode.anodium.Rpc.Utxo value) {
      value.getClass();
  ensureUtxosIsMutable();
      utxos_.set(index, value);
    }
    /**
     * <pre>
     * A list of utxos
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
     */
    private void addUtxos(co.anode.anodium.Rpc.Utxo value) {
      value.getClass();
  ensureUtxosIsMutable();
      utxos_.add(value);
    }
    /**
     * <pre>
     * A list of utxos
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
     */
    private void addUtxos(
        int index, co.anode.anodium.Rpc.Utxo value) {
      value.getClass();
  ensureUtxosIsMutable();
      utxos_.add(index, value);
    }
    /**
     * <pre>
     * A list of utxos
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
     */
    private void addAllUtxos(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.Utxo> values) {
      ensureUtxosIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, utxos_);
    }
    /**
     * <pre>
     * A list of utxos
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
     */
    private void clearUtxos() {
      utxos_ = emptyProtobufList();
    }
    /**
     * <pre>
     * A list of utxos
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
     */
    private void removeUtxos(int index) {
      ensureUtxosIsMutable();
      utxos_.remove(index);
    }

    public static co.anode.anodium.Rpc.ListUnspentResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListUnspentResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListUnspentResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListUnspentResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListUnspentResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListUnspentResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListUnspentResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListUnspentResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListUnspentResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListUnspentResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListUnspentResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListUnspentResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ListUnspentResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ListUnspentResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ListUnspentResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ListUnspentResponse)
        co.anode.anodium.Rpc.ListUnspentResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.ListUnspentResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * A list of utxos
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.Utxo> getUtxosList() {
        return java.util.Collections.unmodifiableList(
            instance.getUtxosList());
      }
      /**
       * <pre>
       * A list of utxos
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
       */
      @java.lang.Override
      public int getUtxosCount() {
        return instance.getUtxosCount();
      }/**
       * <pre>
       * A list of utxos
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Utxo getUtxos(int index) {
        return instance.getUtxos(index);
      }
      /**
       * <pre>
       * A list of utxos
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
       */
      public Builder setUtxos(
          int index, co.anode.anodium.Rpc.Utxo value) {
        copyOnWrite();
        instance.setUtxos(index, value);
        return this;
      }
      /**
       * <pre>
       * A list of utxos
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
       */
      public Builder setUtxos(
          int index, co.anode.anodium.Rpc.Utxo.Builder builderForValue) {
        copyOnWrite();
        instance.setUtxos(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A list of utxos
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
       */
      public Builder addUtxos(co.anode.anodium.Rpc.Utxo value) {
        copyOnWrite();
        instance.addUtxos(value);
        return this;
      }
      /**
       * <pre>
       * A list of utxos
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
       */
      public Builder addUtxos(
          int index, co.anode.anodium.Rpc.Utxo value) {
        copyOnWrite();
        instance.addUtxos(index, value);
        return this;
      }
      /**
       * <pre>
       * A list of utxos
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
       */
      public Builder addUtxos(
          co.anode.anodium.Rpc.Utxo.Builder builderForValue) {
        copyOnWrite();
        instance.addUtxos(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A list of utxos
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
       */
      public Builder addUtxos(
          int index, co.anode.anodium.Rpc.Utxo.Builder builderForValue) {
        copyOnWrite();
        instance.addUtxos(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A list of utxos
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
       */
      public Builder addAllUtxos(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.Utxo> values) {
        copyOnWrite();
        instance.addAllUtxos(values);
        return this;
      }
      /**
       * <pre>
       * A list of utxos
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
       */
      public Builder clearUtxos() {
        copyOnWrite();
        instance.clearUtxos();
        return this;
      }
      /**
       * <pre>
       * A list of utxos
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Utxo utxos = 1;</code>
       */
      public Builder removeUtxos(int index) {
        copyOnWrite();
        instance.removeUtxos(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ListUnspentResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ListUnspentResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "utxos_",
              co.anode.anodium.Rpc.Utxo.class,
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0000\u0001\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ListUnspentResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ListUnspentResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ListUnspentResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ListUnspentResponse)
    private static final co.anode.anodium.Rpc.ListUnspentResponse DEFAULT_INSTANCE;
    static {
      ListUnspentResponse defaultInstance = new ListUnspentResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ListUnspentResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ListUnspentResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ListUnspentResponse> PARSER;

    public static com.google.protobuf.Parser<ListUnspentResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface NewAddressRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.NewAddressRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The address type
     * </pre>
     *
     * <code>.co.anode.anodium.AddressType type = 1;</code>
     * @return The enum numeric value on the wire for type.
     */
    int getTypeValue();
    /**
     * <pre>
     * The address type
     * </pre>
     *
     * <code>.co.anode.anodium.AddressType type = 1;</code>
     * @return The type.
     */
    co.anode.anodium.Rpc.AddressType getType();
  }
  /**
   * Protobuf type {@code co.anode.anodium.NewAddressRequest}
   */
  public  static final class NewAddressRequest extends
      com.google.protobuf.GeneratedMessageLite<
          NewAddressRequest, NewAddressRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.NewAddressRequest)
      NewAddressRequestOrBuilder {
    private NewAddressRequest() {
    }
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_;
    /**
     * <pre>
     * The address type
     * </pre>
     *
     * <code>.co.anode.anodium.AddressType type = 1;</code>
     * @return The enum numeric value on the wire for type.
     */
    @java.lang.Override
    public int getTypeValue() {
      return type_;
    }
    /**
     * <pre>
     * The address type
     * </pre>
     *
     * <code>.co.anode.anodium.AddressType type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.AddressType getType() {
      co.anode.anodium.Rpc.AddressType result = co.anode.anodium.Rpc.AddressType.forNumber(type_);
      return result == null ? co.anode.anodium.Rpc.AddressType.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * The address type
     * </pre>
     *
     * <code>.co.anode.anodium.AddressType type = 1;</code>
     * @param value The enum numeric value on the wire for type to set.
     */
    private void setTypeValue(int value) {
        type_ = value;
    }
    /**
     * <pre>
     * The address type
     * </pre>
     *
     * <code>.co.anode.anodium.AddressType type = 1;</code>
     * @param value The type to set.
     */
    private void setType(co.anode.anodium.Rpc.AddressType value) {
      type_ = value.getNumber();
      
    }
    /**
     * <pre>
     * The address type
     * </pre>
     *
     * <code>.co.anode.anodium.AddressType type = 1;</code>
     */
    private void clearType() {
      
      type_ = 0;
    }

    public static co.anode.anodium.Rpc.NewAddressRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NewAddressRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NewAddressRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NewAddressRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NewAddressRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NewAddressRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NewAddressRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NewAddressRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NewAddressRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NewAddressRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NewAddressRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NewAddressRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.NewAddressRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.NewAddressRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.NewAddressRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.NewAddressRequest)
        co.anode.anodium.Rpc.NewAddressRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.NewAddressRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The address type
       * </pre>
       *
       * <code>.co.anode.anodium.AddressType type = 1;</code>
       * @return The enum numeric value on the wire for type.
       */
      @java.lang.Override
      public int getTypeValue() {
        return instance.getTypeValue();
      }
      /**
       * <pre>
       * The address type
       * </pre>
       *
       * <code>.co.anode.anodium.AddressType type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeValue(int value) {
        copyOnWrite();
        instance.setTypeValue(value);
        return this;
      }
      /**
       * <pre>
       * The address type
       * </pre>
       *
       * <code>.co.anode.anodium.AddressType type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.AddressType getType() {
        return instance.getType();
      }
      /**
       * <pre>
       * The address type
       * </pre>
       *
       * <code>.co.anode.anodium.AddressType type = 1;</code>
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setType(co.anode.anodium.Rpc.AddressType value) {
        copyOnWrite();
        instance.setType(value);
        return this;
      }
      /**
       * <pre>
       * The address type
       * </pre>
       *
       * <code>.co.anode.anodium.AddressType type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        copyOnWrite();
        instance.clearType();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.NewAddressRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.NewAddressRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "type_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\f";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.NewAddressRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.NewAddressRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.NewAddressRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.NewAddressRequest)
    private static final co.anode.anodium.Rpc.NewAddressRequest DEFAULT_INSTANCE;
    static {
      NewAddressRequest defaultInstance = new NewAddressRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        NewAddressRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.NewAddressRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<NewAddressRequest> PARSER;

    public static com.google.protobuf.Parser<NewAddressRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface NewAddressResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.NewAddressResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The newly generated wallet address
     * </pre>
     *
     * <code>string address = 1;</code>
     * @return The address.
     */
    java.lang.String getAddress();
    /**
     * <pre>
     * The newly generated wallet address
     * </pre>
     *
     * <code>string address = 1;</code>
     * @return The bytes for address.
     */
    com.google.protobuf.ByteString
        getAddressBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.NewAddressResponse}
   */
  public  static final class NewAddressResponse extends
      com.google.protobuf.GeneratedMessageLite<
          NewAddressResponse, NewAddressResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.NewAddressResponse)
      NewAddressResponseOrBuilder {
    private NewAddressResponse() {
      address_ = "";
    }
    public static final int ADDRESS_FIELD_NUMBER = 1;
    private java.lang.String address_;
    /**
     * <pre>
     * The newly generated wallet address
     * </pre>
     *
     * <code>string address = 1;</code>
     * @return The address.
     */
    @java.lang.Override
    public java.lang.String getAddress() {
      return address_;
    }
    /**
     * <pre>
     * The newly generated wallet address
     * </pre>
     *
     * <code>string address = 1;</code>
     * @return The bytes for address.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAddressBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(address_);
    }
    /**
     * <pre>
     * The newly generated wallet address
     * </pre>
     *
     * <code>string address = 1;</code>
     * @param value The address to set.
     */
    private void setAddress(
        java.lang.String value) {
      value.getClass();
  
      address_ = value;
    }
    /**
     * <pre>
     * The newly generated wallet address
     * </pre>
     *
     * <code>string address = 1;</code>
     */
    private void clearAddress() {
      
      address_ = getDefaultInstance().getAddress();
    }
    /**
     * <pre>
     * The newly generated wallet address
     * </pre>
     *
     * <code>string address = 1;</code>
     * @param value The bytes for address to set.
     */
    private void setAddressBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      address_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.NewAddressResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NewAddressResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NewAddressResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NewAddressResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NewAddressResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NewAddressResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NewAddressResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NewAddressResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NewAddressResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NewAddressResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NewAddressResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NewAddressResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.NewAddressResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.NewAddressResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.NewAddressResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.NewAddressResponse)
        co.anode.anodium.Rpc.NewAddressResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.NewAddressResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The newly generated wallet address
       * </pre>
       *
       * <code>string address = 1;</code>
       * @return The address.
       */
      @java.lang.Override
      public java.lang.String getAddress() {
        return instance.getAddress();
      }
      /**
       * <pre>
       * The newly generated wallet address
       * </pre>
       *
       * <code>string address = 1;</code>
       * @return The bytes for address.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getAddressBytes() {
        return instance.getAddressBytes();
      }
      /**
       * <pre>
       * The newly generated wallet address
       * </pre>
       *
       * <code>string address = 1;</code>
       * @param value The address to set.
       * @return This builder for chaining.
       */
      public Builder setAddress(
          java.lang.String value) {
        copyOnWrite();
        instance.setAddress(value);
        return this;
      }
      /**
       * <pre>
       * The newly generated wallet address
       * </pre>
       *
       * <code>string address = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAddress() {
        copyOnWrite();
        instance.clearAddress();
        return this;
      }
      /**
       * <pre>
       * The newly generated wallet address
       * </pre>
       *
       * <code>string address = 1;</code>
       * @param value The bytes for address to set.
       * @return This builder for chaining.
       */
      public Builder setAddressBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setAddressBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.NewAddressResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.NewAddressResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "address_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u0208";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.NewAddressResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.NewAddressResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.NewAddressResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.NewAddressResponse)
    private static final co.anode.anodium.Rpc.NewAddressResponse DEFAULT_INSTANCE;
    static {
      NewAddressResponse defaultInstance = new NewAddressResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        NewAddressResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.NewAddressResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<NewAddressResponse> PARSER;

    public static com.google.protobuf.Parser<NewAddressResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SignMessageRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.SignMessageRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The message to be signed. When using REST, this field must be encoded as
     *base64.
     * </pre>
     *
     * <code>bytes msg = 1;</code>
     * @return The msg.
     */
    com.google.protobuf.ByteString getMsg();
  }
  /**
   * Protobuf type {@code co.anode.anodium.SignMessageRequest}
   */
  public  static final class SignMessageRequest extends
      com.google.protobuf.GeneratedMessageLite<
          SignMessageRequest, SignMessageRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.SignMessageRequest)
      SignMessageRequestOrBuilder {
    private SignMessageRequest() {
      msg_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int MSG_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString msg_;
    /**
     * <pre>
     *The message to be signed. When using REST, this field must be encoded as
     *base64.
     * </pre>
     *
     * <code>bytes msg = 1;</code>
     * @return The msg.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getMsg() {
      return msg_;
    }
    /**
     * <pre>
     *The message to be signed. When using REST, this field must be encoded as
     *base64.
     * </pre>
     *
     * <code>bytes msg = 1;</code>
     * @param value The msg to set.
     */
    private void setMsg(com.google.protobuf.ByteString value) {
      value.getClass();
  
      msg_ = value;
    }
    /**
     * <pre>
     *The message to be signed. When using REST, this field must be encoded as
     *base64.
     * </pre>
     *
     * <code>bytes msg = 1;</code>
     */
    private void clearMsg() {
      
      msg_ = getDefaultInstance().getMsg();
    }

    public static co.anode.anodium.Rpc.SignMessageRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SignMessageRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SignMessageRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SignMessageRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SignMessageRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SignMessageRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SignMessageRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SignMessageRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SignMessageRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SignMessageRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SignMessageRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SignMessageRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.SignMessageRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.SignMessageRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.SignMessageRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.SignMessageRequest)
        co.anode.anodium.Rpc.SignMessageRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.SignMessageRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The message to be signed. When using REST, this field must be encoded as
       *base64.
       * </pre>
       *
       * <code>bytes msg = 1;</code>
       * @return The msg.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getMsg() {
        return instance.getMsg();
      }
      /**
       * <pre>
       *The message to be signed. When using REST, this field must be encoded as
       *base64.
       * </pre>
       *
       * <code>bytes msg = 1;</code>
       * @param value The msg to set.
       * @return This builder for chaining.
       */
      public Builder setMsg(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setMsg(value);
        return this;
      }
      /**
       * <pre>
       *The message to be signed. When using REST, this field must be encoded as
       *base64.
       * </pre>
       *
       * <code>bytes msg = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearMsg() {
        copyOnWrite();
        instance.clearMsg();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.SignMessageRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.SignMessageRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "msg_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.SignMessageRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.SignMessageRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.SignMessageRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.SignMessageRequest)
    private static final co.anode.anodium.Rpc.SignMessageRequest DEFAULT_INSTANCE;
    static {
      SignMessageRequest defaultInstance = new SignMessageRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        SignMessageRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.SignMessageRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SignMessageRequest> PARSER;

    public static com.google.protobuf.Parser<SignMessageRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SignMessageResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.SignMessageResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The signature for the given message
     * </pre>
     *
     * <code>string signature = 1;</code>
     * @return The signature.
     */
    java.lang.String getSignature();
    /**
     * <pre>
     * The signature for the given message
     * </pre>
     *
     * <code>string signature = 1;</code>
     * @return The bytes for signature.
     */
    com.google.protobuf.ByteString
        getSignatureBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.SignMessageResponse}
   */
  public  static final class SignMessageResponse extends
      com.google.protobuf.GeneratedMessageLite<
          SignMessageResponse, SignMessageResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.SignMessageResponse)
      SignMessageResponseOrBuilder {
    private SignMessageResponse() {
      signature_ = "";
    }
    public static final int SIGNATURE_FIELD_NUMBER = 1;
    private java.lang.String signature_;
    /**
     * <pre>
     * The signature for the given message
     * </pre>
     *
     * <code>string signature = 1;</code>
     * @return The signature.
     */
    @java.lang.Override
    public java.lang.String getSignature() {
      return signature_;
    }
    /**
     * <pre>
     * The signature for the given message
     * </pre>
     *
     * <code>string signature = 1;</code>
     * @return The bytes for signature.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSignatureBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(signature_);
    }
    /**
     * <pre>
     * The signature for the given message
     * </pre>
     *
     * <code>string signature = 1;</code>
     * @param value The signature to set.
     */
    private void setSignature(
        java.lang.String value) {
      value.getClass();
  
      signature_ = value;
    }
    /**
     * <pre>
     * The signature for the given message
     * </pre>
     *
     * <code>string signature = 1;</code>
     */
    private void clearSignature() {
      
      signature_ = getDefaultInstance().getSignature();
    }
    /**
     * <pre>
     * The signature for the given message
     * </pre>
     *
     * <code>string signature = 1;</code>
     * @param value The bytes for signature to set.
     */
    private void setSignatureBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      signature_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.SignMessageResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SignMessageResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SignMessageResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SignMessageResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SignMessageResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.SignMessageResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SignMessageResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SignMessageResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SignMessageResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SignMessageResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.SignMessageResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.SignMessageResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.SignMessageResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.SignMessageResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.SignMessageResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.SignMessageResponse)
        co.anode.anodium.Rpc.SignMessageResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.SignMessageResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The signature for the given message
       * </pre>
       *
       * <code>string signature = 1;</code>
       * @return The signature.
       */
      @java.lang.Override
      public java.lang.String getSignature() {
        return instance.getSignature();
      }
      /**
       * <pre>
       * The signature for the given message
       * </pre>
       *
       * <code>string signature = 1;</code>
       * @return The bytes for signature.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getSignatureBytes() {
        return instance.getSignatureBytes();
      }
      /**
       * <pre>
       * The signature for the given message
       * </pre>
       *
       * <code>string signature = 1;</code>
       * @param value The signature to set.
       * @return This builder for chaining.
       */
      public Builder setSignature(
          java.lang.String value) {
        copyOnWrite();
        instance.setSignature(value);
        return this;
      }
      /**
       * <pre>
       * The signature for the given message
       * </pre>
       *
       * <code>string signature = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignature() {
        copyOnWrite();
        instance.clearSignature();
        return this;
      }
      /**
       * <pre>
       * The signature for the given message
       * </pre>
       *
       * <code>string signature = 1;</code>
       * @param value The bytes for signature to set.
       * @return This builder for chaining.
       */
      public Builder setSignatureBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSignatureBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.SignMessageResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.SignMessageResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "signature_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u0208";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.SignMessageResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.SignMessageResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.SignMessageResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.SignMessageResponse)
    private static final co.anode.anodium.Rpc.SignMessageResponse DEFAULT_INSTANCE;
    static {
      SignMessageResponse defaultInstance = new SignMessageResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        SignMessageResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.SignMessageResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SignMessageResponse> PARSER;

    public static com.google.protobuf.Parser<SignMessageResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface VerifyMessageRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.VerifyMessageRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The message over which the signature is to be verified. When using REST,
     *this field must be encoded as base64.
     * </pre>
     *
     * <code>bytes msg = 1;</code>
     * @return The msg.
     */
    com.google.protobuf.ByteString getMsg();

    /**
     * <pre>
     * The signature to be verified over the given message
     * </pre>
     *
     * <code>string signature = 2;</code>
     * @return The signature.
     */
    java.lang.String getSignature();
    /**
     * <pre>
     * The signature to be verified over the given message
     * </pre>
     *
     * <code>string signature = 2;</code>
     * @return The bytes for signature.
     */
    com.google.protobuf.ByteString
        getSignatureBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.VerifyMessageRequest}
   */
  public  static final class VerifyMessageRequest extends
      com.google.protobuf.GeneratedMessageLite<
          VerifyMessageRequest, VerifyMessageRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.VerifyMessageRequest)
      VerifyMessageRequestOrBuilder {
    private VerifyMessageRequest() {
      msg_ = com.google.protobuf.ByteString.EMPTY;
      signature_ = "";
    }
    public static final int MSG_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString msg_;
    /**
     * <pre>
     *The message over which the signature is to be verified. When using REST,
     *this field must be encoded as base64.
     * </pre>
     *
     * <code>bytes msg = 1;</code>
     * @return The msg.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getMsg() {
      return msg_;
    }
    /**
     * <pre>
     *The message over which the signature is to be verified. When using REST,
     *this field must be encoded as base64.
     * </pre>
     *
     * <code>bytes msg = 1;</code>
     * @param value The msg to set.
     */
    private void setMsg(com.google.protobuf.ByteString value) {
      value.getClass();
  
      msg_ = value;
    }
    /**
     * <pre>
     *The message over which the signature is to be verified. When using REST,
     *this field must be encoded as base64.
     * </pre>
     *
     * <code>bytes msg = 1;</code>
     */
    private void clearMsg() {
      
      msg_ = getDefaultInstance().getMsg();
    }

    public static final int SIGNATURE_FIELD_NUMBER = 2;
    private java.lang.String signature_;
    /**
     * <pre>
     * The signature to be verified over the given message
     * </pre>
     *
     * <code>string signature = 2;</code>
     * @return The signature.
     */
    @java.lang.Override
    public java.lang.String getSignature() {
      return signature_;
    }
    /**
     * <pre>
     * The signature to be verified over the given message
     * </pre>
     *
     * <code>string signature = 2;</code>
     * @return The bytes for signature.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSignatureBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(signature_);
    }
    /**
     * <pre>
     * The signature to be verified over the given message
     * </pre>
     *
     * <code>string signature = 2;</code>
     * @param value The signature to set.
     */
    private void setSignature(
        java.lang.String value) {
      value.getClass();
  
      signature_ = value;
    }
    /**
     * <pre>
     * The signature to be verified over the given message
     * </pre>
     *
     * <code>string signature = 2;</code>
     */
    private void clearSignature() {
      
      signature_ = getDefaultInstance().getSignature();
    }
    /**
     * <pre>
     * The signature to be verified over the given message
     * </pre>
     *
     * <code>string signature = 2;</code>
     * @param value The bytes for signature to set.
     */
    private void setSignatureBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      signature_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.VerifyMessageRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.VerifyMessageRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.VerifyMessageRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.VerifyMessageRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.VerifyMessageRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.VerifyMessageRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.VerifyMessageRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.VerifyMessageRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.VerifyMessageRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.VerifyMessageRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.VerifyMessageRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.VerifyMessageRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.VerifyMessageRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.VerifyMessageRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.VerifyMessageRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.VerifyMessageRequest)
        co.anode.anodium.Rpc.VerifyMessageRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.VerifyMessageRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The message over which the signature is to be verified. When using REST,
       *this field must be encoded as base64.
       * </pre>
       *
       * <code>bytes msg = 1;</code>
       * @return The msg.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getMsg() {
        return instance.getMsg();
      }
      /**
       * <pre>
       *The message over which the signature is to be verified. When using REST,
       *this field must be encoded as base64.
       * </pre>
       *
       * <code>bytes msg = 1;</code>
       * @param value The msg to set.
       * @return This builder for chaining.
       */
      public Builder setMsg(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setMsg(value);
        return this;
      }
      /**
       * <pre>
       *The message over which the signature is to be verified. When using REST,
       *this field must be encoded as base64.
       * </pre>
       *
       * <code>bytes msg = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearMsg() {
        copyOnWrite();
        instance.clearMsg();
        return this;
      }

      /**
       * <pre>
       * The signature to be verified over the given message
       * </pre>
       *
       * <code>string signature = 2;</code>
       * @return The signature.
       */
      @java.lang.Override
      public java.lang.String getSignature() {
        return instance.getSignature();
      }
      /**
       * <pre>
       * The signature to be verified over the given message
       * </pre>
       *
       * <code>string signature = 2;</code>
       * @return The bytes for signature.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getSignatureBytes() {
        return instance.getSignatureBytes();
      }
      /**
       * <pre>
       * The signature to be verified over the given message
       * </pre>
       *
       * <code>string signature = 2;</code>
       * @param value The signature to set.
       * @return This builder for chaining.
       */
      public Builder setSignature(
          java.lang.String value) {
        copyOnWrite();
        instance.setSignature(value);
        return this;
      }
      /**
       * <pre>
       * The signature to be verified over the given message
       * </pre>
       *
       * <code>string signature = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignature() {
        copyOnWrite();
        instance.clearSignature();
        return this;
      }
      /**
       * <pre>
       * The signature to be verified over the given message
       * </pre>
       *
       * <code>string signature = 2;</code>
       * @param value The bytes for signature to set.
       * @return This builder for chaining.
       */
      public Builder setSignatureBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSignatureBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.VerifyMessageRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.VerifyMessageRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "msg_",
              "signature_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\n\u0002\u0208" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.VerifyMessageRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.VerifyMessageRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.VerifyMessageRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.VerifyMessageRequest)
    private static final co.anode.anodium.Rpc.VerifyMessageRequest DEFAULT_INSTANCE;
    static {
      VerifyMessageRequest defaultInstance = new VerifyMessageRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        VerifyMessageRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.VerifyMessageRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<VerifyMessageRequest> PARSER;

    public static com.google.protobuf.Parser<VerifyMessageRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface VerifyMessageResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.VerifyMessageResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Whether the signature was valid over the given message
     * </pre>
     *
     * <code>bool valid = 1;</code>
     * @return The valid.
     */
    boolean getValid();

    /**
     * <pre>
     * The pubkey recovered from the signature
     * </pre>
     *
     * <code>string pubkey = 2;</code>
     * @return The pubkey.
     */
    java.lang.String getPubkey();
    /**
     * <pre>
     * The pubkey recovered from the signature
     * </pre>
     *
     * <code>string pubkey = 2;</code>
     * @return The bytes for pubkey.
     */
    com.google.protobuf.ByteString
        getPubkeyBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.VerifyMessageResponse}
   */
  public  static final class VerifyMessageResponse extends
      com.google.protobuf.GeneratedMessageLite<
          VerifyMessageResponse, VerifyMessageResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.VerifyMessageResponse)
      VerifyMessageResponseOrBuilder {
    private VerifyMessageResponse() {
      pubkey_ = "";
    }
    public static final int VALID_FIELD_NUMBER = 1;
    private boolean valid_;
    /**
     * <pre>
     * Whether the signature was valid over the given message
     * </pre>
     *
     * <code>bool valid = 1;</code>
     * @return The valid.
     */
    @java.lang.Override
    public boolean getValid() {
      return valid_;
    }
    /**
     * <pre>
     * Whether the signature was valid over the given message
     * </pre>
     *
     * <code>bool valid = 1;</code>
     * @param value The valid to set.
     */
    private void setValid(boolean value) {
      
      valid_ = value;
    }
    /**
     * <pre>
     * Whether the signature was valid over the given message
     * </pre>
     *
     * <code>bool valid = 1;</code>
     */
    private void clearValid() {
      
      valid_ = false;
    }

    public static final int PUBKEY_FIELD_NUMBER = 2;
    private java.lang.String pubkey_;
    /**
     * <pre>
     * The pubkey recovered from the signature
     * </pre>
     *
     * <code>string pubkey = 2;</code>
     * @return The pubkey.
     */
    @java.lang.Override
    public java.lang.String getPubkey() {
      return pubkey_;
    }
    /**
     * <pre>
     * The pubkey recovered from the signature
     * </pre>
     *
     * <code>string pubkey = 2;</code>
     * @return The bytes for pubkey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPubkeyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(pubkey_);
    }
    /**
     * <pre>
     * The pubkey recovered from the signature
     * </pre>
     *
     * <code>string pubkey = 2;</code>
     * @param value The pubkey to set.
     */
    private void setPubkey(
        java.lang.String value) {
      value.getClass();
  
      pubkey_ = value;
    }
    /**
     * <pre>
     * The pubkey recovered from the signature
     * </pre>
     *
     * <code>string pubkey = 2;</code>
     */
    private void clearPubkey() {
      
      pubkey_ = getDefaultInstance().getPubkey();
    }
    /**
     * <pre>
     * The pubkey recovered from the signature
     * </pre>
     *
     * <code>string pubkey = 2;</code>
     * @param value The bytes for pubkey to set.
     */
    private void setPubkeyBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      pubkey_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.VerifyMessageResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.VerifyMessageResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.VerifyMessageResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.VerifyMessageResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.VerifyMessageResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.VerifyMessageResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.VerifyMessageResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.VerifyMessageResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.VerifyMessageResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.VerifyMessageResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.VerifyMessageResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.VerifyMessageResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.VerifyMessageResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.VerifyMessageResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.VerifyMessageResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.VerifyMessageResponse)
        co.anode.anodium.Rpc.VerifyMessageResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.VerifyMessageResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Whether the signature was valid over the given message
       * </pre>
       *
       * <code>bool valid = 1;</code>
       * @return The valid.
       */
      @java.lang.Override
      public boolean getValid() {
        return instance.getValid();
      }
      /**
       * <pre>
       * Whether the signature was valid over the given message
       * </pre>
       *
       * <code>bool valid = 1;</code>
       * @param value The valid to set.
       * @return This builder for chaining.
       */
      public Builder setValid(boolean value) {
        copyOnWrite();
        instance.setValid(value);
        return this;
      }
      /**
       * <pre>
       * Whether the signature was valid over the given message
       * </pre>
       *
       * <code>bool valid = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearValid() {
        copyOnWrite();
        instance.clearValid();
        return this;
      }

      /**
       * <pre>
       * The pubkey recovered from the signature
       * </pre>
       *
       * <code>string pubkey = 2;</code>
       * @return The pubkey.
       */
      @java.lang.Override
      public java.lang.String getPubkey() {
        return instance.getPubkey();
      }
      /**
       * <pre>
       * The pubkey recovered from the signature
       * </pre>
       *
       * <code>string pubkey = 2;</code>
       * @return The bytes for pubkey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPubkeyBytes() {
        return instance.getPubkeyBytes();
      }
      /**
       * <pre>
       * The pubkey recovered from the signature
       * </pre>
       *
       * <code>string pubkey = 2;</code>
       * @param value The pubkey to set.
       * @return This builder for chaining.
       */
      public Builder setPubkey(
          java.lang.String value) {
        copyOnWrite();
        instance.setPubkey(value);
        return this;
      }
      /**
       * <pre>
       * The pubkey recovered from the signature
       * </pre>
       *
       * <code>string pubkey = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPubkey() {
        copyOnWrite();
        instance.clearPubkey();
        return this;
      }
      /**
       * <pre>
       * The pubkey recovered from the signature
       * </pre>
       *
       * <code>string pubkey = 2;</code>
       * @param value The bytes for pubkey to set.
       * @return This builder for chaining.
       */
      public Builder setPubkeyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPubkeyBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.VerifyMessageResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.VerifyMessageResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "valid_",
              "pubkey_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0007\u0002\u0208" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.VerifyMessageResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.VerifyMessageResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.VerifyMessageResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.VerifyMessageResponse)
    private static final co.anode.anodium.Rpc.VerifyMessageResponse DEFAULT_INSTANCE;
    static {
      VerifyMessageResponse defaultInstance = new VerifyMessageResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        VerifyMessageResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.VerifyMessageResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<VerifyMessageResponse> PARSER;

    public static com.google.protobuf.Parser<VerifyMessageResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ConnectPeerRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ConnectPeerRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Lightning address of the peer, in the format `&lt;pubkey&gt;&#64;host`
     * </pre>
     *
     * <code>.co.anode.anodium.LightningAddress addr = 1;</code>
     * @return Whether the addr field is set.
     */
    boolean hasAddr();
    /**
     * <pre>
     * Lightning address of the peer, in the format `&lt;pubkey&gt;&#64;host`
     * </pre>
     *
     * <code>.co.anode.anodium.LightningAddress addr = 1;</code>
     * @return The addr.
     */
    co.anode.anodium.Rpc.LightningAddress getAddr();

    /**
     * <pre>
     * If set, the daemon will attempt to persistently connect to the target
     * peer. Otherwise, the call will be synchronous. 
     * </pre>
     *
     * <code>bool perm = 2;</code>
     * @return The perm.
     */
    boolean getPerm();

    /**
     * <pre>
     *The connection timeout value (in seconds) for this request. It won't affect
     *other requests.
     * </pre>
     *
     * <code>uint64 timeout = 3;</code>
     * @return The timeout.
     */
    long getTimeout();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ConnectPeerRequest}
   */
  public  static final class ConnectPeerRequest extends
      com.google.protobuf.GeneratedMessageLite<
          ConnectPeerRequest, ConnectPeerRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ConnectPeerRequest)
      ConnectPeerRequestOrBuilder {
    private ConnectPeerRequest() {
    }
    public static final int ADDR_FIELD_NUMBER = 1;
    private co.anode.anodium.Rpc.LightningAddress addr_;
    /**
     * <pre>
     * Lightning address of the peer, in the format `&lt;pubkey&gt;&#64;host`
     * </pre>
     *
     * <code>.co.anode.anodium.LightningAddress addr = 1;</code>
     */
    @java.lang.Override
    public boolean hasAddr() {
      return addr_ != null;
    }
    /**
     * <pre>
     * Lightning address of the peer, in the format `&lt;pubkey&gt;&#64;host`
     * </pre>
     *
     * <code>.co.anode.anodium.LightningAddress addr = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.LightningAddress getAddr() {
      return addr_ == null ? co.anode.anodium.Rpc.LightningAddress.getDefaultInstance() : addr_;
    }
    /**
     * <pre>
     * Lightning address of the peer, in the format `&lt;pubkey&gt;&#64;host`
     * </pre>
     *
     * <code>.co.anode.anodium.LightningAddress addr = 1;</code>
     */
    private void setAddr(co.anode.anodium.Rpc.LightningAddress value) {
      value.getClass();
  addr_ = value;
      
      }
    /**
     * <pre>
     * Lightning address of the peer, in the format `&lt;pubkey&gt;&#64;host`
     * </pre>
     *
     * <code>.co.anode.anodium.LightningAddress addr = 1;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeAddr(co.anode.anodium.Rpc.LightningAddress value) {
      value.getClass();
  if (addr_ != null &&
          addr_ != co.anode.anodium.Rpc.LightningAddress.getDefaultInstance()) {
        addr_ =
          co.anode.anodium.Rpc.LightningAddress.newBuilder(addr_).mergeFrom(value).buildPartial();
      } else {
        addr_ = value;
      }
      
    }
    /**
     * <pre>
     * Lightning address of the peer, in the format `&lt;pubkey&gt;&#64;host`
     * </pre>
     *
     * <code>.co.anode.anodium.LightningAddress addr = 1;</code>
     */
    private void clearAddr() {  addr_ = null;
      
    }

    public static final int PERM_FIELD_NUMBER = 2;
    private boolean perm_;
    /**
     * <pre>
     * If set, the daemon will attempt to persistently connect to the target
     * peer. Otherwise, the call will be synchronous. 
     * </pre>
     *
     * <code>bool perm = 2;</code>
     * @return The perm.
     */
    @java.lang.Override
    public boolean getPerm() {
      return perm_;
    }
    /**
     * <pre>
     * If set, the daemon will attempt to persistently connect to the target
     * peer. Otherwise, the call will be synchronous. 
     * </pre>
     *
     * <code>bool perm = 2;</code>
     * @param value The perm to set.
     */
    private void setPerm(boolean value) {
      
      perm_ = value;
    }
    /**
     * <pre>
     * If set, the daemon will attempt to persistently connect to the target
     * peer. Otherwise, the call will be synchronous. 
     * </pre>
     *
     * <code>bool perm = 2;</code>
     */
    private void clearPerm() {
      
      perm_ = false;
    }

    public static final int TIMEOUT_FIELD_NUMBER = 3;
    private long timeout_;
    /**
     * <pre>
     *The connection timeout value (in seconds) for this request. It won't affect
     *other requests.
     * </pre>
     *
     * <code>uint64 timeout = 3;</code>
     * @return The timeout.
     */
    @java.lang.Override
    public long getTimeout() {
      return timeout_;
    }
    /**
     * <pre>
     *The connection timeout value (in seconds) for this request. It won't affect
     *other requests.
     * </pre>
     *
     * <code>uint64 timeout = 3;</code>
     * @param value The timeout to set.
     */
    private void setTimeout(long value) {
      
      timeout_ = value;
    }
    /**
     * <pre>
     *The connection timeout value (in seconds) for this request. It won't affect
     *other requests.
     * </pre>
     *
     * <code>uint64 timeout = 3;</code>
     */
    private void clearTimeout() {
      
      timeout_ = 0L;
    }

    public static co.anode.anodium.Rpc.ConnectPeerRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ConnectPeerRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ConnectPeerRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ConnectPeerRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ConnectPeerRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ConnectPeerRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ConnectPeerRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ConnectPeerRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ConnectPeerRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ConnectPeerRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ConnectPeerRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ConnectPeerRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ConnectPeerRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ConnectPeerRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ConnectPeerRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ConnectPeerRequest)
        co.anode.anodium.Rpc.ConnectPeerRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.ConnectPeerRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Lightning address of the peer, in the format `&lt;pubkey&gt;&#64;host`
       * </pre>
       *
       * <code>.co.anode.anodium.LightningAddress addr = 1;</code>
       */
      @java.lang.Override
      public boolean hasAddr() {
        return instance.hasAddr();
      }
      /**
       * <pre>
       * Lightning address of the peer, in the format `&lt;pubkey&gt;&#64;host`
       * </pre>
       *
       * <code>.co.anode.anodium.LightningAddress addr = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.LightningAddress getAddr() {
        return instance.getAddr();
      }
      /**
       * <pre>
       * Lightning address of the peer, in the format `&lt;pubkey&gt;&#64;host`
       * </pre>
       *
       * <code>.co.anode.anodium.LightningAddress addr = 1;</code>
       */
      public Builder setAddr(co.anode.anodium.Rpc.LightningAddress value) {
        copyOnWrite();
        instance.setAddr(value);
        return this;
        }
      /**
       * <pre>
       * Lightning address of the peer, in the format `&lt;pubkey&gt;&#64;host`
       * </pre>
       *
       * <code>.co.anode.anodium.LightningAddress addr = 1;</code>
       */
      public Builder setAddr(
          co.anode.anodium.Rpc.LightningAddress.Builder builderForValue) {
        copyOnWrite();
        instance.setAddr(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Lightning address of the peer, in the format `&lt;pubkey&gt;&#64;host`
       * </pre>
       *
       * <code>.co.anode.anodium.LightningAddress addr = 1;</code>
       */
      public Builder mergeAddr(co.anode.anodium.Rpc.LightningAddress value) {
        copyOnWrite();
        instance.mergeAddr(value);
        return this;
      }
      /**
       * <pre>
       * Lightning address of the peer, in the format `&lt;pubkey&gt;&#64;host`
       * </pre>
       *
       * <code>.co.anode.anodium.LightningAddress addr = 1;</code>
       */
      public Builder clearAddr() {  copyOnWrite();
        instance.clearAddr();
        return this;
      }

      /**
       * <pre>
       * If set, the daemon will attempt to persistently connect to the target
       * peer. Otherwise, the call will be synchronous. 
       * </pre>
       *
       * <code>bool perm = 2;</code>
       * @return The perm.
       */
      @java.lang.Override
      public boolean getPerm() {
        return instance.getPerm();
      }
      /**
       * <pre>
       * If set, the daemon will attempt to persistently connect to the target
       * peer. Otherwise, the call will be synchronous. 
       * </pre>
       *
       * <code>bool perm = 2;</code>
       * @param value The perm to set.
       * @return This builder for chaining.
       */
      public Builder setPerm(boolean value) {
        copyOnWrite();
        instance.setPerm(value);
        return this;
      }
      /**
       * <pre>
       * If set, the daemon will attempt to persistently connect to the target
       * peer. Otherwise, the call will be synchronous. 
       * </pre>
       *
       * <code>bool perm = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPerm() {
        copyOnWrite();
        instance.clearPerm();
        return this;
      }

      /**
       * <pre>
       *The connection timeout value (in seconds) for this request. It won't affect
       *other requests.
       * </pre>
       *
       * <code>uint64 timeout = 3;</code>
       * @return The timeout.
       */
      @java.lang.Override
      public long getTimeout() {
        return instance.getTimeout();
      }
      /**
       * <pre>
       *The connection timeout value (in seconds) for this request. It won't affect
       *other requests.
       * </pre>
       *
       * <code>uint64 timeout = 3;</code>
       * @param value The timeout to set.
       * @return This builder for chaining.
       */
      public Builder setTimeout(long value) {
        copyOnWrite();
        instance.setTimeout(value);
        return this;
      }
      /**
       * <pre>
       *The connection timeout value (in seconds) for this request. It won't affect
       *other requests.
       * </pre>
       *
       * <code>uint64 timeout = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimeout() {
        copyOnWrite();
        instance.clearTimeout();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ConnectPeerRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ConnectPeerRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "addr_",
              "perm_",
              "timeout_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0003\u0003\u0000\u0000\u0000\u0001\t\u0002\u0007" +
                "\u0003\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ConnectPeerRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ConnectPeerRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ConnectPeerRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ConnectPeerRequest)
    private static final co.anode.anodium.Rpc.ConnectPeerRequest DEFAULT_INSTANCE;
    static {
      ConnectPeerRequest defaultInstance = new ConnectPeerRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ConnectPeerRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ConnectPeerRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ConnectPeerRequest> PARSER;

    public static com.google.protobuf.Parser<ConnectPeerRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ConnectPeerResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ConnectPeerResponse)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.ConnectPeerResponse}
   */
  public  static final class ConnectPeerResponse extends
      com.google.protobuf.GeneratedMessageLite<
          ConnectPeerResponse, ConnectPeerResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ConnectPeerResponse)
      ConnectPeerResponseOrBuilder {
    private ConnectPeerResponse() {
    }
    public static co.anode.anodium.Rpc.ConnectPeerResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ConnectPeerResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ConnectPeerResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ConnectPeerResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ConnectPeerResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ConnectPeerResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ConnectPeerResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ConnectPeerResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ConnectPeerResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ConnectPeerResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ConnectPeerResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ConnectPeerResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ConnectPeerResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ConnectPeerResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ConnectPeerResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ConnectPeerResponse)
        co.anode.anodium.Rpc.ConnectPeerResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.ConnectPeerResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ConnectPeerResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ConnectPeerResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ConnectPeerResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ConnectPeerResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ConnectPeerResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ConnectPeerResponse)
    private static final co.anode.anodium.Rpc.ConnectPeerResponse DEFAULT_INSTANCE;
    static {
      ConnectPeerResponse defaultInstance = new ConnectPeerResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ConnectPeerResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ConnectPeerResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ConnectPeerResponse> PARSER;

    public static com.google.protobuf.Parser<ConnectPeerResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface DisconnectPeerRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.DisconnectPeerRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The pubkey of the node to disconnect from
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The pubKey.
     */
    java.lang.String getPubKey();
    /**
     * <pre>
     * The pubkey of the node to disconnect from
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The bytes for pubKey.
     */
    com.google.protobuf.ByteString
        getPubKeyBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.DisconnectPeerRequest}
   */
  public  static final class DisconnectPeerRequest extends
      com.google.protobuf.GeneratedMessageLite<
          DisconnectPeerRequest, DisconnectPeerRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.DisconnectPeerRequest)
      DisconnectPeerRequestOrBuilder {
    private DisconnectPeerRequest() {
      pubKey_ = "";
    }
    public static final int PUB_KEY_FIELD_NUMBER = 1;
    private java.lang.String pubKey_;
    /**
     * <pre>
     * The pubkey of the node to disconnect from
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The pubKey.
     */
    @java.lang.Override
    public java.lang.String getPubKey() {
      return pubKey_;
    }
    /**
     * <pre>
     * The pubkey of the node to disconnect from
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The bytes for pubKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPubKeyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(pubKey_);
    }
    /**
     * <pre>
     * The pubkey of the node to disconnect from
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @param value The pubKey to set.
     */
    private void setPubKey(
        java.lang.String value) {
      value.getClass();
  
      pubKey_ = value;
    }
    /**
     * <pre>
     * The pubkey of the node to disconnect from
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     */
    private void clearPubKey() {
      
      pubKey_ = getDefaultInstance().getPubKey();
    }
    /**
     * <pre>
     * The pubkey of the node to disconnect from
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @param value The bytes for pubKey to set.
     */
    private void setPubKeyBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      pubKey_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.DisconnectPeerRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.DisconnectPeerRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.DisconnectPeerRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.DisconnectPeerRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.DisconnectPeerRequest)
        co.anode.anodium.Rpc.DisconnectPeerRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.DisconnectPeerRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The pubkey of the node to disconnect from
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @return The pubKey.
       */
      @java.lang.Override
      public java.lang.String getPubKey() {
        return instance.getPubKey();
      }
      /**
       * <pre>
       * The pubkey of the node to disconnect from
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @return The bytes for pubKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPubKeyBytes() {
        return instance.getPubKeyBytes();
      }
      /**
       * <pre>
       * The pubkey of the node to disconnect from
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @param value The pubKey to set.
       * @return This builder for chaining.
       */
      public Builder setPubKey(
          java.lang.String value) {
        copyOnWrite();
        instance.setPubKey(value);
        return this;
      }
      /**
       * <pre>
       * The pubkey of the node to disconnect from
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPubKey() {
        copyOnWrite();
        instance.clearPubKey();
        return this;
      }
      /**
       * <pre>
       * The pubkey of the node to disconnect from
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @param value The bytes for pubKey to set.
       * @return This builder for chaining.
       */
      public Builder setPubKeyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPubKeyBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.DisconnectPeerRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.DisconnectPeerRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "pubKey_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u0208";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.DisconnectPeerRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.DisconnectPeerRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.DisconnectPeerRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.DisconnectPeerRequest)
    private static final co.anode.anodium.Rpc.DisconnectPeerRequest DEFAULT_INSTANCE;
    static {
      DisconnectPeerRequest defaultInstance = new DisconnectPeerRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        DisconnectPeerRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.DisconnectPeerRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<DisconnectPeerRequest> PARSER;

    public static com.google.protobuf.Parser<DisconnectPeerRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface DisconnectPeerResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.DisconnectPeerResponse)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.DisconnectPeerResponse}
   */
  public  static final class DisconnectPeerResponse extends
      com.google.protobuf.GeneratedMessageLite<
          DisconnectPeerResponse, DisconnectPeerResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.DisconnectPeerResponse)
      DisconnectPeerResponseOrBuilder {
    private DisconnectPeerResponse() {
    }
    public static co.anode.anodium.Rpc.DisconnectPeerResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DisconnectPeerResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.DisconnectPeerResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.DisconnectPeerResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.DisconnectPeerResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.DisconnectPeerResponse)
        co.anode.anodium.Rpc.DisconnectPeerResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.DisconnectPeerResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.DisconnectPeerResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.DisconnectPeerResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.DisconnectPeerResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.DisconnectPeerResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.DisconnectPeerResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.DisconnectPeerResponse)
    private static final co.anode.anodium.Rpc.DisconnectPeerResponse DEFAULT_INSTANCE;
    static {
      DisconnectPeerResponse defaultInstance = new DisconnectPeerResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        DisconnectPeerResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.DisconnectPeerResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<DisconnectPeerResponse> PARSER;

    public static com.google.protobuf.Parser<DisconnectPeerResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface HTLCOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.HTLC)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>bool incoming = 1;</code>
     * @return The incoming.
     */
    boolean getIncoming();

    /**
     * <code>int64 amount = 2;</code>
     * @return The amount.
     */
    long getAmount();

    /**
     * <code>bytes hash_lock = 3;</code>
     * @return The hashLock.
     */
    com.google.protobuf.ByteString getHashLock();

    /**
     * <code>uint32 expiration_height = 4;</code>
     * @return The expirationHeight.
     */
    int getExpirationHeight();

    /**
     * <pre>
     * Index identifying the htlc on the channel.
     * </pre>
     *
     * <code>uint64 htlc_index = 5;</code>
     * @return The htlcIndex.
     */
    long getHtlcIndex();

    /**
     * <pre>
     * If this HTLC is involved in a forwarding operation, this field indicates
     * the forwarding channel. For an outgoing htlc, it is the incoming channel.
     * For an incoming htlc, it is the outgoing channel. When the htlc
     * originates from this node or this node is the final destination,
     * forwarding_channel will be zero. The forwarding channel will also be zero
     * for htlcs that need to be forwarded but don't have a forwarding decision
     * persisted yet.
     * </pre>
     *
     * <code>uint64 forwarding_channel = 6;</code>
     * @return The forwardingChannel.
     */
    long getForwardingChannel();

    /**
     * <pre>
     * Index identifying the htlc on the forwarding channel.
     * </pre>
     *
     * <code>uint64 forwarding_htlc_index = 7;</code>
     * @return The forwardingHtlcIndex.
     */
    long getForwardingHtlcIndex();
  }
  /**
   * Protobuf type {@code co.anode.anodium.HTLC}
   */
  public  static final class HTLC extends
      com.google.protobuf.GeneratedMessageLite<
          HTLC, HTLC.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.HTLC)
      HTLCOrBuilder {
    private HTLC() {
      hashLock_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int INCOMING_FIELD_NUMBER = 1;
    private boolean incoming_;
    /**
     * <code>bool incoming = 1;</code>
     * @return The incoming.
     */
    @java.lang.Override
    public boolean getIncoming() {
      return incoming_;
    }
    /**
     * <code>bool incoming = 1;</code>
     * @param value The incoming to set.
     */
    private void setIncoming(boolean value) {
      
      incoming_ = value;
    }
    /**
     * <code>bool incoming = 1;</code>
     */
    private void clearIncoming() {
      
      incoming_ = false;
    }

    public static final int AMOUNT_FIELD_NUMBER = 2;
    private long amount_;
    /**
     * <code>int64 amount = 2;</code>
     * @return The amount.
     */
    @java.lang.Override
    public long getAmount() {
      return amount_;
    }
    /**
     * <code>int64 amount = 2;</code>
     * @param value The amount to set.
     */
    private void setAmount(long value) {
      
      amount_ = value;
    }
    /**
     * <code>int64 amount = 2;</code>
     */
    private void clearAmount() {
      
      amount_ = 0L;
    }

    public static final int HASH_LOCK_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString hashLock_;
    /**
     * <code>bytes hash_lock = 3;</code>
     * @return The hashLock.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getHashLock() {
      return hashLock_;
    }
    /**
     * <code>bytes hash_lock = 3;</code>
     * @param value The hashLock to set.
     */
    private void setHashLock(com.google.protobuf.ByteString value) {
      value.getClass();
  
      hashLock_ = value;
    }
    /**
     * <code>bytes hash_lock = 3;</code>
     */
    private void clearHashLock() {
      
      hashLock_ = getDefaultInstance().getHashLock();
    }

    public static final int EXPIRATION_HEIGHT_FIELD_NUMBER = 4;
    private int expirationHeight_;
    /**
     * <code>uint32 expiration_height = 4;</code>
     * @return The expirationHeight.
     */
    @java.lang.Override
    public int getExpirationHeight() {
      return expirationHeight_;
    }
    /**
     * <code>uint32 expiration_height = 4;</code>
     * @param value The expirationHeight to set.
     */
    private void setExpirationHeight(int value) {
      
      expirationHeight_ = value;
    }
    /**
     * <code>uint32 expiration_height = 4;</code>
     */
    private void clearExpirationHeight() {
      
      expirationHeight_ = 0;
    }

    public static final int HTLC_INDEX_FIELD_NUMBER = 5;
    private long htlcIndex_;
    /**
     * <pre>
     * Index identifying the htlc on the channel.
     * </pre>
     *
     * <code>uint64 htlc_index = 5;</code>
     * @return The htlcIndex.
     */
    @java.lang.Override
    public long getHtlcIndex() {
      return htlcIndex_;
    }
    /**
     * <pre>
     * Index identifying the htlc on the channel.
     * </pre>
     *
     * <code>uint64 htlc_index = 5;</code>
     * @param value The htlcIndex to set.
     */
    private void setHtlcIndex(long value) {
      
      htlcIndex_ = value;
    }
    /**
     * <pre>
     * Index identifying the htlc on the channel.
     * </pre>
     *
     * <code>uint64 htlc_index = 5;</code>
     */
    private void clearHtlcIndex() {
      
      htlcIndex_ = 0L;
    }

    public static final int FORWARDING_CHANNEL_FIELD_NUMBER = 6;
    private long forwardingChannel_;
    /**
     * <pre>
     * If this HTLC is involved in a forwarding operation, this field indicates
     * the forwarding channel. For an outgoing htlc, it is the incoming channel.
     * For an incoming htlc, it is the outgoing channel. When the htlc
     * originates from this node or this node is the final destination,
     * forwarding_channel will be zero. The forwarding channel will also be zero
     * for htlcs that need to be forwarded but don't have a forwarding decision
     * persisted yet.
     * </pre>
     *
     * <code>uint64 forwarding_channel = 6;</code>
     * @return The forwardingChannel.
     */
    @java.lang.Override
    public long getForwardingChannel() {
      return forwardingChannel_;
    }
    /**
     * <pre>
     * If this HTLC is involved in a forwarding operation, this field indicates
     * the forwarding channel. For an outgoing htlc, it is the incoming channel.
     * For an incoming htlc, it is the outgoing channel. When the htlc
     * originates from this node or this node is the final destination,
     * forwarding_channel will be zero. The forwarding channel will also be zero
     * for htlcs that need to be forwarded but don't have a forwarding decision
     * persisted yet.
     * </pre>
     *
     * <code>uint64 forwarding_channel = 6;</code>
     * @param value The forwardingChannel to set.
     */
    private void setForwardingChannel(long value) {
      
      forwardingChannel_ = value;
    }
    /**
     * <pre>
     * If this HTLC is involved in a forwarding operation, this field indicates
     * the forwarding channel. For an outgoing htlc, it is the incoming channel.
     * For an incoming htlc, it is the outgoing channel. When the htlc
     * originates from this node or this node is the final destination,
     * forwarding_channel will be zero. The forwarding channel will also be zero
     * for htlcs that need to be forwarded but don't have a forwarding decision
     * persisted yet.
     * </pre>
     *
     * <code>uint64 forwarding_channel = 6;</code>
     */
    private void clearForwardingChannel() {
      
      forwardingChannel_ = 0L;
    }

    public static final int FORWARDING_HTLC_INDEX_FIELD_NUMBER = 7;
    private long forwardingHtlcIndex_;
    /**
     * <pre>
     * Index identifying the htlc on the forwarding channel.
     * </pre>
     *
     * <code>uint64 forwarding_htlc_index = 7;</code>
     * @return The forwardingHtlcIndex.
     */
    @java.lang.Override
    public long getForwardingHtlcIndex() {
      return forwardingHtlcIndex_;
    }
    /**
     * <pre>
     * Index identifying the htlc on the forwarding channel.
     * </pre>
     *
     * <code>uint64 forwarding_htlc_index = 7;</code>
     * @param value The forwardingHtlcIndex to set.
     */
    private void setForwardingHtlcIndex(long value) {
      
      forwardingHtlcIndex_ = value;
    }
    /**
     * <pre>
     * Index identifying the htlc on the forwarding channel.
     * </pre>
     *
     * <code>uint64 forwarding_htlc_index = 7;</code>
     */
    private void clearForwardingHtlcIndex() {
      
      forwardingHtlcIndex_ = 0L;
    }

    public static co.anode.anodium.Rpc.HTLC parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.HTLC parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.HTLC parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.HTLC parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.HTLC parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.HTLC parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.HTLC parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.HTLC parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.HTLC parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.HTLC parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.HTLC parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.HTLC parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.HTLC prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.HTLC}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.HTLC, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.HTLC)
        co.anode.anodium.Rpc.HTLCOrBuilder {
      // Construct using co.anode.anodium.Rpc.HTLC.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>bool incoming = 1;</code>
       * @return The incoming.
       */
      @java.lang.Override
      public boolean getIncoming() {
        return instance.getIncoming();
      }
      /**
       * <code>bool incoming = 1;</code>
       * @param value The incoming to set.
       * @return This builder for chaining.
       */
      public Builder setIncoming(boolean value) {
        copyOnWrite();
        instance.setIncoming(value);
        return this;
      }
      /**
       * <code>bool incoming = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearIncoming() {
        copyOnWrite();
        instance.clearIncoming();
        return this;
      }

      /**
       * <code>int64 amount = 2;</code>
       * @return The amount.
       */
      @java.lang.Override
      public long getAmount() {
        return instance.getAmount();
      }
      /**
       * <code>int64 amount = 2;</code>
       * @param value The amount to set.
       * @return This builder for chaining.
       */
      public Builder setAmount(long value) {
        copyOnWrite();
        instance.setAmount(value);
        return this;
      }
      /**
       * <code>int64 amount = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmount() {
        copyOnWrite();
        instance.clearAmount();
        return this;
      }

      /**
       * <code>bytes hash_lock = 3;</code>
       * @return The hashLock.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getHashLock() {
        return instance.getHashLock();
      }
      /**
       * <code>bytes hash_lock = 3;</code>
       * @param value The hashLock to set.
       * @return This builder for chaining.
       */
      public Builder setHashLock(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setHashLock(value);
        return this;
      }
      /**
       * <code>bytes hash_lock = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearHashLock() {
        copyOnWrite();
        instance.clearHashLock();
        return this;
      }

      /**
       * <code>uint32 expiration_height = 4;</code>
       * @return The expirationHeight.
       */
      @java.lang.Override
      public int getExpirationHeight() {
        return instance.getExpirationHeight();
      }
      /**
       * <code>uint32 expiration_height = 4;</code>
       * @param value The expirationHeight to set.
       * @return This builder for chaining.
       */
      public Builder setExpirationHeight(int value) {
        copyOnWrite();
        instance.setExpirationHeight(value);
        return this;
      }
      /**
       * <code>uint32 expiration_height = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearExpirationHeight() {
        copyOnWrite();
        instance.clearExpirationHeight();
        return this;
      }

      /**
       * <pre>
       * Index identifying the htlc on the channel.
       * </pre>
       *
       * <code>uint64 htlc_index = 5;</code>
       * @return The htlcIndex.
       */
      @java.lang.Override
      public long getHtlcIndex() {
        return instance.getHtlcIndex();
      }
      /**
       * <pre>
       * Index identifying the htlc on the channel.
       * </pre>
       *
       * <code>uint64 htlc_index = 5;</code>
       * @param value The htlcIndex to set.
       * @return This builder for chaining.
       */
      public Builder setHtlcIndex(long value) {
        copyOnWrite();
        instance.setHtlcIndex(value);
        return this;
      }
      /**
       * <pre>
       * Index identifying the htlc on the channel.
       * </pre>
       *
       * <code>uint64 htlc_index = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearHtlcIndex() {
        copyOnWrite();
        instance.clearHtlcIndex();
        return this;
      }

      /**
       * <pre>
       * If this HTLC is involved in a forwarding operation, this field indicates
       * the forwarding channel. For an outgoing htlc, it is the incoming channel.
       * For an incoming htlc, it is the outgoing channel. When the htlc
       * originates from this node or this node is the final destination,
       * forwarding_channel will be zero. The forwarding channel will also be zero
       * for htlcs that need to be forwarded but don't have a forwarding decision
       * persisted yet.
       * </pre>
       *
       * <code>uint64 forwarding_channel = 6;</code>
       * @return The forwardingChannel.
       */
      @java.lang.Override
      public long getForwardingChannel() {
        return instance.getForwardingChannel();
      }
      /**
       * <pre>
       * If this HTLC is involved in a forwarding operation, this field indicates
       * the forwarding channel. For an outgoing htlc, it is the incoming channel.
       * For an incoming htlc, it is the outgoing channel. When the htlc
       * originates from this node or this node is the final destination,
       * forwarding_channel will be zero. The forwarding channel will also be zero
       * for htlcs that need to be forwarded but don't have a forwarding decision
       * persisted yet.
       * </pre>
       *
       * <code>uint64 forwarding_channel = 6;</code>
       * @param value The forwardingChannel to set.
       * @return This builder for chaining.
       */
      public Builder setForwardingChannel(long value) {
        copyOnWrite();
        instance.setForwardingChannel(value);
        return this;
      }
      /**
       * <pre>
       * If this HTLC is involved in a forwarding operation, this field indicates
       * the forwarding channel. For an outgoing htlc, it is the incoming channel.
       * For an incoming htlc, it is the outgoing channel. When the htlc
       * originates from this node or this node is the final destination,
       * forwarding_channel will be zero. The forwarding channel will also be zero
       * for htlcs that need to be forwarded but don't have a forwarding decision
       * persisted yet.
       * </pre>
       *
       * <code>uint64 forwarding_channel = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearForwardingChannel() {
        copyOnWrite();
        instance.clearForwardingChannel();
        return this;
      }

      /**
       * <pre>
       * Index identifying the htlc on the forwarding channel.
       * </pre>
       *
       * <code>uint64 forwarding_htlc_index = 7;</code>
       * @return The forwardingHtlcIndex.
       */
      @java.lang.Override
      public long getForwardingHtlcIndex() {
        return instance.getForwardingHtlcIndex();
      }
      /**
       * <pre>
       * Index identifying the htlc on the forwarding channel.
       * </pre>
       *
       * <code>uint64 forwarding_htlc_index = 7;</code>
       * @param value The forwardingHtlcIndex to set.
       * @return This builder for chaining.
       */
      public Builder setForwardingHtlcIndex(long value) {
        copyOnWrite();
        instance.setForwardingHtlcIndex(value);
        return this;
      }
      /**
       * <pre>
       * Index identifying the htlc on the forwarding channel.
       * </pre>
       *
       * <code>uint64 forwarding_htlc_index = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearForwardingHtlcIndex() {
        copyOnWrite();
        instance.clearForwardingHtlcIndex();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.HTLC)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.HTLC();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "incoming_",
              "amount_",
              "hashLock_",
              "expirationHeight_",
              "htlcIndex_",
              "forwardingChannel_",
              "forwardingHtlcIndex_",
            };
            java.lang.String info =
                "\u0000\u0007\u0000\u0000\u0001\u0007\u0007\u0000\u0000\u0000\u0001\u0007\u0002\u0002" +
                "\u0003\n\u0004\u000b\u0005\u0003\u0006\u0003\u0007\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.HTLC> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.HTLC.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.HTLC>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.HTLC)
    private static final co.anode.anodium.Rpc.HTLC DEFAULT_INSTANCE;
    static {
      HTLC defaultInstance = new HTLC();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        HTLC.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.HTLC getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<HTLC> PARSER;

    public static com.google.protobuf.Parser<HTLC> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelConstraintsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelConstraints)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The CSV delay expressed in relative blocks. If the channel is force closed,
     *we will need to wait for this many blocks before we can regain our funds.
     * </pre>
     *
     * <code>uint32 csv_delay = 1;</code>
     * @return The csvDelay.
     */
    int getCsvDelay();

    /**
     * <pre>
     * The minimum satoshis this node is required to reserve in its balance.
     * </pre>
     *
     * <code>uint64 chan_reserve_sat = 2;</code>
     * @return The chanReserveSat.
     */
    long getChanReserveSat();

    /**
     * <pre>
     * The dust limit (in satoshis) of the initiator's commitment tx.
     * </pre>
     *
     * <code>uint64 dust_limit_sat = 3;</code>
     * @return The dustLimitSat.
     */
    long getDustLimitSat();

    /**
     * <pre>
     * The maximum amount of coins in millisatoshis that can be pending in this
     * channel.
     * </pre>
     *
     * <code>uint64 max_pending_amt_msat = 4;</code>
     * @return The maxPendingAmtMsat.
     */
    long getMaxPendingAmtMsat();

    /**
     * <pre>
     * The smallest HTLC in millisatoshis that the initiator will accept.
     * </pre>
     *
     * <code>uint64 min_htlc_msat = 5;</code>
     * @return The minHtlcMsat.
     */
    long getMinHtlcMsat();

    /**
     * <pre>
     * The total number of incoming HTLC's that the initiator will accept.
     * </pre>
     *
     * <code>uint32 max_accepted_htlcs = 6;</code>
     * @return The maxAcceptedHtlcs.
     */
    int getMaxAcceptedHtlcs();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChannelConstraints}
   */
  public  static final class ChannelConstraints extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelConstraints, ChannelConstraints.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelConstraints)
      ChannelConstraintsOrBuilder {
    private ChannelConstraints() {
    }
    public static final int CSV_DELAY_FIELD_NUMBER = 1;
    private int csvDelay_;
    /**
     * <pre>
     *The CSV delay expressed in relative blocks. If the channel is force closed,
     *we will need to wait for this many blocks before we can regain our funds.
     * </pre>
     *
     * <code>uint32 csv_delay = 1;</code>
     * @return The csvDelay.
     */
    @java.lang.Override
    public int getCsvDelay() {
      return csvDelay_;
    }
    /**
     * <pre>
     *The CSV delay expressed in relative blocks. If the channel is force closed,
     *we will need to wait for this many blocks before we can regain our funds.
     * </pre>
     *
     * <code>uint32 csv_delay = 1;</code>
     * @param value The csvDelay to set.
     */
    private void setCsvDelay(int value) {
      
      csvDelay_ = value;
    }
    /**
     * <pre>
     *The CSV delay expressed in relative blocks. If the channel is force closed,
     *we will need to wait for this many blocks before we can regain our funds.
     * </pre>
     *
     * <code>uint32 csv_delay = 1;</code>
     */
    private void clearCsvDelay() {
      
      csvDelay_ = 0;
    }

    public static final int CHAN_RESERVE_SAT_FIELD_NUMBER = 2;
    private long chanReserveSat_;
    /**
     * <pre>
     * The minimum satoshis this node is required to reserve in its balance.
     * </pre>
     *
     * <code>uint64 chan_reserve_sat = 2;</code>
     * @return The chanReserveSat.
     */
    @java.lang.Override
    public long getChanReserveSat() {
      return chanReserveSat_;
    }
    /**
     * <pre>
     * The minimum satoshis this node is required to reserve in its balance.
     * </pre>
     *
     * <code>uint64 chan_reserve_sat = 2;</code>
     * @param value The chanReserveSat to set.
     */
    private void setChanReserveSat(long value) {
      
      chanReserveSat_ = value;
    }
    /**
     * <pre>
     * The minimum satoshis this node is required to reserve in its balance.
     * </pre>
     *
     * <code>uint64 chan_reserve_sat = 2;</code>
     */
    private void clearChanReserveSat() {
      
      chanReserveSat_ = 0L;
    }

    public static final int DUST_LIMIT_SAT_FIELD_NUMBER = 3;
    private long dustLimitSat_;
    /**
     * <pre>
     * The dust limit (in satoshis) of the initiator's commitment tx.
     * </pre>
     *
     * <code>uint64 dust_limit_sat = 3;</code>
     * @return The dustLimitSat.
     */
    @java.lang.Override
    public long getDustLimitSat() {
      return dustLimitSat_;
    }
    /**
     * <pre>
     * The dust limit (in satoshis) of the initiator's commitment tx.
     * </pre>
     *
     * <code>uint64 dust_limit_sat = 3;</code>
     * @param value The dustLimitSat to set.
     */
    private void setDustLimitSat(long value) {
      
      dustLimitSat_ = value;
    }
    /**
     * <pre>
     * The dust limit (in satoshis) of the initiator's commitment tx.
     * </pre>
     *
     * <code>uint64 dust_limit_sat = 3;</code>
     */
    private void clearDustLimitSat() {
      
      dustLimitSat_ = 0L;
    }

    public static final int MAX_PENDING_AMT_MSAT_FIELD_NUMBER = 4;
    private long maxPendingAmtMsat_;
    /**
     * <pre>
     * The maximum amount of coins in millisatoshis that can be pending in this
     * channel.
     * </pre>
     *
     * <code>uint64 max_pending_amt_msat = 4;</code>
     * @return The maxPendingAmtMsat.
     */
    @java.lang.Override
    public long getMaxPendingAmtMsat() {
      return maxPendingAmtMsat_;
    }
    /**
     * <pre>
     * The maximum amount of coins in millisatoshis that can be pending in this
     * channel.
     * </pre>
     *
     * <code>uint64 max_pending_amt_msat = 4;</code>
     * @param value The maxPendingAmtMsat to set.
     */
    private void setMaxPendingAmtMsat(long value) {
      
      maxPendingAmtMsat_ = value;
    }
    /**
     * <pre>
     * The maximum amount of coins in millisatoshis that can be pending in this
     * channel.
     * </pre>
     *
     * <code>uint64 max_pending_amt_msat = 4;</code>
     */
    private void clearMaxPendingAmtMsat() {
      
      maxPendingAmtMsat_ = 0L;
    }

    public static final int MIN_HTLC_MSAT_FIELD_NUMBER = 5;
    private long minHtlcMsat_;
    /**
     * <pre>
     * The smallest HTLC in millisatoshis that the initiator will accept.
     * </pre>
     *
     * <code>uint64 min_htlc_msat = 5;</code>
     * @return The minHtlcMsat.
     */
    @java.lang.Override
    public long getMinHtlcMsat() {
      return minHtlcMsat_;
    }
    /**
     * <pre>
     * The smallest HTLC in millisatoshis that the initiator will accept.
     * </pre>
     *
     * <code>uint64 min_htlc_msat = 5;</code>
     * @param value The minHtlcMsat to set.
     */
    private void setMinHtlcMsat(long value) {
      
      minHtlcMsat_ = value;
    }
    /**
     * <pre>
     * The smallest HTLC in millisatoshis that the initiator will accept.
     * </pre>
     *
     * <code>uint64 min_htlc_msat = 5;</code>
     */
    private void clearMinHtlcMsat() {
      
      minHtlcMsat_ = 0L;
    }

    public static final int MAX_ACCEPTED_HTLCS_FIELD_NUMBER = 6;
    private int maxAcceptedHtlcs_;
    /**
     * <pre>
     * The total number of incoming HTLC's that the initiator will accept.
     * </pre>
     *
     * <code>uint32 max_accepted_htlcs = 6;</code>
     * @return The maxAcceptedHtlcs.
     */
    @java.lang.Override
    public int getMaxAcceptedHtlcs() {
      return maxAcceptedHtlcs_;
    }
    /**
     * <pre>
     * The total number of incoming HTLC's that the initiator will accept.
     * </pre>
     *
     * <code>uint32 max_accepted_htlcs = 6;</code>
     * @param value The maxAcceptedHtlcs to set.
     */
    private void setMaxAcceptedHtlcs(int value) {
      
      maxAcceptedHtlcs_ = value;
    }
    /**
     * <pre>
     * The total number of incoming HTLC's that the initiator will accept.
     * </pre>
     *
     * <code>uint32 max_accepted_htlcs = 6;</code>
     */
    private void clearMaxAcceptedHtlcs() {
      
      maxAcceptedHtlcs_ = 0;
    }

    public static co.anode.anodium.Rpc.ChannelConstraints parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelConstraints parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelConstraints parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelConstraints parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelConstraints parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelConstraints parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelConstraints parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelConstraints parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelConstraints parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelConstraints parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelConstraints parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelConstraints parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelConstraints prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChannelConstraints}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelConstraints, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelConstraints)
        co.anode.anodium.Rpc.ChannelConstraintsOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelConstraints.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The CSV delay expressed in relative blocks. If the channel is force closed,
       *we will need to wait for this many blocks before we can regain our funds.
       * </pre>
       *
       * <code>uint32 csv_delay = 1;</code>
       * @return The csvDelay.
       */
      @java.lang.Override
      public int getCsvDelay() {
        return instance.getCsvDelay();
      }
      /**
       * <pre>
       *The CSV delay expressed in relative blocks. If the channel is force closed,
       *we will need to wait for this many blocks before we can regain our funds.
       * </pre>
       *
       * <code>uint32 csv_delay = 1;</code>
       * @param value The csvDelay to set.
       * @return This builder for chaining.
       */
      public Builder setCsvDelay(int value) {
        copyOnWrite();
        instance.setCsvDelay(value);
        return this;
      }
      /**
       * <pre>
       *The CSV delay expressed in relative blocks. If the channel is force closed,
       *we will need to wait for this many blocks before we can regain our funds.
       * </pre>
       *
       * <code>uint32 csv_delay = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearCsvDelay() {
        copyOnWrite();
        instance.clearCsvDelay();
        return this;
      }

      /**
       * <pre>
       * The minimum satoshis this node is required to reserve in its balance.
       * </pre>
       *
       * <code>uint64 chan_reserve_sat = 2;</code>
       * @return The chanReserveSat.
       */
      @java.lang.Override
      public long getChanReserveSat() {
        return instance.getChanReserveSat();
      }
      /**
       * <pre>
       * The minimum satoshis this node is required to reserve in its balance.
       * </pre>
       *
       * <code>uint64 chan_reserve_sat = 2;</code>
       * @param value The chanReserveSat to set.
       * @return This builder for chaining.
       */
      public Builder setChanReserveSat(long value) {
        copyOnWrite();
        instance.setChanReserveSat(value);
        return this;
      }
      /**
       * <pre>
       * The minimum satoshis this node is required to reserve in its balance.
       * </pre>
       *
       * <code>uint64 chan_reserve_sat = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearChanReserveSat() {
        copyOnWrite();
        instance.clearChanReserveSat();
        return this;
      }

      /**
       * <pre>
       * The dust limit (in satoshis) of the initiator's commitment tx.
       * </pre>
       *
       * <code>uint64 dust_limit_sat = 3;</code>
       * @return The dustLimitSat.
       */
      @java.lang.Override
      public long getDustLimitSat() {
        return instance.getDustLimitSat();
      }
      /**
       * <pre>
       * The dust limit (in satoshis) of the initiator's commitment tx.
       * </pre>
       *
       * <code>uint64 dust_limit_sat = 3;</code>
       * @param value The dustLimitSat to set.
       * @return This builder for chaining.
       */
      public Builder setDustLimitSat(long value) {
        copyOnWrite();
        instance.setDustLimitSat(value);
        return this;
      }
      /**
       * <pre>
       * The dust limit (in satoshis) of the initiator's commitment tx.
       * </pre>
       *
       * <code>uint64 dust_limit_sat = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearDustLimitSat() {
        copyOnWrite();
        instance.clearDustLimitSat();
        return this;
      }

      /**
       * <pre>
       * The maximum amount of coins in millisatoshis that can be pending in this
       * channel.
       * </pre>
       *
       * <code>uint64 max_pending_amt_msat = 4;</code>
       * @return The maxPendingAmtMsat.
       */
      @java.lang.Override
      public long getMaxPendingAmtMsat() {
        return instance.getMaxPendingAmtMsat();
      }
      /**
       * <pre>
       * The maximum amount of coins in millisatoshis that can be pending in this
       * channel.
       * </pre>
       *
       * <code>uint64 max_pending_amt_msat = 4;</code>
       * @param value The maxPendingAmtMsat to set.
       * @return This builder for chaining.
       */
      public Builder setMaxPendingAmtMsat(long value) {
        copyOnWrite();
        instance.setMaxPendingAmtMsat(value);
        return this;
      }
      /**
       * <pre>
       * The maximum amount of coins in millisatoshis that can be pending in this
       * channel.
       * </pre>
       *
       * <code>uint64 max_pending_amt_msat = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxPendingAmtMsat() {
        copyOnWrite();
        instance.clearMaxPendingAmtMsat();
        return this;
      }

      /**
       * <pre>
       * The smallest HTLC in millisatoshis that the initiator will accept.
       * </pre>
       *
       * <code>uint64 min_htlc_msat = 5;</code>
       * @return The minHtlcMsat.
       */
      @java.lang.Override
      public long getMinHtlcMsat() {
        return instance.getMinHtlcMsat();
      }
      /**
       * <pre>
       * The smallest HTLC in millisatoshis that the initiator will accept.
       * </pre>
       *
       * <code>uint64 min_htlc_msat = 5;</code>
       * @param value The minHtlcMsat to set.
       * @return This builder for chaining.
       */
      public Builder setMinHtlcMsat(long value) {
        copyOnWrite();
        instance.setMinHtlcMsat(value);
        return this;
      }
      /**
       * <pre>
       * The smallest HTLC in millisatoshis that the initiator will accept.
       * </pre>
       *
       * <code>uint64 min_htlc_msat = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinHtlcMsat() {
        copyOnWrite();
        instance.clearMinHtlcMsat();
        return this;
      }

      /**
       * <pre>
       * The total number of incoming HTLC's that the initiator will accept.
       * </pre>
       *
       * <code>uint32 max_accepted_htlcs = 6;</code>
       * @return The maxAcceptedHtlcs.
       */
      @java.lang.Override
      public int getMaxAcceptedHtlcs() {
        return instance.getMaxAcceptedHtlcs();
      }
      /**
       * <pre>
       * The total number of incoming HTLC's that the initiator will accept.
       * </pre>
       *
       * <code>uint32 max_accepted_htlcs = 6;</code>
       * @param value The maxAcceptedHtlcs to set.
       * @return This builder for chaining.
       */
      public Builder setMaxAcceptedHtlcs(int value) {
        copyOnWrite();
        instance.setMaxAcceptedHtlcs(value);
        return this;
      }
      /**
       * <pre>
       * The total number of incoming HTLC's that the initiator will accept.
       * </pre>
       *
       * <code>uint32 max_accepted_htlcs = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxAcceptedHtlcs() {
        copyOnWrite();
        instance.clearMaxAcceptedHtlcs();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelConstraints)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelConstraints();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "csvDelay_",
              "chanReserveSat_",
              "dustLimitSat_",
              "maxPendingAmtMsat_",
              "minHtlcMsat_",
              "maxAcceptedHtlcs_",
            };
            java.lang.String info =
                "\u0000\u0006\u0000\u0000\u0001\u0006\u0006\u0000\u0000\u0000\u0001\u000b\u0002\u0003" +
                "\u0003\u0003\u0004\u0003\u0005\u0003\u0006\u000b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelConstraints> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelConstraints.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelConstraints>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelConstraints)
    private static final co.anode.anodium.Rpc.ChannelConstraints DEFAULT_INSTANCE;
    static {
      ChannelConstraints defaultInstance = new ChannelConstraints();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelConstraints.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelConstraints getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelConstraints> PARSER;

    public static com.google.protobuf.Parser<ChannelConstraints> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.Channel)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Whether this channel is active or not
     * </pre>
     *
     * <code>bool active = 1;</code>
     * @return The active.
     */
    boolean getActive();

    /**
     * <pre>
     * The identity pubkey of the remote node
     * </pre>
     *
     * <code>string remote_pubkey = 2;</code>
     * @return The remotePubkey.
     */
    java.lang.String getRemotePubkey();
    /**
     * <pre>
     * The identity pubkey of the remote node
     * </pre>
     *
     * <code>string remote_pubkey = 2;</code>
     * @return The bytes for remotePubkey.
     */
    com.google.protobuf.ByteString
        getRemotePubkeyBytes();

    /**
     * <pre>
     *The outpoint (txid:index) of the funding transaction. With this value, Bob
     *will be able to generate a signature for Alice's version of the commitment
     *transaction.
     * </pre>
     *
     * <code>string channel_point = 3;</code>
     * @return The channelPoint.
     */
    java.lang.String getChannelPoint();
    /**
     * <pre>
     *The outpoint (txid:index) of the funding transaction. With this value, Bob
     *will be able to generate a signature for Alice's version of the commitment
     *transaction.
     * </pre>
     *
     * <code>string channel_point = 3;</code>
     * @return The bytes for channelPoint.
     */
    com.google.protobuf.ByteString
        getChannelPointBytes();

    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 4 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    long getChanId();

    /**
     * <pre>
     * The total amount of funds held in this channel
     * </pre>
     *
     * <code>int64 capacity = 5;</code>
     * @return The capacity.
     */
    long getCapacity();

    /**
     * <pre>
     * This node's current balance in this channel
     * </pre>
     *
     * <code>int64 local_balance = 6;</code>
     * @return The localBalance.
     */
    long getLocalBalance();

    /**
     * <pre>
     * The counterparty's current balance in this channel
     * </pre>
     *
     * <code>int64 remote_balance = 7;</code>
     * @return The remoteBalance.
     */
    long getRemoteBalance();

    /**
     * <pre>
     *The amount calculated to be paid in fees for the current set of commitment
     *transactions. The fee amount is persisted with the channel in order to
     *allow the fee amount to be removed and recalculated with each channel state
     *update, including updates that happen after a system restart.
     * </pre>
     *
     * <code>int64 commit_fee = 8;</code>
     * @return The commitFee.
     */
    long getCommitFee();

    /**
     * <pre>
     * The weight of the commitment transaction
     * </pre>
     *
     * <code>int64 commit_weight = 9;</code>
     * @return The commitWeight.
     */
    long getCommitWeight();

    /**
     * <pre>
     *The required number of satoshis per kilo-weight that the requester will pay
     *at all times, for both the funding transaction and commitment transaction.
     *This value can later be updated once the channel is open.
     * </pre>
     *
     * <code>int64 fee_per_kw = 10;</code>
     * @return The feePerKw.
     */
    long getFeePerKw();

    /**
     * <pre>
     * The unsettled balance in this channel
     * </pre>
     *
     * <code>int64 unsettled_balance = 11;</code>
     * @return The unsettledBalance.
     */
    long getUnsettledBalance();

    /**
     * <pre>
     *The total number of satoshis we've sent within this channel.
     * </pre>
     *
     * <code>int64 total_satoshis_sent = 12;</code>
     * @return The totalSatoshisSent.
     */
    long getTotalSatoshisSent();

    /**
     * <pre>
     *The total number of satoshis we've received within this channel.
     * </pre>
     *
     * <code>int64 total_satoshis_received = 13;</code>
     * @return The totalSatoshisReceived.
     */
    long getTotalSatoshisReceived();

    /**
     * <pre>
     *The total number of updates conducted within this channel.
     * </pre>
     *
     * <code>uint64 num_updates = 14;</code>
     * @return The numUpdates.
     */
    long getNumUpdates();

    /**
     * <pre>
     *The list of active, uncleared HTLCs currently pending within the channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
     */
    java.util.List<co.anode.anodium.Rpc.HTLC> 
        getPendingHtlcsList();
    /**
     * <pre>
     *The list of active, uncleared HTLCs currently pending within the channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
     */
    co.anode.anodium.Rpc.HTLC getPendingHtlcs(int index);
    /**
     * <pre>
     *The list of active, uncleared HTLCs currently pending within the channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
     */
    int getPendingHtlcsCount();

    /**
     * <pre>
     *Deprecated. The CSV delay expressed in relative blocks. If the channel is
     *force closed, we will need to wait for this many blocks before we can regain
     *our funds.
     * </pre>
     *
     * <code>uint32 csv_delay = 16 [deprecated = true];</code>
     * @return The csvDelay.
     */
    @java.lang.Deprecated int getCsvDelay();

    /**
     * <pre>
     * Whether this channel is advertised to the network or not.
     * </pre>
     *
     * <code>bool private = 17;</code>
     * @return The private.
     */
    boolean getPrivate();

    /**
     * <pre>
     * True if we were the ones that created the channel.
     * </pre>
     *
     * <code>bool initiator = 18;</code>
     * @return The initiator.
     */
    boolean getInitiator();

    /**
     * <pre>
     * A set of flags showing the current state of the channel.
     * </pre>
     *
     * <code>string chan_status_flags = 19;</code>
     * @return The chanStatusFlags.
     */
    java.lang.String getChanStatusFlags();
    /**
     * <pre>
     * A set of flags showing the current state of the channel.
     * </pre>
     *
     * <code>string chan_status_flags = 19;</code>
     * @return The bytes for chanStatusFlags.
     */
    com.google.protobuf.ByteString
        getChanStatusFlagsBytes();

    /**
     * <pre>
     * Deprecated. The minimum satoshis this node is required to reserve in its
     * balance.
     * </pre>
     *
     * <code>int64 local_chan_reserve_sat = 20 [deprecated = true];</code>
     * @return The localChanReserveSat.
     */
    @java.lang.Deprecated long getLocalChanReserveSat();

    /**
     * <pre>
     *Deprecated. The minimum satoshis the other node is required to reserve in
     *its balance.
     * </pre>
     *
     * <code>int64 remote_chan_reserve_sat = 21 [deprecated = true];</code>
     * @return The remoteChanReserveSat.
     */
    @java.lang.Deprecated long getRemoteChanReserveSat();

    /**
     * <pre>
     * Deprecated. Use commitment_type.
     * </pre>
     *
     * <code>bool static_remote_key = 22 [deprecated = true];</code>
     * @return The staticRemoteKey.
     */
    @java.lang.Deprecated boolean getStaticRemoteKey();

    /**
     * <pre>
     * The commitment type used by this channel.
     * </pre>
     *
     * <code>.co.anode.anodium.CommitmentType commitment_type = 26;</code>
     * @return The enum numeric value on the wire for commitmentType.
     */
    int getCommitmentTypeValue();
    /**
     * <pre>
     * The commitment type used by this channel.
     * </pre>
     *
     * <code>.co.anode.anodium.CommitmentType commitment_type = 26;</code>
     * @return The commitmentType.
     */
    co.anode.anodium.Rpc.CommitmentType getCommitmentType();

    /**
     * <pre>
     *The number of seconds that the channel has been monitored by the channel
     *scoring system. Scores are currently not persisted, so this value may be
     *less than the lifetime of the channel [EXPERIMENTAL].
     * </pre>
     *
     * <code>int64 lifetime = 23;</code>
     * @return The lifetime.
     */
    long getLifetime();

    /**
     * <pre>
     *The number of seconds that the remote peer has been observed as being online
     *by the channel scoring system over the lifetime of the channel
     *[EXPERIMENTAL].
     * </pre>
     *
     * <code>int64 uptime = 24;</code>
     * @return The uptime.
     */
    long getUptime();

    /**
     * <pre>
     *Close address is the address that we will enforce payout to on cooperative
     *close if the channel was opened utilizing option upfront shutdown. This
     *value can be set on channel open by setting close_address in an open channel
     *request. If this value is not set, you can still choose a payout address by
     *cooperatively closing with the delivery_address field set.
     * </pre>
     *
     * <code>string close_address = 25;</code>
     * @return The closeAddress.
     */
    java.lang.String getCloseAddress();
    /**
     * <pre>
     *Close address is the address that we will enforce payout to on cooperative
     *close if the channel was opened utilizing option upfront shutdown. This
     *value can be set on channel open by setting close_address in an open channel
     *request. If this value is not set, you can still choose a payout address by
     *cooperatively closing with the delivery_address field set.
     * </pre>
     *
     * <code>string close_address = 25;</code>
     * @return The bytes for closeAddress.
     */
    com.google.protobuf.ByteString
        getCloseAddressBytes();

    /**
     * <pre>
     *The amount that the initiator of the channel optionally pushed to the remote
     *party on channel open. This amount will be zero if the channel initiator did
     *not push any funds to the remote peer. If the initiator field is true, we
     *pushed this amount to our peer, if it is false, the remote peer pushed this
     *amount to us.
     * </pre>
     *
     * <code>uint64 push_amount_sat = 27;</code>
     * @return The pushAmountSat.
     */
    long getPushAmountSat();

    /**
     * <pre>
     *This uint32 indicates if this channel is to be considered 'frozen'. A
     *frozen channel doest not allow a cooperative channel close by the
     *initiator. The thaw_height is the height that this restriction stops
     *applying to the channel. This field is optional, not setting it or using a
     *value of zero will mean the channel has no additional restrictions. The
     *height can be interpreted in two ways: as a relative height if the value is
     *less than 500,000, or as an absolute height otherwise.
     * </pre>
     *
     * <code>uint32 thaw_height = 28;</code>
     * @return The thawHeight.
     */
    int getThawHeight();

    /**
     * <pre>
     * List constraints for the local node.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelConstraints local_constraints = 29;</code>
     * @return Whether the localConstraints field is set.
     */
    boolean hasLocalConstraints();
    /**
     * <pre>
     * List constraints for the local node.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelConstraints local_constraints = 29;</code>
     * @return The localConstraints.
     */
    co.anode.anodium.Rpc.ChannelConstraints getLocalConstraints();

    /**
     * <pre>
     * List constraints for the remote node.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelConstraints remote_constraints = 30;</code>
     * @return Whether the remoteConstraints field is set.
     */
    boolean hasRemoteConstraints();
    /**
     * <pre>
     * List constraints for the remote node.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelConstraints remote_constraints = 30;</code>
     * @return The remoteConstraints.
     */
    co.anode.anodium.Rpc.ChannelConstraints getRemoteConstraints();
  }
  /**
   * Protobuf type {@code co.anode.anodium.Channel}
   */
  public  static final class Channel extends
      com.google.protobuf.GeneratedMessageLite<
          Channel, Channel.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.Channel)
      ChannelOrBuilder {
    private Channel() {
      remotePubkey_ = "";
      channelPoint_ = "";
      pendingHtlcs_ = emptyProtobufList();
      chanStatusFlags_ = "";
      closeAddress_ = "";
    }
    public static final int ACTIVE_FIELD_NUMBER = 1;
    private boolean active_;
    /**
     * <pre>
     * Whether this channel is active or not
     * </pre>
     *
     * <code>bool active = 1;</code>
     * @return The active.
     */
    @java.lang.Override
    public boolean getActive() {
      return active_;
    }
    /**
     * <pre>
     * Whether this channel is active or not
     * </pre>
     *
     * <code>bool active = 1;</code>
     * @param value The active to set.
     */
    private void setActive(boolean value) {
      
      active_ = value;
    }
    /**
     * <pre>
     * Whether this channel is active or not
     * </pre>
     *
     * <code>bool active = 1;</code>
     */
    private void clearActive() {
      
      active_ = false;
    }

    public static final int REMOTE_PUBKEY_FIELD_NUMBER = 2;
    private java.lang.String remotePubkey_;
    /**
     * <pre>
     * The identity pubkey of the remote node
     * </pre>
     *
     * <code>string remote_pubkey = 2;</code>
     * @return The remotePubkey.
     */
    @java.lang.Override
    public java.lang.String getRemotePubkey() {
      return remotePubkey_;
    }
    /**
     * <pre>
     * The identity pubkey of the remote node
     * </pre>
     *
     * <code>string remote_pubkey = 2;</code>
     * @return The bytes for remotePubkey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRemotePubkeyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(remotePubkey_);
    }
    /**
     * <pre>
     * The identity pubkey of the remote node
     * </pre>
     *
     * <code>string remote_pubkey = 2;</code>
     * @param value The remotePubkey to set.
     */
    private void setRemotePubkey(
        java.lang.String value) {
      value.getClass();
  
      remotePubkey_ = value;
    }
    /**
     * <pre>
     * The identity pubkey of the remote node
     * </pre>
     *
     * <code>string remote_pubkey = 2;</code>
     */
    private void clearRemotePubkey() {
      
      remotePubkey_ = getDefaultInstance().getRemotePubkey();
    }
    /**
     * <pre>
     * The identity pubkey of the remote node
     * </pre>
     *
     * <code>string remote_pubkey = 2;</code>
     * @param value The bytes for remotePubkey to set.
     */
    private void setRemotePubkeyBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      remotePubkey_ = value.toStringUtf8();
      
    }

    public static final int CHANNEL_POINT_FIELD_NUMBER = 3;
    private java.lang.String channelPoint_;
    /**
     * <pre>
     *The outpoint (txid:index) of the funding transaction. With this value, Bob
     *will be able to generate a signature for Alice's version of the commitment
     *transaction.
     * </pre>
     *
     * <code>string channel_point = 3;</code>
     * @return The channelPoint.
     */
    @java.lang.Override
    public java.lang.String getChannelPoint() {
      return channelPoint_;
    }
    /**
     * <pre>
     *The outpoint (txid:index) of the funding transaction. With this value, Bob
     *will be able to generate a signature for Alice's version of the commitment
     *transaction.
     * </pre>
     *
     * <code>string channel_point = 3;</code>
     * @return The bytes for channelPoint.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getChannelPointBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(channelPoint_);
    }
    /**
     * <pre>
     *The outpoint (txid:index) of the funding transaction. With this value, Bob
     *will be able to generate a signature for Alice's version of the commitment
     *transaction.
     * </pre>
     *
     * <code>string channel_point = 3;</code>
     * @param value The channelPoint to set.
     */
    private void setChannelPoint(
        java.lang.String value) {
      value.getClass();
  
      channelPoint_ = value;
    }
    /**
     * <pre>
     *The outpoint (txid:index) of the funding transaction. With this value, Bob
     *will be able to generate a signature for Alice's version of the commitment
     *transaction.
     * </pre>
     *
     * <code>string channel_point = 3;</code>
     */
    private void clearChannelPoint() {
      
      channelPoint_ = getDefaultInstance().getChannelPoint();
    }
    /**
     * <pre>
     *The outpoint (txid:index) of the funding transaction. With this value, Bob
     *will be able to generate a signature for Alice's version of the commitment
     *transaction.
     * </pre>
     *
     * <code>string channel_point = 3;</code>
     * @param value The bytes for channelPoint to set.
     */
    private void setChannelPointBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      channelPoint_ = value.toStringUtf8();
      
    }

    public static final int CHAN_ID_FIELD_NUMBER = 4;
    private long chanId_;
    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 4 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    @java.lang.Override
    public long getChanId() {
      return chanId_;
    }
    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 4 [jstype = JS_STRING];</code>
     * @param value The chanId to set.
     */
    private void setChanId(long value) {
      
      chanId_ = value;
    }
    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 4 [jstype = JS_STRING];</code>
     */
    private void clearChanId() {
      
      chanId_ = 0L;
    }

    public static final int CAPACITY_FIELD_NUMBER = 5;
    private long capacity_;
    /**
     * <pre>
     * The total amount of funds held in this channel
     * </pre>
     *
     * <code>int64 capacity = 5;</code>
     * @return The capacity.
     */
    @java.lang.Override
    public long getCapacity() {
      return capacity_;
    }
    /**
     * <pre>
     * The total amount of funds held in this channel
     * </pre>
     *
     * <code>int64 capacity = 5;</code>
     * @param value The capacity to set.
     */
    private void setCapacity(long value) {
      
      capacity_ = value;
    }
    /**
     * <pre>
     * The total amount of funds held in this channel
     * </pre>
     *
     * <code>int64 capacity = 5;</code>
     */
    private void clearCapacity() {
      
      capacity_ = 0L;
    }

    public static final int LOCAL_BALANCE_FIELD_NUMBER = 6;
    private long localBalance_;
    /**
     * <pre>
     * This node's current balance in this channel
     * </pre>
     *
     * <code>int64 local_balance = 6;</code>
     * @return The localBalance.
     */
    @java.lang.Override
    public long getLocalBalance() {
      return localBalance_;
    }
    /**
     * <pre>
     * This node's current balance in this channel
     * </pre>
     *
     * <code>int64 local_balance = 6;</code>
     * @param value The localBalance to set.
     */
    private void setLocalBalance(long value) {
      
      localBalance_ = value;
    }
    /**
     * <pre>
     * This node's current balance in this channel
     * </pre>
     *
     * <code>int64 local_balance = 6;</code>
     */
    private void clearLocalBalance() {
      
      localBalance_ = 0L;
    }

    public static final int REMOTE_BALANCE_FIELD_NUMBER = 7;
    private long remoteBalance_;
    /**
     * <pre>
     * The counterparty's current balance in this channel
     * </pre>
     *
     * <code>int64 remote_balance = 7;</code>
     * @return The remoteBalance.
     */
    @java.lang.Override
    public long getRemoteBalance() {
      return remoteBalance_;
    }
    /**
     * <pre>
     * The counterparty's current balance in this channel
     * </pre>
     *
     * <code>int64 remote_balance = 7;</code>
     * @param value The remoteBalance to set.
     */
    private void setRemoteBalance(long value) {
      
      remoteBalance_ = value;
    }
    /**
     * <pre>
     * The counterparty's current balance in this channel
     * </pre>
     *
     * <code>int64 remote_balance = 7;</code>
     */
    private void clearRemoteBalance() {
      
      remoteBalance_ = 0L;
    }

    public static final int COMMIT_FEE_FIELD_NUMBER = 8;
    private long commitFee_;
    /**
     * <pre>
     *The amount calculated to be paid in fees for the current set of commitment
     *transactions. The fee amount is persisted with the channel in order to
     *allow the fee amount to be removed and recalculated with each channel state
     *update, including updates that happen after a system restart.
     * </pre>
     *
     * <code>int64 commit_fee = 8;</code>
     * @return The commitFee.
     */
    @java.lang.Override
    public long getCommitFee() {
      return commitFee_;
    }
    /**
     * <pre>
     *The amount calculated to be paid in fees for the current set of commitment
     *transactions. The fee amount is persisted with the channel in order to
     *allow the fee amount to be removed and recalculated with each channel state
     *update, including updates that happen after a system restart.
     * </pre>
     *
     * <code>int64 commit_fee = 8;</code>
     * @param value The commitFee to set.
     */
    private void setCommitFee(long value) {
      
      commitFee_ = value;
    }
    /**
     * <pre>
     *The amount calculated to be paid in fees for the current set of commitment
     *transactions. The fee amount is persisted with the channel in order to
     *allow the fee amount to be removed and recalculated with each channel state
     *update, including updates that happen after a system restart.
     * </pre>
     *
     * <code>int64 commit_fee = 8;</code>
     */
    private void clearCommitFee() {
      
      commitFee_ = 0L;
    }

    public static final int COMMIT_WEIGHT_FIELD_NUMBER = 9;
    private long commitWeight_;
    /**
     * <pre>
     * The weight of the commitment transaction
     * </pre>
     *
     * <code>int64 commit_weight = 9;</code>
     * @return The commitWeight.
     */
    @java.lang.Override
    public long getCommitWeight() {
      return commitWeight_;
    }
    /**
     * <pre>
     * The weight of the commitment transaction
     * </pre>
     *
     * <code>int64 commit_weight = 9;</code>
     * @param value The commitWeight to set.
     */
    private void setCommitWeight(long value) {
      
      commitWeight_ = value;
    }
    /**
     * <pre>
     * The weight of the commitment transaction
     * </pre>
     *
     * <code>int64 commit_weight = 9;</code>
     */
    private void clearCommitWeight() {
      
      commitWeight_ = 0L;
    }

    public static final int FEE_PER_KW_FIELD_NUMBER = 10;
    private long feePerKw_;
    /**
     * <pre>
     *The required number of satoshis per kilo-weight that the requester will pay
     *at all times, for both the funding transaction and commitment transaction.
     *This value can later be updated once the channel is open.
     * </pre>
     *
     * <code>int64 fee_per_kw = 10;</code>
     * @return The feePerKw.
     */
    @java.lang.Override
    public long getFeePerKw() {
      return feePerKw_;
    }
    /**
     * <pre>
     *The required number of satoshis per kilo-weight that the requester will pay
     *at all times, for both the funding transaction and commitment transaction.
     *This value can later be updated once the channel is open.
     * </pre>
     *
     * <code>int64 fee_per_kw = 10;</code>
     * @param value The feePerKw to set.
     */
    private void setFeePerKw(long value) {
      
      feePerKw_ = value;
    }
    /**
     * <pre>
     *The required number of satoshis per kilo-weight that the requester will pay
     *at all times, for both the funding transaction and commitment transaction.
     *This value can later be updated once the channel is open.
     * </pre>
     *
     * <code>int64 fee_per_kw = 10;</code>
     */
    private void clearFeePerKw() {
      
      feePerKw_ = 0L;
    }

    public static final int UNSETTLED_BALANCE_FIELD_NUMBER = 11;
    private long unsettledBalance_;
    /**
     * <pre>
     * The unsettled balance in this channel
     * </pre>
     *
     * <code>int64 unsettled_balance = 11;</code>
     * @return The unsettledBalance.
     */
    @java.lang.Override
    public long getUnsettledBalance() {
      return unsettledBalance_;
    }
    /**
     * <pre>
     * The unsettled balance in this channel
     * </pre>
     *
     * <code>int64 unsettled_balance = 11;</code>
     * @param value The unsettledBalance to set.
     */
    private void setUnsettledBalance(long value) {
      
      unsettledBalance_ = value;
    }
    /**
     * <pre>
     * The unsettled balance in this channel
     * </pre>
     *
     * <code>int64 unsettled_balance = 11;</code>
     */
    private void clearUnsettledBalance() {
      
      unsettledBalance_ = 0L;
    }

    public static final int TOTAL_SATOSHIS_SENT_FIELD_NUMBER = 12;
    private long totalSatoshisSent_;
    /**
     * <pre>
     *The total number of satoshis we've sent within this channel.
     * </pre>
     *
     * <code>int64 total_satoshis_sent = 12;</code>
     * @return The totalSatoshisSent.
     */
    @java.lang.Override
    public long getTotalSatoshisSent() {
      return totalSatoshisSent_;
    }
    /**
     * <pre>
     *The total number of satoshis we've sent within this channel.
     * </pre>
     *
     * <code>int64 total_satoshis_sent = 12;</code>
     * @param value The totalSatoshisSent to set.
     */
    private void setTotalSatoshisSent(long value) {
      
      totalSatoshisSent_ = value;
    }
    /**
     * <pre>
     *The total number of satoshis we've sent within this channel.
     * </pre>
     *
     * <code>int64 total_satoshis_sent = 12;</code>
     */
    private void clearTotalSatoshisSent() {
      
      totalSatoshisSent_ = 0L;
    }

    public static final int TOTAL_SATOSHIS_RECEIVED_FIELD_NUMBER = 13;
    private long totalSatoshisReceived_;
    /**
     * <pre>
     *The total number of satoshis we've received within this channel.
     * </pre>
     *
     * <code>int64 total_satoshis_received = 13;</code>
     * @return The totalSatoshisReceived.
     */
    @java.lang.Override
    public long getTotalSatoshisReceived() {
      return totalSatoshisReceived_;
    }
    /**
     * <pre>
     *The total number of satoshis we've received within this channel.
     * </pre>
     *
     * <code>int64 total_satoshis_received = 13;</code>
     * @param value The totalSatoshisReceived to set.
     */
    private void setTotalSatoshisReceived(long value) {
      
      totalSatoshisReceived_ = value;
    }
    /**
     * <pre>
     *The total number of satoshis we've received within this channel.
     * </pre>
     *
     * <code>int64 total_satoshis_received = 13;</code>
     */
    private void clearTotalSatoshisReceived() {
      
      totalSatoshisReceived_ = 0L;
    }

    public static final int NUM_UPDATES_FIELD_NUMBER = 14;
    private long numUpdates_;
    /**
     * <pre>
     *The total number of updates conducted within this channel.
     * </pre>
     *
     * <code>uint64 num_updates = 14;</code>
     * @return The numUpdates.
     */
    @java.lang.Override
    public long getNumUpdates() {
      return numUpdates_;
    }
    /**
     * <pre>
     *The total number of updates conducted within this channel.
     * </pre>
     *
     * <code>uint64 num_updates = 14;</code>
     * @param value The numUpdates to set.
     */
    private void setNumUpdates(long value) {
      
      numUpdates_ = value;
    }
    /**
     * <pre>
     *The total number of updates conducted within this channel.
     * </pre>
     *
     * <code>uint64 num_updates = 14;</code>
     */
    private void clearNumUpdates() {
      
      numUpdates_ = 0L;
    }

    public static final int PENDING_HTLCS_FIELD_NUMBER = 15;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.HTLC> pendingHtlcs_;
    /**
     * <pre>
     *The list of active, uncleared HTLCs currently pending within the channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.HTLC> getPendingHtlcsList() {
      return pendingHtlcs_;
    }
    /**
     * <pre>
     *The list of active, uncleared HTLCs currently pending within the channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.HTLCOrBuilder> 
        getPendingHtlcsOrBuilderList() {
      return pendingHtlcs_;
    }
    /**
     * <pre>
     *The list of active, uncleared HTLCs currently pending within the channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
     */
    @java.lang.Override
    public int getPendingHtlcsCount() {
      return pendingHtlcs_.size();
    }
    /**
     * <pre>
     *The list of active, uncleared HTLCs currently pending within the channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.HTLC getPendingHtlcs(int index) {
      return pendingHtlcs_.get(index);
    }
    /**
     * <pre>
     *The list of active, uncleared HTLCs currently pending within the channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
     */
    public co.anode.anodium.Rpc.HTLCOrBuilder getPendingHtlcsOrBuilder(
        int index) {
      return pendingHtlcs_.get(index);
    }
    private void ensurePendingHtlcsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.HTLC> tmp = pendingHtlcs_;
      if (!tmp.isModifiable()) {
        pendingHtlcs_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     *The list of active, uncleared HTLCs currently pending within the channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
     */
    private void setPendingHtlcs(
        int index, co.anode.anodium.Rpc.HTLC value) {
      value.getClass();
  ensurePendingHtlcsIsMutable();
      pendingHtlcs_.set(index, value);
    }
    /**
     * <pre>
     *The list of active, uncleared HTLCs currently pending within the channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
     */
    private void addPendingHtlcs(co.anode.anodium.Rpc.HTLC value) {
      value.getClass();
  ensurePendingHtlcsIsMutable();
      pendingHtlcs_.add(value);
    }
    /**
     * <pre>
     *The list of active, uncleared HTLCs currently pending within the channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
     */
    private void addPendingHtlcs(
        int index, co.anode.anodium.Rpc.HTLC value) {
      value.getClass();
  ensurePendingHtlcsIsMutable();
      pendingHtlcs_.add(index, value);
    }
    /**
     * <pre>
     *The list of active, uncleared HTLCs currently pending within the channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
     */
    private void addAllPendingHtlcs(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.HTLC> values) {
      ensurePendingHtlcsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, pendingHtlcs_);
    }
    /**
     * <pre>
     *The list of active, uncleared HTLCs currently pending within the channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
     */
    private void clearPendingHtlcs() {
      pendingHtlcs_ = emptyProtobufList();
    }
    /**
     * <pre>
     *The list of active, uncleared HTLCs currently pending within the channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
     */
    private void removePendingHtlcs(int index) {
      ensurePendingHtlcsIsMutable();
      pendingHtlcs_.remove(index);
    }

    public static final int CSV_DELAY_FIELD_NUMBER = 16;
    private int csvDelay_;
    /**
     * <pre>
     *Deprecated. The CSV delay expressed in relative blocks. If the channel is
     *force closed, we will need to wait for this many blocks before we can regain
     *our funds.
     * </pre>
     *
     * <code>uint32 csv_delay = 16 [deprecated = true];</code>
     * @return The csvDelay.
     */
    @java.lang.Override
    @java.lang.Deprecated public int getCsvDelay() {
      return csvDelay_;
    }
    /**
     * <pre>
     *Deprecated. The CSV delay expressed in relative blocks. If the channel is
     *force closed, we will need to wait for this many blocks before we can regain
     *our funds.
     * </pre>
     *
     * <code>uint32 csv_delay = 16 [deprecated = true];</code>
     * @param value The csvDelay to set.
     */
    private void setCsvDelay(int value) {
      
      csvDelay_ = value;
    }
    /**
     * <pre>
     *Deprecated. The CSV delay expressed in relative blocks. If the channel is
     *force closed, we will need to wait for this many blocks before we can regain
     *our funds.
     * </pre>
     *
     * <code>uint32 csv_delay = 16 [deprecated = true];</code>
     */
    private void clearCsvDelay() {
      
      csvDelay_ = 0;
    }

    public static final int PRIVATE_FIELD_NUMBER = 17;
    private boolean private_;
    /**
     * <pre>
     * Whether this channel is advertised to the network or not.
     * </pre>
     *
     * <code>bool private = 17;</code>
     * @return The private.
     */
    @java.lang.Override
    public boolean getPrivate() {
      return private_;
    }
    /**
     * <pre>
     * Whether this channel is advertised to the network or not.
     * </pre>
     *
     * <code>bool private = 17;</code>
     * @param value The private to set.
     */
    private void setPrivate(boolean value) {
      
      private_ = value;
    }
    /**
     * <pre>
     * Whether this channel is advertised to the network or not.
     * </pre>
     *
     * <code>bool private = 17;</code>
     */
    private void clearPrivate() {
      
      private_ = false;
    }

    public static final int INITIATOR_FIELD_NUMBER = 18;
    private boolean initiator_;
    /**
     * <pre>
     * True if we were the ones that created the channel.
     * </pre>
     *
     * <code>bool initiator = 18;</code>
     * @return The initiator.
     */
    @java.lang.Override
    public boolean getInitiator() {
      return initiator_;
    }
    /**
     * <pre>
     * True if we were the ones that created the channel.
     * </pre>
     *
     * <code>bool initiator = 18;</code>
     * @param value The initiator to set.
     */
    private void setInitiator(boolean value) {
      
      initiator_ = value;
    }
    /**
     * <pre>
     * True if we were the ones that created the channel.
     * </pre>
     *
     * <code>bool initiator = 18;</code>
     */
    private void clearInitiator() {
      
      initiator_ = false;
    }

    public static final int CHAN_STATUS_FLAGS_FIELD_NUMBER = 19;
    private java.lang.String chanStatusFlags_;
    /**
     * <pre>
     * A set of flags showing the current state of the channel.
     * </pre>
     *
     * <code>string chan_status_flags = 19;</code>
     * @return The chanStatusFlags.
     */
    @java.lang.Override
    public java.lang.String getChanStatusFlags() {
      return chanStatusFlags_;
    }
    /**
     * <pre>
     * A set of flags showing the current state of the channel.
     * </pre>
     *
     * <code>string chan_status_flags = 19;</code>
     * @return The bytes for chanStatusFlags.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getChanStatusFlagsBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(chanStatusFlags_);
    }
    /**
     * <pre>
     * A set of flags showing the current state of the channel.
     * </pre>
     *
     * <code>string chan_status_flags = 19;</code>
     * @param value The chanStatusFlags to set.
     */
    private void setChanStatusFlags(
        java.lang.String value) {
      value.getClass();
  
      chanStatusFlags_ = value;
    }
    /**
     * <pre>
     * A set of flags showing the current state of the channel.
     * </pre>
     *
     * <code>string chan_status_flags = 19;</code>
     */
    private void clearChanStatusFlags() {
      
      chanStatusFlags_ = getDefaultInstance().getChanStatusFlags();
    }
    /**
     * <pre>
     * A set of flags showing the current state of the channel.
     * </pre>
     *
     * <code>string chan_status_flags = 19;</code>
     * @param value The bytes for chanStatusFlags to set.
     */
    private void setChanStatusFlagsBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      chanStatusFlags_ = value.toStringUtf8();
      
    }

    public static final int LOCAL_CHAN_RESERVE_SAT_FIELD_NUMBER = 20;
    private long localChanReserveSat_;
    /**
     * <pre>
     * Deprecated. The minimum satoshis this node is required to reserve in its
     * balance.
     * </pre>
     *
     * <code>int64 local_chan_reserve_sat = 20 [deprecated = true];</code>
     * @return The localChanReserveSat.
     */
    @java.lang.Override
    @java.lang.Deprecated public long getLocalChanReserveSat() {
      return localChanReserveSat_;
    }
    /**
     * <pre>
     * Deprecated. The minimum satoshis this node is required to reserve in its
     * balance.
     * </pre>
     *
     * <code>int64 local_chan_reserve_sat = 20 [deprecated = true];</code>
     * @param value The localChanReserveSat to set.
     */
    private void setLocalChanReserveSat(long value) {
      
      localChanReserveSat_ = value;
    }
    /**
     * <pre>
     * Deprecated. The minimum satoshis this node is required to reserve in its
     * balance.
     * </pre>
     *
     * <code>int64 local_chan_reserve_sat = 20 [deprecated = true];</code>
     */
    private void clearLocalChanReserveSat() {
      
      localChanReserveSat_ = 0L;
    }

    public static final int REMOTE_CHAN_RESERVE_SAT_FIELD_NUMBER = 21;
    private long remoteChanReserveSat_;
    /**
     * <pre>
     *Deprecated. The minimum satoshis the other node is required to reserve in
     *its balance.
     * </pre>
     *
     * <code>int64 remote_chan_reserve_sat = 21 [deprecated = true];</code>
     * @return The remoteChanReserveSat.
     */
    @java.lang.Override
    @java.lang.Deprecated public long getRemoteChanReserveSat() {
      return remoteChanReserveSat_;
    }
    /**
     * <pre>
     *Deprecated. The minimum satoshis the other node is required to reserve in
     *its balance.
     * </pre>
     *
     * <code>int64 remote_chan_reserve_sat = 21 [deprecated = true];</code>
     * @param value The remoteChanReserveSat to set.
     */
    private void setRemoteChanReserveSat(long value) {
      
      remoteChanReserveSat_ = value;
    }
    /**
     * <pre>
     *Deprecated. The minimum satoshis the other node is required to reserve in
     *its balance.
     * </pre>
     *
     * <code>int64 remote_chan_reserve_sat = 21 [deprecated = true];</code>
     */
    private void clearRemoteChanReserveSat() {
      
      remoteChanReserveSat_ = 0L;
    }

    public static final int STATIC_REMOTE_KEY_FIELD_NUMBER = 22;
    private boolean staticRemoteKey_;
    /**
     * <pre>
     * Deprecated. Use commitment_type.
     * </pre>
     *
     * <code>bool static_remote_key = 22 [deprecated = true];</code>
     * @return The staticRemoteKey.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean getStaticRemoteKey() {
      return staticRemoteKey_;
    }
    /**
     * <pre>
     * Deprecated. Use commitment_type.
     * </pre>
     *
     * <code>bool static_remote_key = 22 [deprecated = true];</code>
     * @param value The staticRemoteKey to set.
     */
    private void setStaticRemoteKey(boolean value) {
      
      staticRemoteKey_ = value;
    }
    /**
     * <pre>
     * Deprecated. Use commitment_type.
     * </pre>
     *
     * <code>bool static_remote_key = 22 [deprecated = true];</code>
     */
    private void clearStaticRemoteKey() {
      
      staticRemoteKey_ = false;
    }

    public static final int COMMITMENT_TYPE_FIELD_NUMBER = 26;
    private int commitmentType_;
    /**
     * <pre>
     * The commitment type used by this channel.
     * </pre>
     *
     * <code>.co.anode.anodium.CommitmentType commitment_type = 26;</code>
     * @return The enum numeric value on the wire for commitmentType.
     */
    @java.lang.Override
    public int getCommitmentTypeValue() {
      return commitmentType_;
    }
    /**
     * <pre>
     * The commitment type used by this channel.
     * </pre>
     *
     * <code>.co.anode.anodium.CommitmentType commitment_type = 26;</code>
     * @return The commitmentType.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.CommitmentType getCommitmentType() {
      co.anode.anodium.Rpc.CommitmentType result = co.anode.anodium.Rpc.CommitmentType.forNumber(commitmentType_);
      return result == null ? co.anode.anodium.Rpc.CommitmentType.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * The commitment type used by this channel.
     * </pre>
     *
     * <code>.co.anode.anodium.CommitmentType commitment_type = 26;</code>
     * @param value The enum numeric value on the wire for commitmentType to set.
     */
    private void setCommitmentTypeValue(int value) {
        commitmentType_ = value;
    }
    /**
     * <pre>
     * The commitment type used by this channel.
     * </pre>
     *
     * <code>.co.anode.anodium.CommitmentType commitment_type = 26;</code>
     * @param value The commitmentType to set.
     */
    private void setCommitmentType(co.anode.anodium.Rpc.CommitmentType value) {
      commitmentType_ = value.getNumber();
      
    }
    /**
     * <pre>
     * The commitment type used by this channel.
     * </pre>
     *
     * <code>.co.anode.anodium.CommitmentType commitment_type = 26;</code>
     */
    private void clearCommitmentType() {
      
      commitmentType_ = 0;
    }

    public static final int LIFETIME_FIELD_NUMBER = 23;
    private long lifetime_;
    /**
     * <pre>
     *The number of seconds that the channel has been monitored by the channel
     *scoring system. Scores are currently not persisted, so this value may be
     *less than the lifetime of the channel [EXPERIMENTAL].
     * </pre>
     *
     * <code>int64 lifetime = 23;</code>
     * @return The lifetime.
     */
    @java.lang.Override
    public long getLifetime() {
      return lifetime_;
    }
    /**
     * <pre>
     *The number of seconds that the channel has been monitored by the channel
     *scoring system. Scores are currently not persisted, so this value may be
     *less than the lifetime of the channel [EXPERIMENTAL].
     * </pre>
     *
     * <code>int64 lifetime = 23;</code>
     * @param value The lifetime to set.
     */
    private void setLifetime(long value) {
      
      lifetime_ = value;
    }
    /**
     * <pre>
     *The number of seconds that the channel has been monitored by the channel
     *scoring system. Scores are currently not persisted, so this value may be
     *less than the lifetime of the channel [EXPERIMENTAL].
     * </pre>
     *
     * <code>int64 lifetime = 23;</code>
     */
    private void clearLifetime() {
      
      lifetime_ = 0L;
    }

    public static final int UPTIME_FIELD_NUMBER = 24;
    private long uptime_;
    /**
     * <pre>
     *The number of seconds that the remote peer has been observed as being online
     *by the channel scoring system over the lifetime of the channel
     *[EXPERIMENTAL].
     * </pre>
     *
     * <code>int64 uptime = 24;</code>
     * @return The uptime.
     */
    @java.lang.Override
    public long getUptime() {
      return uptime_;
    }
    /**
     * <pre>
     *The number of seconds that the remote peer has been observed as being online
     *by the channel scoring system over the lifetime of the channel
     *[EXPERIMENTAL].
     * </pre>
     *
     * <code>int64 uptime = 24;</code>
     * @param value The uptime to set.
     */
    private void setUptime(long value) {
      
      uptime_ = value;
    }
    /**
     * <pre>
     *The number of seconds that the remote peer has been observed as being online
     *by the channel scoring system over the lifetime of the channel
     *[EXPERIMENTAL].
     * </pre>
     *
     * <code>int64 uptime = 24;</code>
     */
    private void clearUptime() {
      
      uptime_ = 0L;
    }

    public static final int CLOSE_ADDRESS_FIELD_NUMBER = 25;
    private java.lang.String closeAddress_;
    /**
     * <pre>
     *Close address is the address that we will enforce payout to on cooperative
     *close if the channel was opened utilizing option upfront shutdown. This
     *value can be set on channel open by setting close_address in an open channel
     *request. If this value is not set, you can still choose a payout address by
     *cooperatively closing with the delivery_address field set.
     * </pre>
     *
     * <code>string close_address = 25;</code>
     * @return The closeAddress.
     */
    @java.lang.Override
    public java.lang.String getCloseAddress() {
      return closeAddress_;
    }
    /**
     * <pre>
     *Close address is the address that we will enforce payout to on cooperative
     *close if the channel was opened utilizing option upfront shutdown. This
     *value can be set on channel open by setting close_address in an open channel
     *request. If this value is not set, you can still choose a payout address by
     *cooperatively closing with the delivery_address field set.
     * </pre>
     *
     * <code>string close_address = 25;</code>
     * @return The bytes for closeAddress.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getCloseAddressBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(closeAddress_);
    }
    /**
     * <pre>
     *Close address is the address that we will enforce payout to on cooperative
     *close if the channel was opened utilizing option upfront shutdown. This
     *value can be set on channel open by setting close_address in an open channel
     *request. If this value is not set, you can still choose a payout address by
     *cooperatively closing with the delivery_address field set.
     * </pre>
     *
     * <code>string close_address = 25;</code>
     * @param value The closeAddress to set.
     */
    private void setCloseAddress(
        java.lang.String value) {
      value.getClass();
  
      closeAddress_ = value;
    }
    /**
     * <pre>
     *Close address is the address that we will enforce payout to on cooperative
     *close if the channel was opened utilizing option upfront shutdown. This
     *value can be set on channel open by setting close_address in an open channel
     *request. If this value is not set, you can still choose a payout address by
     *cooperatively closing with the delivery_address field set.
     * </pre>
     *
     * <code>string close_address = 25;</code>
     */
    private void clearCloseAddress() {
      
      closeAddress_ = getDefaultInstance().getCloseAddress();
    }
    /**
     * <pre>
     *Close address is the address that we will enforce payout to on cooperative
     *close if the channel was opened utilizing option upfront shutdown. This
     *value can be set on channel open by setting close_address in an open channel
     *request. If this value is not set, you can still choose a payout address by
     *cooperatively closing with the delivery_address field set.
     * </pre>
     *
     * <code>string close_address = 25;</code>
     * @param value The bytes for closeAddress to set.
     */
    private void setCloseAddressBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      closeAddress_ = value.toStringUtf8();
      
    }

    public static final int PUSH_AMOUNT_SAT_FIELD_NUMBER = 27;
    private long pushAmountSat_;
    /**
     * <pre>
     *The amount that the initiator of the channel optionally pushed to the remote
     *party on channel open. This amount will be zero if the channel initiator did
     *not push any funds to the remote peer. If the initiator field is true, we
     *pushed this amount to our peer, if it is false, the remote peer pushed this
     *amount to us.
     * </pre>
     *
     * <code>uint64 push_amount_sat = 27;</code>
     * @return The pushAmountSat.
     */
    @java.lang.Override
    public long getPushAmountSat() {
      return pushAmountSat_;
    }
    /**
     * <pre>
     *The amount that the initiator of the channel optionally pushed to the remote
     *party on channel open. This amount will be zero if the channel initiator did
     *not push any funds to the remote peer. If the initiator field is true, we
     *pushed this amount to our peer, if it is false, the remote peer pushed this
     *amount to us.
     * </pre>
     *
     * <code>uint64 push_amount_sat = 27;</code>
     * @param value The pushAmountSat to set.
     */
    private void setPushAmountSat(long value) {
      
      pushAmountSat_ = value;
    }
    /**
     * <pre>
     *The amount that the initiator of the channel optionally pushed to the remote
     *party on channel open. This amount will be zero if the channel initiator did
     *not push any funds to the remote peer. If the initiator field is true, we
     *pushed this amount to our peer, if it is false, the remote peer pushed this
     *amount to us.
     * </pre>
     *
     * <code>uint64 push_amount_sat = 27;</code>
     */
    private void clearPushAmountSat() {
      
      pushAmountSat_ = 0L;
    }

    public static final int THAW_HEIGHT_FIELD_NUMBER = 28;
    private int thawHeight_;
    /**
     * <pre>
     *This uint32 indicates if this channel is to be considered 'frozen'. A
     *frozen channel doest not allow a cooperative channel close by the
     *initiator. The thaw_height is the height that this restriction stops
     *applying to the channel. This field is optional, not setting it or using a
     *value of zero will mean the channel has no additional restrictions. The
     *height can be interpreted in two ways: as a relative height if the value is
     *less than 500,000, or as an absolute height otherwise.
     * </pre>
     *
     * <code>uint32 thaw_height = 28;</code>
     * @return The thawHeight.
     */
    @java.lang.Override
    public int getThawHeight() {
      return thawHeight_;
    }
    /**
     * <pre>
     *This uint32 indicates if this channel is to be considered 'frozen'. A
     *frozen channel doest not allow a cooperative channel close by the
     *initiator. The thaw_height is the height that this restriction stops
     *applying to the channel. This field is optional, not setting it or using a
     *value of zero will mean the channel has no additional restrictions. The
     *height can be interpreted in two ways: as a relative height if the value is
     *less than 500,000, or as an absolute height otherwise.
     * </pre>
     *
     * <code>uint32 thaw_height = 28;</code>
     * @param value The thawHeight to set.
     */
    private void setThawHeight(int value) {
      
      thawHeight_ = value;
    }
    /**
     * <pre>
     *This uint32 indicates if this channel is to be considered 'frozen'. A
     *frozen channel doest not allow a cooperative channel close by the
     *initiator. The thaw_height is the height that this restriction stops
     *applying to the channel. This field is optional, not setting it or using a
     *value of zero will mean the channel has no additional restrictions. The
     *height can be interpreted in two ways: as a relative height if the value is
     *less than 500,000, or as an absolute height otherwise.
     * </pre>
     *
     * <code>uint32 thaw_height = 28;</code>
     */
    private void clearThawHeight() {
      
      thawHeight_ = 0;
    }

    public static final int LOCAL_CONSTRAINTS_FIELD_NUMBER = 29;
    private co.anode.anodium.Rpc.ChannelConstraints localConstraints_;
    /**
     * <pre>
     * List constraints for the local node.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelConstraints local_constraints = 29;</code>
     */
    @java.lang.Override
    public boolean hasLocalConstraints() {
      return localConstraints_ != null;
    }
    /**
     * <pre>
     * List constraints for the local node.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelConstraints local_constraints = 29;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelConstraints getLocalConstraints() {
      return localConstraints_ == null ? co.anode.anodium.Rpc.ChannelConstraints.getDefaultInstance() : localConstraints_;
    }
    /**
     * <pre>
     * List constraints for the local node.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelConstraints local_constraints = 29;</code>
     */
    private void setLocalConstraints(co.anode.anodium.Rpc.ChannelConstraints value) {
      value.getClass();
  localConstraints_ = value;
      
      }
    /**
     * <pre>
     * List constraints for the local node.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelConstraints local_constraints = 29;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeLocalConstraints(co.anode.anodium.Rpc.ChannelConstraints value) {
      value.getClass();
  if (localConstraints_ != null &&
          localConstraints_ != co.anode.anodium.Rpc.ChannelConstraints.getDefaultInstance()) {
        localConstraints_ =
          co.anode.anodium.Rpc.ChannelConstraints.newBuilder(localConstraints_).mergeFrom(value).buildPartial();
      } else {
        localConstraints_ = value;
      }
      
    }
    /**
     * <pre>
     * List constraints for the local node.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelConstraints local_constraints = 29;</code>
     */
    private void clearLocalConstraints() {  localConstraints_ = null;
      
    }

    public static final int REMOTE_CONSTRAINTS_FIELD_NUMBER = 30;
    private co.anode.anodium.Rpc.ChannelConstraints remoteConstraints_;
    /**
     * <pre>
     * List constraints for the remote node.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelConstraints remote_constraints = 30;</code>
     */
    @java.lang.Override
    public boolean hasRemoteConstraints() {
      return remoteConstraints_ != null;
    }
    /**
     * <pre>
     * List constraints for the remote node.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelConstraints remote_constraints = 30;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelConstraints getRemoteConstraints() {
      return remoteConstraints_ == null ? co.anode.anodium.Rpc.ChannelConstraints.getDefaultInstance() : remoteConstraints_;
    }
    /**
     * <pre>
     * List constraints for the remote node.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelConstraints remote_constraints = 30;</code>
     */
    private void setRemoteConstraints(co.anode.anodium.Rpc.ChannelConstraints value) {
      value.getClass();
  remoteConstraints_ = value;
      
      }
    /**
     * <pre>
     * List constraints for the remote node.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelConstraints remote_constraints = 30;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeRemoteConstraints(co.anode.anodium.Rpc.ChannelConstraints value) {
      value.getClass();
  if (remoteConstraints_ != null &&
          remoteConstraints_ != co.anode.anodium.Rpc.ChannelConstraints.getDefaultInstance()) {
        remoteConstraints_ =
          co.anode.anodium.Rpc.ChannelConstraints.newBuilder(remoteConstraints_).mergeFrom(value).buildPartial();
      } else {
        remoteConstraints_ = value;
      }
      
    }
    /**
     * <pre>
     * List constraints for the remote node.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelConstraints remote_constraints = 30;</code>
     */
    private void clearRemoteConstraints() {  remoteConstraints_ = null;
      
    }

    public static co.anode.anodium.Rpc.Channel parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Channel parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Channel parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Channel parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Channel parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Channel parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Channel parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Channel parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Channel parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Channel parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Channel parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Channel parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.Channel prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.Channel}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.Channel, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.Channel)
        co.anode.anodium.Rpc.ChannelOrBuilder {
      // Construct using co.anode.anodium.Rpc.Channel.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Whether this channel is active or not
       * </pre>
       *
       * <code>bool active = 1;</code>
       * @return The active.
       */
      @java.lang.Override
      public boolean getActive() {
        return instance.getActive();
      }
      /**
       * <pre>
       * Whether this channel is active or not
       * </pre>
       *
       * <code>bool active = 1;</code>
       * @param value The active to set.
       * @return This builder for chaining.
       */
      public Builder setActive(boolean value) {
        copyOnWrite();
        instance.setActive(value);
        return this;
      }
      /**
       * <pre>
       * Whether this channel is active or not
       * </pre>
       *
       * <code>bool active = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearActive() {
        copyOnWrite();
        instance.clearActive();
        return this;
      }

      /**
       * <pre>
       * The identity pubkey of the remote node
       * </pre>
       *
       * <code>string remote_pubkey = 2;</code>
       * @return The remotePubkey.
       */
      @java.lang.Override
      public java.lang.String getRemotePubkey() {
        return instance.getRemotePubkey();
      }
      /**
       * <pre>
       * The identity pubkey of the remote node
       * </pre>
       *
       * <code>string remote_pubkey = 2;</code>
       * @return The bytes for remotePubkey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getRemotePubkeyBytes() {
        return instance.getRemotePubkeyBytes();
      }
      /**
       * <pre>
       * The identity pubkey of the remote node
       * </pre>
       *
       * <code>string remote_pubkey = 2;</code>
       * @param value The remotePubkey to set.
       * @return This builder for chaining.
       */
      public Builder setRemotePubkey(
          java.lang.String value) {
        copyOnWrite();
        instance.setRemotePubkey(value);
        return this;
      }
      /**
       * <pre>
       * The identity pubkey of the remote node
       * </pre>
       *
       * <code>string remote_pubkey = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearRemotePubkey() {
        copyOnWrite();
        instance.clearRemotePubkey();
        return this;
      }
      /**
       * <pre>
       * The identity pubkey of the remote node
       * </pre>
       *
       * <code>string remote_pubkey = 2;</code>
       * @param value The bytes for remotePubkey to set.
       * @return This builder for chaining.
       */
      public Builder setRemotePubkeyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setRemotePubkeyBytes(value);
        return this;
      }

      /**
       * <pre>
       *The outpoint (txid:index) of the funding transaction. With this value, Bob
       *will be able to generate a signature for Alice's version of the commitment
       *transaction.
       * </pre>
       *
       * <code>string channel_point = 3;</code>
       * @return The channelPoint.
       */
      @java.lang.Override
      public java.lang.String getChannelPoint() {
        return instance.getChannelPoint();
      }
      /**
       * <pre>
       *The outpoint (txid:index) of the funding transaction. With this value, Bob
       *will be able to generate a signature for Alice's version of the commitment
       *transaction.
       * </pre>
       *
       * <code>string channel_point = 3;</code>
       * @return The bytes for channelPoint.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getChannelPointBytes() {
        return instance.getChannelPointBytes();
      }
      /**
       * <pre>
       *The outpoint (txid:index) of the funding transaction. With this value, Bob
       *will be able to generate a signature for Alice's version of the commitment
       *transaction.
       * </pre>
       *
       * <code>string channel_point = 3;</code>
       * @param value The channelPoint to set.
       * @return This builder for chaining.
       */
      public Builder setChannelPoint(
          java.lang.String value) {
        copyOnWrite();
        instance.setChannelPoint(value);
        return this;
      }
      /**
       * <pre>
       *The outpoint (txid:index) of the funding transaction. With this value, Bob
       *will be able to generate a signature for Alice's version of the commitment
       *transaction.
       * </pre>
       *
       * <code>string channel_point = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearChannelPoint() {
        copyOnWrite();
        instance.clearChannelPoint();
        return this;
      }
      /**
       * <pre>
       *The outpoint (txid:index) of the funding transaction. With this value, Bob
       *will be able to generate a signature for Alice's version of the commitment
       *transaction.
       * </pre>
       *
       * <code>string channel_point = 3;</code>
       * @param value The bytes for channelPoint to set.
       * @return This builder for chaining.
       */
      public Builder setChannelPointBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setChannelPointBytes(value);
        return this;
      }

      /**
       * <pre>
       *The unique channel ID for the channel. The first 3 bytes are the block
       *height, the next 3 the index within the block, and the last 2 bytes are the
       *output index for the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 4 [jstype = JS_STRING];</code>
       * @return The chanId.
       */
      @java.lang.Override
      public long getChanId() {
        return instance.getChanId();
      }
      /**
       * <pre>
       *The unique channel ID for the channel. The first 3 bytes are the block
       *height, the next 3 the index within the block, and the last 2 bytes are the
       *output index for the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 4 [jstype = JS_STRING];</code>
       * @param value The chanId to set.
       * @return This builder for chaining.
       */
      public Builder setChanId(long value) {
        copyOnWrite();
        instance.setChanId(value);
        return this;
      }
      /**
       * <pre>
       *The unique channel ID for the channel. The first 3 bytes are the block
       *height, the next 3 the index within the block, and the last 2 bytes are the
       *output index for the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 4 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearChanId() {
        copyOnWrite();
        instance.clearChanId();
        return this;
      }

      /**
       * <pre>
       * The total amount of funds held in this channel
       * </pre>
       *
       * <code>int64 capacity = 5;</code>
       * @return The capacity.
       */
      @java.lang.Override
      public long getCapacity() {
        return instance.getCapacity();
      }
      /**
       * <pre>
       * The total amount of funds held in this channel
       * </pre>
       *
       * <code>int64 capacity = 5;</code>
       * @param value The capacity to set.
       * @return This builder for chaining.
       */
      public Builder setCapacity(long value) {
        copyOnWrite();
        instance.setCapacity(value);
        return this;
      }
      /**
       * <pre>
       * The total amount of funds held in this channel
       * </pre>
       *
       * <code>int64 capacity = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearCapacity() {
        copyOnWrite();
        instance.clearCapacity();
        return this;
      }

      /**
       * <pre>
       * This node's current balance in this channel
       * </pre>
       *
       * <code>int64 local_balance = 6;</code>
       * @return The localBalance.
       */
      @java.lang.Override
      public long getLocalBalance() {
        return instance.getLocalBalance();
      }
      /**
       * <pre>
       * This node's current balance in this channel
       * </pre>
       *
       * <code>int64 local_balance = 6;</code>
       * @param value The localBalance to set.
       * @return This builder for chaining.
       */
      public Builder setLocalBalance(long value) {
        copyOnWrite();
        instance.setLocalBalance(value);
        return this;
      }
      /**
       * <pre>
       * This node's current balance in this channel
       * </pre>
       *
       * <code>int64 local_balance = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearLocalBalance() {
        copyOnWrite();
        instance.clearLocalBalance();
        return this;
      }

      /**
       * <pre>
       * The counterparty's current balance in this channel
       * </pre>
       *
       * <code>int64 remote_balance = 7;</code>
       * @return The remoteBalance.
       */
      @java.lang.Override
      public long getRemoteBalance() {
        return instance.getRemoteBalance();
      }
      /**
       * <pre>
       * The counterparty's current balance in this channel
       * </pre>
       *
       * <code>int64 remote_balance = 7;</code>
       * @param value The remoteBalance to set.
       * @return This builder for chaining.
       */
      public Builder setRemoteBalance(long value) {
        copyOnWrite();
        instance.setRemoteBalance(value);
        return this;
      }
      /**
       * <pre>
       * The counterparty's current balance in this channel
       * </pre>
       *
       * <code>int64 remote_balance = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearRemoteBalance() {
        copyOnWrite();
        instance.clearRemoteBalance();
        return this;
      }

      /**
       * <pre>
       *The amount calculated to be paid in fees for the current set of commitment
       *transactions. The fee amount is persisted with the channel in order to
       *allow the fee amount to be removed and recalculated with each channel state
       *update, including updates that happen after a system restart.
       * </pre>
       *
       * <code>int64 commit_fee = 8;</code>
       * @return The commitFee.
       */
      @java.lang.Override
      public long getCommitFee() {
        return instance.getCommitFee();
      }
      /**
       * <pre>
       *The amount calculated to be paid in fees for the current set of commitment
       *transactions. The fee amount is persisted with the channel in order to
       *allow the fee amount to be removed and recalculated with each channel state
       *update, including updates that happen after a system restart.
       * </pre>
       *
       * <code>int64 commit_fee = 8;</code>
       * @param value The commitFee to set.
       * @return This builder for chaining.
       */
      public Builder setCommitFee(long value) {
        copyOnWrite();
        instance.setCommitFee(value);
        return this;
      }
      /**
       * <pre>
       *The amount calculated to be paid in fees for the current set of commitment
       *transactions. The fee amount is persisted with the channel in order to
       *allow the fee amount to be removed and recalculated with each channel state
       *update, including updates that happen after a system restart.
       * </pre>
       *
       * <code>int64 commit_fee = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearCommitFee() {
        copyOnWrite();
        instance.clearCommitFee();
        return this;
      }

      /**
       * <pre>
       * The weight of the commitment transaction
       * </pre>
       *
       * <code>int64 commit_weight = 9;</code>
       * @return The commitWeight.
       */
      @java.lang.Override
      public long getCommitWeight() {
        return instance.getCommitWeight();
      }
      /**
       * <pre>
       * The weight of the commitment transaction
       * </pre>
       *
       * <code>int64 commit_weight = 9;</code>
       * @param value The commitWeight to set.
       * @return This builder for chaining.
       */
      public Builder setCommitWeight(long value) {
        copyOnWrite();
        instance.setCommitWeight(value);
        return this;
      }
      /**
       * <pre>
       * The weight of the commitment transaction
       * </pre>
       *
       * <code>int64 commit_weight = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearCommitWeight() {
        copyOnWrite();
        instance.clearCommitWeight();
        return this;
      }

      /**
       * <pre>
       *The required number of satoshis per kilo-weight that the requester will pay
       *at all times, for both the funding transaction and commitment transaction.
       *This value can later be updated once the channel is open.
       * </pre>
       *
       * <code>int64 fee_per_kw = 10;</code>
       * @return The feePerKw.
       */
      @java.lang.Override
      public long getFeePerKw() {
        return instance.getFeePerKw();
      }
      /**
       * <pre>
       *The required number of satoshis per kilo-weight that the requester will pay
       *at all times, for both the funding transaction and commitment transaction.
       *This value can later be updated once the channel is open.
       * </pre>
       *
       * <code>int64 fee_per_kw = 10;</code>
       * @param value The feePerKw to set.
       * @return This builder for chaining.
       */
      public Builder setFeePerKw(long value) {
        copyOnWrite();
        instance.setFeePerKw(value);
        return this;
      }
      /**
       * <pre>
       *The required number of satoshis per kilo-weight that the requester will pay
       *at all times, for both the funding transaction and commitment transaction.
       *This value can later be updated once the channel is open.
       * </pre>
       *
       * <code>int64 fee_per_kw = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearFeePerKw() {
        copyOnWrite();
        instance.clearFeePerKw();
        return this;
      }

      /**
       * <pre>
       * The unsettled balance in this channel
       * </pre>
       *
       * <code>int64 unsettled_balance = 11;</code>
       * @return The unsettledBalance.
       */
      @java.lang.Override
      public long getUnsettledBalance() {
        return instance.getUnsettledBalance();
      }
      /**
       * <pre>
       * The unsettled balance in this channel
       * </pre>
       *
       * <code>int64 unsettled_balance = 11;</code>
       * @param value The unsettledBalance to set.
       * @return This builder for chaining.
       */
      public Builder setUnsettledBalance(long value) {
        copyOnWrite();
        instance.setUnsettledBalance(value);
        return this;
      }
      /**
       * <pre>
       * The unsettled balance in this channel
       * </pre>
       *
       * <code>int64 unsettled_balance = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearUnsettledBalance() {
        copyOnWrite();
        instance.clearUnsettledBalance();
        return this;
      }

      /**
       * <pre>
       *The total number of satoshis we've sent within this channel.
       * </pre>
       *
       * <code>int64 total_satoshis_sent = 12;</code>
       * @return The totalSatoshisSent.
       */
      @java.lang.Override
      public long getTotalSatoshisSent() {
        return instance.getTotalSatoshisSent();
      }
      /**
       * <pre>
       *The total number of satoshis we've sent within this channel.
       * </pre>
       *
       * <code>int64 total_satoshis_sent = 12;</code>
       * @param value The totalSatoshisSent to set.
       * @return This builder for chaining.
       */
      public Builder setTotalSatoshisSent(long value) {
        copyOnWrite();
        instance.setTotalSatoshisSent(value);
        return this;
      }
      /**
       * <pre>
       *The total number of satoshis we've sent within this channel.
       * </pre>
       *
       * <code>int64 total_satoshis_sent = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearTotalSatoshisSent() {
        copyOnWrite();
        instance.clearTotalSatoshisSent();
        return this;
      }

      /**
       * <pre>
       *The total number of satoshis we've received within this channel.
       * </pre>
       *
       * <code>int64 total_satoshis_received = 13;</code>
       * @return The totalSatoshisReceived.
       */
      @java.lang.Override
      public long getTotalSatoshisReceived() {
        return instance.getTotalSatoshisReceived();
      }
      /**
       * <pre>
       *The total number of satoshis we've received within this channel.
       * </pre>
       *
       * <code>int64 total_satoshis_received = 13;</code>
       * @param value The totalSatoshisReceived to set.
       * @return This builder for chaining.
       */
      public Builder setTotalSatoshisReceived(long value) {
        copyOnWrite();
        instance.setTotalSatoshisReceived(value);
        return this;
      }
      /**
       * <pre>
       *The total number of satoshis we've received within this channel.
       * </pre>
       *
       * <code>int64 total_satoshis_received = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearTotalSatoshisReceived() {
        copyOnWrite();
        instance.clearTotalSatoshisReceived();
        return this;
      }

      /**
       * <pre>
       *The total number of updates conducted within this channel.
       * </pre>
       *
       * <code>uint64 num_updates = 14;</code>
       * @return The numUpdates.
       */
      @java.lang.Override
      public long getNumUpdates() {
        return instance.getNumUpdates();
      }
      /**
       * <pre>
       *The total number of updates conducted within this channel.
       * </pre>
       *
       * <code>uint64 num_updates = 14;</code>
       * @param value The numUpdates to set.
       * @return This builder for chaining.
       */
      public Builder setNumUpdates(long value) {
        copyOnWrite();
        instance.setNumUpdates(value);
        return this;
      }
      /**
       * <pre>
       *The total number of updates conducted within this channel.
       * </pre>
       *
       * <code>uint64 num_updates = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumUpdates() {
        copyOnWrite();
        instance.clearNumUpdates();
        return this;
      }

      /**
       * <pre>
       *The list of active, uncleared HTLCs currently pending within the channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.HTLC> getPendingHtlcsList() {
        return java.util.Collections.unmodifiableList(
            instance.getPendingHtlcsList());
      }
      /**
       * <pre>
       *The list of active, uncleared HTLCs currently pending within the channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
       */
      @java.lang.Override
      public int getPendingHtlcsCount() {
        return instance.getPendingHtlcsCount();
      }/**
       * <pre>
       *The list of active, uncleared HTLCs currently pending within the channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.HTLC getPendingHtlcs(int index) {
        return instance.getPendingHtlcs(index);
      }
      /**
       * <pre>
       *The list of active, uncleared HTLCs currently pending within the channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
       */
      public Builder setPendingHtlcs(
          int index, co.anode.anodium.Rpc.HTLC value) {
        copyOnWrite();
        instance.setPendingHtlcs(index, value);
        return this;
      }
      /**
       * <pre>
       *The list of active, uncleared HTLCs currently pending within the channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
       */
      public Builder setPendingHtlcs(
          int index, co.anode.anodium.Rpc.HTLC.Builder builderForValue) {
        copyOnWrite();
        instance.setPendingHtlcs(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *The list of active, uncleared HTLCs currently pending within the channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
       */
      public Builder addPendingHtlcs(co.anode.anodium.Rpc.HTLC value) {
        copyOnWrite();
        instance.addPendingHtlcs(value);
        return this;
      }
      /**
       * <pre>
       *The list of active, uncleared HTLCs currently pending within the channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
       */
      public Builder addPendingHtlcs(
          int index, co.anode.anodium.Rpc.HTLC value) {
        copyOnWrite();
        instance.addPendingHtlcs(index, value);
        return this;
      }
      /**
       * <pre>
       *The list of active, uncleared HTLCs currently pending within the channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
       */
      public Builder addPendingHtlcs(
          co.anode.anodium.Rpc.HTLC.Builder builderForValue) {
        copyOnWrite();
        instance.addPendingHtlcs(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *The list of active, uncleared HTLCs currently pending within the channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
       */
      public Builder addPendingHtlcs(
          int index, co.anode.anodium.Rpc.HTLC.Builder builderForValue) {
        copyOnWrite();
        instance.addPendingHtlcs(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *The list of active, uncleared HTLCs currently pending within the channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
       */
      public Builder addAllPendingHtlcs(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.HTLC> values) {
        copyOnWrite();
        instance.addAllPendingHtlcs(values);
        return this;
      }
      /**
       * <pre>
       *The list of active, uncleared HTLCs currently pending within the channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
       */
      public Builder clearPendingHtlcs() {
        copyOnWrite();
        instance.clearPendingHtlcs();
        return this;
      }
      /**
       * <pre>
       *The list of active, uncleared HTLCs currently pending within the channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLC pending_htlcs = 15;</code>
       */
      public Builder removePendingHtlcs(int index) {
        copyOnWrite();
        instance.removePendingHtlcs(index);
        return this;
      }

      /**
       * <pre>
       *Deprecated. The CSV delay expressed in relative blocks. If the channel is
       *force closed, we will need to wait for this many blocks before we can regain
       *our funds.
       * </pre>
       *
       * <code>uint32 csv_delay = 16 [deprecated = true];</code>
       * @return The csvDelay.
       */
      @java.lang.Override
      @java.lang.Deprecated public int getCsvDelay() {
        return instance.getCsvDelay();
      }
      /**
       * <pre>
       *Deprecated. The CSV delay expressed in relative blocks. If the channel is
       *force closed, we will need to wait for this many blocks before we can regain
       *our funds.
       * </pre>
       *
       * <code>uint32 csv_delay = 16 [deprecated = true];</code>
       * @param value The csvDelay to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setCsvDelay(int value) {
        copyOnWrite();
        instance.setCsvDelay(value);
        return this;
      }
      /**
       * <pre>
       *Deprecated. The CSV delay expressed in relative blocks. If the channel is
       *force closed, we will need to wait for this many blocks before we can regain
       *our funds.
       * </pre>
       *
       * <code>uint32 csv_delay = 16 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearCsvDelay() {
        copyOnWrite();
        instance.clearCsvDelay();
        return this;
      }

      /**
       * <pre>
       * Whether this channel is advertised to the network or not.
       * </pre>
       *
       * <code>bool private = 17;</code>
       * @return The private.
       */
      @java.lang.Override
      public boolean getPrivate() {
        return instance.getPrivate();
      }
      /**
       * <pre>
       * Whether this channel is advertised to the network or not.
       * </pre>
       *
       * <code>bool private = 17;</code>
       * @param value The private to set.
       * @return This builder for chaining.
       */
      public Builder setPrivate(boolean value) {
        copyOnWrite();
        instance.setPrivate(value);
        return this;
      }
      /**
       * <pre>
       * Whether this channel is advertised to the network or not.
       * </pre>
       *
       * <code>bool private = 17;</code>
       * @return This builder for chaining.
       */
      public Builder clearPrivate() {
        copyOnWrite();
        instance.clearPrivate();
        return this;
      }

      /**
       * <pre>
       * True if we were the ones that created the channel.
       * </pre>
       *
       * <code>bool initiator = 18;</code>
       * @return The initiator.
       */
      @java.lang.Override
      public boolean getInitiator() {
        return instance.getInitiator();
      }
      /**
       * <pre>
       * True if we were the ones that created the channel.
       * </pre>
       *
       * <code>bool initiator = 18;</code>
       * @param value The initiator to set.
       * @return This builder for chaining.
       */
      public Builder setInitiator(boolean value) {
        copyOnWrite();
        instance.setInitiator(value);
        return this;
      }
      /**
       * <pre>
       * True if we were the ones that created the channel.
       * </pre>
       *
       * <code>bool initiator = 18;</code>
       * @return This builder for chaining.
       */
      public Builder clearInitiator() {
        copyOnWrite();
        instance.clearInitiator();
        return this;
      }

      /**
       * <pre>
       * A set of flags showing the current state of the channel.
       * </pre>
       *
       * <code>string chan_status_flags = 19;</code>
       * @return The chanStatusFlags.
       */
      @java.lang.Override
      public java.lang.String getChanStatusFlags() {
        return instance.getChanStatusFlags();
      }
      /**
       * <pre>
       * A set of flags showing the current state of the channel.
       * </pre>
       *
       * <code>string chan_status_flags = 19;</code>
       * @return The bytes for chanStatusFlags.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getChanStatusFlagsBytes() {
        return instance.getChanStatusFlagsBytes();
      }
      /**
       * <pre>
       * A set of flags showing the current state of the channel.
       * </pre>
       *
       * <code>string chan_status_flags = 19;</code>
       * @param value The chanStatusFlags to set.
       * @return This builder for chaining.
       */
      public Builder setChanStatusFlags(
          java.lang.String value) {
        copyOnWrite();
        instance.setChanStatusFlags(value);
        return this;
      }
      /**
       * <pre>
       * A set of flags showing the current state of the channel.
       * </pre>
       *
       * <code>string chan_status_flags = 19;</code>
       * @return This builder for chaining.
       */
      public Builder clearChanStatusFlags() {
        copyOnWrite();
        instance.clearChanStatusFlags();
        return this;
      }
      /**
       * <pre>
       * A set of flags showing the current state of the channel.
       * </pre>
       *
       * <code>string chan_status_flags = 19;</code>
       * @param value The bytes for chanStatusFlags to set.
       * @return This builder for chaining.
       */
      public Builder setChanStatusFlagsBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setChanStatusFlagsBytes(value);
        return this;
      }

      /**
       * <pre>
       * Deprecated. The minimum satoshis this node is required to reserve in its
       * balance.
       * </pre>
       *
       * <code>int64 local_chan_reserve_sat = 20 [deprecated = true];</code>
       * @return The localChanReserveSat.
       */
      @java.lang.Override
      @java.lang.Deprecated public long getLocalChanReserveSat() {
        return instance.getLocalChanReserveSat();
      }
      /**
       * <pre>
       * Deprecated. The minimum satoshis this node is required to reserve in its
       * balance.
       * </pre>
       *
       * <code>int64 local_chan_reserve_sat = 20 [deprecated = true];</code>
       * @param value The localChanReserveSat to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setLocalChanReserveSat(long value) {
        copyOnWrite();
        instance.setLocalChanReserveSat(value);
        return this;
      }
      /**
       * <pre>
       * Deprecated. The minimum satoshis this node is required to reserve in its
       * balance.
       * </pre>
       *
       * <code>int64 local_chan_reserve_sat = 20 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearLocalChanReserveSat() {
        copyOnWrite();
        instance.clearLocalChanReserveSat();
        return this;
      }

      /**
       * <pre>
       *Deprecated. The minimum satoshis the other node is required to reserve in
       *its balance.
       * </pre>
       *
       * <code>int64 remote_chan_reserve_sat = 21 [deprecated = true];</code>
       * @return The remoteChanReserveSat.
       */
      @java.lang.Override
      @java.lang.Deprecated public long getRemoteChanReserveSat() {
        return instance.getRemoteChanReserveSat();
      }
      /**
       * <pre>
       *Deprecated. The minimum satoshis the other node is required to reserve in
       *its balance.
       * </pre>
       *
       * <code>int64 remote_chan_reserve_sat = 21 [deprecated = true];</code>
       * @param value The remoteChanReserveSat to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setRemoteChanReserveSat(long value) {
        copyOnWrite();
        instance.setRemoteChanReserveSat(value);
        return this;
      }
      /**
       * <pre>
       *Deprecated. The minimum satoshis the other node is required to reserve in
       *its balance.
       * </pre>
       *
       * <code>int64 remote_chan_reserve_sat = 21 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearRemoteChanReserveSat() {
        copyOnWrite();
        instance.clearRemoteChanReserveSat();
        return this;
      }

      /**
       * <pre>
       * Deprecated. Use commitment_type.
       * </pre>
       *
       * <code>bool static_remote_key = 22 [deprecated = true];</code>
       * @return The staticRemoteKey.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean getStaticRemoteKey() {
        return instance.getStaticRemoteKey();
      }
      /**
       * <pre>
       * Deprecated. Use commitment_type.
       * </pre>
       *
       * <code>bool static_remote_key = 22 [deprecated = true];</code>
       * @param value The staticRemoteKey to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setStaticRemoteKey(boolean value) {
        copyOnWrite();
        instance.setStaticRemoteKey(value);
        return this;
      }
      /**
       * <pre>
       * Deprecated. Use commitment_type.
       * </pre>
       *
       * <code>bool static_remote_key = 22 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearStaticRemoteKey() {
        copyOnWrite();
        instance.clearStaticRemoteKey();
        return this;
      }

      /**
       * <pre>
       * The commitment type used by this channel.
       * </pre>
       *
       * <code>.co.anode.anodium.CommitmentType commitment_type = 26;</code>
       * @return The enum numeric value on the wire for commitmentType.
       */
      @java.lang.Override
      public int getCommitmentTypeValue() {
        return instance.getCommitmentTypeValue();
      }
      /**
       * <pre>
       * The commitment type used by this channel.
       * </pre>
       *
       * <code>.co.anode.anodium.CommitmentType commitment_type = 26;</code>
       * @param value The commitmentType to set.
       * @return This builder for chaining.
       */
      public Builder setCommitmentTypeValue(int value) {
        copyOnWrite();
        instance.setCommitmentTypeValue(value);
        return this;
      }
      /**
       * <pre>
       * The commitment type used by this channel.
       * </pre>
       *
       * <code>.co.anode.anodium.CommitmentType commitment_type = 26;</code>
       * @return The commitmentType.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.CommitmentType getCommitmentType() {
        return instance.getCommitmentType();
      }
      /**
       * <pre>
       * The commitment type used by this channel.
       * </pre>
       *
       * <code>.co.anode.anodium.CommitmentType commitment_type = 26;</code>
       * @param value The enum numeric value on the wire for commitmentType to set.
       * @return This builder for chaining.
       */
      public Builder setCommitmentType(co.anode.anodium.Rpc.CommitmentType value) {
        copyOnWrite();
        instance.setCommitmentType(value);
        return this;
      }
      /**
       * <pre>
       * The commitment type used by this channel.
       * </pre>
       *
       * <code>.co.anode.anodium.CommitmentType commitment_type = 26;</code>
       * @return This builder for chaining.
       */
      public Builder clearCommitmentType() {
        copyOnWrite();
        instance.clearCommitmentType();
        return this;
      }

      /**
       * <pre>
       *The number of seconds that the channel has been monitored by the channel
       *scoring system. Scores are currently not persisted, so this value may be
       *less than the lifetime of the channel [EXPERIMENTAL].
       * </pre>
       *
       * <code>int64 lifetime = 23;</code>
       * @return The lifetime.
       */
      @java.lang.Override
      public long getLifetime() {
        return instance.getLifetime();
      }
      /**
       * <pre>
       *The number of seconds that the channel has been monitored by the channel
       *scoring system. Scores are currently not persisted, so this value may be
       *less than the lifetime of the channel [EXPERIMENTAL].
       * </pre>
       *
       * <code>int64 lifetime = 23;</code>
       * @param value The lifetime to set.
       * @return This builder for chaining.
       */
      public Builder setLifetime(long value) {
        copyOnWrite();
        instance.setLifetime(value);
        return this;
      }
      /**
       * <pre>
       *The number of seconds that the channel has been monitored by the channel
       *scoring system. Scores are currently not persisted, so this value may be
       *less than the lifetime of the channel [EXPERIMENTAL].
       * </pre>
       *
       * <code>int64 lifetime = 23;</code>
       * @return This builder for chaining.
       */
      public Builder clearLifetime() {
        copyOnWrite();
        instance.clearLifetime();
        return this;
      }

      /**
       * <pre>
       *The number of seconds that the remote peer has been observed as being online
       *by the channel scoring system over the lifetime of the channel
       *[EXPERIMENTAL].
       * </pre>
       *
       * <code>int64 uptime = 24;</code>
       * @return The uptime.
       */
      @java.lang.Override
      public long getUptime() {
        return instance.getUptime();
      }
      /**
       * <pre>
       *The number of seconds that the remote peer has been observed as being online
       *by the channel scoring system over the lifetime of the channel
       *[EXPERIMENTAL].
       * </pre>
       *
       * <code>int64 uptime = 24;</code>
       * @param value The uptime to set.
       * @return This builder for chaining.
       */
      public Builder setUptime(long value) {
        copyOnWrite();
        instance.setUptime(value);
        return this;
      }
      /**
       * <pre>
       *The number of seconds that the remote peer has been observed as being online
       *by the channel scoring system over the lifetime of the channel
       *[EXPERIMENTAL].
       * </pre>
       *
       * <code>int64 uptime = 24;</code>
       * @return This builder for chaining.
       */
      public Builder clearUptime() {
        copyOnWrite();
        instance.clearUptime();
        return this;
      }

      /**
       * <pre>
       *Close address is the address that we will enforce payout to on cooperative
       *close if the channel was opened utilizing option upfront shutdown. This
       *value can be set on channel open by setting close_address in an open channel
       *request. If this value is not set, you can still choose a payout address by
       *cooperatively closing with the delivery_address field set.
       * </pre>
       *
       * <code>string close_address = 25;</code>
       * @return The closeAddress.
       */
      @java.lang.Override
      public java.lang.String getCloseAddress() {
        return instance.getCloseAddress();
      }
      /**
       * <pre>
       *Close address is the address that we will enforce payout to on cooperative
       *close if the channel was opened utilizing option upfront shutdown. This
       *value can be set on channel open by setting close_address in an open channel
       *request. If this value is not set, you can still choose a payout address by
       *cooperatively closing with the delivery_address field set.
       * </pre>
       *
       * <code>string close_address = 25;</code>
       * @return The bytes for closeAddress.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getCloseAddressBytes() {
        return instance.getCloseAddressBytes();
      }
      /**
       * <pre>
       *Close address is the address that we will enforce payout to on cooperative
       *close if the channel was opened utilizing option upfront shutdown. This
       *value can be set on channel open by setting close_address in an open channel
       *request. If this value is not set, you can still choose a payout address by
       *cooperatively closing with the delivery_address field set.
       * </pre>
       *
       * <code>string close_address = 25;</code>
       * @param value The closeAddress to set.
       * @return This builder for chaining.
       */
      public Builder setCloseAddress(
          java.lang.String value) {
        copyOnWrite();
        instance.setCloseAddress(value);
        return this;
      }
      /**
       * <pre>
       *Close address is the address that we will enforce payout to on cooperative
       *close if the channel was opened utilizing option upfront shutdown. This
       *value can be set on channel open by setting close_address in an open channel
       *request. If this value is not set, you can still choose a payout address by
       *cooperatively closing with the delivery_address field set.
       * </pre>
       *
       * <code>string close_address = 25;</code>
       * @return This builder for chaining.
       */
      public Builder clearCloseAddress() {
        copyOnWrite();
        instance.clearCloseAddress();
        return this;
      }
      /**
       * <pre>
       *Close address is the address that we will enforce payout to on cooperative
       *close if the channel was opened utilizing option upfront shutdown. This
       *value can be set on channel open by setting close_address in an open channel
       *request. If this value is not set, you can still choose a payout address by
       *cooperatively closing with the delivery_address field set.
       * </pre>
       *
       * <code>string close_address = 25;</code>
       * @param value The bytes for closeAddress to set.
       * @return This builder for chaining.
       */
      public Builder setCloseAddressBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setCloseAddressBytes(value);
        return this;
      }

      /**
       * <pre>
       *The amount that the initiator of the channel optionally pushed to the remote
       *party on channel open. This amount will be zero if the channel initiator did
       *not push any funds to the remote peer. If the initiator field is true, we
       *pushed this amount to our peer, if it is false, the remote peer pushed this
       *amount to us.
       * </pre>
       *
       * <code>uint64 push_amount_sat = 27;</code>
       * @return The pushAmountSat.
       */
      @java.lang.Override
      public long getPushAmountSat() {
        return instance.getPushAmountSat();
      }
      /**
       * <pre>
       *The amount that the initiator of the channel optionally pushed to the remote
       *party on channel open. This amount will be zero if the channel initiator did
       *not push any funds to the remote peer. If the initiator field is true, we
       *pushed this amount to our peer, if it is false, the remote peer pushed this
       *amount to us.
       * </pre>
       *
       * <code>uint64 push_amount_sat = 27;</code>
       * @param value The pushAmountSat to set.
       * @return This builder for chaining.
       */
      public Builder setPushAmountSat(long value) {
        copyOnWrite();
        instance.setPushAmountSat(value);
        return this;
      }
      /**
       * <pre>
       *The amount that the initiator of the channel optionally pushed to the remote
       *party on channel open. This amount will be zero if the channel initiator did
       *not push any funds to the remote peer. If the initiator field is true, we
       *pushed this amount to our peer, if it is false, the remote peer pushed this
       *amount to us.
       * </pre>
       *
       * <code>uint64 push_amount_sat = 27;</code>
       * @return This builder for chaining.
       */
      public Builder clearPushAmountSat() {
        copyOnWrite();
        instance.clearPushAmountSat();
        return this;
      }

      /**
       * <pre>
       *This uint32 indicates if this channel is to be considered 'frozen'. A
       *frozen channel doest not allow a cooperative channel close by the
       *initiator. The thaw_height is the height that this restriction stops
       *applying to the channel. This field is optional, not setting it or using a
       *value of zero will mean the channel has no additional restrictions. The
       *height can be interpreted in two ways: as a relative height if the value is
       *less than 500,000, or as an absolute height otherwise.
       * </pre>
       *
       * <code>uint32 thaw_height = 28;</code>
       * @return The thawHeight.
       */
      @java.lang.Override
      public int getThawHeight() {
        return instance.getThawHeight();
      }
      /**
       * <pre>
       *This uint32 indicates if this channel is to be considered 'frozen'. A
       *frozen channel doest not allow a cooperative channel close by the
       *initiator. The thaw_height is the height that this restriction stops
       *applying to the channel. This field is optional, not setting it or using a
       *value of zero will mean the channel has no additional restrictions. The
       *height can be interpreted in two ways: as a relative height if the value is
       *less than 500,000, or as an absolute height otherwise.
       * </pre>
       *
       * <code>uint32 thaw_height = 28;</code>
       * @param value The thawHeight to set.
       * @return This builder for chaining.
       */
      public Builder setThawHeight(int value) {
        copyOnWrite();
        instance.setThawHeight(value);
        return this;
      }
      /**
       * <pre>
       *This uint32 indicates if this channel is to be considered 'frozen'. A
       *frozen channel doest not allow a cooperative channel close by the
       *initiator. The thaw_height is the height that this restriction stops
       *applying to the channel. This field is optional, not setting it or using a
       *value of zero will mean the channel has no additional restrictions. The
       *height can be interpreted in two ways: as a relative height if the value is
       *less than 500,000, or as an absolute height otherwise.
       * </pre>
       *
       * <code>uint32 thaw_height = 28;</code>
       * @return This builder for chaining.
       */
      public Builder clearThawHeight() {
        copyOnWrite();
        instance.clearThawHeight();
        return this;
      }

      /**
       * <pre>
       * List constraints for the local node.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelConstraints local_constraints = 29;</code>
       */
      @java.lang.Override
      public boolean hasLocalConstraints() {
        return instance.hasLocalConstraints();
      }
      /**
       * <pre>
       * List constraints for the local node.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelConstraints local_constraints = 29;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelConstraints getLocalConstraints() {
        return instance.getLocalConstraints();
      }
      /**
       * <pre>
       * List constraints for the local node.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelConstraints local_constraints = 29;</code>
       */
      public Builder setLocalConstraints(co.anode.anodium.Rpc.ChannelConstraints value) {
        copyOnWrite();
        instance.setLocalConstraints(value);
        return this;
        }
      /**
       * <pre>
       * List constraints for the local node.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelConstraints local_constraints = 29;</code>
       */
      public Builder setLocalConstraints(
          co.anode.anodium.Rpc.ChannelConstraints.Builder builderForValue) {
        copyOnWrite();
        instance.setLocalConstraints(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * List constraints for the local node.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelConstraints local_constraints = 29;</code>
       */
      public Builder mergeLocalConstraints(co.anode.anodium.Rpc.ChannelConstraints value) {
        copyOnWrite();
        instance.mergeLocalConstraints(value);
        return this;
      }
      /**
       * <pre>
       * List constraints for the local node.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelConstraints local_constraints = 29;</code>
       */
      public Builder clearLocalConstraints() {  copyOnWrite();
        instance.clearLocalConstraints();
        return this;
      }

      /**
       * <pre>
       * List constraints for the remote node.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelConstraints remote_constraints = 30;</code>
       */
      @java.lang.Override
      public boolean hasRemoteConstraints() {
        return instance.hasRemoteConstraints();
      }
      /**
       * <pre>
       * List constraints for the remote node.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelConstraints remote_constraints = 30;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelConstraints getRemoteConstraints() {
        return instance.getRemoteConstraints();
      }
      /**
       * <pre>
       * List constraints for the remote node.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelConstraints remote_constraints = 30;</code>
       */
      public Builder setRemoteConstraints(co.anode.anodium.Rpc.ChannelConstraints value) {
        copyOnWrite();
        instance.setRemoteConstraints(value);
        return this;
        }
      /**
       * <pre>
       * List constraints for the remote node.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelConstraints remote_constraints = 30;</code>
       */
      public Builder setRemoteConstraints(
          co.anode.anodium.Rpc.ChannelConstraints.Builder builderForValue) {
        copyOnWrite();
        instance.setRemoteConstraints(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * List constraints for the remote node.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelConstraints remote_constraints = 30;</code>
       */
      public Builder mergeRemoteConstraints(co.anode.anodium.Rpc.ChannelConstraints value) {
        copyOnWrite();
        instance.mergeRemoteConstraints(value);
        return this;
      }
      /**
       * <pre>
       * List constraints for the remote node.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelConstraints remote_constraints = 30;</code>
       */
      public Builder clearRemoteConstraints() {  copyOnWrite();
        instance.clearRemoteConstraints();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.Channel)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.Channel();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "active_",
              "remotePubkey_",
              "channelPoint_",
              "chanId_",
              "capacity_",
              "localBalance_",
              "remoteBalance_",
              "commitFee_",
              "commitWeight_",
              "feePerKw_",
              "unsettledBalance_",
              "totalSatoshisSent_",
              "totalSatoshisReceived_",
              "numUpdates_",
              "pendingHtlcs_",
              co.anode.anodium.Rpc.HTLC.class,
              "csvDelay_",
              "private_",
              "initiator_",
              "chanStatusFlags_",
              "localChanReserveSat_",
              "remoteChanReserveSat_",
              "staticRemoteKey_",
              "lifetime_",
              "uptime_",
              "closeAddress_",
              "commitmentType_",
              "pushAmountSat_",
              "thawHeight_",
              "localConstraints_",
              "remoteConstraints_",
            };
            java.lang.String info =
                "\u0000\u001e\u0000\u0000\u0001\u001e\u001e\u0000\u0001\u0000\u0001\u0007\u0002\u0208" +
                "\u0003\u0208\u0004\u0003\u0005\u0002\u0006\u0002\u0007\u0002\b\u0002\t\u0002\n\u0002" +
                "\u000b\u0002\f\u0002\r\u0002\u000e\u0003\u000f\u001b\u0010\u000b\u0011\u0007\u0012" +
                "\u0007\u0013\u0208\u0014\u0002\u0015\u0002\u0016\u0007\u0017\u0002\u0018\u0002\u0019" +
                "\u0208\u001a\f\u001b\u0003\u001c\u000b\u001d\t\u001e\t";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.Channel> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.Channel.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.Channel>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.Channel)
    private static final co.anode.anodium.Rpc.Channel DEFAULT_INSTANCE;
    static {
      Channel defaultInstance = new Channel();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Channel.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.Channel getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Channel> PARSER;

    public static com.google.protobuf.Parser<Channel> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ListChannelsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ListChannelsRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>bool active_only = 1;</code>
     * @return The activeOnly.
     */
    boolean getActiveOnly();

    /**
     * <code>bool inactive_only = 2;</code>
     * @return The inactiveOnly.
     */
    boolean getInactiveOnly();

    /**
     * <code>bool public_only = 3;</code>
     * @return The publicOnly.
     */
    boolean getPublicOnly();

    /**
     * <code>bool private_only = 4;</code>
     * @return The privateOnly.
     */
    boolean getPrivateOnly();

    /**
     * <pre>
     *Filters the response for channels with a target peer's pubkey. If peer is
     *empty, all channels will be returned.
     * </pre>
     *
     * <code>bytes peer = 5;</code>
     * @return The peer.
     */
    com.google.protobuf.ByteString getPeer();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ListChannelsRequest}
   */
  public  static final class ListChannelsRequest extends
      com.google.protobuf.GeneratedMessageLite<
          ListChannelsRequest, ListChannelsRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ListChannelsRequest)
      ListChannelsRequestOrBuilder {
    private ListChannelsRequest() {
      peer_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int ACTIVE_ONLY_FIELD_NUMBER = 1;
    private boolean activeOnly_;
    /**
     * <code>bool active_only = 1;</code>
     * @return The activeOnly.
     */
    @java.lang.Override
    public boolean getActiveOnly() {
      return activeOnly_;
    }
    /**
     * <code>bool active_only = 1;</code>
     * @param value The activeOnly to set.
     */
    private void setActiveOnly(boolean value) {
      
      activeOnly_ = value;
    }
    /**
     * <code>bool active_only = 1;</code>
     */
    private void clearActiveOnly() {
      
      activeOnly_ = false;
    }

    public static final int INACTIVE_ONLY_FIELD_NUMBER = 2;
    private boolean inactiveOnly_;
    /**
     * <code>bool inactive_only = 2;</code>
     * @return The inactiveOnly.
     */
    @java.lang.Override
    public boolean getInactiveOnly() {
      return inactiveOnly_;
    }
    /**
     * <code>bool inactive_only = 2;</code>
     * @param value The inactiveOnly to set.
     */
    private void setInactiveOnly(boolean value) {
      
      inactiveOnly_ = value;
    }
    /**
     * <code>bool inactive_only = 2;</code>
     */
    private void clearInactiveOnly() {
      
      inactiveOnly_ = false;
    }

    public static final int PUBLIC_ONLY_FIELD_NUMBER = 3;
    private boolean publicOnly_;
    /**
     * <code>bool public_only = 3;</code>
     * @return The publicOnly.
     */
    @java.lang.Override
    public boolean getPublicOnly() {
      return publicOnly_;
    }
    /**
     * <code>bool public_only = 3;</code>
     * @param value The publicOnly to set.
     */
    private void setPublicOnly(boolean value) {
      
      publicOnly_ = value;
    }
    /**
     * <code>bool public_only = 3;</code>
     */
    private void clearPublicOnly() {
      
      publicOnly_ = false;
    }

    public static final int PRIVATE_ONLY_FIELD_NUMBER = 4;
    private boolean privateOnly_;
    /**
     * <code>bool private_only = 4;</code>
     * @return The privateOnly.
     */
    @java.lang.Override
    public boolean getPrivateOnly() {
      return privateOnly_;
    }
    /**
     * <code>bool private_only = 4;</code>
     * @param value The privateOnly to set.
     */
    private void setPrivateOnly(boolean value) {
      
      privateOnly_ = value;
    }
    /**
     * <code>bool private_only = 4;</code>
     */
    private void clearPrivateOnly() {
      
      privateOnly_ = false;
    }

    public static final int PEER_FIELD_NUMBER = 5;
    private com.google.protobuf.ByteString peer_;
    /**
     * <pre>
     *Filters the response for channels with a target peer's pubkey. If peer is
     *empty, all channels will be returned.
     * </pre>
     *
     * <code>bytes peer = 5;</code>
     * @return The peer.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPeer() {
      return peer_;
    }
    /**
     * <pre>
     *Filters the response for channels with a target peer's pubkey. If peer is
     *empty, all channels will be returned.
     * </pre>
     *
     * <code>bytes peer = 5;</code>
     * @param value The peer to set.
     */
    private void setPeer(com.google.protobuf.ByteString value) {
      value.getClass();
  
      peer_ = value;
    }
    /**
     * <pre>
     *Filters the response for channels with a target peer's pubkey. If peer is
     *empty, all channels will be returned.
     * </pre>
     *
     * <code>bytes peer = 5;</code>
     */
    private void clearPeer() {
      
      peer_ = getDefaultInstance().getPeer();
    }

    public static co.anode.anodium.Rpc.ListChannelsRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListChannelsRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListChannelsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListChannelsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListChannelsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListChannelsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListChannelsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListChannelsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListChannelsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListChannelsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListChannelsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListChannelsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ListChannelsRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ListChannelsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ListChannelsRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ListChannelsRequest)
        co.anode.anodium.Rpc.ListChannelsRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.ListChannelsRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>bool active_only = 1;</code>
       * @return The activeOnly.
       */
      @java.lang.Override
      public boolean getActiveOnly() {
        return instance.getActiveOnly();
      }
      /**
       * <code>bool active_only = 1;</code>
       * @param value The activeOnly to set.
       * @return This builder for chaining.
       */
      public Builder setActiveOnly(boolean value) {
        copyOnWrite();
        instance.setActiveOnly(value);
        return this;
      }
      /**
       * <code>bool active_only = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearActiveOnly() {
        copyOnWrite();
        instance.clearActiveOnly();
        return this;
      }

      /**
       * <code>bool inactive_only = 2;</code>
       * @return The inactiveOnly.
       */
      @java.lang.Override
      public boolean getInactiveOnly() {
        return instance.getInactiveOnly();
      }
      /**
       * <code>bool inactive_only = 2;</code>
       * @param value The inactiveOnly to set.
       * @return This builder for chaining.
       */
      public Builder setInactiveOnly(boolean value) {
        copyOnWrite();
        instance.setInactiveOnly(value);
        return this;
      }
      /**
       * <code>bool inactive_only = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearInactiveOnly() {
        copyOnWrite();
        instance.clearInactiveOnly();
        return this;
      }

      /**
       * <code>bool public_only = 3;</code>
       * @return The publicOnly.
       */
      @java.lang.Override
      public boolean getPublicOnly() {
        return instance.getPublicOnly();
      }
      /**
       * <code>bool public_only = 3;</code>
       * @param value The publicOnly to set.
       * @return This builder for chaining.
       */
      public Builder setPublicOnly(boolean value) {
        copyOnWrite();
        instance.setPublicOnly(value);
        return this;
      }
      /**
       * <code>bool public_only = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearPublicOnly() {
        copyOnWrite();
        instance.clearPublicOnly();
        return this;
      }

      /**
       * <code>bool private_only = 4;</code>
       * @return The privateOnly.
       */
      @java.lang.Override
      public boolean getPrivateOnly() {
        return instance.getPrivateOnly();
      }
      /**
       * <code>bool private_only = 4;</code>
       * @param value The privateOnly to set.
       * @return This builder for chaining.
       */
      public Builder setPrivateOnly(boolean value) {
        copyOnWrite();
        instance.setPrivateOnly(value);
        return this;
      }
      /**
       * <code>bool private_only = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearPrivateOnly() {
        copyOnWrite();
        instance.clearPrivateOnly();
        return this;
      }

      /**
       * <pre>
       *Filters the response for channels with a target peer's pubkey. If peer is
       *empty, all channels will be returned.
       * </pre>
       *
       * <code>bytes peer = 5;</code>
       * @return The peer.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPeer() {
        return instance.getPeer();
      }
      /**
       * <pre>
       *Filters the response for channels with a target peer's pubkey. If peer is
       *empty, all channels will be returned.
       * </pre>
       *
       * <code>bytes peer = 5;</code>
       * @param value The peer to set.
       * @return This builder for chaining.
       */
      public Builder setPeer(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPeer(value);
        return this;
      }
      /**
       * <pre>
       *Filters the response for channels with a target peer's pubkey. If peer is
       *empty, all channels will be returned.
       * </pre>
       *
       * <code>bytes peer = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearPeer() {
        copyOnWrite();
        instance.clearPeer();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ListChannelsRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ListChannelsRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "activeOnly_",
              "inactiveOnly_",
              "publicOnly_",
              "privateOnly_",
              "peer_",
            };
            java.lang.String info =
                "\u0000\u0005\u0000\u0000\u0001\u0005\u0005\u0000\u0000\u0000\u0001\u0007\u0002\u0007" +
                "\u0003\u0007\u0004\u0007\u0005\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ListChannelsRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ListChannelsRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ListChannelsRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ListChannelsRequest)
    private static final co.anode.anodium.Rpc.ListChannelsRequest DEFAULT_INSTANCE;
    static {
      ListChannelsRequest defaultInstance = new ListChannelsRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ListChannelsRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ListChannelsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ListChannelsRequest> PARSER;

    public static com.google.protobuf.Parser<ListChannelsRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ListChannelsResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ListChannelsResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The list of active channels
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
     */
    java.util.List<co.anode.anodium.Rpc.Channel> 
        getChannelsList();
    /**
     * <pre>
     * The list of active channels
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
     */
    co.anode.anodium.Rpc.Channel getChannels(int index);
    /**
     * <pre>
     * The list of active channels
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
     */
    int getChannelsCount();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ListChannelsResponse}
   */
  public  static final class ListChannelsResponse extends
      com.google.protobuf.GeneratedMessageLite<
          ListChannelsResponse, ListChannelsResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ListChannelsResponse)
      ListChannelsResponseOrBuilder {
    private ListChannelsResponse() {
      channels_ = emptyProtobufList();
    }
    public static final int CHANNELS_FIELD_NUMBER = 11;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Channel> channels_;
    /**
     * <pre>
     * The list of active channels
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.Channel> getChannelsList() {
      return channels_;
    }
    /**
     * <pre>
     * The list of active channels
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.ChannelOrBuilder> 
        getChannelsOrBuilderList() {
      return channels_;
    }
    /**
     * <pre>
     * The list of active channels
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
     */
    @java.lang.Override
    public int getChannelsCount() {
      return channels_.size();
    }
    /**
     * <pre>
     * The list of active channels
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Channel getChannels(int index) {
      return channels_.get(index);
    }
    /**
     * <pre>
     * The list of active channels
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
     */
    public co.anode.anodium.Rpc.ChannelOrBuilder getChannelsOrBuilder(
        int index) {
      return channels_.get(index);
    }
    private void ensureChannelsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Channel> tmp = channels_;
      if (!tmp.isModifiable()) {
        channels_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * The list of active channels
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
     */
    private void setChannels(
        int index, co.anode.anodium.Rpc.Channel value) {
      value.getClass();
  ensureChannelsIsMutable();
      channels_.set(index, value);
    }
    /**
     * <pre>
     * The list of active channels
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
     */
    private void addChannels(co.anode.anodium.Rpc.Channel value) {
      value.getClass();
  ensureChannelsIsMutable();
      channels_.add(value);
    }
    /**
     * <pre>
     * The list of active channels
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
     */
    private void addChannels(
        int index, co.anode.anodium.Rpc.Channel value) {
      value.getClass();
  ensureChannelsIsMutable();
      channels_.add(index, value);
    }
    /**
     * <pre>
     * The list of active channels
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
     */
    private void addAllChannels(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.Channel> values) {
      ensureChannelsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, channels_);
    }
    /**
     * <pre>
     * The list of active channels
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
     */
    private void clearChannels() {
      channels_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The list of active channels
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
     */
    private void removeChannels(int index) {
      ensureChannelsIsMutable();
      channels_.remove(index);
    }

    public static co.anode.anodium.Rpc.ListChannelsResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListChannelsResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListChannelsResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListChannelsResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListChannelsResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListChannelsResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListChannelsResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListChannelsResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListChannelsResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListChannelsResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListChannelsResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListChannelsResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ListChannelsResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ListChannelsResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ListChannelsResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ListChannelsResponse)
        co.anode.anodium.Rpc.ListChannelsResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.ListChannelsResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The list of active channels
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.Channel> getChannelsList() {
        return java.util.Collections.unmodifiableList(
            instance.getChannelsList());
      }
      /**
       * <pre>
       * The list of active channels
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
       */
      @java.lang.Override
      public int getChannelsCount() {
        return instance.getChannelsCount();
      }/**
       * <pre>
       * The list of active channels
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Channel getChannels(int index) {
        return instance.getChannels(index);
      }
      /**
       * <pre>
       * The list of active channels
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
       */
      public Builder setChannels(
          int index, co.anode.anodium.Rpc.Channel value) {
        copyOnWrite();
        instance.setChannels(index, value);
        return this;
      }
      /**
       * <pre>
       * The list of active channels
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
       */
      public Builder setChannels(
          int index, co.anode.anodium.Rpc.Channel.Builder builderForValue) {
        copyOnWrite();
        instance.setChannels(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of active channels
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
       */
      public Builder addChannels(co.anode.anodium.Rpc.Channel value) {
        copyOnWrite();
        instance.addChannels(value);
        return this;
      }
      /**
       * <pre>
       * The list of active channels
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
       */
      public Builder addChannels(
          int index, co.anode.anodium.Rpc.Channel value) {
        copyOnWrite();
        instance.addChannels(index, value);
        return this;
      }
      /**
       * <pre>
       * The list of active channels
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
       */
      public Builder addChannels(
          co.anode.anodium.Rpc.Channel.Builder builderForValue) {
        copyOnWrite();
        instance.addChannels(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of active channels
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
       */
      public Builder addChannels(
          int index, co.anode.anodium.Rpc.Channel.Builder builderForValue) {
        copyOnWrite();
        instance.addChannels(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of active channels
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
       */
      public Builder addAllChannels(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.Channel> values) {
        copyOnWrite();
        instance.addAllChannels(values);
        return this;
      }
      /**
       * <pre>
       * The list of active channels
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
       */
      public Builder clearChannels() {
        copyOnWrite();
        instance.clearChannels();
        return this;
      }
      /**
       * <pre>
       * The list of active channels
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Channel channels = 11;</code>
       */
      public Builder removeChannels(int index) {
        copyOnWrite();
        instance.removeChannels(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ListChannelsResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ListChannelsResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "channels_",
              co.anode.anodium.Rpc.Channel.class,
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u000b\u000b\u0001\u0000\u0001\u0000\u000b\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ListChannelsResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ListChannelsResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ListChannelsResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ListChannelsResponse)
    private static final co.anode.anodium.Rpc.ListChannelsResponse DEFAULT_INSTANCE;
    static {
      ListChannelsResponse defaultInstance = new ListChannelsResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ListChannelsResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ListChannelsResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ListChannelsResponse> PARSER;

    public static com.google.protobuf.Parser<ListChannelsResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelCloseSummaryOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelCloseSummary)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The outpoint (txid:index) of the funding transaction.
     * </pre>
     *
     * <code>string channel_point = 1;</code>
     * @return The channelPoint.
     */
    java.lang.String getChannelPoint();
    /**
     * <pre>
     * The outpoint (txid:index) of the funding transaction.
     * </pre>
     *
     * <code>string channel_point = 1;</code>
     * @return The bytes for channelPoint.
     */
    com.google.protobuf.ByteString
        getChannelPointBytes();

    /**
     * <pre>
     *  The unique channel ID for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 2 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    long getChanId();

    /**
     * <pre>
     * The hash of the genesis block that this channel resides within.
     * </pre>
     *
     * <code>string chain_hash = 3;</code>
     * @return The chainHash.
     */
    java.lang.String getChainHash();
    /**
     * <pre>
     * The hash of the genesis block that this channel resides within.
     * </pre>
     *
     * <code>string chain_hash = 3;</code>
     * @return The bytes for chainHash.
     */
    com.google.protobuf.ByteString
        getChainHashBytes();

    /**
     * <pre>
     * The txid of the transaction which ultimately closed this channel.
     * </pre>
     *
     * <code>string closing_tx_hash = 4;</code>
     * @return The closingTxHash.
     */
    java.lang.String getClosingTxHash();
    /**
     * <pre>
     * The txid of the transaction which ultimately closed this channel.
     * </pre>
     *
     * <code>string closing_tx_hash = 4;</code>
     * @return The bytes for closingTxHash.
     */
    com.google.protobuf.ByteString
        getClosingTxHashBytes();

    /**
     * <pre>
     * Public key of the remote peer that we formerly had a channel with.
     * </pre>
     *
     * <code>string remote_pubkey = 5;</code>
     * @return The remotePubkey.
     */
    java.lang.String getRemotePubkey();
    /**
     * <pre>
     * Public key of the remote peer that we formerly had a channel with.
     * </pre>
     *
     * <code>string remote_pubkey = 5;</code>
     * @return The bytes for remotePubkey.
     */
    com.google.protobuf.ByteString
        getRemotePubkeyBytes();

    /**
     * <pre>
     * Total capacity of the channel.
     * </pre>
     *
     * <code>int64 capacity = 6;</code>
     * @return The capacity.
     */
    long getCapacity();

    /**
     * <pre>
     * Height at which the funding transaction was spent.
     * </pre>
     *
     * <code>uint32 close_height = 7;</code>
     * @return The closeHeight.
     */
    int getCloseHeight();

    /**
     * <pre>
     * Settled balance at the time of channel closure
     * </pre>
     *
     * <code>int64 settled_balance = 8;</code>
     * @return The settledBalance.
     */
    long getSettledBalance();

    /**
     * <pre>
     * The sum of all the time-locked outputs at the time of channel closure
     * </pre>
     *
     * <code>int64 time_locked_balance = 9;</code>
     * @return The timeLockedBalance.
     */
    long getTimeLockedBalance();

    /**
     * <pre>
     * Details on how the channel was closed.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelCloseSummary.ClosureType close_type = 10;</code>
     * @return The enum numeric value on the wire for closeType.
     */
    int getCloseTypeValue();
    /**
     * <pre>
     * Details on how the channel was closed.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelCloseSummary.ClosureType close_type = 10;</code>
     * @return The closeType.
     */
    co.anode.anodium.Rpc.ChannelCloseSummary.ClosureType getCloseType();

    /**
     * <pre>
     *Open initiator is the party that initiated opening the channel. Note that
     *this value may be unknown if the channel was closed before we migrated to
     *store open channel information after close.
     * </pre>
     *
     * <code>.co.anode.anodium.Initiator open_initiator = 11;</code>
     * @return The enum numeric value on the wire for openInitiator.
     */
    int getOpenInitiatorValue();
    /**
     * <pre>
     *Open initiator is the party that initiated opening the channel. Note that
     *this value may be unknown if the channel was closed before we migrated to
     *store open channel information after close.
     * </pre>
     *
     * <code>.co.anode.anodium.Initiator open_initiator = 11;</code>
     * @return The openInitiator.
     */
    co.anode.anodium.Rpc.Initiator getOpenInitiator();

    /**
     * <pre>
     *Close initiator indicates which party initiated the close. This value will
     *be unknown for channels that were cooperatively closed before we started
     *tracking cooperative close initiators. Note that this indicates which party
     *initiated a close, and it is possible for both to initiate cooperative or
     *force closes, although only one party's close will be confirmed on chain.
     * </pre>
     *
     * <code>.co.anode.anodium.Initiator close_initiator = 12;</code>
     * @return The enum numeric value on the wire for closeInitiator.
     */
    int getCloseInitiatorValue();
    /**
     * <pre>
     *Close initiator indicates which party initiated the close. This value will
     *be unknown for channels that were cooperatively closed before we started
     *tracking cooperative close initiators. Note that this indicates which party
     *initiated a close, and it is possible for both to initiate cooperative or
     *force closes, although only one party's close will be confirmed on chain.
     * </pre>
     *
     * <code>.co.anode.anodium.Initiator close_initiator = 12;</code>
     * @return The closeInitiator.
     */
    co.anode.anodium.Rpc.Initiator getCloseInitiator();

    /**
     * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
     */
    java.util.List<co.anode.anodium.Rpc.Resolution> 
        getResolutionsList();
    /**
     * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
     */
    co.anode.anodium.Rpc.Resolution getResolutions(int index);
    /**
     * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
     */
    int getResolutionsCount();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChannelCloseSummary}
   */
  public  static final class ChannelCloseSummary extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelCloseSummary, ChannelCloseSummary.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelCloseSummary)
      ChannelCloseSummaryOrBuilder {
    private ChannelCloseSummary() {
      channelPoint_ = "";
      chainHash_ = "";
      closingTxHash_ = "";
      remotePubkey_ = "";
      resolutions_ = emptyProtobufList();
    }
    /**
     * Protobuf enum {@code co.anode.anodium.ChannelCloseSummary.ClosureType}
     */
    public enum ClosureType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>COOPERATIVE_CLOSE = 0;</code>
       */
      COOPERATIVE_CLOSE(0),
      /**
       * <code>LOCAL_FORCE_CLOSE = 1;</code>
       */
      LOCAL_FORCE_CLOSE(1),
      /**
       * <code>REMOTE_FORCE_CLOSE = 2;</code>
       */
      REMOTE_FORCE_CLOSE(2),
      /**
       * <code>BREACH_CLOSE = 3;</code>
       */
      BREACH_CLOSE(3),
      /**
       * <code>FUNDING_CANCELED = 4;</code>
       */
      FUNDING_CANCELED(4),
      /**
       * <code>ABANDONED = 5;</code>
       */
      ABANDONED(5),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>COOPERATIVE_CLOSE = 0;</code>
       */
      public static final int COOPERATIVE_CLOSE_VALUE = 0;
      /**
       * <code>LOCAL_FORCE_CLOSE = 1;</code>
       */
      public static final int LOCAL_FORCE_CLOSE_VALUE = 1;
      /**
       * <code>REMOTE_FORCE_CLOSE = 2;</code>
       */
      public static final int REMOTE_FORCE_CLOSE_VALUE = 2;
      /**
       * <code>BREACH_CLOSE = 3;</code>
       */
      public static final int BREACH_CLOSE_VALUE = 3;
      /**
       * <code>FUNDING_CANCELED = 4;</code>
       */
      public static final int FUNDING_CANCELED_VALUE = 4;
      /**
       * <code>ABANDONED = 5;</code>
       */
      public static final int ABANDONED_VALUE = 5;


      @java.lang.Override
      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ClosureType valueOf(int value) {
        return forNumber(value);
      }

      public static ClosureType forNumber(int value) {
        switch (value) {
          case 0: return COOPERATIVE_CLOSE;
          case 1: return LOCAL_FORCE_CLOSE;
          case 2: return REMOTE_FORCE_CLOSE;
          case 3: return BREACH_CLOSE;
          case 4: return FUNDING_CANCELED;
          case 5: return ABANDONED;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ClosureType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ClosureType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ClosureType>() {
              @java.lang.Override
              public ClosureType findValueByNumber(int number) {
                return ClosureType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return ClosureTypeVerifier.INSTANCE;
      }

      private static final class ClosureTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new ClosureTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return ClosureType.forNumber(number) != null;
              }
            };

      private final int value;

      private ClosureType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:co.anode.anodium.ChannelCloseSummary.ClosureType)
    }

    public static final int CHANNEL_POINT_FIELD_NUMBER = 1;
    private java.lang.String channelPoint_;
    /**
     * <pre>
     * The outpoint (txid:index) of the funding transaction.
     * </pre>
     *
     * <code>string channel_point = 1;</code>
     * @return The channelPoint.
     */
    @java.lang.Override
    public java.lang.String getChannelPoint() {
      return channelPoint_;
    }
    /**
     * <pre>
     * The outpoint (txid:index) of the funding transaction.
     * </pre>
     *
     * <code>string channel_point = 1;</code>
     * @return The bytes for channelPoint.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getChannelPointBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(channelPoint_);
    }
    /**
     * <pre>
     * The outpoint (txid:index) of the funding transaction.
     * </pre>
     *
     * <code>string channel_point = 1;</code>
     * @param value The channelPoint to set.
     */
    private void setChannelPoint(
        java.lang.String value) {
      value.getClass();
  
      channelPoint_ = value;
    }
    /**
     * <pre>
     * The outpoint (txid:index) of the funding transaction.
     * </pre>
     *
     * <code>string channel_point = 1;</code>
     */
    private void clearChannelPoint() {
      
      channelPoint_ = getDefaultInstance().getChannelPoint();
    }
    /**
     * <pre>
     * The outpoint (txid:index) of the funding transaction.
     * </pre>
     *
     * <code>string channel_point = 1;</code>
     * @param value The bytes for channelPoint to set.
     */
    private void setChannelPointBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      channelPoint_ = value.toStringUtf8();
      
    }

    public static final int CHAN_ID_FIELD_NUMBER = 2;
    private long chanId_;
    /**
     * <pre>
     *  The unique channel ID for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 2 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    @java.lang.Override
    public long getChanId() {
      return chanId_;
    }
    /**
     * <pre>
     *  The unique channel ID for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 2 [jstype = JS_STRING];</code>
     * @param value The chanId to set.
     */
    private void setChanId(long value) {
      
      chanId_ = value;
    }
    /**
     * <pre>
     *  The unique channel ID for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 2 [jstype = JS_STRING];</code>
     */
    private void clearChanId() {
      
      chanId_ = 0L;
    }

    public static final int CHAIN_HASH_FIELD_NUMBER = 3;
    private java.lang.String chainHash_;
    /**
     * <pre>
     * The hash of the genesis block that this channel resides within.
     * </pre>
     *
     * <code>string chain_hash = 3;</code>
     * @return The chainHash.
     */
    @java.lang.Override
    public java.lang.String getChainHash() {
      return chainHash_;
    }
    /**
     * <pre>
     * The hash of the genesis block that this channel resides within.
     * </pre>
     *
     * <code>string chain_hash = 3;</code>
     * @return The bytes for chainHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getChainHashBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(chainHash_);
    }
    /**
     * <pre>
     * The hash of the genesis block that this channel resides within.
     * </pre>
     *
     * <code>string chain_hash = 3;</code>
     * @param value The chainHash to set.
     */
    private void setChainHash(
        java.lang.String value) {
      value.getClass();
  
      chainHash_ = value;
    }
    /**
     * <pre>
     * The hash of the genesis block that this channel resides within.
     * </pre>
     *
     * <code>string chain_hash = 3;</code>
     */
    private void clearChainHash() {
      
      chainHash_ = getDefaultInstance().getChainHash();
    }
    /**
     * <pre>
     * The hash of the genesis block that this channel resides within.
     * </pre>
     *
     * <code>string chain_hash = 3;</code>
     * @param value The bytes for chainHash to set.
     */
    private void setChainHashBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      chainHash_ = value.toStringUtf8();
      
    }

    public static final int CLOSING_TX_HASH_FIELD_NUMBER = 4;
    private java.lang.String closingTxHash_;
    /**
     * <pre>
     * The txid of the transaction which ultimately closed this channel.
     * </pre>
     *
     * <code>string closing_tx_hash = 4;</code>
     * @return The closingTxHash.
     */
    @java.lang.Override
    public java.lang.String getClosingTxHash() {
      return closingTxHash_;
    }
    /**
     * <pre>
     * The txid of the transaction which ultimately closed this channel.
     * </pre>
     *
     * <code>string closing_tx_hash = 4;</code>
     * @return The bytes for closingTxHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getClosingTxHashBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(closingTxHash_);
    }
    /**
     * <pre>
     * The txid of the transaction which ultimately closed this channel.
     * </pre>
     *
     * <code>string closing_tx_hash = 4;</code>
     * @param value The closingTxHash to set.
     */
    private void setClosingTxHash(
        java.lang.String value) {
      value.getClass();
  
      closingTxHash_ = value;
    }
    /**
     * <pre>
     * The txid of the transaction which ultimately closed this channel.
     * </pre>
     *
     * <code>string closing_tx_hash = 4;</code>
     */
    private void clearClosingTxHash() {
      
      closingTxHash_ = getDefaultInstance().getClosingTxHash();
    }
    /**
     * <pre>
     * The txid of the transaction which ultimately closed this channel.
     * </pre>
     *
     * <code>string closing_tx_hash = 4;</code>
     * @param value The bytes for closingTxHash to set.
     */
    private void setClosingTxHashBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      closingTxHash_ = value.toStringUtf8();
      
    }

    public static final int REMOTE_PUBKEY_FIELD_NUMBER = 5;
    private java.lang.String remotePubkey_;
    /**
     * <pre>
     * Public key of the remote peer that we formerly had a channel with.
     * </pre>
     *
     * <code>string remote_pubkey = 5;</code>
     * @return The remotePubkey.
     */
    @java.lang.Override
    public java.lang.String getRemotePubkey() {
      return remotePubkey_;
    }
    /**
     * <pre>
     * Public key of the remote peer that we formerly had a channel with.
     * </pre>
     *
     * <code>string remote_pubkey = 5;</code>
     * @return The bytes for remotePubkey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRemotePubkeyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(remotePubkey_);
    }
    /**
     * <pre>
     * Public key of the remote peer that we formerly had a channel with.
     * </pre>
     *
     * <code>string remote_pubkey = 5;</code>
     * @param value The remotePubkey to set.
     */
    private void setRemotePubkey(
        java.lang.String value) {
      value.getClass();
  
      remotePubkey_ = value;
    }
    /**
     * <pre>
     * Public key of the remote peer that we formerly had a channel with.
     * </pre>
     *
     * <code>string remote_pubkey = 5;</code>
     */
    private void clearRemotePubkey() {
      
      remotePubkey_ = getDefaultInstance().getRemotePubkey();
    }
    /**
     * <pre>
     * Public key of the remote peer that we formerly had a channel with.
     * </pre>
     *
     * <code>string remote_pubkey = 5;</code>
     * @param value The bytes for remotePubkey to set.
     */
    private void setRemotePubkeyBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      remotePubkey_ = value.toStringUtf8();
      
    }

    public static final int CAPACITY_FIELD_NUMBER = 6;
    private long capacity_;
    /**
     * <pre>
     * Total capacity of the channel.
     * </pre>
     *
     * <code>int64 capacity = 6;</code>
     * @return The capacity.
     */
    @java.lang.Override
    public long getCapacity() {
      return capacity_;
    }
    /**
     * <pre>
     * Total capacity of the channel.
     * </pre>
     *
     * <code>int64 capacity = 6;</code>
     * @param value The capacity to set.
     */
    private void setCapacity(long value) {
      
      capacity_ = value;
    }
    /**
     * <pre>
     * Total capacity of the channel.
     * </pre>
     *
     * <code>int64 capacity = 6;</code>
     */
    private void clearCapacity() {
      
      capacity_ = 0L;
    }

    public static final int CLOSE_HEIGHT_FIELD_NUMBER = 7;
    private int closeHeight_;
    /**
     * <pre>
     * Height at which the funding transaction was spent.
     * </pre>
     *
     * <code>uint32 close_height = 7;</code>
     * @return The closeHeight.
     */
    @java.lang.Override
    public int getCloseHeight() {
      return closeHeight_;
    }
    /**
     * <pre>
     * Height at which the funding transaction was spent.
     * </pre>
     *
     * <code>uint32 close_height = 7;</code>
     * @param value The closeHeight to set.
     */
    private void setCloseHeight(int value) {
      
      closeHeight_ = value;
    }
    /**
     * <pre>
     * Height at which the funding transaction was spent.
     * </pre>
     *
     * <code>uint32 close_height = 7;</code>
     */
    private void clearCloseHeight() {
      
      closeHeight_ = 0;
    }

    public static final int SETTLED_BALANCE_FIELD_NUMBER = 8;
    private long settledBalance_;
    /**
     * <pre>
     * Settled balance at the time of channel closure
     * </pre>
     *
     * <code>int64 settled_balance = 8;</code>
     * @return The settledBalance.
     */
    @java.lang.Override
    public long getSettledBalance() {
      return settledBalance_;
    }
    /**
     * <pre>
     * Settled balance at the time of channel closure
     * </pre>
     *
     * <code>int64 settled_balance = 8;</code>
     * @param value The settledBalance to set.
     */
    private void setSettledBalance(long value) {
      
      settledBalance_ = value;
    }
    /**
     * <pre>
     * Settled balance at the time of channel closure
     * </pre>
     *
     * <code>int64 settled_balance = 8;</code>
     */
    private void clearSettledBalance() {
      
      settledBalance_ = 0L;
    }

    public static final int TIME_LOCKED_BALANCE_FIELD_NUMBER = 9;
    private long timeLockedBalance_;
    /**
     * <pre>
     * The sum of all the time-locked outputs at the time of channel closure
     * </pre>
     *
     * <code>int64 time_locked_balance = 9;</code>
     * @return The timeLockedBalance.
     */
    @java.lang.Override
    public long getTimeLockedBalance() {
      return timeLockedBalance_;
    }
    /**
     * <pre>
     * The sum of all the time-locked outputs at the time of channel closure
     * </pre>
     *
     * <code>int64 time_locked_balance = 9;</code>
     * @param value The timeLockedBalance to set.
     */
    private void setTimeLockedBalance(long value) {
      
      timeLockedBalance_ = value;
    }
    /**
     * <pre>
     * The sum of all the time-locked outputs at the time of channel closure
     * </pre>
     *
     * <code>int64 time_locked_balance = 9;</code>
     */
    private void clearTimeLockedBalance() {
      
      timeLockedBalance_ = 0L;
    }

    public static final int CLOSE_TYPE_FIELD_NUMBER = 10;
    private int closeType_;
    /**
     * <pre>
     * Details on how the channel was closed.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelCloseSummary.ClosureType close_type = 10;</code>
     * @return The enum numeric value on the wire for closeType.
     */
    @java.lang.Override
    public int getCloseTypeValue() {
      return closeType_;
    }
    /**
     * <pre>
     * Details on how the channel was closed.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelCloseSummary.ClosureType close_type = 10;</code>
     * @return The closeType.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelCloseSummary.ClosureType getCloseType() {
      co.anode.anodium.Rpc.ChannelCloseSummary.ClosureType result = co.anode.anodium.Rpc.ChannelCloseSummary.ClosureType.forNumber(closeType_);
      return result == null ? co.anode.anodium.Rpc.ChannelCloseSummary.ClosureType.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * Details on how the channel was closed.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelCloseSummary.ClosureType close_type = 10;</code>
     * @param value The enum numeric value on the wire for closeType to set.
     */
    private void setCloseTypeValue(int value) {
        closeType_ = value;
    }
    /**
     * <pre>
     * Details on how the channel was closed.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelCloseSummary.ClosureType close_type = 10;</code>
     * @param value The closeType to set.
     */
    private void setCloseType(co.anode.anodium.Rpc.ChannelCloseSummary.ClosureType value) {
      closeType_ = value.getNumber();
      
    }
    /**
     * <pre>
     * Details on how the channel was closed.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelCloseSummary.ClosureType close_type = 10;</code>
     */
    private void clearCloseType() {
      
      closeType_ = 0;
    }

    public static final int OPEN_INITIATOR_FIELD_NUMBER = 11;
    private int openInitiator_;
    /**
     * <pre>
     *Open initiator is the party that initiated opening the channel. Note that
     *this value may be unknown if the channel was closed before we migrated to
     *store open channel information after close.
     * </pre>
     *
     * <code>.co.anode.anodium.Initiator open_initiator = 11;</code>
     * @return The enum numeric value on the wire for openInitiator.
     */
    @java.lang.Override
    public int getOpenInitiatorValue() {
      return openInitiator_;
    }
    /**
     * <pre>
     *Open initiator is the party that initiated opening the channel. Note that
     *this value may be unknown if the channel was closed before we migrated to
     *store open channel information after close.
     * </pre>
     *
     * <code>.co.anode.anodium.Initiator open_initiator = 11;</code>
     * @return The openInitiator.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Initiator getOpenInitiator() {
      co.anode.anodium.Rpc.Initiator result = co.anode.anodium.Rpc.Initiator.forNumber(openInitiator_);
      return result == null ? co.anode.anodium.Rpc.Initiator.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     *Open initiator is the party that initiated opening the channel. Note that
     *this value may be unknown if the channel was closed before we migrated to
     *store open channel information after close.
     * </pre>
     *
     * <code>.co.anode.anodium.Initiator open_initiator = 11;</code>
     * @param value The enum numeric value on the wire for openInitiator to set.
     */
    private void setOpenInitiatorValue(int value) {
        openInitiator_ = value;
    }
    /**
     * <pre>
     *Open initiator is the party that initiated opening the channel. Note that
     *this value may be unknown if the channel was closed before we migrated to
     *store open channel information after close.
     * </pre>
     *
     * <code>.co.anode.anodium.Initiator open_initiator = 11;</code>
     * @param value The openInitiator to set.
     */
    private void setOpenInitiator(co.anode.anodium.Rpc.Initiator value) {
      openInitiator_ = value.getNumber();
      
    }
    /**
     * <pre>
     *Open initiator is the party that initiated opening the channel. Note that
     *this value may be unknown if the channel was closed before we migrated to
     *store open channel information after close.
     * </pre>
     *
     * <code>.co.anode.anodium.Initiator open_initiator = 11;</code>
     */
    private void clearOpenInitiator() {
      
      openInitiator_ = 0;
    }

    public static final int CLOSE_INITIATOR_FIELD_NUMBER = 12;
    private int closeInitiator_;
    /**
     * <pre>
     *Close initiator indicates which party initiated the close. This value will
     *be unknown for channels that were cooperatively closed before we started
     *tracking cooperative close initiators. Note that this indicates which party
     *initiated a close, and it is possible for both to initiate cooperative or
     *force closes, although only one party's close will be confirmed on chain.
     * </pre>
     *
     * <code>.co.anode.anodium.Initiator close_initiator = 12;</code>
     * @return The enum numeric value on the wire for closeInitiator.
     */
    @java.lang.Override
    public int getCloseInitiatorValue() {
      return closeInitiator_;
    }
    /**
     * <pre>
     *Close initiator indicates which party initiated the close. This value will
     *be unknown for channels that were cooperatively closed before we started
     *tracking cooperative close initiators. Note that this indicates which party
     *initiated a close, and it is possible for both to initiate cooperative or
     *force closes, although only one party's close will be confirmed on chain.
     * </pre>
     *
     * <code>.co.anode.anodium.Initiator close_initiator = 12;</code>
     * @return The closeInitiator.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Initiator getCloseInitiator() {
      co.anode.anodium.Rpc.Initiator result = co.anode.anodium.Rpc.Initiator.forNumber(closeInitiator_);
      return result == null ? co.anode.anodium.Rpc.Initiator.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     *Close initiator indicates which party initiated the close. This value will
     *be unknown for channels that were cooperatively closed before we started
     *tracking cooperative close initiators. Note that this indicates which party
     *initiated a close, and it is possible for both to initiate cooperative or
     *force closes, although only one party's close will be confirmed on chain.
     * </pre>
     *
     * <code>.co.anode.anodium.Initiator close_initiator = 12;</code>
     * @param value The enum numeric value on the wire for closeInitiator to set.
     */
    private void setCloseInitiatorValue(int value) {
        closeInitiator_ = value;
    }
    /**
     * <pre>
     *Close initiator indicates which party initiated the close. This value will
     *be unknown for channels that were cooperatively closed before we started
     *tracking cooperative close initiators. Note that this indicates which party
     *initiated a close, and it is possible for both to initiate cooperative or
     *force closes, although only one party's close will be confirmed on chain.
     * </pre>
     *
     * <code>.co.anode.anodium.Initiator close_initiator = 12;</code>
     * @param value The closeInitiator to set.
     */
    private void setCloseInitiator(co.anode.anodium.Rpc.Initiator value) {
      closeInitiator_ = value.getNumber();
      
    }
    /**
     * <pre>
     *Close initiator indicates which party initiated the close. This value will
     *be unknown for channels that were cooperatively closed before we started
     *tracking cooperative close initiators. Note that this indicates which party
     *initiated a close, and it is possible for both to initiate cooperative or
     *force closes, although only one party's close will be confirmed on chain.
     * </pre>
     *
     * <code>.co.anode.anodium.Initiator close_initiator = 12;</code>
     */
    private void clearCloseInitiator() {
      
      closeInitiator_ = 0;
    }

    public static final int RESOLUTIONS_FIELD_NUMBER = 13;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Resolution> resolutions_;
    /**
     * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.Resolution> getResolutionsList() {
      return resolutions_;
    }
    /**
     * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.ResolutionOrBuilder> 
        getResolutionsOrBuilderList() {
      return resolutions_;
    }
    /**
     * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
     */
    @java.lang.Override
    public int getResolutionsCount() {
      return resolutions_.size();
    }
    /**
     * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Resolution getResolutions(int index) {
      return resolutions_.get(index);
    }
    /**
     * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
     */
    public co.anode.anodium.Rpc.ResolutionOrBuilder getResolutionsOrBuilder(
        int index) {
      return resolutions_.get(index);
    }
    private void ensureResolutionsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Resolution> tmp = resolutions_;
      if (!tmp.isModifiable()) {
        resolutions_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
     */
    private void setResolutions(
        int index, co.anode.anodium.Rpc.Resolution value) {
      value.getClass();
  ensureResolutionsIsMutable();
      resolutions_.set(index, value);
    }
    /**
     * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
     */
    private void addResolutions(co.anode.anodium.Rpc.Resolution value) {
      value.getClass();
  ensureResolutionsIsMutable();
      resolutions_.add(value);
    }
    /**
     * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
     */
    private void addResolutions(
        int index, co.anode.anodium.Rpc.Resolution value) {
      value.getClass();
  ensureResolutionsIsMutable();
      resolutions_.add(index, value);
    }
    /**
     * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
     */
    private void addAllResolutions(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.Resolution> values) {
      ensureResolutionsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, resolutions_);
    }
    /**
     * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
     */
    private void clearResolutions() {
      resolutions_ = emptyProtobufList();
    }
    /**
     * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
     */
    private void removeResolutions(int index) {
      ensureResolutionsIsMutable();
      resolutions_.remove(index);
    }

    public static co.anode.anodium.Rpc.ChannelCloseSummary parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelCloseSummary parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelCloseSummary parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelCloseSummary parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelCloseSummary parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelCloseSummary parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelCloseSummary parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelCloseSummary parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelCloseSummary parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelCloseSummary parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelCloseSummary parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelCloseSummary parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelCloseSummary prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChannelCloseSummary}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelCloseSummary, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelCloseSummary)
        co.anode.anodium.Rpc.ChannelCloseSummaryOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelCloseSummary.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The outpoint (txid:index) of the funding transaction.
       * </pre>
       *
       * <code>string channel_point = 1;</code>
       * @return The channelPoint.
       */
      @java.lang.Override
      public java.lang.String getChannelPoint() {
        return instance.getChannelPoint();
      }
      /**
       * <pre>
       * The outpoint (txid:index) of the funding transaction.
       * </pre>
       *
       * <code>string channel_point = 1;</code>
       * @return The bytes for channelPoint.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getChannelPointBytes() {
        return instance.getChannelPointBytes();
      }
      /**
       * <pre>
       * The outpoint (txid:index) of the funding transaction.
       * </pre>
       *
       * <code>string channel_point = 1;</code>
       * @param value The channelPoint to set.
       * @return This builder for chaining.
       */
      public Builder setChannelPoint(
          java.lang.String value) {
        copyOnWrite();
        instance.setChannelPoint(value);
        return this;
      }
      /**
       * <pre>
       * The outpoint (txid:index) of the funding transaction.
       * </pre>
       *
       * <code>string channel_point = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearChannelPoint() {
        copyOnWrite();
        instance.clearChannelPoint();
        return this;
      }
      /**
       * <pre>
       * The outpoint (txid:index) of the funding transaction.
       * </pre>
       *
       * <code>string channel_point = 1;</code>
       * @param value The bytes for channelPoint to set.
       * @return This builder for chaining.
       */
      public Builder setChannelPointBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setChannelPointBytes(value);
        return this;
      }

      /**
       * <pre>
       *  The unique channel ID for the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 2 [jstype = JS_STRING];</code>
       * @return The chanId.
       */
      @java.lang.Override
      public long getChanId() {
        return instance.getChanId();
      }
      /**
       * <pre>
       *  The unique channel ID for the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 2 [jstype = JS_STRING];</code>
       * @param value The chanId to set.
       * @return This builder for chaining.
       */
      public Builder setChanId(long value) {
        copyOnWrite();
        instance.setChanId(value);
        return this;
      }
      /**
       * <pre>
       *  The unique channel ID for the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 2 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearChanId() {
        copyOnWrite();
        instance.clearChanId();
        return this;
      }

      /**
       * <pre>
       * The hash of the genesis block that this channel resides within.
       * </pre>
       *
       * <code>string chain_hash = 3;</code>
       * @return The chainHash.
       */
      @java.lang.Override
      public java.lang.String getChainHash() {
        return instance.getChainHash();
      }
      /**
       * <pre>
       * The hash of the genesis block that this channel resides within.
       * </pre>
       *
       * <code>string chain_hash = 3;</code>
       * @return The bytes for chainHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getChainHashBytes() {
        return instance.getChainHashBytes();
      }
      /**
       * <pre>
       * The hash of the genesis block that this channel resides within.
       * </pre>
       *
       * <code>string chain_hash = 3;</code>
       * @param value The chainHash to set.
       * @return This builder for chaining.
       */
      public Builder setChainHash(
          java.lang.String value) {
        copyOnWrite();
        instance.setChainHash(value);
        return this;
      }
      /**
       * <pre>
       * The hash of the genesis block that this channel resides within.
       * </pre>
       *
       * <code>string chain_hash = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearChainHash() {
        copyOnWrite();
        instance.clearChainHash();
        return this;
      }
      /**
       * <pre>
       * The hash of the genesis block that this channel resides within.
       * </pre>
       *
       * <code>string chain_hash = 3;</code>
       * @param value The bytes for chainHash to set.
       * @return This builder for chaining.
       */
      public Builder setChainHashBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setChainHashBytes(value);
        return this;
      }

      /**
       * <pre>
       * The txid of the transaction which ultimately closed this channel.
       * </pre>
       *
       * <code>string closing_tx_hash = 4;</code>
       * @return The closingTxHash.
       */
      @java.lang.Override
      public java.lang.String getClosingTxHash() {
        return instance.getClosingTxHash();
      }
      /**
       * <pre>
       * The txid of the transaction which ultimately closed this channel.
       * </pre>
       *
       * <code>string closing_tx_hash = 4;</code>
       * @return The bytes for closingTxHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getClosingTxHashBytes() {
        return instance.getClosingTxHashBytes();
      }
      /**
       * <pre>
       * The txid of the transaction which ultimately closed this channel.
       * </pre>
       *
       * <code>string closing_tx_hash = 4;</code>
       * @param value The closingTxHash to set.
       * @return This builder for chaining.
       */
      public Builder setClosingTxHash(
          java.lang.String value) {
        copyOnWrite();
        instance.setClosingTxHash(value);
        return this;
      }
      /**
       * <pre>
       * The txid of the transaction which ultimately closed this channel.
       * </pre>
       *
       * <code>string closing_tx_hash = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearClosingTxHash() {
        copyOnWrite();
        instance.clearClosingTxHash();
        return this;
      }
      /**
       * <pre>
       * The txid of the transaction which ultimately closed this channel.
       * </pre>
       *
       * <code>string closing_tx_hash = 4;</code>
       * @param value The bytes for closingTxHash to set.
       * @return This builder for chaining.
       */
      public Builder setClosingTxHashBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setClosingTxHashBytes(value);
        return this;
      }

      /**
       * <pre>
       * Public key of the remote peer that we formerly had a channel with.
       * </pre>
       *
       * <code>string remote_pubkey = 5;</code>
       * @return The remotePubkey.
       */
      @java.lang.Override
      public java.lang.String getRemotePubkey() {
        return instance.getRemotePubkey();
      }
      /**
       * <pre>
       * Public key of the remote peer that we formerly had a channel with.
       * </pre>
       *
       * <code>string remote_pubkey = 5;</code>
       * @return The bytes for remotePubkey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getRemotePubkeyBytes() {
        return instance.getRemotePubkeyBytes();
      }
      /**
       * <pre>
       * Public key of the remote peer that we formerly had a channel with.
       * </pre>
       *
       * <code>string remote_pubkey = 5;</code>
       * @param value The remotePubkey to set.
       * @return This builder for chaining.
       */
      public Builder setRemotePubkey(
          java.lang.String value) {
        copyOnWrite();
        instance.setRemotePubkey(value);
        return this;
      }
      /**
       * <pre>
       * Public key of the remote peer that we formerly had a channel with.
       * </pre>
       *
       * <code>string remote_pubkey = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearRemotePubkey() {
        copyOnWrite();
        instance.clearRemotePubkey();
        return this;
      }
      /**
       * <pre>
       * Public key of the remote peer that we formerly had a channel with.
       * </pre>
       *
       * <code>string remote_pubkey = 5;</code>
       * @param value The bytes for remotePubkey to set.
       * @return This builder for chaining.
       */
      public Builder setRemotePubkeyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setRemotePubkeyBytes(value);
        return this;
      }

      /**
       * <pre>
       * Total capacity of the channel.
       * </pre>
       *
       * <code>int64 capacity = 6;</code>
       * @return The capacity.
       */
      @java.lang.Override
      public long getCapacity() {
        return instance.getCapacity();
      }
      /**
       * <pre>
       * Total capacity of the channel.
       * </pre>
       *
       * <code>int64 capacity = 6;</code>
       * @param value The capacity to set.
       * @return This builder for chaining.
       */
      public Builder setCapacity(long value) {
        copyOnWrite();
        instance.setCapacity(value);
        return this;
      }
      /**
       * <pre>
       * Total capacity of the channel.
       * </pre>
       *
       * <code>int64 capacity = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearCapacity() {
        copyOnWrite();
        instance.clearCapacity();
        return this;
      }

      /**
       * <pre>
       * Height at which the funding transaction was spent.
       * </pre>
       *
       * <code>uint32 close_height = 7;</code>
       * @return The closeHeight.
       */
      @java.lang.Override
      public int getCloseHeight() {
        return instance.getCloseHeight();
      }
      /**
       * <pre>
       * Height at which the funding transaction was spent.
       * </pre>
       *
       * <code>uint32 close_height = 7;</code>
       * @param value The closeHeight to set.
       * @return This builder for chaining.
       */
      public Builder setCloseHeight(int value) {
        copyOnWrite();
        instance.setCloseHeight(value);
        return this;
      }
      /**
       * <pre>
       * Height at which the funding transaction was spent.
       * </pre>
       *
       * <code>uint32 close_height = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearCloseHeight() {
        copyOnWrite();
        instance.clearCloseHeight();
        return this;
      }

      /**
       * <pre>
       * Settled balance at the time of channel closure
       * </pre>
       *
       * <code>int64 settled_balance = 8;</code>
       * @return The settledBalance.
       */
      @java.lang.Override
      public long getSettledBalance() {
        return instance.getSettledBalance();
      }
      /**
       * <pre>
       * Settled balance at the time of channel closure
       * </pre>
       *
       * <code>int64 settled_balance = 8;</code>
       * @param value The settledBalance to set.
       * @return This builder for chaining.
       */
      public Builder setSettledBalance(long value) {
        copyOnWrite();
        instance.setSettledBalance(value);
        return this;
      }
      /**
       * <pre>
       * Settled balance at the time of channel closure
       * </pre>
       *
       * <code>int64 settled_balance = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearSettledBalance() {
        copyOnWrite();
        instance.clearSettledBalance();
        return this;
      }

      /**
       * <pre>
       * The sum of all the time-locked outputs at the time of channel closure
       * </pre>
       *
       * <code>int64 time_locked_balance = 9;</code>
       * @return The timeLockedBalance.
       */
      @java.lang.Override
      public long getTimeLockedBalance() {
        return instance.getTimeLockedBalance();
      }
      /**
       * <pre>
       * The sum of all the time-locked outputs at the time of channel closure
       * </pre>
       *
       * <code>int64 time_locked_balance = 9;</code>
       * @param value The timeLockedBalance to set.
       * @return This builder for chaining.
       */
      public Builder setTimeLockedBalance(long value) {
        copyOnWrite();
        instance.setTimeLockedBalance(value);
        return this;
      }
      /**
       * <pre>
       * The sum of all the time-locked outputs at the time of channel closure
       * </pre>
       *
       * <code>int64 time_locked_balance = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimeLockedBalance() {
        copyOnWrite();
        instance.clearTimeLockedBalance();
        return this;
      }

      /**
       * <pre>
       * Details on how the channel was closed.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelCloseSummary.ClosureType close_type = 10;</code>
       * @return The enum numeric value on the wire for closeType.
       */
      @java.lang.Override
      public int getCloseTypeValue() {
        return instance.getCloseTypeValue();
      }
      /**
       * <pre>
       * Details on how the channel was closed.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelCloseSummary.ClosureType close_type = 10;</code>
       * @param value The closeType to set.
       * @return This builder for chaining.
       */
      public Builder setCloseTypeValue(int value) {
        copyOnWrite();
        instance.setCloseTypeValue(value);
        return this;
      }
      /**
       * <pre>
       * Details on how the channel was closed.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelCloseSummary.ClosureType close_type = 10;</code>
       * @return The closeType.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelCloseSummary.ClosureType getCloseType() {
        return instance.getCloseType();
      }
      /**
       * <pre>
       * Details on how the channel was closed.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelCloseSummary.ClosureType close_type = 10;</code>
       * @param value The enum numeric value on the wire for closeType to set.
       * @return This builder for chaining.
       */
      public Builder setCloseType(co.anode.anodium.Rpc.ChannelCloseSummary.ClosureType value) {
        copyOnWrite();
        instance.setCloseType(value);
        return this;
      }
      /**
       * <pre>
       * Details on how the channel was closed.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelCloseSummary.ClosureType close_type = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearCloseType() {
        copyOnWrite();
        instance.clearCloseType();
        return this;
      }

      /**
       * <pre>
       *Open initiator is the party that initiated opening the channel. Note that
       *this value may be unknown if the channel was closed before we migrated to
       *store open channel information after close.
       * </pre>
       *
       * <code>.co.anode.anodium.Initiator open_initiator = 11;</code>
       * @return The enum numeric value on the wire for openInitiator.
       */
      @java.lang.Override
      public int getOpenInitiatorValue() {
        return instance.getOpenInitiatorValue();
      }
      /**
       * <pre>
       *Open initiator is the party that initiated opening the channel. Note that
       *this value may be unknown if the channel was closed before we migrated to
       *store open channel information after close.
       * </pre>
       *
       * <code>.co.anode.anodium.Initiator open_initiator = 11;</code>
       * @param value The openInitiator to set.
       * @return This builder for chaining.
       */
      public Builder setOpenInitiatorValue(int value) {
        copyOnWrite();
        instance.setOpenInitiatorValue(value);
        return this;
      }
      /**
       * <pre>
       *Open initiator is the party that initiated opening the channel. Note that
       *this value may be unknown if the channel was closed before we migrated to
       *store open channel information after close.
       * </pre>
       *
       * <code>.co.anode.anodium.Initiator open_initiator = 11;</code>
       * @return The openInitiator.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Initiator getOpenInitiator() {
        return instance.getOpenInitiator();
      }
      /**
       * <pre>
       *Open initiator is the party that initiated opening the channel. Note that
       *this value may be unknown if the channel was closed before we migrated to
       *store open channel information after close.
       * </pre>
       *
       * <code>.co.anode.anodium.Initiator open_initiator = 11;</code>
       * @param value The enum numeric value on the wire for openInitiator to set.
       * @return This builder for chaining.
       */
      public Builder setOpenInitiator(co.anode.anodium.Rpc.Initiator value) {
        copyOnWrite();
        instance.setOpenInitiator(value);
        return this;
      }
      /**
       * <pre>
       *Open initiator is the party that initiated opening the channel. Note that
       *this value may be unknown if the channel was closed before we migrated to
       *store open channel information after close.
       * </pre>
       *
       * <code>.co.anode.anodium.Initiator open_initiator = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearOpenInitiator() {
        copyOnWrite();
        instance.clearOpenInitiator();
        return this;
      }

      /**
       * <pre>
       *Close initiator indicates which party initiated the close. This value will
       *be unknown for channels that were cooperatively closed before we started
       *tracking cooperative close initiators. Note that this indicates which party
       *initiated a close, and it is possible for both to initiate cooperative or
       *force closes, although only one party's close will be confirmed on chain.
       * </pre>
       *
       * <code>.co.anode.anodium.Initiator close_initiator = 12;</code>
       * @return The enum numeric value on the wire for closeInitiator.
       */
      @java.lang.Override
      public int getCloseInitiatorValue() {
        return instance.getCloseInitiatorValue();
      }
      /**
       * <pre>
       *Close initiator indicates which party initiated the close. This value will
       *be unknown for channels that were cooperatively closed before we started
       *tracking cooperative close initiators. Note that this indicates which party
       *initiated a close, and it is possible for both to initiate cooperative or
       *force closes, although only one party's close will be confirmed on chain.
       * </pre>
       *
       * <code>.co.anode.anodium.Initiator close_initiator = 12;</code>
       * @param value The closeInitiator to set.
       * @return This builder for chaining.
       */
      public Builder setCloseInitiatorValue(int value) {
        copyOnWrite();
        instance.setCloseInitiatorValue(value);
        return this;
      }
      /**
       * <pre>
       *Close initiator indicates which party initiated the close. This value will
       *be unknown for channels that were cooperatively closed before we started
       *tracking cooperative close initiators. Note that this indicates which party
       *initiated a close, and it is possible for both to initiate cooperative or
       *force closes, although only one party's close will be confirmed on chain.
       * </pre>
       *
       * <code>.co.anode.anodium.Initiator close_initiator = 12;</code>
       * @return The closeInitiator.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Initiator getCloseInitiator() {
        return instance.getCloseInitiator();
      }
      /**
       * <pre>
       *Close initiator indicates which party initiated the close. This value will
       *be unknown for channels that were cooperatively closed before we started
       *tracking cooperative close initiators. Note that this indicates which party
       *initiated a close, and it is possible for both to initiate cooperative or
       *force closes, although only one party's close will be confirmed on chain.
       * </pre>
       *
       * <code>.co.anode.anodium.Initiator close_initiator = 12;</code>
       * @param value The enum numeric value on the wire for closeInitiator to set.
       * @return This builder for chaining.
       */
      public Builder setCloseInitiator(co.anode.anodium.Rpc.Initiator value) {
        copyOnWrite();
        instance.setCloseInitiator(value);
        return this;
      }
      /**
       * <pre>
       *Close initiator indicates which party initiated the close. This value will
       *be unknown for channels that were cooperatively closed before we started
       *tracking cooperative close initiators. Note that this indicates which party
       *initiated a close, and it is possible for both to initiate cooperative or
       *force closes, although only one party's close will be confirmed on chain.
       * </pre>
       *
       * <code>.co.anode.anodium.Initiator close_initiator = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearCloseInitiator() {
        copyOnWrite();
        instance.clearCloseInitiator();
        return this;
      }

      /**
       * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.Resolution> getResolutionsList() {
        return java.util.Collections.unmodifiableList(
            instance.getResolutionsList());
      }
      /**
       * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
       */
      @java.lang.Override
      public int getResolutionsCount() {
        return instance.getResolutionsCount();
      }/**
       * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Resolution getResolutions(int index) {
        return instance.getResolutions(index);
      }
      /**
       * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
       */
      public Builder setResolutions(
          int index, co.anode.anodium.Rpc.Resolution value) {
        copyOnWrite();
        instance.setResolutions(index, value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
       */
      public Builder setResolutions(
          int index, co.anode.anodium.Rpc.Resolution.Builder builderForValue) {
        copyOnWrite();
        instance.setResolutions(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
       */
      public Builder addResolutions(co.anode.anodium.Rpc.Resolution value) {
        copyOnWrite();
        instance.addResolutions(value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
       */
      public Builder addResolutions(
          int index, co.anode.anodium.Rpc.Resolution value) {
        copyOnWrite();
        instance.addResolutions(index, value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
       */
      public Builder addResolutions(
          co.anode.anodium.Rpc.Resolution.Builder builderForValue) {
        copyOnWrite();
        instance.addResolutions(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
       */
      public Builder addResolutions(
          int index, co.anode.anodium.Rpc.Resolution.Builder builderForValue) {
        copyOnWrite();
        instance.addResolutions(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
       */
      public Builder addAllResolutions(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.Resolution> values) {
        copyOnWrite();
        instance.addAllResolutions(values);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
       */
      public Builder clearResolutions() {
        copyOnWrite();
        instance.clearResolutions();
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.Resolution resolutions = 13;</code>
       */
      public Builder removeResolutions(int index) {
        copyOnWrite();
        instance.removeResolutions(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelCloseSummary)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelCloseSummary();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "channelPoint_",
              "chanId_",
              "chainHash_",
              "closingTxHash_",
              "remotePubkey_",
              "capacity_",
              "closeHeight_",
              "settledBalance_",
              "timeLockedBalance_",
              "closeType_",
              "openInitiator_",
              "closeInitiator_",
              "resolutions_",
              co.anode.anodium.Rpc.Resolution.class,
            };
            java.lang.String info =
                "\u0000\r\u0000\u0000\u0001\r\r\u0000\u0001\u0000\u0001\u0208\u0002\u0003\u0003\u0208" +
                "\u0004\u0208\u0005\u0208\u0006\u0002\u0007\u000b\b\u0002\t\u0002\n\f\u000b\f\f\f" +
                "\r\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelCloseSummary> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelCloseSummary.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelCloseSummary>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelCloseSummary)
    private static final co.anode.anodium.Rpc.ChannelCloseSummary DEFAULT_INSTANCE;
    static {
      ChannelCloseSummary defaultInstance = new ChannelCloseSummary();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelCloseSummary.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelCloseSummary getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelCloseSummary> PARSER;

    public static com.google.protobuf.Parser<ChannelCloseSummary> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ResolutionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.Resolution)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The type of output we are resolving.
     * </pre>
     *
     * <code>.co.anode.anodium.ResolutionType resolution_type = 1;</code>
     * @return The enum numeric value on the wire for resolutionType.
     */
    int getResolutionTypeValue();
    /**
     * <pre>
     * The type of output we are resolving.
     * </pre>
     *
     * <code>.co.anode.anodium.ResolutionType resolution_type = 1;</code>
     * @return The resolutionType.
     */
    co.anode.anodium.Rpc.ResolutionType getResolutionType();

    /**
     * <pre>
     * The outcome of our on chain action that resolved the outpoint.
     * </pre>
     *
     * <code>.co.anode.anodium.ResolutionOutcome outcome = 2;</code>
     * @return The enum numeric value on the wire for outcome.
     */
    int getOutcomeValue();
    /**
     * <pre>
     * The outcome of our on chain action that resolved the outpoint.
     * </pre>
     *
     * <code>.co.anode.anodium.ResolutionOutcome outcome = 2;</code>
     * @return The outcome.
     */
    co.anode.anodium.Rpc.ResolutionOutcome getOutcome();

    /**
     * <pre>
     * The outpoint that was spent by the resolution.
     * </pre>
     *
     * <code>.co.anode.anodium.OutPoint outpoint = 3;</code>
     * @return Whether the outpoint field is set.
     */
    boolean hasOutpoint();
    /**
     * <pre>
     * The outpoint that was spent by the resolution.
     * </pre>
     *
     * <code>.co.anode.anodium.OutPoint outpoint = 3;</code>
     * @return The outpoint.
     */
    co.anode.anodium.Rpc.OutPoint getOutpoint();

    /**
     * <pre>
     * The amount that was claimed by the resolution.
     * </pre>
     *
     * <code>uint64 amount_sat = 4;</code>
     * @return The amountSat.
     */
    long getAmountSat();

    /**
     * <pre>
     * The hex-encoded transaction ID of the sweep transaction that spent the
     * output.
     * </pre>
     *
     * <code>string sweep_txid = 5;</code>
     * @return The sweepTxid.
     */
    java.lang.String getSweepTxid();
    /**
     * <pre>
     * The hex-encoded transaction ID of the sweep transaction that spent the
     * output.
     * </pre>
     *
     * <code>string sweep_txid = 5;</code>
     * @return The bytes for sweepTxid.
     */
    com.google.protobuf.ByteString
        getSweepTxidBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.Resolution}
   */
  public  static final class Resolution extends
      com.google.protobuf.GeneratedMessageLite<
          Resolution, Resolution.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.Resolution)
      ResolutionOrBuilder {
    private Resolution() {
      sweepTxid_ = "";
    }
    public static final int RESOLUTION_TYPE_FIELD_NUMBER = 1;
    private int resolutionType_;
    /**
     * <pre>
     * The type of output we are resolving.
     * </pre>
     *
     * <code>.co.anode.anodium.ResolutionType resolution_type = 1;</code>
     * @return The enum numeric value on the wire for resolutionType.
     */
    @java.lang.Override
    public int getResolutionTypeValue() {
      return resolutionType_;
    }
    /**
     * <pre>
     * The type of output we are resolving.
     * </pre>
     *
     * <code>.co.anode.anodium.ResolutionType resolution_type = 1;</code>
     * @return The resolutionType.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ResolutionType getResolutionType() {
      co.anode.anodium.Rpc.ResolutionType result = co.anode.anodium.Rpc.ResolutionType.forNumber(resolutionType_);
      return result == null ? co.anode.anodium.Rpc.ResolutionType.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * The type of output we are resolving.
     * </pre>
     *
     * <code>.co.anode.anodium.ResolutionType resolution_type = 1;</code>
     * @param value The enum numeric value on the wire for resolutionType to set.
     */
    private void setResolutionTypeValue(int value) {
        resolutionType_ = value;
    }
    /**
     * <pre>
     * The type of output we are resolving.
     * </pre>
     *
     * <code>.co.anode.anodium.ResolutionType resolution_type = 1;</code>
     * @param value The resolutionType to set.
     */
    private void setResolutionType(co.anode.anodium.Rpc.ResolutionType value) {
      resolutionType_ = value.getNumber();
      
    }
    /**
     * <pre>
     * The type of output we are resolving.
     * </pre>
     *
     * <code>.co.anode.anodium.ResolutionType resolution_type = 1;</code>
     */
    private void clearResolutionType() {
      
      resolutionType_ = 0;
    }

    public static final int OUTCOME_FIELD_NUMBER = 2;
    private int outcome_;
    /**
     * <pre>
     * The outcome of our on chain action that resolved the outpoint.
     * </pre>
     *
     * <code>.co.anode.anodium.ResolutionOutcome outcome = 2;</code>
     * @return The enum numeric value on the wire for outcome.
     */
    @java.lang.Override
    public int getOutcomeValue() {
      return outcome_;
    }
    /**
     * <pre>
     * The outcome of our on chain action that resolved the outpoint.
     * </pre>
     *
     * <code>.co.anode.anodium.ResolutionOutcome outcome = 2;</code>
     * @return The outcome.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ResolutionOutcome getOutcome() {
      co.anode.anodium.Rpc.ResolutionOutcome result = co.anode.anodium.Rpc.ResolutionOutcome.forNumber(outcome_);
      return result == null ? co.anode.anodium.Rpc.ResolutionOutcome.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * The outcome of our on chain action that resolved the outpoint.
     * </pre>
     *
     * <code>.co.anode.anodium.ResolutionOutcome outcome = 2;</code>
     * @param value The enum numeric value on the wire for outcome to set.
     */
    private void setOutcomeValue(int value) {
        outcome_ = value;
    }
    /**
     * <pre>
     * The outcome of our on chain action that resolved the outpoint.
     * </pre>
     *
     * <code>.co.anode.anodium.ResolutionOutcome outcome = 2;</code>
     * @param value The outcome to set.
     */
    private void setOutcome(co.anode.anodium.Rpc.ResolutionOutcome value) {
      outcome_ = value.getNumber();
      
    }
    /**
     * <pre>
     * The outcome of our on chain action that resolved the outpoint.
     * </pre>
     *
     * <code>.co.anode.anodium.ResolutionOutcome outcome = 2;</code>
     */
    private void clearOutcome() {
      
      outcome_ = 0;
    }

    public static final int OUTPOINT_FIELD_NUMBER = 3;
    private co.anode.anodium.Rpc.OutPoint outpoint_;
    /**
     * <pre>
     * The outpoint that was spent by the resolution.
     * </pre>
     *
     * <code>.co.anode.anodium.OutPoint outpoint = 3;</code>
     */
    @java.lang.Override
    public boolean hasOutpoint() {
      return outpoint_ != null;
    }
    /**
     * <pre>
     * The outpoint that was spent by the resolution.
     * </pre>
     *
     * <code>.co.anode.anodium.OutPoint outpoint = 3;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.OutPoint getOutpoint() {
      return outpoint_ == null ? co.anode.anodium.Rpc.OutPoint.getDefaultInstance() : outpoint_;
    }
    /**
     * <pre>
     * The outpoint that was spent by the resolution.
     * </pre>
     *
     * <code>.co.anode.anodium.OutPoint outpoint = 3;</code>
     */
    private void setOutpoint(co.anode.anodium.Rpc.OutPoint value) {
      value.getClass();
  outpoint_ = value;
      
      }
    /**
     * <pre>
     * The outpoint that was spent by the resolution.
     * </pre>
     *
     * <code>.co.anode.anodium.OutPoint outpoint = 3;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeOutpoint(co.anode.anodium.Rpc.OutPoint value) {
      value.getClass();
  if (outpoint_ != null &&
          outpoint_ != co.anode.anodium.Rpc.OutPoint.getDefaultInstance()) {
        outpoint_ =
          co.anode.anodium.Rpc.OutPoint.newBuilder(outpoint_).mergeFrom(value).buildPartial();
      } else {
        outpoint_ = value;
      }
      
    }
    /**
     * <pre>
     * The outpoint that was spent by the resolution.
     * </pre>
     *
     * <code>.co.anode.anodium.OutPoint outpoint = 3;</code>
     */
    private void clearOutpoint() {  outpoint_ = null;
      
    }

    public static final int AMOUNT_SAT_FIELD_NUMBER = 4;
    private long amountSat_;
    /**
     * <pre>
     * The amount that was claimed by the resolution.
     * </pre>
     *
     * <code>uint64 amount_sat = 4;</code>
     * @return The amountSat.
     */
    @java.lang.Override
    public long getAmountSat() {
      return amountSat_;
    }
    /**
     * <pre>
     * The amount that was claimed by the resolution.
     * </pre>
     *
     * <code>uint64 amount_sat = 4;</code>
     * @param value The amountSat to set.
     */
    private void setAmountSat(long value) {
      
      amountSat_ = value;
    }
    /**
     * <pre>
     * The amount that was claimed by the resolution.
     * </pre>
     *
     * <code>uint64 amount_sat = 4;</code>
     */
    private void clearAmountSat() {
      
      amountSat_ = 0L;
    }

    public static final int SWEEP_TXID_FIELD_NUMBER = 5;
    private java.lang.String sweepTxid_;
    /**
     * <pre>
     * The hex-encoded transaction ID of the sweep transaction that spent the
     * output.
     * </pre>
     *
     * <code>string sweep_txid = 5;</code>
     * @return The sweepTxid.
     */
    @java.lang.Override
    public java.lang.String getSweepTxid() {
      return sweepTxid_;
    }
    /**
     * <pre>
     * The hex-encoded transaction ID of the sweep transaction that spent the
     * output.
     * </pre>
     *
     * <code>string sweep_txid = 5;</code>
     * @return The bytes for sweepTxid.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSweepTxidBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(sweepTxid_);
    }
    /**
     * <pre>
     * The hex-encoded transaction ID of the sweep transaction that spent the
     * output.
     * </pre>
     *
     * <code>string sweep_txid = 5;</code>
     * @param value The sweepTxid to set.
     */
    private void setSweepTxid(
        java.lang.String value) {
      value.getClass();
  
      sweepTxid_ = value;
    }
    /**
     * <pre>
     * The hex-encoded transaction ID of the sweep transaction that spent the
     * output.
     * </pre>
     *
     * <code>string sweep_txid = 5;</code>
     */
    private void clearSweepTxid() {
      
      sweepTxid_ = getDefaultInstance().getSweepTxid();
    }
    /**
     * <pre>
     * The hex-encoded transaction ID of the sweep transaction that spent the
     * output.
     * </pre>
     *
     * <code>string sweep_txid = 5;</code>
     * @param value The bytes for sweepTxid to set.
     */
    private void setSweepTxidBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      sweepTxid_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.Resolution parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Resolution parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Resolution parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Resolution parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Resolution parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Resolution parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Resolution parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Resolution parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Resolution parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Resolution parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Resolution parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Resolution parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.Resolution prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.Resolution}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.Resolution, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.Resolution)
        co.anode.anodium.Rpc.ResolutionOrBuilder {
      // Construct using co.anode.anodium.Rpc.Resolution.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The type of output we are resolving.
       * </pre>
       *
       * <code>.co.anode.anodium.ResolutionType resolution_type = 1;</code>
       * @return The enum numeric value on the wire for resolutionType.
       */
      @java.lang.Override
      public int getResolutionTypeValue() {
        return instance.getResolutionTypeValue();
      }
      /**
       * <pre>
       * The type of output we are resolving.
       * </pre>
       *
       * <code>.co.anode.anodium.ResolutionType resolution_type = 1;</code>
       * @param value The resolutionType to set.
       * @return This builder for chaining.
       */
      public Builder setResolutionTypeValue(int value) {
        copyOnWrite();
        instance.setResolutionTypeValue(value);
        return this;
      }
      /**
       * <pre>
       * The type of output we are resolving.
       * </pre>
       *
       * <code>.co.anode.anodium.ResolutionType resolution_type = 1;</code>
       * @return The resolutionType.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ResolutionType getResolutionType() {
        return instance.getResolutionType();
      }
      /**
       * <pre>
       * The type of output we are resolving.
       * </pre>
       *
       * <code>.co.anode.anodium.ResolutionType resolution_type = 1;</code>
       * @param value The enum numeric value on the wire for resolutionType to set.
       * @return This builder for chaining.
       */
      public Builder setResolutionType(co.anode.anodium.Rpc.ResolutionType value) {
        copyOnWrite();
        instance.setResolutionType(value);
        return this;
      }
      /**
       * <pre>
       * The type of output we are resolving.
       * </pre>
       *
       * <code>.co.anode.anodium.ResolutionType resolution_type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearResolutionType() {
        copyOnWrite();
        instance.clearResolutionType();
        return this;
      }

      /**
       * <pre>
       * The outcome of our on chain action that resolved the outpoint.
       * </pre>
       *
       * <code>.co.anode.anodium.ResolutionOutcome outcome = 2;</code>
       * @return The enum numeric value on the wire for outcome.
       */
      @java.lang.Override
      public int getOutcomeValue() {
        return instance.getOutcomeValue();
      }
      /**
       * <pre>
       * The outcome of our on chain action that resolved the outpoint.
       * </pre>
       *
       * <code>.co.anode.anodium.ResolutionOutcome outcome = 2;</code>
       * @param value The outcome to set.
       * @return This builder for chaining.
       */
      public Builder setOutcomeValue(int value) {
        copyOnWrite();
        instance.setOutcomeValue(value);
        return this;
      }
      /**
       * <pre>
       * The outcome of our on chain action that resolved the outpoint.
       * </pre>
       *
       * <code>.co.anode.anodium.ResolutionOutcome outcome = 2;</code>
       * @return The outcome.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ResolutionOutcome getOutcome() {
        return instance.getOutcome();
      }
      /**
       * <pre>
       * The outcome of our on chain action that resolved the outpoint.
       * </pre>
       *
       * <code>.co.anode.anodium.ResolutionOutcome outcome = 2;</code>
       * @param value The enum numeric value on the wire for outcome to set.
       * @return This builder for chaining.
       */
      public Builder setOutcome(co.anode.anodium.Rpc.ResolutionOutcome value) {
        copyOnWrite();
        instance.setOutcome(value);
        return this;
      }
      /**
       * <pre>
       * The outcome of our on chain action that resolved the outpoint.
       * </pre>
       *
       * <code>.co.anode.anodium.ResolutionOutcome outcome = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearOutcome() {
        copyOnWrite();
        instance.clearOutcome();
        return this;
      }

      /**
       * <pre>
       * The outpoint that was spent by the resolution.
       * </pre>
       *
       * <code>.co.anode.anodium.OutPoint outpoint = 3;</code>
       */
      @java.lang.Override
      public boolean hasOutpoint() {
        return instance.hasOutpoint();
      }
      /**
       * <pre>
       * The outpoint that was spent by the resolution.
       * </pre>
       *
       * <code>.co.anode.anodium.OutPoint outpoint = 3;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.OutPoint getOutpoint() {
        return instance.getOutpoint();
      }
      /**
       * <pre>
       * The outpoint that was spent by the resolution.
       * </pre>
       *
       * <code>.co.anode.anodium.OutPoint outpoint = 3;</code>
       */
      public Builder setOutpoint(co.anode.anodium.Rpc.OutPoint value) {
        copyOnWrite();
        instance.setOutpoint(value);
        return this;
        }
      /**
       * <pre>
       * The outpoint that was spent by the resolution.
       * </pre>
       *
       * <code>.co.anode.anodium.OutPoint outpoint = 3;</code>
       */
      public Builder setOutpoint(
          co.anode.anodium.Rpc.OutPoint.Builder builderForValue) {
        copyOnWrite();
        instance.setOutpoint(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The outpoint that was spent by the resolution.
       * </pre>
       *
       * <code>.co.anode.anodium.OutPoint outpoint = 3;</code>
       */
      public Builder mergeOutpoint(co.anode.anodium.Rpc.OutPoint value) {
        copyOnWrite();
        instance.mergeOutpoint(value);
        return this;
      }
      /**
       * <pre>
       * The outpoint that was spent by the resolution.
       * </pre>
       *
       * <code>.co.anode.anodium.OutPoint outpoint = 3;</code>
       */
      public Builder clearOutpoint() {  copyOnWrite();
        instance.clearOutpoint();
        return this;
      }

      /**
       * <pre>
       * The amount that was claimed by the resolution.
       * </pre>
       *
       * <code>uint64 amount_sat = 4;</code>
       * @return The amountSat.
       */
      @java.lang.Override
      public long getAmountSat() {
        return instance.getAmountSat();
      }
      /**
       * <pre>
       * The amount that was claimed by the resolution.
       * </pre>
       *
       * <code>uint64 amount_sat = 4;</code>
       * @param value The amountSat to set.
       * @return This builder for chaining.
       */
      public Builder setAmountSat(long value) {
        copyOnWrite();
        instance.setAmountSat(value);
        return this;
      }
      /**
       * <pre>
       * The amount that was claimed by the resolution.
       * </pre>
       *
       * <code>uint64 amount_sat = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmountSat() {
        copyOnWrite();
        instance.clearAmountSat();
        return this;
      }

      /**
       * <pre>
       * The hex-encoded transaction ID of the sweep transaction that spent the
       * output.
       * </pre>
       *
       * <code>string sweep_txid = 5;</code>
       * @return The sweepTxid.
       */
      @java.lang.Override
      public java.lang.String getSweepTxid() {
        return instance.getSweepTxid();
      }
      /**
       * <pre>
       * The hex-encoded transaction ID of the sweep transaction that spent the
       * output.
       * </pre>
       *
       * <code>string sweep_txid = 5;</code>
       * @return The bytes for sweepTxid.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getSweepTxidBytes() {
        return instance.getSweepTxidBytes();
      }
      /**
       * <pre>
       * The hex-encoded transaction ID of the sweep transaction that spent the
       * output.
       * </pre>
       *
       * <code>string sweep_txid = 5;</code>
       * @param value The sweepTxid to set.
       * @return This builder for chaining.
       */
      public Builder setSweepTxid(
          java.lang.String value) {
        copyOnWrite();
        instance.setSweepTxid(value);
        return this;
      }
      /**
       * <pre>
       * The hex-encoded transaction ID of the sweep transaction that spent the
       * output.
       * </pre>
       *
       * <code>string sweep_txid = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearSweepTxid() {
        copyOnWrite();
        instance.clearSweepTxid();
        return this;
      }
      /**
       * <pre>
       * The hex-encoded transaction ID of the sweep transaction that spent the
       * output.
       * </pre>
       *
       * <code>string sweep_txid = 5;</code>
       * @param value The bytes for sweepTxid to set.
       * @return This builder for chaining.
       */
      public Builder setSweepTxidBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSweepTxidBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.Resolution)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.Resolution();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "resolutionType_",
              "outcome_",
              "outpoint_",
              "amountSat_",
              "sweepTxid_",
            };
            java.lang.String info =
                "\u0000\u0005\u0000\u0000\u0001\u0005\u0005\u0000\u0000\u0000\u0001\f\u0002\f\u0003" +
                "\t\u0004\u0003\u0005\u0208";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.Resolution> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.Resolution.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.Resolution>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.Resolution)
    private static final co.anode.anodium.Rpc.Resolution DEFAULT_INSTANCE;
    static {
      Resolution defaultInstance = new Resolution();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Resolution.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.Resolution getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Resolution> PARSER;

    public static com.google.protobuf.Parser<Resolution> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ClosedChannelsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ClosedChannelsRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>bool cooperative = 1;</code>
     * @return The cooperative.
     */
    boolean getCooperative();

    /**
     * <code>bool local_force = 2;</code>
     * @return The localForce.
     */
    boolean getLocalForce();

    /**
     * <code>bool remote_force = 3;</code>
     * @return The remoteForce.
     */
    boolean getRemoteForce();

    /**
     * <code>bool breach = 4;</code>
     * @return The breach.
     */
    boolean getBreach();

    /**
     * <code>bool funding_canceled = 5;</code>
     * @return The fundingCanceled.
     */
    boolean getFundingCanceled();

    /**
     * <code>bool abandoned = 6;</code>
     * @return The abandoned.
     */
    boolean getAbandoned();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ClosedChannelsRequest}
   */
  public  static final class ClosedChannelsRequest extends
      com.google.protobuf.GeneratedMessageLite<
          ClosedChannelsRequest, ClosedChannelsRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ClosedChannelsRequest)
      ClosedChannelsRequestOrBuilder {
    private ClosedChannelsRequest() {
    }
    public static final int COOPERATIVE_FIELD_NUMBER = 1;
    private boolean cooperative_;
    /**
     * <code>bool cooperative = 1;</code>
     * @return The cooperative.
     */
    @java.lang.Override
    public boolean getCooperative() {
      return cooperative_;
    }
    /**
     * <code>bool cooperative = 1;</code>
     * @param value The cooperative to set.
     */
    private void setCooperative(boolean value) {
      
      cooperative_ = value;
    }
    /**
     * <code>bool cooperative = 1;</code>
     */
    private void clearCooperative() {
      
      cooperative_ = false;
    }

    public static final int LOCAL_FORCE_FIELD_NUMBER = 2;
    private boolean localForce_;
    /**
     * <code>bool local_force = 2;</code>
     * @return The localForce.
     */
    @java.lang.Override
    public boolean getLocalForce() {
      return localForce_;
    }
    /**
     * <code>bool local_force = 2;</code>
     * @param value The localForce to set.
     */
    private void setLocalForce(boolean value) {
      
      localForce_ = value;
    }
    /**
     * <code>bool local_force = 2;</code>
     */
    private void clearLocalForce() {
      
      localForce_ = false;
    }

    public static final int REMOTE_FORCE_FIELD_NUMBER = 3;
    private boolean remoteForce_;
    /**
     * <code>bool remote_force = 3;</code>
     * @return The remoteForce.
     */
    @java.lang.Override
    public boolean getRemoteForce() {
      return remoteForce_;
    }
    /**
     * <code>bool remote_force = 3;</code>
     * @param value The remoteForce to set.
     */
    private void setRemoteForce(boolean value) {
      
      remoteForce_ = value;
    }
    /**
     * <code>bool remote_force = 3;</code>
     */
    private void clearRemoteForce() {
      
      remoteForce_ = false;
    }

    public static final int BREACH_FIELD_NUMBER = 4;
    private boolean breach_;
    /**
     * <code>bool breach = 4;</code>
     * @return The breach.
     */
    @java.lang.Override
    public boolean getBreach() {
      return breach_;
    }
    /**
     * <code>bool breach = 4;</code>
     * @param value The breach to set.
     */
    private void setBreach(boolean value) {
      
      breach_ = value;
    }
    /**
     * <code>bool breach = 4;</code>
     */
    private void clearBreach() {
      
      breach_ = false;
    }

    public static final int FUNDING_CANCELED_FIELD_NUMBER = 5;
    private boolean fundingCanceled_;
    /**
     * <code>bool funding_canceled = 5;</code>
     * @return The fundingCanceled.
     */
    @java.lang.Override
    public boolean getFundingCanceled() {
      return fundingCanceled_;
    }
    /**
     * <code>bool funding_canceled = 5;</code>
     * @param value The fundingCanceled to set.
     */
    private void setFundingCanceled(boolean value) {
      
      fundingCanceled_ = value;
    }
    /**
     * <code>bool funding_canceled = 5;</code>
     */
    private void clearFundingCanceled() {
      
      fundingCanceled_ = false;
    }

    public static final int ABANDONED_FIELD_NUMBER = 6;
    private boolean abandoned_;
    /**
     * <code>bool abandoned = 6;</code>
     * @return The abandoned.
     */
    @java.lang.Override
    public boolean getAbandoned() {
      return abandoned_;
    }
    /**
     * <code>bool abandoned = 6;</code>
     * @param value The abandoned to set.
     */
    private void setAbandoned(boolean value) {
      
      abandoned_ = value;
    }
    /**
     * <code>bool abandoned = 6;</code>
     */
    private void clearAbandoned() {
      
      abandoned_ = false;
    }

    public static co.anode.anodium.Rpc.ClosedChannelsRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ClosedChannelsRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ClosedChannelsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ClosedChannelsRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ClosedChannelsRequest)
        co.anode.anodium.Rpc.ClosedChannelsRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.ClosedChannelsRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>bool cooperative = 1;</code>
       * @return The cooperative.
       */
      @java.lang.Override
      public boolean getCooperative() {
        return instance.getCooperative();
      }
      /**
       * <code>bool cooperative = 1;</code>
       * @param value The cooperative to set.
       * @return This builder for chaining.
       */
      public Builder setCooperative(boolean value) {
        copyOnWrite();
        instance.setCooperative(value);
        return this;
      }
      /**
       * <code>bool cooperative = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearCooperative() {
        copyOnWrite();
        instance.clearCooperative();
        return this;
      }

      /**
       * <code>bool local_force = 2;</code>
       * @return The localForce.
       */
      @java.lang.Override
      public boolean getLocalForce() {
        return instance.getLocalForce();
      }
      /**
       * <code>bool local_force = 2;</code>
       * @param value The localForce to set.
       * @return This builder for chaining.
       */
      public Builder setLocalForce(boolean value) {
        copyOnWrite();
        instance.setLocalForce(value);
        return this;
      }
      /**
       * <code>bool local_force = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearLocalForce() {
        copyOnWrite();
        instance.clearLocalForce();
        return this;
      }

      /**
       * <code>bool remote_force = 3;</code>
       * @return The remoteForce.
       */
      @java.lang.Override
      public boolean getRemoteForce() {
        return instance.getRemoteForce();
      }
      /**
       * <code>bool remote_force = 3;</code>
       * @param value The remoteForce to set.
       * @return This builder for chaining.
       */
      public Builder setRemoteForce(boolean value) {
        copyOnWrite();
        instance.setRemoteForce(value);
        return this;
      }
      /**
       * <code>bool remote_force = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearRemoteForce() {
        copyOnWrite();
        instance.clearRemoteForce();
        return this;
      }

      /**
       * <code>bool breach = 4;</code>
       * @return The breach.
       */
      @java.lang.Override
      public boolean getBreach() {
        return instance.getBreach();
      }
      /**
       * <code>bool breach = 4;</code>
       * @param value The breach to set.
       * @return This builder for chaining.
       */
      public Builder setBreach(boolean value) {
        copyOnWrite();
        instance.setBreach(value);
        return this;
      }
      /**
       * <code>bool breach = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearBreach() {
        copyOnWrite();
        instance.clearBreach();
        return this;
      }

      /**
       * <code>bool funding_canceled = 5;</code>
       * @return The fundingCanceled.
       */
      @java.lang.Override
      public boolean getFundingCanceled() {
        return instance.getFundingCanceled();
      }
      /**
       * <code>bool funding_canceled = 5;</code>
       * @param value The fundingCanceled to set.
       * @return This builder for chaining.
       */
      public Builder setFundingCanceled(boolean value) {
        copyOnWrite();
        instance.setFundingCanceled(value);
        return this;
      }
      /**
       * <code>bool funding_canceled = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearFundingCanceled() {
        copyOnWrite();
        instance.clearFundingCanceled();
        return this;
      }

      /**
       * <code>bool abandoned = 6;</code>
       * @return The abandoned.
       */
      @java.lang.Override
      public boolean getAbandoned() {
        return instance.getAbandoned();
      }
      /**
       * <code>bool abandoned = 6;</code>
       * @param value The abandoned to set.
       * @return This builder for chaining.
       */
      public Builder setAbandoned(boolean value) {
        copyOnWrite();
        instance.setAbandoned(value);
        return this;
      }
      /**
       * <code>bool abandoned = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearAbandoned() {
        copyOnWrite();
        instance.clearAbandoned();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ClosedChannelsRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ClosedChannelsRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "cooperative_",
              "localForce_",
              "remoteForce_",
              "breach_",
              "fundingCanceled_",
              "abandoned_",
            };
            java.lang.String info =
                "\u0000\u0006\u0000\u0000\u0001\u0006\u0006\u0000\u0000\u0000\u0001\u0007\u0002\u0007" +
                "\u0003\u0007\u0004\u0007\u0005\u0007\u0006\u0007";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ClosedChannelsRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ClosedChannelsRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ClosedChannelsRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ClosedChannelsRequest)
    private static final co.anode.anodium.Rpc.ClosedChannelsRequest DEFAULT_INSTANCE;
    static {
      ClosedChannelsRequest defaultInstance = new ClosedChannelsRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ClosedChannelsRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ClosedChannelsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ClosedChannelsRequest> PARSER;

    public static com.google.protobuf.Parser<ClosedChannelsRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ClosedChannelsResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ClosedChannelsResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
     */
    java.util.List<co.anode.anodium.Rpc.ChannelCloseSummary> 
        getChannelsList();
    /**
     * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
     */
    co.anode.anodium.Rpc.ChannelCloseSummary getChannels(int index);
    /**
     * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
     */
    int getChannelsCount();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ClosedChannelsResponse}
   */
  public  static final class ClosedChannelsResponse extends
      com.google.protobuf.GeneratedMessageLite<
          ClosedChannelsResponse, ClosedChannelsResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ClosedChannelsResponse)
      ClosedChannelsResponseOrBuilder {
    private ClosedChannelsResponse() {
      channels_ = emptyProtobufList();
    }
    public static final int CHANNELS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.ChannelCloseSummary> channels_;
    /**
     * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.ChannelCloseSummary> getChannelsList() {
      return channels_;
    }
    /**
     * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.ChannelCloseSummaryOrBuilder> 
        getChannelsOrBuilderList() {
      return channels_;
    }
    /**
     * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
     */
    @java.lang.Override
    public int getChannelsCount() {
      return channels_.size();
    }
    /**
     * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelCloseSummary getChannels(int index) {
      return channels_.get(index);
    }
    /**
     * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
     */
    public co.anode.anodium.Rpc.ChannelCloseSummaryOrBuilder getChannelsOrBuilder(
        int index) {
      return channels_.get(index);
    }
    private void ensureChannelsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.ChannelCloseSummary> tmp = channels_;
      if (!tmp.isModifiable()) {
        channels_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
     */
    private void setChannels(
        int index, co.anode.anodium.Rpc.ChannelCloseSummary value) {
      value.getClass();
  ensureChannelsIsMutable();
      channels_.set(index, value);
    }
    /**
     * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
     */
    private void addChannels(co.anode.anodium.Rpc.ChannelCloseSummary value) {
      value.getClass();
  ensureChannelsIsMutable();
      channels_.add(value);
    }
    /**
     * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
     */
    private void addChannels(
        int index, co.anode.anodium.Rpc.ChannelCloseSummary value) {
      value.getClass();
  ensureChannelsIsMutable();
      channels_.add(index, value);
    }
    /**
     * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
     */
    private void addAllChannels(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.ChannelCloseSummary> values) {
      ensureChannelsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, channels_);
    }
    /**
     * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
     */
    private void clearChannels() {
      channels_ = emptyProtobufList();
    }
    /**
     * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
     */
    private void removeChannels(int index) {
      ensureChannelsIsMutable();
      channels_.remove(index);
    }

    public static co.anode.anodium.Rpc.ClosedChannelsResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ClosedChannelsResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ClosedChannelsResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ClosedChannelsResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ClosedChannelsResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ClosedChannelsResponse)
        co.anode.anodium.Rpc.ClosedChannelsResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.ClosedChannelsResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.ChannelCloseSummary> getChannelsList() {
        return java.util.Collections.unmodifiableList(
            instance.getChannelsList());
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
       */
      @java.lang.Override
      public int getChannelsCount() {
        return instance.getChannelsCount();
      }/**
       * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelCloseSummary getChannels(int index) {
        return instance.getChannels(index);
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
       */
      public Builder setChannels(
          int index, co.anode.anodium.Rpc.ChannelCloseSummary value) {
        copyOnWrite();
        instance.setChannels(index, value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
       */
      public Builder setChannels(
          int index, co.anode.anodium.Rpc.ChannelCloseSummary.Builder builderForValue) {
        copyOnWrite();
        instance.setChannels(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
       */
      public Builder addChannels(co.anode.anodium.Rpc.ChannelCloseSummary value) {
        copyOnWrite();
        instance.addChannels(value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
       */
      public Builder addChannels(
          int index, co.anode.anodium.Rpc.ChannelCloseSummary value) {
        copyOnWrite();
        instance.addChannels(index, value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
       */
      public Builder addChannels(
          co.anode.anodium.Rpc.ChannelCloseSummary.Builder builderForValue) {
        copyOnWrite();
        instance.addChannels(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
       */
      public Builder addChannels(
          int index, co.anode.anodium.Rpc.ChannelCloseSummary.Builder builderForValue) {
        copyOnWrite();
        instance.addChannels(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
       */
      public Builder addAllChannels(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.ChannelCloseSummary> values) {
        copyOnWrite();
        instance.addAllChannels(values);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
       */
      public Builder clearChannels() {
        copyOnWrite();
        instance.clearChannels();
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelCloseSummary channels = 1;</code>
       */
      public Builder removeChannels(int index) {
        copyOnWrite();
        instance.removeChannels(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ClosedChannelsResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ClosedChannelsResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "channels_",
              co.anode.anodium.Rpc.ChannelCloseSummary.class,
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0000\u0001\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ClosedChannelsResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ClosedChannelsResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ClosedChannelsResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ClosedChannelsResponse)
    private static final co.anode.anodium.Rpc.ClosedChannelsResponse DEFAULT_INSTANCE;
    static {
      ClosedChannelsResponse defaultInstance = new ClosedChannelsResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ClosedChannelsResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ClosedChannelsResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ClosedChannelsResponse> PARSER;

    public static com.google.protobuf.Parser<ClosedChannelsResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PeerOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.Peer)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The identity pubkey of the peer
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The pubKey.
     */
    java.lang.String getPubKey();
    /**
     * <pre>
     * The identity pubkey of the peer
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The bytes for pubKey.
     */
    com.google.protobuf.ByteString
        getPubKeyBytes();

    /**
     * <pre>
     * Network address of the peer; eg `127.0.0.1:10011`
     * </pre>
     *
     * <code>string address = 3;</code>
     * @return The address.
     */
    java.lang.String getAddress();
    /**
     * <pre>
     * Network address of the peer; eg `127.0.0.1:10011`
     * </pre>
     *
     * <code>string address = 3;</code>
     * @return The bytes for address.
     */
    com.google.protobuf.ByteString
        getAddressBytes();

    /**
     * <pre>
     * Bytes of data transmitted to this peer
     * </pre>
     *
     * <code>uint64 bytes_sent = 4;</code>
     * @return The bytesSent.
     */
    long getBytesSent();

    /**
     * <pre>
     * Bytes of data transmitted from this peer
     * </pre>
     *
     * <code>uint64 bytes_recv = 5;</code>
     * @return The bytesRecv.
     */
    long getBytesRecv();

    /**
     * <pre>
     * Satoshis sent to this peer
     * </pre>
     *
     * <code>int64 sat_sent = 6;</code>
     * @return The satSent.
     */
    long getSatSent();

    /**
     * <pre>
     * Satoshis received from this peer
     * </pre>
     *
     * <code>int64 sat_recv = 7;</code>
     * @return The satRecv.
     */
    long getSatRecv();

    /**
     * <pre>
     * A channel is inbound if the counterparty initiated the channel
     * </pre>
     *
     * <code>bool inbound = 8;</code>
     * @return The inbound.
     */
    boolean getInbound();

    /**
     * <pre>
     * Ping time to this peer
     * </pre>
     *
     * <code>int64 ping_time = 9;</code>
     * @return The pingTime.
     */
    long getPingTime();

    /**
     * <pre>
     * The type of sync we are currently performing with this peer.
     * </pre>
     *
     * <code>.co.anode.anodium.Peer.SyncType sync_type = 10;</code>
     * @return The enum numeric value on the wire for syncType.
     */
    int getSyncTypeValue();
    /**
     * <pre>
     * The type of sync we are currently performing with this peer.
     * </pre>
     *
     * <code>.co.anode.anodium.Peer.SyncType sync_type = 10;</code>
     * @return The syncType.
     */
    co.anode.anodium.Rpc.Peer.SyncType getSyncType();

    /**
     * <pre>
     * Features advertised by the remote peer in their init message.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 11;</code>
     */
    int getFeaturesCount();
    /**
     * <pre>
     * Features advertised by the remote peer in their init message.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 11;</code>
     */
    boolean containsFeatures(
        int key);
    /**
     * Use {@link #getFeaturesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    getFeatures();
    /**
     * <pre>
     * Features advertised by the remote peer in their init message.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 11;</code>
     */
    java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    getFeaturesMap();
    /**
     * <pre>
     * Features advertised by the remote peer in their init message.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 11;</code>
     */

    co.anode.anodium.Rpc.Feature getFeaturesOrDefault(
        int key,
        co.anode.anodium.Rpc.Feature defaultValue);
    /**
     * <pre>
     * Features advertised by the remote peer in their init message.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 11;</code>
     */

    co.anode.anodium.Rpc.Feature getFeaturesOrThrow(
        int key);

    /**
     * <pre>
     *The latest errors received from our peer with timestamps, limited to the 10
     *most recent errors. These errors are tracked across peer connections, but
     *are not persisted across lnd restarts. Note that these errors are only
     *stored for peers that we have channels open with, to prevent peers from
     *spamming us with errors at no cost.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
     */
    java.util.List<co.anode.anodium.Rpc.TimestampedError> 
        getErrorsList();
    /**
     * <pre>
     *The latest errors received from our peer with timestamps, limited to the 10
     *most recent errors. These errors are tracked across peer connections, but
     *are not persisted across lnd restarts. Note that these errors are only
     *stored for peers that we have channels open with, to prevent peers from
     *spamming us with errors at no cost.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
     */
    co.anode.anodium.Rpc.TimestampedError getErrors(int index);
    /**
     * <pre>
     *The latest errors received from our peer with timestamps, limited to the 10
     *most recent errors. These errors are tracked across peer connections, but
     *are not persisted across lnd restarts. Note that these errors are only
     *stored for peers that we have channels open with, to prevent peers from
     *spamming us with errors at no cost.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
     */
    int getErrorsCount();

    /**
     * <pre>
     *The number of times we have recorded this peer going offline or coming
     *online, recorded across restarts. Note that this value is decreased over
     *time if the peer has not recently flapped, so that we can forgive peers
     *with historically high flap counts.
     * </pre>
     *
     * <code>int32 flap_count = 13;</code>
     * @return The flapCount.
     */
    int getFlapCount();

    /**
     * <pre>
     *The timestamp of the last flap we observed for this peer. If this value is
     *zero, we have not observed any flaps for this peer.
     * </pre>
     *
     * <code>int64 last_flap_ns = 14;</code>
     * @return The lastFlapNs.
     */
    long getLastFlapNs();
  }
  /**
   * Protobuf type {@code co.anode.anodium.Peer}
   */
  public  static final class Peer extends
      com.google.protobuf.GeneratedMessageLite<
          Peer, Peer.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.Peer)
      PeerOrBuilder {
    private Peer() {
      pubKey_ = "";
      address_ = "";
      errors_ = emptyProtobufList();
    }
    /**
     * Protobuf enum {@code co.anode.anodium.Peer.SyncType}
     */
    public enum SyncType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       *Denotes that we cannot determine the peer's current sync type.
       * </pre>
       *
       * <code>UNKNOWN_SYNC = 0;</code>
       */
      UNKNOWN_SYNC(0),
      /**
       * <pre>
       *Denotes that we are actively receiving new graph updates from the peer.
       * </pre>
       *
       * <code>ACTIVE_SYNC = 1;</code>
       */
      ACTIVE_SYNC(1),
      /**
       * <pre>
       *Denotes that we are not receiving new graph updates from the peer.
       * </pre>
       *
       * <code>PASSIVE_SYNC = 2;</code>
       */
      PASSIVE_SYNC(2),
      UNRECOGNIZED(-1),
      ;

      /**
       * <pre>
       *Denotes that we cannot determine the peer's current sync type.
       * </pre>
       *
       * <code>UNKNOWN_SYNC = 0;</code>
       */
      public static final int UNKNOWN_SYNC_VALUE = 0;
      /**
       * <pre>
       *Denotes that we are actively receiving new graph updates from the peer.
       * </pre>
       *
       * <code>ACTIVE_SYNC = 1;</code>
       */
      public static final int ACTIVE_SYNC_VALUE = 1;
      /**
       * <pre>
       *Denotes that we are not receiving new graph updates from the peer.
       * </pre>
       *
       * <code>PASSIVE_SYNC = 2;</code>
       */
      public static final int PASSIVE_SYNC_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SyncType valueOf(int value) {
        return forNumber(value);
      }

      public static SyncType forNumber(int value) {
        switch (value) {
          case 0: return UNKNOWN_SYNC;
          case 1: return ACTIVE_SYNC;
          case 2: return PASSIVE_SYNC;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SyncType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SyncType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SyncType>() {
              @java.lang.Override
              public SyncType findValueByNumber(int number) {
                return SyncType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return SyncTypeVerifier.INSTANCE;
      }

      private static final class SyncTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new SyncTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return SyncType.forNumber(number) != null;
              }
            };

      private final int value;

      private SyncType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:co.anode.anodium.Peer.SyncType)
    }

    public static final int PUB_KEY_FIELD_NUMBER = 1;
    private java.lang.String pubKey_;
    /**
     * <pre>
     * The identity pubkey of the peer
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The pubKey.
     */
    @java.lang.Override
    public java.lang.String getPubKey() {
      return pubKey_;
    }
    /**
     * <pre>
     * The identity pubkey of the peer
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The bytes for pubKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPubKeyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(pubKey_);
    }
    /**
     * <pre>
     * The identity pubkey of the peer
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @param value The pubKey to set.
     */
    private void setPubKey(
        java.lang.String value) {
      value.getClass();
  
      pubKey_ = value;
    }
    /**
     * <pre>
     * The identity pubkey of the peer
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     */
    private void clearPubKey() {
      
      pubKey_ = getDefaultInstance().getPubKey();
    }
    /**
     * <pre>
     * The identity pubkey of the peer
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @param value The bytes for pubKey to set.
     */
    private void setPubKeyBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      pubKey_ = value.toStringUtf8();
      
    }

    public static final int ADDRESS_FIELD_NUMBER = 3;
    private java.lang.String address_;
    /**
     * <pre>
     * Network address of the peer; eg `127.0.0.1:10011`
     * </pre>
     *
     * <code>string address = 3;</code>
     * @return The address.
     */
    @java.lang.Override
    public java.lang.String getAddress() {
      return address_;
    }
    /**
     * <pre>
     * Network address of the peer; eg `127.0.0.1:10011`
     * </pre>
     *
     * <code>string address = 3;</code>
     * @return The bytes for address.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAddressBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(address_);
    }
    /**
     * <pre>
     * Network address of the peer; eg `127.0.0.1:10011`
     * </pre>
     *
     * <code>string address = 3;</code>
     * @param value The address to set.
     */
    private void setAddress(
        java.lang.String value) {
      value.getClass();
  
      address_ = value;
    }
    /**
     * <pre>
     * Network address of the peer; eg `127.0.0.1:10011`
     * </pre>
     *
     * <code>string address = 3;</code>
     */
    private void clearAddress() {
      
      address_ = getDefaultInstance().getAddress();
    }
    /**
     * <pre>
     * Network address of the peer; eg `127.0.0.1:10011`
     * </pre>
     *
     * <code>string address = 3;</code>
     * @param value The bytes for address to set.
     */
    private void setAddressBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      address_ = value.toStringUtf8();
      
    }

    public static final int BYTES_SENT_FIELD_NUMBER = 4;
    private long bytesSent_;
    /**
     * <pre>
     * Bytes of data transmitted to this peer
     * </pre>
     *
     * <code>uint64 bytes_sent = 4;</code>
     * @return The bytesSent.
     */
    @java.lang.Override
    public long getBytesSent() {
      return bytesSent_;
    }
    /**
     * <pre>
     * Bytes of data transmitted to this peer
     * </pre>
     *
     * <code>uint64 bytes_sent = 4;</code>
     * @param value The bytesSent to set.
     */
    private void setBytesSent(long value) {
      
      bytesSent_ = value;
    }
    /**
     * <pre>
     * Bytes of data transmitted to this peer
     * </pre>
     *
     * <code>uint64 bytes_sent = 4;</code>
     */
    private void clearBytesSent() {
      
      bytesSent_ = 0L;
    }

    public static final int BYTES_RECV_FIELD_NUMBER = 5;
    private long bytesRecv_;
    /**
     * <pre>
     * Bytes of data transmitted from this peer
     * </pre>
     *
     * <code>uint64 bytes_recv = 5;</code>
     * @return The bytesRecv.
     */
    @java.lang.Override
    public long getBytesRecv() {
      return bytesRecv_;
    }
    /**
     * <pre>
     * Bytes of data transmitted from this peer
     * </pre>
     *
     * <code>uint64 bytes_recv = 5;</code>
     * @param value The bytesRecv to set.
     */
    private void setBytesRecv(long value) {
      
      bytesRecv_ = value;
    }
    /**
     * <pre>
     * Bytes of data transmitted from this peer
     * </pre>
     *
     * <code>uint64 bytes_recv = 5;</code>
     */
    private void clearBytesRecv() {
      
      bytesRecv_ = 0L;
    }

    public static final int SAT_SENT_FIELD_NUMBER = 6;
    private long satSent_;
    /**
     * <pre>
     * Satoshis sent to this peer
     * </pre>
     *
     * <code>int64 sat_sent = 6;</code>
     * @return The satSent.
     */
    @java.lang.Override
    public long getSatSent() {
      return satSent_;
    }
    /**
     * <pre>
     * Satoshis sent to this peer
     * </pre>
     *
     * <code>int64 sat_sent = 6;</code>
     * @param value The satSent to set.
     */
    private void setSatSent(long value) {
      
      satSent_ = value;
    }
    /**
     * <pre>
     * Satoshis sent to this peer
     * </pre>
     *
     * <code>int64 sat_sent = 6;</code>
     */
    private void clearSatSent() {
      
      satSent_ = 0L;
    }

    public static final int SAT_RECV_FIELD_NUMBER = 7;
    private long satRecv_;
    /**
     * <pre>
     * Satoshis received from this peer
     * </pre>
     *
     * <code>int64 sat_recv = 7;</code>
     * @return The satRecv.
     */
    @java.lang.Override
    public long getSatRecv() {
      return satRecv_;
    }
    /**
     * <pre>
     * Satoshis received from this peer
     * </pre>
     *
     * <code>int64 sat_recv = 7;</code>
     * @param value The satRecv to set.
     */
    private void setSatRecv(long value) {
      
      satRecv_ = value;
    }
    /**
     * <pre>
     * Satoshis received from this peer
     * </pre>
     *
     * <code>int64 sat_recv = 7;</code>
     */
    private void clearSatRecv() {
      
      satRecv_ = 0L;
    }

    public static final int INBOUND_FIELD_NUMBER = 8;
    private boolean inbound_;
    /**
     * <pre>
     * A channel is inbound if the counterparty initiated the channel
     * </pre>
     *
     * <code>bool inbound = 8;</code>
     * @return The inbound.
     */
    @java.lang.Override
    public boolean getInbound() {
      return inbound_;
    }
    /**
     * <pre>
     * A channel is inbound if the counterparty initiated the channel
     * </pre>
     *
     * <code>bool inbound = 8;</code>
     * @param value The inbound to set.
     */
    private void setInbound(boolean value) {
      
      inbound_ = value;
    }
    /**
     * <pre>
     * A channel is inbound if the counterparty initiated the channel
     * </pre>
     *
     * <code>bool inbound = 8;</code>
     */
    private void clearInbound() {
      
      inbound_ = false;
    }

    public static final int PING_TIME_FIELD_NUMBER = 9;
    private long pingTime_;
    /**
     * <pre>
     * Ping time to this peer
     * </pre>
     *
     * <code>int64 ping_time = 9;</code>
     * @return The pingTime.
     */
    @java.lang.Override
    public long getPingTime() {
      return pingTime_;
    }
    /**
     * <pre>
     * Ping time to this peer
     * </pre>
     *
     * <code>int64 ping_time = 9;</code>
     * @param value The pingTime to set.
     */
    private void setPingTime(long value) {
      
      pingTime_ = value;
    }
    /**
     * <pre>
     * Ping time to this peer
     * </pre>
     *
     * <code>int64 ping_time = 9;</code>
     */
    private void clearPingTime() {
      
      pingTime_ = 0L;
    }

    public static final int SYNC_TYPE_FIELD_NUMBER = 10;
    private int syncType_;
    /**
     * <pre>
     * The type of sync we are currently performing with this peer.
     * </pre>
     *
     * <code>.co.anode.anodium.Peer.SyncType sync_type = 10;</code>
     * @return The enum numeric value on the wire for syncType.
     */
    @java.lang.Override
    public int getSyncTypeValue() {
      return syncType_;
    }
    /**
     * <pre>
     * The type of sync we are currently performing with this peer.
     * </pre>
     *
     * <code>.co.anode.anodium.Peer.SyncType sync_type = 10;</code>
     * @return The syncType.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Peer.SyncType getSyncType() {
      co.anode.anodium.Rpc.Peer.SyncType result = co.anode.anodium.Rpc.Peer.SyncType.forNumber(syncType_);
      return result == null ? co.anode.anodium.Rpc.Peer.SyncType.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * The type of sync we are currently performing with this peer.
     * </pre>
     *
     * <code>.co.anode.anodium.Peer.SyncType sync_type = 10;</code>
     * @param value The enum numeric value on the wire for syncType to set.
     */
    private void setSyncTypeValue(int value) {
        syncType_ = value;
    }
    /**
     * <pre>
     * The type of sync we are currently performing with this peer.
     * </pre>
     *
     * <code>.co.anode.anodium.Peer.SyncType sync_type = 10;</code>
     * @param value The syncType to set.
     */
    private void setSyncType(co.anode.anodium.Rpc.Peer.SyncType value) {
      syncType_ = value.getNumber();
      
    }
    /**
     * <pre>
     * The type of sync we are currently performing with this peer.
     * </pre>
     *
     * <code>.co.anode.anodium.Peer.SyncType sync_type = 10;</code>
     */
    private void clearSyncType() {
      
      syncType_ = 0;
    }

    public static final int FEATURES_FIELD_NUMBER = 11;
    private static final class FeaturesDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Integer, co.anode.anodium.Rpc.Feature> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Integer, co.anode.anodium.Rpc.Feature>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.UINT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  co.anode.anodium.Rpc.Feature.getDefaultInstance());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Integer, co.anode.anodium.Rpc.Feature> features_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    internalGetFeatures() {
      return features_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    internalGetMutableFeatures() {
      if (!features_.isMutable()) {
        features_ = features_.mutableCopy();
      }
      return features_;
    }
    @java.lang.Override

    public int getFeaturesCount() {
      return internalGetFeatures().size();
    }
    /**
     * <pre>
     * Features advertised by the remote peer in their init message.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 11;</code>
     */
    @java.lang.Override

    public boolean containsFeatures(
        int key) {
      
      return internalGetFeatures().containsKey(key);
    }
    /**
     * Use {@link #getFeaturesMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeatures() {
      return getFeaturesMap();
    }
    /**
     * <pre>
     * Features advertised by the remote peer in their init message.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 11;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeaturesMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetFeatures());
    }
    /**
     * <pre>
     * Features advertised by the remote peer in their init message.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 11;</code>
     */
    @java.lang.Override

    public co.anode.anodium.Rpc.Feature getFeaturesOrDefault(
        int key,
        co.anode.anodium.Rpc.Feature defaultValue) {
      
      java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
          internalGetFeatures();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Features advertised by the remote peer in their init message.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 11;</code>
     */
    @java.lang.Override

    public co.anode.anodium.Rpc.Feature getFeaturesOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
          internalGetFeatures();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * Features advertised by the remote peer in their init message.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 11;</code>
     */
    private java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    getMutableFeaturesMap() {
      return internalGetMutableFeatures();
    }

    public static final int ERRORS_FIELD_NUMBER = 12;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.TimestampedError> errors_;
    /**
     * <pre>
     *The latest errors received from our peer with timestamps, limited to the 10
     *most recent errors. These errors are tracked across peer connections, but
     *are not persisted across lnd restarts. Note that these errors are only
     *stored for peers that we have channels open with, to prevent peers from
     *spamming us with errors at no cost.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.TimestampedError> getErrorsList() {
      return errors_;
    }
    /**
     * <pre>
     *The latest errors received from our peer with timestamps, limited to the 10
     *most recent errors. These errors are tracked across peer connections, but
     *are not persisted across lnd restarts. Note that these errors are only
     *stored for peers that we have channels open with, to prevent peers from
     *spamming us with errors at no cost.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.TimestampedErrorOrBuilder> 
        getErrorsOrBuilderList() {
      return errors_;
    }
    /**
     * <pre>
     *The latest errors received from our peer with timestamps, limited to the 10
     *most recent errors. These errors are tracked across peer connections, but
     *are not persisted across lnd restarts. Note that these errors are only
     *stored for peers that we have channels open with, to prevent peers from
     *spamming us with errors at no cost.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
     */
    @java.lang.Override
    public int getErrorsCount() {
      return errors_.size();
    }
    /**
     * <pre>
     *The latest errors received from our peer with timestamps, limited to the 10
     *most recent errors. These errors are tracked across peer connections, but
     *are not persisted across lnd restarts. Note that these errors are only
     *stored for peers that we have channels open with, to prevent peers from
     *spamming us with errors at no cost.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.TimestampedError getErrors(int index) {
      return errors_.get(index);
    }
    /**
     * <pre>
     *The latest errors received from our peer with timestamps, limited to the 10
     *most recent errors. These errors are tracked across peer connections, but
     *are not persisted across lnd restarts. Note that these errors are only
     *stored for peers that we have channels open with, to prevent peers from
     *spamming us with errors at no cost.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
     */
    public co.anode.anodium.Rpc.TimestampedErrorOrBuilder getErrorsOrBuilder(
        int index) {
      return errors_.get(index);
    }
    private void ensureErrorsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.TimestampedError> tmp = errors_;
      if (!tmp.isModifiable()) {
        errors_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     *The latest errors received from our peer with timestamps, limited to the 10
     *most recent errors. These errors are tracked across peer connections, but
     *are not persisted across lnd restarts. Note that these errors are only
     *stored for peers that we have channels open with, to prevent peers from
     *spamming us with errors at no cost.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
     */
    private void setErrors(
        int index, co.anode.anodium.Rpc.TimestampedError value) {
      value.getClass();
  ensureErrorsIsMutable();
      errors_.set(index, value);
    }
    /**
     * <pre>
     *The latest errors received from our peer with timestamps, limited to the 10
     *most recent errors. These errors are tracked across peer connections, but
     *are not persisted across lnd restarts. Note that these errors are only
     *stored for peers that we have channels open with, to prevent peers from
     *spamming us with errors at no cost.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
     */
    private void addErrors(co.anode.anodium.Rpc.TimestampedError value) {
      value.getClass();
  ensureErrorsIsMutable();
      errors_.add(value);
    }
    /**
     * <pre>
     *The latest errors received from our peer with timestamps, limited to the 10
     *most recent errors. These errors are tracked across peer connections, but
     *are not persisted across lnd restarts. Note that these errors are only
     *stored for peers that we have channels open with, to prevent peers from
     *spamming us with errors at no cost.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
     */
    private void addErrors(
        int index, co.anode.anodium.Rpc.TimestampedError value) {
      value.getClass();
  ensureErrorsIsMutable();
      errors_.add(index, value);
    }
    /**
     * <pre>
     *The latest errors received from our peer with timestamps, limited to the 10
     *most recent errors. These errors are tracked across peer connections, but
     *are not persisted across lnd restarts. Note that these errors are only
     *stored for peers that we have channels open with, to prevent peers from
     *spamming us with errors at no cost.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
     */
    private void addAllErrors(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.TimestampedError> values) {
      ensureErrorsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, errors_);
    }
    /**
     * <pre>
     *The latest errors received from our peer with timestamps, limited to the 10
     *most recent errors. These errors are tracked across peer connections, but
     *are not persisted across lnd restarts. Note that these errors are only
     *stored for peers that we have channels open with, to prevent peers from
     *spamming us with errors at no cost.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
     */
    private void clearErrors() {
      errors_ = emptyProtobufList();
    }
    /**
     * <pre>
     *The latest errors received from our peer with timestamps, limited to the 10
     *most recent errors. These errors are tracked across peer connections, but
     *are not persisted across lnd restarts. Note that these errors are only
     *stored for peers that we have channels open with, to prevent peers from
     *spamming us with errors at no cost.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
     */
    private void removeErrors(int index) {
      ensureErrorsIsMutable();
      errors_.remove(index);
    }

    public static final int FLAP_COUNT_FIELD_NUMBER = 13;
    private int flapCount_;
    /**
     * <pre>
     *The number of times we have recorded this peer going offline or coming
     *online, recorded across restarts. Note that this value is decreased over
     *time if the peer has not recently flapped, so that we can forgive peers
     *with historically high flap counts.
     * </pre>
     *
     * <code>int32 flap_count = 13;</code>
     * @return The flapCount.
     */
    @java.lang.Override
    public int getFlapCount() {
      return flapCount_;
    }
    /**
     * <pre>
     *The number of times we have recorded this peer going offline or coming
     *online, recorded across restarts. Note that this value is decreased over
     *time if the peer has not recently flapped, so that we can forgive peers
     *with historically high flap counts.
     * </pre>
     *
     * <code>int32 flap_count = 13;</code>
     * @param value The flapCount to set.
     */
    private void setFlapCount(int value) {
      
      flapCount_ = value;
    }
    /**
     * <pre>
     *The number of times we have recorded this peer going offline or coming
     *online, recorded across restarts. Note that this value is decreased over
     *time if the peer has not recently flapped, so that we can forgive peers
     *with historically high flap counts.
     * </pre>
     *
     * <code>int32 flap_count = 13;</code>
     */
    private void clearFlapCount() {
      
      flapCount_ = 0;
    }

    public static final int LAST_FLAP_NS_FIELD_NUMBER = 14;
    private long lastFlapNs_;
    /**
     * <pre>
     *The timestamp of the last flap we observed for this peer. If this value is
     *zero, we have not observed any flaps for this peer.
     * </pre>
     *
     * <code>int64 last_flap_ns = 14;</code>
     * @return The lastFlapNs.
     */
    @java.lang.Override
    public long getLastFlapNs() {
      return lastFlapNs_;
    }
    /**
     * <pre>
     *The timestamp of the last flap we observed for this peer. If this value is
     *zero, we have not observed any flaps for this peer.
     * </pre>
     *
     * <code>int64 last_flap_ns = 14;</code>
     * @param value The lastFlapNs to set.
     */
    private void setLastFlapNs(long value) {
      
      lastFlapNs_ = value;
    }
    /**
     * <pre>
     *The timestamp of the last flap we observed for this peer. If this value is
     *zero, we have not observed any flaps for this peer.
     * </pre>
     *
     * <code>int64 last_flap_ns = 14;</code>
     */
    private void clearLastFlapNs() {
      
      lastFlapNs_ = 0L;
    }

    public static co.anode.anodium.Rpc.Peer parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Peer parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Peer parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Peer parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Peer parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Peer parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Peer parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Peer parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Peer parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Peer parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Peer parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Peer parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.Peer prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.Peer}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.Peer, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.Peer)
        co.anode.anodium.Rpc.PeerOrBuilder {
      // Construct using co.anode.anodium.Rpc.Peer.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The identity pubkey of the peer
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @return The pubKey.
       */
      @java.lang.Override
      public java.lang.String getPubKey() {
        return instance.getPubKey();
      }
      /**
       * <pre>
       * The identity pubkey of the peer
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @return The bytes for pubKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPubKeyBytes() {
        return instance.getPubKeyBytes();
      }
      /**
       * <pre>
       * The identity pubkey of the peer
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @param value The pubKey to set.
       * @return This builder for chaining.
       */
      public Builder setPubKey(
          java.lang.String value) {
        copyOnWrite();
        instance.setPubKey(value);
        return this;
      }
      /**
       * <pre>
       * The identity pubkey of the peer
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPubKey() {
        copyOnWrite();
        instance.clearPubKey();
        return this;
      }
      /**
       * <pre>
       * The identity pubkey of the peer
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @param value The bytes for pubKey to set.
       * @return This builder for chaining.
       */
      public Builder setPubKeyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPubKeyBytes(value);
        return this;
      }

      /**
       * <pre>
       * Network address of the peer; eg `127.0.0.1:10011`
       * </pre>
       *
       * <code>string address = 3;</code>
       * @return The address.
       */
      @java.lang.Override
      public java.lang.String getAddress() {
        return instance.getAddress();
      }
      /**
       * <pre>
       * Network address of the peer; eg `127.0.0.1:10011`
       * </pre>
       *
       * <code>string address = 3;</code>
       * @return The bytes for address.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getAddressBytes() {
        return instance.getAddressBytes();
      }
      /**
       * <pre>
       * Network address of the peer; eg `127.0.0.1:10011`
       * </pre>
       *
       * <code>string address = 3;</code>
       * @param value The address to set.
       * @return This builder for chaining.
       */
      public Builder setAddress(
          java.lang.String value) {
        copyOnWrite();
        instance.setAddress(value);
        return this;
      }
      /**
       * <pre>
       * Network address of the peer; eg `127.0.0.1:10011`
       * </pre>
       *
       * <code>string address = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearAddress() {
        copyOnWrite();
        instance.clearAddress();
        return this;
      }
      /**
       * <pre>
       * Network address of the peer; eg `127.0.0.1:10011`
       * </pre>
       *
       * <code>string address = 3;</code>
       * @param value The bytes for address to set.
       * @return This builder for chaining.
       */
      public Builder setAddressBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setAddressBytes(value);
        return this;
      }

      /**
       * <pre>
       * Bytes of data transmitted to this peer
       * </pre>
       *
       * <code>uint64 bytes_sent = 4;</code>
       * @return The bytesSent.
       */
      @java.lang.Override
      public long getBytesSent() {
        return instance.getBytesSent();
      }
      /**
       * <pre>
       * Bytes of data transmitted to this peer
       * </pre>
       *
       * <code>uint64 bytes_sent = 4;</code>
       * @param value The bytesSent to set.
       * @return This builder for chaining.
       */
      public Builder setBytesSent(long value) {
        copyOnWrite();
        instance.setBytesSent(value);
        return this;
      }
      /**
       * <pre>
       * Bytes of data transmitted to this peer
       * </pre>
       *
       * <code>uint64 bytes_sent = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearBytesSent() {
        copyOnWrite();
        instance.clearBytesSent();
        return this;
      }

      /**
       * <pre>
       * Bytes of data transmitted from this peer
       * </pre>
       *
       * <code>uint64 bytes_recv = 5;</code>
       * @return The bytesRecv.
       */
      @java.lang.Override
      public long getBytesRecv() {
        return instance.getBytesRecv();
      }
      /**
       * <pre>
       * Bytes of data transmitted from this peer
       * </pre>
       *
       * <code>uint64 bytes_recv = 5;</code>
       * @param value The bytesRecv to set.
       * @return This builder for chaining.
       */
      public Builder setBytesRecv(long value) {
        copyOnWrite();
        instance.setBytesRecv(value);
        return this;
      }
      /**
       * <pre>
       * Bytes of data transmitted from this peer
       * </pre>
       *
       * <code>uint64 bytes_recv = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearBytesRecv() {
        copyOnWrite();
        instance.clearBytesRecv();
        return this;
      }

      /**
       * <pre>
       * Satoshis sent to this peer
       * </pre>
       *
       * <code>int64 sat_sent = 6;</code>
       * @return The satSent.
       */
      @java.lang.Override
      public long getSatSent() {
        return instance.getSatSent();
      }
      /**
       * <pre>
       * Satoshis sent to this peer
       * </pre>
       *
       * <code>int64 sat_sent = 6;</code>
       * @param value The satSent to set.
       * @return This builder for chaining.
       */
      public Builder setSatSent(long value) {
        copyOnWrite();
        instance.setSatSent(value);
        return this;
      }
      /**
       * <pre>
       * Satoshis sent to this peer
       * </pre>
       *
       * <code>int64 sat_sent = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearSatSent() {
        copyOnWrite();
        instance.clearSatSent();
        return this;
      }

      /**
       * <pre>
       * Satoshis received from this peer
       * </pre>
       *
       * <code>int64 sat_recv = 7;</code>
       * @return The satRecv.
       */
      @java.lang.Override
      public long getSatRecv() {
        return instance.getSatRecv();
      }
      /**
       * <pre>
       * Satoshis received from this peer
       * </pre>
       *
       * <code>int64 sat_recv = 7;</code>
       * @param value The satRecv to set.
       * @return This builder for chaining.
       */
      public Builder setSatRecv(long value) {
        copyOnWrite();
        instance.setSatRecv(value);
        return this;
      }
      /**
       * <pre>
       * Satoshis received from this peer
       * </pre>
       *
       * <code>int64 sat_recv = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearSatRecv() {
        copyOnWrite();
        instance.clearSatRecv();
        return this;
      }

      /**
       * <pre>
       * A channel is inbound if the counterparty initiated the channel
       * </pre>
       *
       * <code>bool inbound = 8;</code>
       * @return The inbound.
       */
      @java.lang.Override
      public boolean getInbound() {
        return instance.getInbound();
      }
      /**
       * <pre>
       * A channel is inbound if the counterparty initiated the channel
       * </pre>
       *
       * <code>bool inbound = 8;</code>
       * @param value The inbound to set.
       * @return This builder for chaining.
       */
      public Builder setInbound(boolean value) {
        copyOnWrite();
        instance.setInbound(value);
        return this;
      }
      /**
       * <pre>
       * A channel is inbound if the counterparty initiated the channel
       * </pre>
       *
       * <code>bool inbound = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearInbound() {
        copyOnWrite();
        instance.clearInbound();
        return this;
      }

      /**
       * <pre>
       * Ping time to this peer
       * </pre>
       *
       * <code>int64 ping_time = 9;</code>
       * @return The pingTime.
       */
      @java.lang.Override
      public long getPingTime() {
        return instance.getPingTime();
      }
      /**
       * <pre>
       * Ping time to this peer
       * </pre>
       *
       * <code>int64 ping_time = 9;</code>
       * @param value The pingTime to set.
       * @return This builder for chaining.
       */
      public Builder setPingTime(long value) {
        copyOnWrite();
        instance.setPingTime(value);
        return this;
      }
      /**
       * <pre>
       * Ping time to this peer
       * </pre>
       *
       * <code>int64 ping_time = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearPingTime() {
        copyOnWrite();
        instance.clearPingTime();
        return this;
      }

      /**
       * <pre>
       * The type of sync we are currently performing with this peer.
       * </pre>
       *
       * <code>.co.anode.anodium.Peer.SyncType sync_type = 10;</code>
       * @return The enum numeric value on the wire for syncType.
       */
      @java.lang.Override
      public int getSyncTypeValue() {
        return instance.getSyncTypeValue();
      }
      /**
       * <pre>
       * The type of sync we are currently performing with this peer.
       * </pre>
       *
       * <code>.co.anode.anodium.Peer.SyncType sync_type = 10;</code>
       * @param value The syncType to set.
       * @return This builder for chaining.
       */
      public Builder setSyncTypeValue(int value) {
        copyOnWrite();
        instance.setSyncTypeValue(value);
        return this;
      }
      /**
       * <pre>
       * The type of sync we are currently performing with this peer.
       * </pre>
       *
       * <code>.co.anode.anodium.Peer.SyncType sync_type = 10;</code>
       * @return The syncType.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Peer.SyncType getSyncType() {
        return instance.getSyncType();
      }
      /**
       * <pre>
       * The type of sync we are currently performing with this peer.
       * </pre>
       *
       * <code>.co.anode.anodium.Peer.SyncType sync_type = 10;</code>
       * @param value The enum numeric value on the wire for syncType to set.
       * @return This builder for chaining.
       */
      public Builder setSyncType(co.anode.anodium.Rpc.Peer.SyncType value) {
        copyOnWrite();
        instance.setSyncType(value);
        return this;
      }
      /**
       * <pre>
       * The type of sync we are currently performing with this peer.
       * </pre>
       *
       * <code>.co.anode.anodium.Peer.SyncType sync_type = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearSyncType() {
        copyOnWrite();
        instance.clearSyncType();
        return this;
      }

      @java.lang.Override

      public int getFeaturesCount() {
        return instance.getFeaturesMap().size();
      }
      /**
       * <pre>
       * Features advertised by the remote peer in their init message.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 11;</code>
       */
      @java.lang.Override

      public boolean containsFeatures(
          int key) {
        
        return instance.getFeaturesMap().containsKey(key);
      }

      public Builder clearFeatures() {
        copyOnWrite();
        instance.getMutableFeaturesMap().clear();
        return this;
      }
      /**
       * <pre>
       * Features advertised by the remote peer in their init message.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 11;</code>
       */

      public Builder removeFeatures(
          int key) {
        
        copyOnWrite();
        instance.getMutableFeaturesMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getFeaturesMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeatures() {
        return getFeaturesMap();
      }
      /**
       * <pre>
       * Features advertised by the remote peer in their init message.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 11;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeaturesMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getFeaturesMap());
      }
      /**
       * <pre>
       * Features advertised by the remote peer in their init message.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 11;</code>
       */
      @java.lang.Override

      public co.anode.anodium.Rpc.Feature getFeaturesOrDefault(
          int key,
          co.anode.anodium.Rpc.Feature defaultValue) {
        
        java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
            instance.getFeaturesMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Features advertised by the remote peer in their init message.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 11;</code>
       */
      @java.lang.Override

      public co.anode.anodium.Rpc.Feature getFeaturesOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
            instance.getFeaturesMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * Features advertised by the remote peer in their init message.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 11;</code>
       */
      public Builder putFeatures(
          int key,
          co.anode.anodium.Rpc.Feature value) {
        
        value.getClass();
        copyOnWrite();
        instance.getMutableFeaturesMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * Features advertised by the remote peer in their init message.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 11;</code>
       */
      public Builder putAllFeatures(
          java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> values) {
        copyOnWrite();
        instance.getMutableFeaturesMap().putAll(values);
        return this;
      }

      /**
       * <pre>
       *The latest errors received from our peer with timestamps, limited to the 10
       *most recent errors. These errors are tracked across peer connections, but
       *are not persisted across lnd restarts. Note that these errors are only
       *stored for peers that we have channels open with, to prevent peers from
       *spamming us with errors at no cost.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.TimestampedError> getErrorsList() {
        return java.util.Collections.unmodifiableList(
            instance.getErrorsList());
      }
      /**
       * <pre>
       *The latest errors received from our peer with timestamps, limited to the 10
       *most recent errors. These errors are tracked across peer connections, but
       *are not persisted across lnd restarts. Note that these errors are only
       *stored for peers that we have channels open with, to prevent peers from
       *spamming us with errors at no cost.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
       */
      @java.lang.Override
      public int getErrorsCount() {
        return instance.getErrorsCount();
      }/**
       * <pre>
       *The latest errors received from our peer with timestamps, limited to the 10
       *most recent errors. These errors are tracked across peer connections, but
       *are not persisted across lnd restarts. Note that these errors are only
       *stored for peers that we have channels open with, to prevent peers from
       *spamming us with errors at no cost.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.TimestampedError getErrors(int index) {
        return instance.getErrors(index);
      }
      /**
       * <pre>
       *The latest errors received from our peer with timestamps, limited to the 10
       *most recent errors. These errors are tracked across peer connections, but
       *are not persisted across lnd restarts. Note that these errors are only
       *stored for peers that we have channels open with, to prevent peers from
       *spamming us with errors at no cost.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
       */
      public Builder setErrors(
          int index, co.anode.anodium.Rpc.TimestampedError value) {
        copyOnWrite();
        instance.setErrors(index, value);
        return this;
      }
      /**
       * <pre>
       *The latest errors received from our peer with timestamps, limited to the 10
       *most recent errors. These errors are tracked across peer connections, but
       *are not persisted across lnd restarts. Note that these errors are only
       *stored for peers that we have channels open with, to prevent peers from
       *spamming us with errors at no cost.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
       */
      public Builder setErrors(
          int index, co.anode.anodium.Rpc.TimestampedError.Builder builderForValue) {
        copyOnWrite();
        instance.setErrors(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *The latest errors received from our peer with timestamps, limited to the 10
       *most recent errors. These errors are tracked across peer connections, but
       *are not persisted across lnd restarts. Note that these errors are only
       *stored for peers that we have channels open with, to prevent peers from
       *spamming us with errors at no cost.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
       */
      public Builder addErrors(co.anode.anodium.Rpc.TimestampedError value) {
        copyOnWrite();
        instance.addErrors(value);
        return this;
      }
      /**
       * <pre>
       *The latest errors received from our peer with timestamps, limited to the 10
       *most recent errors. These errors are tracked across peer connections, but
       *are not persisted across lnd restarts. Note that these errors are only
       *stored for peers that we have channels open with, to prevent peers from
       *spamming us with errors at no cost.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
       */
      public Builder addErrors(
          int index, co.anode.anodium.Rpc.TimestampedError value) {
        copyOnWrite();
        instance.addErrors(index, value);
        return this;
      }
      /**
       * <pre>
       *The latest errors received from our peer with timestamps, limited to the 10
       *most recent errors. These errors are tracked across peer connections, but
       *are not persisted across lnd restarts. Note that these errors are only
       *stored for peers that we have channels open with, to prevent peers from
       *spamming us with errors at no cost.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
       */
      public Builder addErrors(
          co.anode.anodium.Rpc.TimestampedError.Builder builderForValue) {
        copyOnWrite();
        instance.addErrors(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *The latest errors received from our peer with timestamps, limited to the 10
       *most recent errors. These errors are tracked across peer connections, but
       *are not persisted across lnd restarts. Note that these errors are only
       *stored for peers that we have channels open with, to prevent peers from
       *spamming us with errors at no cost.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
       */
      public Builder addErrors(
          int index, co.anode.anodium.Rpc.TimestampedError.Builder builderForValue) {
        copyOnWrite();
        instance.addErrors(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *The latest errors received from our peer with timestamps, limited to the 10
       *most recent errors. These errors are tracked across peer connections, but
       *are not persisted across lnd restarts. Note that these errors are only
       *stored for peers that we have channels open with, to prevent peers from
       *spamming us with errors at no cost.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
       */
      public Builder addAllErrors(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.TimestampedError> values) {
        copyOnWrite();
        instance.addAllErrors(values);
        return this;
      }
      /**
       * <pre>
       *The latest errors received from our peer with timestamps, limited to the 10
       *most recent errors. These errors are tracked across peer connections, but
       *are not persisted across lnd restarts. Note that these errors are only
       *stored for peers that we have channels open with, to prevent peers from
       *spamming us with errors at no cost.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
       */
      public Builder clearErrors() {
        copyOnWrite();
        instance.clearErrors();
        return this;
      }
      /**
       * <pre>
       *The latest errors received from our peer with timestamps, limited to the 10
       *most recent errors. These errors are tracked across peer connections, but
       *are not persisted across lnd restarts. Note that these errors are only
       *stored for peers that we have channels open with, to prevent peers from
       *spamming us with errors at no cost.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.TimestampedError errors = 12;</code>
       */
      public Builder removeErrors(int index) {
        copyOnWrite();
        instance.removeErrors(index);
        return this;
      }

      /**
       * <pre>
       *The number of times we have recorded this peer going offline or coming
       *online, recorded across restarts. Note that this value is decreased over
       *time if the peer has not recently flapped, so that we can forgive peers
       *with historically high flap counts.
       * </pre>
       *
       * <code>int32 flap_count = 13;</code>
       * @return The flapCount.
       */
      @java.lang.Override
      public int getFlapCount() {
        return instance.getFlapCount();
      }
      /**
       * <pre>
       *The number of times we have recorded this peer going offline or coming
       *online, recorded across restarts. Note that this value is decreased over
       *time if the peer has not recently flapped, so that we can forgive peers
       *with historically high flap counts.
       * </pre>
       *
       * <code>int32 flap_count = 13;</code>
       * @param value The flapCount to set.
       * @return This builder for chaining.
       */
      public Builder setFlapCount(int value) {
        copyOnWrite();
        instance.setFlapCount(value);
        return this;
      }
      /**
       * <pre>
       *The number of times we have recorded this peer going offline or coming
       *online, recorded across restarts. Note that this value is decreased over
       *time if the peer has not recently flapped, so that we can forgive peers
       *with historically high flap counts.
       * </pre>
       *
       * <code>int32 flap_count = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearFlapCount() {
        copyOnWrite();
        instance.clearFlapCount();
        return this;
      }

      /**
       * <pre>
       *The timestamp of the last flap we observed for this peer. If this value is
       *zero, we have not observed any flaps for this peer.
       * </pre>
       *
       * <code>int64 last_flap_ns = 14;</code>
       * @return The lastFlapNs.
       */
      @java.lang.Override
      public long getLastFlapNs() {
        return instance.getLastFlapNs();
      }
      /**
       * <pre>
       *The timestamp of the last flap we observed for this peer. If this value is
       *zero, we have not observed any flaps for this peer.
       * </pre>
       *
       * <code>int64 last_flap_ns = 14;</code>
       * @param value The lastFlapNs to set.
       * @return This builder for chaining.
       */
      public Builder setLastFlapNs(long value) {
        copyOnWrite();
        instance.setLastFlapNs(value);
        return this;
      }
      /**
       * <pre>
       *The timestamp of the last flap we observed for this peer. If this value is
       *zero, we have not observed any flaps for this peer.
       * </pre>
       *
       * <code>int64 last_flap_ns = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearLastFlapNs() {
        copyOnWrite();
        instance.clearLastFlapNs();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.Peer)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.Peer();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "pubKey_",
              "address_",
              "bytesSent_",
              "bytesRecv_",
              "satSent_",
              "satRecv_",
              "inbound_",
              "pingTime_",
              "syncType_",
              "features_",
              FeaturesDefaultEntryHolder.defaultEntry,
              "errors_",
              co.anode.anodium.Rpc.TimestampedError.class,
              "flapCount_",
              "lastFlapNs_",
            };
            java.lang.String info =
                "\u0000\r\u0000\u0000\u0001\u000e\r\u0001\u0001\u0000\u0001\u0208\u0003\u0208\u0004" +
                "\u0003\u0005\u0003\u0006\u0002\u0007\u0002\b\u0007\t\u0002\n\f\u000b2\f\u001b\r\u0004" +
                "\u000e\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.Peer> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.Peer.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.Peer>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.Peer)
    private static final co.anode.anodium.Rpc.Peer DEFAULT_INSTANCE;
    static {
      Peer defaultInstance = new Peer();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Peer.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.Peer getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Peer> PARSER;

    public static com.google.protobuf.Parser<Peer> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TimestampedErrorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.TimestampedError)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The unix timestamp in seconds when the error occurred.
     * </pre>
     *
     * <code>uint64 timestamp = 1;</code>
     * @return The timestamp.
     */
    long getTimestamp();

    /**
     * <pre>
     * The string representation of the error sent by our peer.
     * </pre>
     *
     * <code>string error = 2;</code>
     * @return The error.
     */
    java.lang.String getError();
    /**
     * <pre>
     * The string representation of the error sent by our peer.
     * </pre>
     *
     * <code>string error = 2;</code>
     * @return The bytes for error.
     */
    com.google.protobuf.ByteString
        getErrorBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.TimestampedError}
   */
  public  static final class TimestampedError extends
      com.google.protobuf.GeneratedMessageLite<
          TimestampedError, TimestampedError.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.TimestampedError)
      TimestampedErrorOrBuilder {
    private TimestampedError() {
      error_ = "";
    }
    public static final int TIMESTAMP_FIELD_NUMBER = 1;
    private long timestamp_;
    /**
     * <pre>
     * The unix timestamp in seconds when the error occurred.
     * </pre>
     *
     * <code>uint64 timestamp = 1;</code>
     * @return The timestamp.
     */
    @java.lang.Override
    public long getTimestamp() {
      return timestamp_;
    }
    /**
     * <pre>
     * The unix timestamp in seconds when the error occurred.
     * </pre>
     *
     * <code>uint64 timestamp = 1;</code>
     * @param value The timestamp to set.
     */
    private void setTimestamp(long value) {
      
      timestamp_ = value;
    }
    /**
     * <pre>
     * The unix timestamp in seconds when the error occurred.
     * </pre>
     *
     * <code>uint64 timestamp = 1;</code>
     */
    private void clearTimestamp() {
      
      timestamp_ = 0L;
    }

    public static final int ERROR_FIELD_NUMBER = 2;
    private java.lang.String error_;
    /**
     * <pre>
     * The string representation of the error sent by our peer.
     * </pre>
     *
     * <code>string error = 2;</code>
     * @return The error.
     */
    @java.lang.Override
    public java.lang.String getError() {
      return error_;
    }
    /**
     * <pre>
     * The string representation of the error sent by our peer.
     * </pre>
     *
     * <code>string error = 2;</code>
     * @return The bytes for error.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getErrorBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(error_);
    }
    /**
     * <pre>
     * The string representation of the error sent by our peer.
     * </pre>
     *
     * <code>string error = 2;</code>
     * @param value The error to set.
     */
    private void setError(
        java.lang.String value) {
      value.getClass();
  
      error_ = value;
    }
    /**
     * <pre>
     * The string representation of the error sent by our peer.
     * </pre>
     *
     * <code>string error = 2;</code>
     */
    private void clearError() {
      
      error_ = getDefaultInstance().getError();
    }
    /**
     * <pre>
     * The string representation of the error sent by our peer.
     * </pre>
     *
     * <code>string error = 2;</code>
     * @param value The bytes for error to set.
     */
    private void setErrorBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      error_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.TimestampedError parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.TimestampedError parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.TimestampedError parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.TimestampedError parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.TimestampedError parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.TimestampedError parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.TimestampedError parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.TimestampedError parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.TimestampedError parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.TimestampedError parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.TimestampedError parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.TimestampedError parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.TimestampedError prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.TimestampedError}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.TimestampedError, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.TimestampedError)
        co.anode.anodium.Rpc.TimestampedErrorOrBuilder {
      // Construct using co.anode.anodium.Rpc.TimestampedError.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The unix timestamp in seconds when the error occurred.
       * </pre>
       *
       * <code>uint64 timestamp = 1;</code>
       * @return The timestamp.
       */
      @java.lang.Override
      public long getTimestamp() {
        return instance.getTimestamp();
      }
      /**
       * <pre>
       * The unix timestamp in seconds when the error occurred.
       * </pre>
       *
       * <code>uint64 timestamp = 1;</code>
       * @param value The timestamp to set.
       * @return This builder for chaining.
       */
      public Builder setTimestamp(long value) {
        copyOnWrite();
        instance.setTimestamp(value);
        return this;
      }
      /**
       * <pre>
       * The unix timestamp in seconds when the error occurred.
       * </pre>
       *
       * <code>uint64 timestamp = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimestamp() {
        copyOnWrite();
        instance.clearTimestamp();
        return this;
      }

      /**
       * <pre>
       * The string representation of the error sent by our peer.
       * </pre>
       *
       * <code>string error = 2;</code>
       * @return The error.
       */
      @java.lang.Override
      public java.lang.String getError() {
        return instance.getError();
      }
      /**
       * <pre>
       * The string representation of the error sent by our peer.
       * </pre>
       *
       * <code>string error = 2;</code>
       * @return The bytes for error.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getErrorBytes() {
        return instance.getErrorBytes();
      }
      /**
       * <pre>
       * The string representation of the error sent by our peer.
       * </pre>
       *
       * <code>string error = 2;</code>
       * @param value The error to set.
       * @return This builder for chaining.
       */
      public Builder setError(
          java.lang.String value) {
        copyOnWrite();
        instance.setError(value);
        return this;
      }
      /**
       * <pre>
       * The string representation of the error sent by our peer.
       * </pre>
       *
       * <code>string error = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearError() {
        copyOnWrite();
        instance.clearError();
        return this;
      }
      /**
       * <pre>
       * The string representation of the error sent by our peer.
       * </pre>
       *
       * <code>string error = 2;</code>
       * @param value The bytes for error to set.
       * @return This builder for chaining.
       */
      public Builder setErrorBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setErrorBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.TimestampedError)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.TimestampedError();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "timestamp_",
              "error_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0003\u0002\u0208" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.TimestampedError> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.TimestampedError.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.TimestampedError>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.TimestampedError)
    private static final co.anode.anodium.Rpc.TimestampedError DEFAULT_INSTANCE;
    static {
      TimestampedError defaultInstance = new TimestampedError();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TimestampedError.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.TimestampedError getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TimestampedError> PARSER;

    public static com.google.protobuf.Parser<TimestampedError> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ListPeersRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ListPeersRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *If true, only the last error that our peer sent us will be returned with
     *the peer's information, rather than the full set of historic errors we have
     *stored.
     * </pre>
     *
     * <code>bool latest_error = 1;</code>
     * @return The latestError.
     */
    boolean getLatestError();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ListPeersRequest}
   */
  public  static final class ListPeersRequest extends
      com.google.protobuf.GeneratedMessageLite<
          ListPeersRequest, ListPeersRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ListPeersRequest)
      ListPeersRequestOrBuilder {
    private ListPeersRequest() {
    }
    public static final int LATEST_ERROR_FIELD_NUMBER = 1;
    private boolean latestError_;
    /**
     * <pre>
     *If true, only the last error that our peer sent us will be returned with
     *the peer's information, rather than the full set of historic errors we have
     *stored.
     * </pre>
     *
     * <code>bool latest_error = 1;</code>
     * @return The latestError.
     */
    @java.lang.Override
    public boolean getLatestError() {
      return latestError_;
    }
    /**
     * <pre>
     *If true, only the last error that our peer sent us will be returned with
     *the peer's information, rather than the full set of historic errors we have
     *stored.
     * </pre>
     *
     * <code>bool latest_error = 1;</code>
     * @param value The latestError to set.
     */
    private void setLatestError(boolean value) {
      
      latestError_ = value;
    }
    /**
     * <pre>
     *If true, only the last error that our peer sent us will be returned with
     *the peer's information, rather than the full set of historic errors we have
     *stored.
     * </pre>
     *
     * <code>bool latest_error = 1;</code>
     */
    private void clearLatestError() {
      
      latestError_ = false;
    }

    public static co.anode.anodium.Rpc.ListPeersRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListPeersRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPeersRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListPeersRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPeersRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListPeersRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPeersRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListPeersRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPeersRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListPeersRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPeersRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListPeersRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ListPeersRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ListPeersRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ListPeersRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ListPeersRequest)
        co.anode.anodium.Rpc.ListPeersRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.ListPeersRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *If true, only the last error that our peer sent us will be returned with
       *the peer's information, rather than the full set of historic errors we have
       *stored.
       * </pre>
       *
       * <code>bool latest_error = 1;</code>
       * @return The latestError.
       */
      @java.lang.Override
      public boolean getLatestError() {
        return instance.getLatestError();
      }
      /**
       * <pre>
       *If true, only the last error that our peer sent us will be returned with
       *the peer's information, rather than the full set of historic errors we have
       *stored.
       * </pre>
       *
       * <code>bool latest_error = 1;</code>
       * @param value The latestError to set.
       * @return This builder for chaining.
       */
      public Builder setLatestError(boolean value) {
        copyOnWrite();
        instance.setLatestError(value);
        return this;
      }
      /**
       * <pre>
       *If true, only the last error that our peer sent us will be returned with
       *the peer's information, rather than the full set of historic errors we have
       *stored.
       * </pre>
       *
       * <code>bool latest_error = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearLatestError() {
        copyOnWrite();
        instance.clearLatestError();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ListPeersRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ListPeersRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "latestError_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u0007";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ListPeersRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ListPeersRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ListPeersRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ListPeersRequest)
    private static final co.anode.anodium.Rpc.ListPeersRequest DEFAULT_INSTANCE;
    static {
      ListPeersRequest defaultInstance = new ListPeersRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ListPeersRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ListPeersRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ListPeersRequest> PARSER;

    public static com.google.protobuf.Parser<ListPeersRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ListPeersResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ListPeersResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The list of currently connected peers
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
     */
    java.util.List<co.anode.anodium.Rpc.Peer> 
        getPeersList();
    /**
     * <pre>
     * The list of currently connected peers
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
     */
    co.anode.anodium.Rpc.Peer getPeers(int index);
    /**
     * <pre>
     * The list of currently connected peers
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
     */
    int getPeersCount();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ListPeersResponse}
   */
  public  static final class ListPeersResponse extends
      com.google.protobuf.GeneratedMessageLite<
          ListPeersResponse, ListPeersResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ListPeersResponse)
      ListPeersResponseOrBuilder {
    private ListPeersResponse() {
      peers_ = emptyProtobufList();
    }
    public static final int PEERS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Peer> peers_;
    /**
     * <pre>
     * The list of currently connected peers
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.Peer> getPeersList() {
      return peers_;
    }
    /**
     * <pre>
     * The list of currently connected peers
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.PeerOrBuilder> 
        getPeersOrBuilderList() {
      return peers_;
    }
    /**
     * <pre>
     * The list of currently connected peers
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
     */
    @java.lang.Override
    public int getPeersCount() {
      return peers_.size();
    }
    /**
     * <pre>
     * The list of currently connected peers
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Peer getPeers(int index) {
      return peers_.get(index);
    }
    /**
     * <pre>
     * The list of currently connected peers
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
     */
    public co.anode.anodium.Rpc.PeerOrBuilder getPeersOrBuilder(
        int index) {
      return peers_.get(index);
    }
    private void ensurePeersIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Peer> tmp = peers_;
      if (!tmp.isModifiable()) {
        peers_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * The list of currently connected peers
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
     */
    private void setPeers(
        int index, co.anode.anodium.Rpc.Peer value) {
      value.getClass();
  ensurePeersIsMutable();
      peers_.set(index, value);
    }
    /**
     * <pre>
     * The list of currently connected peers
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
     */
    private void addPeers(co.anode.anodium.Rpc.Peer value) {
      value.getClass();
  ensurePeersIsMutable();
      peers_.add(value);
    }
    /**
     * <pre>
     * The list of currently connected peers
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
     */
    private void addPeers(
        int index, co.anode.anodium.Rpc.Peer value) {
      value.getClass();
  ensurePeersIsMutable();
      peers_.add(index, value);
    }
    /**
     * <pre>
     * The list of currently connected peers
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
     */
    private void addAllPeers(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.Peer> values) {
      ensurePeersIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, peers_);
    }
    /**
     * <pre>
     * The list of currently connected peers
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
     */
    private void clearPeers() {
      peers_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The list of currently connected peers
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
     */
    private void removePeers(int index) {
      ensurePeersIsMutable();
      peers_.remove(index);
    }

    public static co.anode.anodium.Rpc.ListPeersResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListPeersResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPeersResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListPeersResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPeersResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListPeersResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPeersResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListPeersResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPeersResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListPeersResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPeersResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListPeersResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ListPeersResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ListPeersResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ListPeersResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ListPeersResponse)
        co.anode.anodium.Rpc.ListPeersResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.ListPeersResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The list of currently connected peers
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.Peer> getPeersList() {
        return java.util.Collections.unmodifiableList(
            instance.getPeersList());
      }
      /**
       * <pre>
       * The list of currently connected peers
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
       */
      @java.lang.Override
      public int getPeersCount() {
        return instance.getPeersCount();
      }/**
       * <pre>
       * The list of currently connected peers
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Peer getPeers(int index) {
        return instance.getPeers(index);
      }
      /**
       * <pre>
       * The list of currently connected peers
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
       */
      public Builder setPeers(
          int index, co.anode.anodium.Rpc.Peer value) {
        copyOnWrite();
        instance.setPeers(index, value);
        return this;
      }
      /**
       * <pre>
       * The list of currently connected peers
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
       */
      public Builder setPeers(
          int index, co.anode.anodium.Rpc.Peer.Builder builderForValue) {
        copyOnWrite();
        instance.setPeers(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of currently connected peers
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
       */
      public Builder addPeers(co.anode.anodium.Rpc.Peer value) {
        copyOnWrite();
        instance.addPeers(value);
        return this;
      }
      /**
       * <pre>
       * The list of currently connected peers
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
       */
      public Builder addPeers(
          int index, co.anode.anodium.Rpc.Peer value) {
        copyOnWrite();
        instance.addPeers(index, value);
        return this;
      }
      /**
       * <pre>
       * The list of currently connected peers
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
       */
      public Builder addPeers(
          co.anode.anodium.Rpc.Peer.Builder builderForValue) {
        copyOnWrite();
        instance.addPeers(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of currently connected peers
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
       */
      public Builder addPeers(
          int index, co.anode.anodium.Rpc.Peer.Builder builderForValue) {
        copyOnWrite();
        instance.addPeers(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of currently connected peers
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
       */
      public Builder addAllPeers(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.Peer> values) {
        copyOnWrite();
        instance.addAllPeers(values);
        return this;
      }
      /**
       * <pre>
       * The list of currently connected peers
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
       */
      public Builder clearPeers() {
        copyOnWrite();
        instance.clearPeers();
        return this;
      }
      /**
       * <pre>
       * The list of currently connected peers
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Peer peers = 1;</code>
       */
      public Builder removePeers(int index) {
        copyOnWrite();
        instance.removePeers(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ListPeersResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ListPeersResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "peers_",
              co.anode.anodium.Rpc.Peer.class,
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0000\u0001\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ListPeersResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ListPeersResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ListPeersResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ListPeersResponse)
    private static final co.anode.anodium.Rpc.ListPeersResponse DEFAULT_INSTANCE;
    static {
      ListPeersResponse defaultInstance = new ListPeersResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ListPeersResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ListPeersResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ListPeersResponse> PARSER;

    public static com.google.protobuf.Parser<ListPeersResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PeerEventSubscriptionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.PeerEventSubscription)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.PeerEventSubscription}
   */
  public  static final class PeerEventSubscription extends
      com.google.protobuf.GeneratedMessageLite<
          PeerEventSubscription, PeerEventSubscription.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.PeerEventSubscription)
      PeerEventSubscriptionOrBuilder {
    private PeerEventSubscription() {
    }
    public static co.anode.anodium.Rpc.PeerEventSubscription parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PeerEventSubscription parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PeerEventSubscription parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PeerEventSubscription parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PeerEventSubscription parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PeerEventSubscription parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PeerEventSubscription parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PeerEventSubscription parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PeerEventSubscription parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PeerEventSubscription parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PeerEventSubscription parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PeerEventSubscription parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.PeerEventSubscription prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.PeerEventSubscription}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.PeerEventSubscription, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.PeerEventSubscription)
        co.anode.anodium.Rpc.PeerEventSubscriptionOrBuilder {
      // Construct using co.anode.anodium.Rpc.PeerEventSubscription.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.PeerEventSubscription)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.PeerEventSubscription();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.PeerEventSubscription> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.PeerEventSubscription.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.PeerEventSubscription>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.PeerEventSubscription)
    private static final co.anode.anodium.Rpc.PeerEventSubscription DEFAULT_INSTANCE;
    static {
      PeerEventSubscription defaultInstance = new PeerEventSubscription();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        PeerEventSubscription.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.PeerEventSubscription getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<PeerEventSubscription> PARSER;

    public static com.google.protobuf.Parser<PeerEventSubscription> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PeerEventOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.PeerEvent)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The identity pubkey of the peer.
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The pubKey.
     */
    java.lang.String getPubKey();
    /**
     * <pre>
     * The identity pubkey of the peer.
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The bytes for pubKey.
     */
    com.google.protobuf.ByteString
        getPubKeyBytes();

    /**
     * <code>.co.anode.anodium.PeerEvent.EventType type = 2;</code>
     * @return The enum numeric value on the wire for type.
     */
    int getTypeValue();
    /**
     * <code>.co.anode.anodium.PeerEvent.EventType type = 2;</code>
     * @return The type.
     */
    co.anode.anodium.Rpc.PeerEvent.EventType getType();
  }
  /**
   * Protobuf type {@code co.anode.anodium.PeerEvent}
   */
  public  static final class PeerEvent extends
      com.google.protobuf.GeneratedMessageLite<
          PeerEvent, PeerEvent.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.PeerEvent)
      PeerEventOrBuilder {
    private PeerEvent() {
      pubKey_ = "";
    }
    /**
     * Protobuf enum {@code co.anode.anodium.PeerEvent.EventType}
     */
    public enum EventType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>PEER_ONLINE = 0;</code>
       */
      PEER_ONLINE(0),
      /**
       * <code>PEER_OFFLINE = 1;</code>
       */
      PEER_OFFLINE(1),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>PEER_ONLINE = 0;</code>
       */
      public static final int PEER_ONLINE_VALUE = 0;
      /**
       * <code>PEER_OFFLINE = 1;</code>
       */
      public static final int PEER_OFFLINE_VALUE = 1;


      @java.lang.Override
      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static EventType valueOf(int value) {
        return forNumber(value);
      }

      public static EventType forNumber(int value) {
        switch (value) {
          case 0: return PEER_ONLINE;
          case 1: return PEER_OFFLINE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<EventType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          EventType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<EventType>() {
              @java.lang.Override
              public EventType findValueByNumber(int number) {
                return EventType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return EventTypeVerifier.INSTANCE;
      }

      private static final class EventTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new EventTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return EventType.forNumber(number) != null;
              }
            };

      private final int value;

      private EventType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:co.anode.anodium.PeerEvent.EventType)
    }

    public static final int PUB_KEY_FIELD_NUMBER = 1;
    private java.lang.String pubKey_;
    /**
     * <pre>
     * The identity pubkey of the peer.
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The pubKey.
     */
    @java.lang.Override
    public java.lang.String getPubKey() {
      return pubKey_;
    }
    /**
     * <pre>
     * The identity pubkey of the peer.
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The bytes for pubKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPubKeyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(pubKey_);
    }
    /**
     * <pre>
     * The identity pubkey of the peer.
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @param value The pubKey to set.
     */
    private void setPubKey(
        java.lang.String value) {
      value.getClass();
  
      pubKey_ = value;
    }
    /**
     * <pre>
     * The identity pubkey of the peer.
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     */
    private void clearPubKey() {
      
      pubKey_ = getDefaultInstance().getPubKey();
    }
    /**
     * <pre>
     * The identity pubkey of the peer.
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @param value The bytes for pubKey to set.
     */
    private void setPubKeyBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      pubKey_ = value.toStringUtf8();
      
    }

    public static final int TYPE_FIELD_NUMBER = 2;
    private int type_;
    /**
     * <code>.co.anode.anodium.PeerEvent.EventType type = 2;</code>
     * @return The enum numeric value on the wire for type.
     */
    @java.lang.Override
    public int getTypeValue() {
      return type_;
    }
    /**
     * <code>.co.anode.anodium.PeerEvent.EventType type = 2;</code>
     * @return The type.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.PeerEvent.EventType getType() {
      co.anode.anodium.Rpc.PeerEvent.EventType result = co.anode.anodium.Rpc.PeerEvent.EventType.forNumber(type_);
      return result == null ? co.anode.anodium.Rpc.PeerEvent.EventType.UNRECOGNIZED : result;
    }
    /**
     * <code>.co.anode.anodium.PeerEvent.EventType type = 2;</code>
     * @param value The enum numeric value on the wire for type to set.
     */
    private void setTypeValue(int value) {
        type_ = value;
    }
    /**
     * <code>.co.anode.anodium.PeerEvent.EventType type = 2;</code>
     * @param value The type to set.
     */
    private void setType(co.anode.anodium.Rpc.PeerEvent.EventType value) {
      type_ = value.getNumber();
      
    }
    /**
     * <code>.co.anode.anodium.PeerEvent.EventType type = 2;</code>
     */
    private void clearType() {
      
      type_ = 0;
    }

    public static co.anode.anodium.Rpc.PeerEvent parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PeerEvent parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PeerEvent parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PeerEvent parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PeerEvent parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PeerEvent parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PeerEvent parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PeerEvent parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PeerEvent parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PeerEvent parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PeerEvent parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PeerEvent parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.PeerEvent prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.PeerEvent}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.PeerEvent, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.PeerEvent)
        co.anode.anodium.Rpc.PeerEventOrBuilder {
      // Construct using co.anode.anodium.Rpc.PeerEvent.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The identity pubkey of the peer.
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @return The pubKey.
       */
      @java.lang.Override
      public java.lang.String getPubKey() {
        return instance.getPubKey();
      }
      /**
       * <pre>
       * The identity pubkey of the peer.
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @return The bytes for pubKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPubKeyBytes() {
        return instance.getPubKeyBytes();
      }
      /**
       * <pre>
       * The identity pubkey of the peer.
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @param value The pubKey to set.
       * @return This builder for chaining.
       */
      public Builder setPubKey(
          java.lang.String value) {
        copyOnWrite();
        instance.setPubKey(value);
        return this;
      }
      /**
       * <pre>
       * The identity pubkey of the peer.
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPubKey() {
        copyOnWrite();
        instance.clearPubKey();
        return this;
      }
      /**
       * <pre>
       * The identity pubkey of the peer.
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @param value The bytes for pubKey to set.
       * @return This builder for chaining.
       */
      public Builder setPubKeyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPubKeyBytes(value);
        return this;
      }

      /**
       * <code>.co.anode.anodium.PeerEvent.EventType type = 2;</code>
       * @return The enum numeric value on the wire for type.
       */
      @java.lang.Override
      public int getTypeValue() {
        return instance.getTypeValue();
      }
      /**
       * <code>.co.anode.anodium.PeerEvent.EventType type = 2;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeValue(int value) {
        copyOnWrite();
        instance.setTypeValue(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.PeerEvent.EventType type = 2;</code>
       * @return The type.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.PeerEvent.EventType getType() {
        return instance.getType();
      }
      /**
       * <code>.co.anode.anodium.PeerEvent.EventType type = 2;</code>
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setType(co.anode.anodium.Rpc.PeerEvent.EventType value) {
        copyOnWrite();
        instance.setType(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.PeerEvent.EventType type = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        copyOnWrite();
        instance.clearType();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.PeerEvent)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.PeerEvent();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "pubKey_",
              "type_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0208\u0002\f" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.PeerEvent> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.PeerEvent.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.PeerEvent>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.PeerEvent)
    private static final co.anode.anodium.Rpc.PeerEvent DEFAULT_INSTANCE;
    static {
      PeerEvent defaultInstance = new PeerEvent();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        PeerEvent.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.PeerEvent getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<PeerEvent> PARSER;

    public static com.google.protobuf.Parser<PeerEvent> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface GetInfoRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.GetInfoRequest)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.GetInfoRequest}
   */
  public  static final class GetInfoRequest extends
      com.google.protobuf.GeneratedMessageLite<
          GetInfoRequest, GetInfoRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.GetInfoRequest)
      GetInfoRequestOrBuilder {
    private GetInfoRequest() {
    }
    public static co.anode.anodium.Rpc.GetInfoRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetInfoRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetInfoRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetInfoRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetInfoRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetInfoRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetInfoRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetInfoRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetInfoRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetInfoRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.GetInfoRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.GetInfoRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.GetInfoRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.GetInfoRequest)
        co.anode.anodium.Rpc.GetInfoRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.GetInfoRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.GetInfoRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.GetInfoRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.GetInfoRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.GetInfoRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.GetInfoRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.GetInfoRequest)
    private static final co.anode.anodium.Rpc.GetInfoRequest DEFAULT_INSTANCE;
    static {
      GetInfoRequest defaultInstance = new GetInfoRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        GetInfoRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.GetInfoRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<GetInfoRequest> PARSER;

    public static com.google.protobuf.Parser<GetInfoRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface GetInfoResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.GetInfoResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The version of the LND software that the node is running.
     * </pre>
     *
     * <code>string version = 14;</code>
     * @return The version.
     */
    java.lang.String getVersion();
    /**
     * <pre>
     * The version of the LND software that the node is running.
     * </pre>
     *
     * <code>string version = 14;</code>
     * @return The bytes for version.
     */
    com.google.protobuf.ByteString
        getVersionBytes();

    /**
     * <pre>
     * The SHA1 commit hash that the daemon is compiled with.
     * </pre>
     *
     * <code>string commit_hash = 20;</code>
     * @return The commitHash.
     */
    java.lang.String getCommitHash();
    /**
     * <pre>
     * The SHA1 commit hash that the daemon is compiled with.
     * </pre>
     *
     * <code>string commit_hash = 20;</code>
     * @return The bytes for commitHash.
     */
    com.google.protobuf.ByteString
        getCommitHashBytes();

    /**
     * <pre>
     * The identity pubkey of the current node.
     * </pre>
     *
     * <code>string identity_pubkey = 1;</code>
     * @return The identityPubkey.
     */
    java.lang.String getIdentityPubkey();
    /**
     * <pre>
     * The identity pubkey of the current node.
     * </pre>
     *
     * <code>string identity_pubkey = 1;</code>
     * @return The bytes for identityPubkey.
     */
    com.google.protobuf.ByteString
        getIdentityPubkeyBytes();

    /**
     * <pre>
     * If applicable, the alias of the current node, e.g. "bob"
     * </pre>
     *
     * <code>string alias = 2;</code>
     * @return The alias.
     */
    java.lang.String getAlias();
    /**
     * <pre>
     * If applicable, the alias of the current node, e.g. "bob"
     * </pre>
     *
     * <code>string alias = 2;</code>
     * @return The bytes for alias.
     */
    com.google.protobuf.ByteString
        getAliasBytes();

    /**
     * <pre>
     * The color of the current node in hex code format
     * </pre>
     *
     * <code>string color = 17;</code>
     * @return The color.
     */
    java.lang.String getColor();
    /**
     * <pre>
     * The color of the current node in hex code format
     * </pre>
     *
     * <code>string color = 17;</code>
     * @return The bytes for color.
     */
    com.google.protobuf.ByteString
        getColorBytes();

    /**
     * <pre>
     * Number of pending channels
     * </pre>
     *
     * <code>uint32 num_pending_channels = 3;</code>
     * @return The numPendingChannels.
     */
    int getNumPendingChannels();

    /**
     * <pre>
     * Number of active channels
     * </pre>
     *
     * <code>uint32 num_active_channels = 4;</code>
     * @return The numActiveChannels.
     */
    int getNumActiveChannels();

    /**
     * <pre>
     * Number of inactive channels
     * </pre>
     *
     * <code>uint32 num_inactive_channels = 15;</code>
     * @return The numInactiveChannels.
     */
    int getNumInactiveChannels();

    /**
     * <pre>
     * Number of peers
     * </pre>
     *
     * <code>uint32 num_peers = 5;</code>
     * @return The numPeers.
     */
    int getNumPeers();

    /**
     * <pre>
     * The node's current view of the height of the best block
     * </pre>
     *
     * <code>uint32 block_height = 6;</code>
     * @return The blockHeight.
     */
    int getBlockHeight();

    /**
     * <pre>
     * The node's current view of the hash of the best block
     * </pre>
     *
     * <code>string block_hash = 8;</code>
     * @return The blockHash.
     */
    java.lang.String getBlockHash();
    /**
     * <pre>
     * The node's current view of the hash of the best block
     * </pre>
     *
     * <code>string block_hash = 8;</code>
     * @return The bytes for blockHash.
     */
    com.google.protobuf.ByteString
        getBlockHashBytes();

    /**
     * <pre>
     * Timestamp of the block best known to the wallet
     * </pre>
     *
     * <code>int64 best_header_timestamp = 13;</code>
     * @return The bestHeaderTimestamp.
     */
    long getBestHeaderTimestamp();

    /**
     * <pre>
     * Whether the wallet's view is synced to the main chain
     * </pre>
     *
     * <code>bool synced_to_chain = 9;</code>
     * @return The syncedToChain.
     */
    boolean getSyncedToChain();

    /**
     * <pre>
     * Whether we consider ourselves synced with the public channel graph.
     * </pre>
     *
     * <code>bool synced_to_graph = 18;</code>
     * @return The syncedToGraph.
     */
    boolean getSyncedToGraph();

    /**
     * <pre>
     *Whether the current node is connected to testnet. This field is
     *deprecated and the network field should be used instead
     * </pre>
     *
     * <code>bool testnet = 10 [deprecated = true];</code>
     * @return The testnet.
     */
    @java.lang.Deprecated boolean getTestnet();

    /**
     * <pre>
     * A list of active chains the node is connected to
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
     */
    java.util.List<co.anode.anodium.Rpc.Chain> 
        getChainsList();
    /**
     * <pre>
     * A list of active chains the node is connected to
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
     */
    co.anode.anodium.Rpc.Chain getChains(int index);
    /**
     * <pre>
     * A list of active chains the node is connected to
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
     */
    int getChainsCount();

    /**
     * <pre>
     * The URIs of the current node.
     * </pre>
     *
     * <code>repeated string uris = 12;</code>
     * @return A list containing the uris.
     */
    java.util.List<java.lang.String>
        getUrisList();
    /**
     * <pre>
     * The URIs of the current node.
     * </pre>
     *
     * <code>repeated string uris = 12;</code>
     * @return The count of uris.
     */
    int getUrisCount();
    /**
     * <pre>
     * The URIs of the current node.
     * </pre>
     *
     * <code>repeated string uris = 12;</code>
     * @param index The index of the element to return.
     * @return The uris at the given index.
     */
    java.lang.String getUris(int index);
    /**
     * <pre>
     * The URIs of the current node.
     * </pre>
     *
     * <code>repeated string uris = 12;</code>
     * @param index The index of the element to return.
     * @return The uris at the given index.
     */
    com.google.protobuf.ByteString
        getUrisBytes(int index);

    /**
     * <pre>
     *Features that our node has advertised in our init message, node
     *announcements and invoices.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 19;</code>
     */
    int getFeaturesCount();
    /**
     * <pre>
     *Features that our node has advertised in our init message, node
     *announcements and invoices.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 19;</code>
     */
    boolean containsFeatures(
        int key);
    /**
     * Use {@link #getFeaturesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    getFeatures();
    /**
     * <pre>
     *Features that our node has advertised in our init message, node
     *announcements and invoices.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 19;</code>
     */
    java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    getFeaturesMap();
    /**
     * <pre>
     *Features that our node has advertised in our init message, node
     *announcements and invoices.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 19;</code>
     */

    co.anode.anodium.Rpc.Feature getFeaturesOrDefault(
        int key,
        co.anode.anodium.Rpc.Feature defaultValue);
    /**
     * <pre>
     *Features that our node has advertised in our init message, node
     *announcements and invoices.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 19;</code>
     */

    co.anode.anodium.Rpc.Feature getFeaturesOrThrow(
        int key);
  }
  /**
   * Protobuf type {@code co.anode.anodium.GetInfoResponse}
   */
  public  static final class GetInfoResponse extends
      com.google.protobuf.GeneratedMessageLite<
          GetInfoResponse, GetInfoResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.GetInfoResponse)
      GetInfoResponseOrBuilder {
    private GetInfoResponse() {
      version_ = "";
      commitHash_ = "";
      identityPubkey_ = "";
      alias_ = "";
      color_ = "";
      blockHash_ = "";
      chains_ = emptyProtobufList();
      uris_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    public static final int VERSION_FIELD_NUMBER = 14;
    private java.lang.String version_;
    /**
     * <pre>
     * The version of the LND software that the node is running.
     * </pre>
     *
     * <code>string version = 14;</code>
     * @return The version.
     */
    @java.lang.Override
    public java.lang.String getVersion() {
      return version_;
    }
    /**
     * <pre>
     * The version of the LND software that the node is running.
     * </pre>
     *
     * <code>string version = 14;</code>
     * @return The bytes for version.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getVersionBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(version_);
    }
    /**
     * <pre>
     * The version of the LND software that the node is running.
     * </pre>
     *
     * <code>string version = 14;</code>
     * @param value The version to set.
     */
    private void setVersion(
        java.lang.String value) {
      value.getClass();
  
      version_ = value;
    }
    /**
     * <pre>
     * The version of the LND software that the node is running.
     * </pre>
     *
     * <code>string version = 14;</code>
     */
    private void clearVersion() {
      
      version_ = getDefaultInstance().getVersion();
    }
    /**
     * <pre>
     * The version of the LND software that the node is running.
     * </pre>
     *
     * <code>string version = 14;</code>
     * @param value The bytes for version to set.
     */
    private void setVersionBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      version_ = value.toStringUtf8();
      
    }

    public static final int COMMIT_HASH_FIELD_NUMBER = 20;
    private java.lang.String commitHash_;
    /**
     * <pre>
     * The SHA1 commit hash that the daemon is compiled with.
     * </pre>
     *
     * <code>string commit_hash = 20;</code>
     * @return The commitHash.
     */
    @java.lang.Override
    public java.lang.String getCommitHash() {
      return commitHash_;
    }
    /**
     * <pre>
     * The SHA1 commit hash that the daemon is compiled with.
     * </pre>
     *
     * <code>string commit_hash = 20;</code>
     * @return The bytes for commitHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getCommitHashBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(commitHash_);
    }
    /**
     * <pre>
     * The SHA1 commit hash that the daemon is compiled with.
     * </pre>
     *
     * <code>string commit_hash = 20;</code>
     * @param value The commitHash to set.
     */
    private void setCommitHash(
        java.lang.String value) {
      value.getClass();
  
      commitHash_ = value;
    }
    /**
     * <pre>
     * The SHA1 commit hash that the daemon is compiled with.
     * </pre>
     *
     * <code>string commit_hash = 20;</code>
     */
    private void clearCommitHash() {
      
      commitHash_ = getDefaultInstance().getCommitHash();
    }
    /**
     * <pre>
     * The SHA1 commit hash that the daemon is compiled with.
     * </pre>
     *
     * <code>string commit_hash = 20;</code>
     * @param value The bytes for commitHash to set.
     */
    private void setCommitHashBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      commitHash_ = value.toStringUtf8();
      
    }

    public static final int IDENTITY_PUBKEY_FIELD_NUMBER = 1;
    private java.lang.String identityPubkey_;
    /**
     * <pre>
     * The identity pubkey of the current node.
     * </pre>
     *
     * <code>string identity_pubkey = 1;</code>
     * @return The identityPubkey.
     */
    @java.lang.Override
    public java.lang.String getIdentityPubkey() {
      return identityPubkey_;
    }
    /**
     * <pre>
     * The identity pubkey of the current node.
     * </pre>
     *
     * <code>string identity_pubkey = 1;</code>
     * @return The bytes for identityPubkey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getIdentityPubkeyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(identityPubkey_);
    }
    /**
     * <pre>
     * The identity pubkey of the current node.
     * </pre>
     *
     * <code>string identity_pubkey = 1;</code>
     * @param value The identityPubkey to set.
     */
    private void setIdentityPubkey(
        java.lang.String value) {
      value.getClass();
  
      identityPubkey_ = value;
    }
    /**
     * <pre>
     * The identity pubkey of the current node.
     * </pre>
     *
     * <code>string identity_pubkey = 1;</code>
     */
    private void clearIdentityPubkey() {
      
      identityPubkey_ = getDefaultInstance().getIdentityPubkey();
    }
    /**
     * <pre>
     * The identity pubkey of the current node.
     * </pre>
     *
     * <code>string identity_pubkey = 1;</code>
     * @param value The bytes for identityPubkey to set.
     */
    private void setIdentityPubkeyBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      identityPubkey_ = value.toStringUtf8();
      
    }

    public static final int ALIAS_FIELD_NUMBER = 2;
    private java.lang.String alias_;
    /**
     * <pre>
     * If applicable, the alias of the current node, e.g. "bob"
     * </pre>
     *
     * <code>string alias = 2;</code>
     * @return The alias.
     */
    @java.lang.Override
    public java.lang.String getAlias() {
      return alias_;
    }
    /**
     * <pre>
     * If applicable, the alias of the current node, e.g. "bob"
     * </pre>
     *
     * <code>string alias = 2;</code>
     * @return The bytes for alias.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAliasBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(alias_);
    }
    /**
     * <pre>
     * If applicable, the alias of the current node, e.g. "bob"
     * </pre>
     *
     * <code>string alias = 2;</code>
     * @param value The alias to set.
     */
    private void setAlias(
        java.lang.String value) {
      value.getClass();
  
      alias_ = value;
    }
    /**
     * <pre>
     * If applicable, the alias of the current node, e.g. "bob"
     * </pre>
     *
     * <code>string alias = 2;</code>
     */
    private void clearAlias() {
      
      alias_ = getDefaultInstance().getAlias();
    }
    /**
     * <pre>
     * If applicable, the alias of the current node, e.g. "bob"
     * </pre>
     *
     * <code>string alias = 2;</code>
     * @param value The bytes for alias to set.
     */
    private void setAliasBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      alias_ = value.toStringUtf8();
      
    }

    public static final int COLOR_FIELD_NUMBER = 17;
    private java.lang.String color_;
    /**
     * <pre>
     * The color of the current node in hex code format
     * </pre>
     *
     * <code>string color = 17;</code>
     * @return The color.
     */
    @java.lang.Override
    public java.lang.String getColor() {
      return color_;
    }
    /**
     * <pre>
     * The color of the current node in hex code format
     * </pre>
     *
     * <code>string color = 17;</code>
     * @return The bytes for color.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getColorBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(color_);
    }
    /**
     * <pre>
     * The color of the current node in hex code format
     * </pre>
     *
     * <code>string color = 17;</code>
     * @param value The color to set.
     */
    private void setColor(
        java.lang.String value) {
      value.getClass();
  
      color_ = value;
    }
    /**
     * <pre>
     * The color of the current node in hex code format
     * </pre>
     *
     * <code>string color = 17;</code>
     */
    private void clearColor() {
      
      color_ = getDefaultInstance().getColor();
    }
    /**
     * <pre>
     * The color of the current node in hex code format
     * </pre>
     *
     * <code>string color = 17;</code>
     * @param value The bytes for color to set.
     */
    private void setColorBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      color_ = value.toStringUtf8();
      
    }

    public static final int NUM_PENDING_CHANNELS_FIELD_NUMBER = 3;
    private int numPendingChannels_;
    /**
     * <pre>
     * Number of pending channels
     * </pre>
     *
     * <code>uint32 num_pending_channels = 3;</code>
     * @return The numPendingChannels.
     */
    @java.lang.Override
    public int getNumPendingChannels() {
      return numPendingChannels_;
    }
    /**
     * <pre>
     * Number of pending channels
     * </pre>
     *
     * <code>uint32 num_pending_channels = 3;</code>
     * @param value The numPendingChannels to set.
     */
    private void setNumPendingChannels(int value) {
      
      numPendingChannels_ = value;
    }
    /**
     * <pre>
     * Number of pending channels
     * </pre>
     *
     * <code>uint32 num_pending_channels = 3;</code>
     */
    private void clearNumPendingChannels() {
      
      numPendingChannels_ = 0;
    }

    public static final int NUM_ACTIVE_CHANNELS_FIELD_NUMBER = 4;
    private int numActiveChannels_;
    /**
     * <pre>
     * Number of active channels
     * </pre>
     *
     * <code>uint32 num_active_channels = 4;</code>
     * @return The numActiveChannels.
     */
    @java.lang.Override
    public int getNumActiveChannels() {
      return numActiveChannels_;
    }
    /**
     * <pre>
     * Number of active channels
     * </pre>
     *
     * <code>uint32 num_active_channels = 4;</code>
     * @param value The numActiveChannels to set.
     */
    private void setNumActiveChannels(int value) {
      
      numActiveChannels_ = value;
    }
    /**
     * <pre>
     * Number of active channels
     * </pre>
     *
     * <code>uint32 num_active_channels = 4;</code>
     */
    private void clearNumActiveChannels() {
      
      numActiveChannels_ = 0;
    }

    public static final int NUM_INACTIVE_CHANNELS_FIELD_NUMBER = 15;
    private int numInactiveChannels_;
    /**
     * <pre>
     * Number of inactive channels
     * </pre>
     *
     * <code>uint32 num_inactive_channels = 15;</code>
     * @return The numInactiveChannels.
     */
    @java.lang.Override
    public int getNumInactiveChannels() {
      return numInactiveChannels_;
    }
    /**
     * <pre>
     * Number of inactive channels
     * </pre>
     *
     * <code>uint32 num_inactive_channels = 15;</code>
     * @param value The numInactiveChannels to set.
     */
    private void setNumInactiveChannels(int value) {
      
      numInactiveChannels_ = value;
    }
    /**
     * <pre>
     * Number of inactive channels
     * </pre>
     *
     * <code>uint32 num_inactive_channels = 15;</code>
     */
    private void clearNumInactiveChannels() {
      
      numInactiveChannels_ = 0;
    }

    public static final int NUM_PEERS_FIELD_NUMBER = 5;
    private int numPeers_;
    /**
     * <pre>
     * Number of peers
     * </pre>
     *
     * <code>uint32 num_peers = 5;</code>
     * @return The numPeers.
     */
    @java.lang.Override
    public int getNumPeers() {
      return numPeers_;
    }
    /**
     * <pre>
     * Number of peers
     * </pre>
     *
     * <code>uint32 num_peers = 5;</code>
     * @param value The numPeers to set.
     */
    private void setNumPeers(int value) {
      
      numPeers_ = value;
    }
    /**
     * <pre>
     * Number of peers
     * </pre>
     *
     * <code>uint32 num_peers = 5;</code>
     */
    private void clearNumPeers() {
      
      numPeers_ = 0;
    }

    public static final int BLOCK_HEIGHT_FIELD_NUMBER = 6;
    private int blockHeight_;
    /**
     * <pre>
     * The node's current view of the height of the best block
     * </pre>
     *
     * <code>uint32 block_height = 6;</code>
     * @return The blockHeight.
     */
    @java.lang.Override
    public int getBlockHeight() {
      return blockHeight_;
    }
    /**
     * <pre>
     * The node's current view of the height of the best block
     * </pre>
     *
     * <code>uint32 block_height = 6;</code>
     * @param value The blockHeight to set.
     */
    private void setBlockHeight(int value) {
      
      blockHeight_ = value;
    }
    /**
     * <pre>
     * The node's current view of the height of the best block
     * </pre>
     *
     * <code>uint32 block_height = 6;</code>
     */
    private void clearBlockHeight() {
      
      blockHeight_ = 0;
    }

    public static final int BLOCK_HASH_FIELD_NUMBER = 8;
    private java.lang.String blockHash_;
    /**
     * <pre>
     * The node's current view of the hash of the best block
     * </pre>
     *
     * <code>string block_hash = 8;</code>
     * @return The blockHash.
     */
    @java.lang.Override
    public java.lang.String getBlockHash() {
      return blockHash_;
    }
    /**
     * <pre>
     * The node's current view of the hash of the best block
     * </pre>
     *
     * <code>string block_hash = 8;</code>
     * @return The bytes for blockHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getBlockHashBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(blockHash_);
    }
    /**
     * <pre>
     * The node's current view of the hash of the best block
     * </pre>
     *
     * <code>string block_hash = 8;</code>
     * @param value The blockHash to set.
     */
    private void setBlockHash(
        java.lang.String value) {
      value.getClass();
  
      blockHash_ = value;
    }
    /**
     * <pre>
     * The node's current view of the hash of the best block
     * </pre>
     *
     * <code>string block_hash = 8;</code>
     */
    private void clearBlockHash() {
      
      blockHash_ = getDefaultInstance().getBlockHash();
    }
    /**
     * <pre>
     * The node's current view of the hash of the best block
     * </pre>
     *
     * <code>string block_hash = 8;</code>
     * @param value The bytes for blockHash to set.
     */
    private void setBlockHashBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      blockHash_ = value.toStringUtf8();
      
    }

    public static final int BEST_HEADER_TIMESTAMP_FIELD_NUMBER = 13;
    private long bestHeaderTimestamp_;
    /**
     * <pre>
     * Timestamp of the block best known to the wallet
     * </pre>
     *
     * <code>int64 best_header_timestamp = 13;</code>
     * @return The bestHeaderTimestamp.
     */
    @java.lang.Override
    public long getBestHeaderTimestamp() {
      return bestHeaderTimestamp_;
    }
    /**
     * <pre>
     * Timestamp of the block best known to the wallet
     * </pre>
     *
     * <code>int64 best_header_timestamp = 13;</code>
     * @param value The bestHeaderTimestamp to set.
     */
    private void setBestHeaderTimestamp(long value) {
      
      bestHeaderTimestamp_ = value;
    }
    /**
     * <pre>
     * Timestamp of the block best known to the wallet
     * </pre>
     *
     * <code>int64 best_header_timestamp = 13;</code>
     */
    private void clearBestHeaderTimestamp() {
      
      bestHeaderTimestamp_ = 0L;
    }

    public static final int SYNCED_TO_CHAIN_FIELD_NUMBER = 9;
    private boolean syncedToChain_;
    /**
     * <pre>
     * Whether the wallet's view is synced to the main chain
     * </pre>
     *
     * <code>bool synced_to_chain = 9;</code>
     * @return The syncedToChain.
     */
    @java.lang.Override
    public boolean getSyncedToChain() {
      return syncedToChain_;
    }
    /**
     * <pre>
     * Whether the wallet's view is synced to the main chain
     * </pre>
     *
     * <code>bool synced_to_chain = 9;</code>
     * @param value The syncedToChain to set.
     */
    private void setSyncedToChain(boolean value) {
      
      syncedToChain_ = value;
    }
    /**
     * <pre>
     * Whether the wallet's view is synced to the main chain
     * </pre>
     *
     * <code>bool synced_to_chain = 9;</code>
     */
    private void clearSyncedToChain() {
      
      syncedToChain_ = false;
    }

    public static final int SYNCED_TO_GRAPH_FIELD_NUMBER = 18;
    private boolean syncedToGraph_;
    /**
     * <pre>
     * Whether we consider ourselves synced with the public channel graph.
     * </pre>
     *
     * <code>bool synced_to_graph = 18;</code>
     * @return The syncedToGraph.
     */
    @java.lang.Override
    public boolean getSyncedToGraph() {
      return syncedToGraph_;
    }
    /**
     * <pre>
     * Whether we consider ourselves synced with the public channel graph.
     * </pre>
     *
     * <code>bool synced_to_graph = 18;</code>
     * @param value The syncedToGraph to set.
     */
    private void setSyncedToGraph(boolean value) {
      
      syncedToGraph_ = value;
    }
    /**
     * <pre>
     * Whether we consider ourselves synced with the public channel graph.
     * </pre>
     *
     * <code>bool synced_to_graph = 18;</code>
     */
    private void clearSyncedToGraph() {
      
      syncedToGraph_ = false;
    }

    public static final int TESTNET_FIELD_NUMBER = 10;
    private boolean testnet_;
    /**
     * <pre>
     *Whether the current node is connected to testnet. This field is
     *deprecated and the network field should be used instead
     * </pre>
     *
     * <code>bool testnet = 10 [deprecated = true];</code>
     * @return The testnet.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean getTestnet() {
      return testnet_;
    }
    /**
     * <pre>
     *Whether the current node is connected to testnet. This field is
     *deprecated and the network field should be used instead
     * </pre>
     *
     * <code>bool testnet = 10 [deprecated = true];</code>
     * @param value The testnet to set.
     */
    private void setTestnet(boolean value) {
      
      testnet_ = value;
    }
    /**
     * <pre>
     *Whether the current node is connected to testnet. This field is
     *deprecated and the network field should be used instead
     * </pre>
     *
     * <code>bool testnet = 10 [deprecated = true];</code>
     */
    private void clearTestnet() {
      
      testnet_ = false;
    }

    public static final int CHAINS_FIELD_NUMBER = 16;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Chain> chains_;
    /**
     * <pre>
     * A list of active chains the node is connected to
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.Chain> getChainsList() {
      return chains_;
    }
    /**
     * <pre>
     * A list of active chains the node is connected to
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.ChainOrBuilder> 
        getChainsOrBuilderList() {
      return chains_;
    }
    /**
     * <pre>
     * A list of active chains the node is connected to
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
     */
    @java.lang.Override
    public int getChainsCount() {
      return chains_.size();
    }
    /**
     * <pre>
     * A list of active chains the node is connected to
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Chain getChains(int index) {
      return chains_.get(index);
    }
    /**
     * <pre>
     * A list of active chains the node is connected to
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
     */
    public co.anode.anodium.Rpc.ChainOrBuilder getChainsOrBuilder(
        int index) {
      return chains_.get(index);
    }
    private void ensureChainsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Chain> tmp = chains_;
      if (!tmp.isModifiable()) {
        chains_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * A list of active chains the node is connected to
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
     */
    private void setChains(
        int index, co.anode.anodium.Rpc.Chain value) {
      value.getClass();
  ensureChainsIsMutable();
      chains_.set(index, value);
    }
    /**
     * <pre>
     * A list of active chains the node is connected to
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
     */
    private void addChains(co.anode.anodium.Rpc.Chain value) {
      value.getClass();
  ensureChainsIsMutable();
      chains_.add(value);
    }
    /**
     * <pre>
     * A list of active chains the node is connected to
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
     */
    private void addChains(
        int index, co.anode.anodium.Rpc.Chain value) {
      value.getClass();
  ensureChainsIsMutable();
      chains_.add(index, value);
    }
    /**
     * <pre>
     * A list of active chains the node is connected to
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
     */
    private void addAllChains(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.Chain> values) {
      ensureChainsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, chains_);
    }
    /**
     * <pre>
     * A list of active chains the node is connected to
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
     */
    private void clearChains() {
      chains_ = emptyProtobufList();
    }
    /**
     * <pre>
     * A list of active chains the node is connected to
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
     */
    private void removeChains(int index) {
      ensureChainsIsMutable();
      chains_.remove(index);
    }

    public static final int URIS_FIELD_NUMBER = 12;
    private com.google.protobuf.Internal.ProtobufList<java.lang.String> uris_;
    /**
     * <pre>
     * The URIs of the current node.
     * </pre>
     *
     * <code>repeated string uris = 12;</code>
     * @return A list containing the uris.
     */
    @java.lang.Override
    public java.util.List<java.lang.String> getUrisList() {
      return uris_;
    }
    /**
     * <pre>
     * The URIs of the current node.
     * </pre>
     *
     * <code>repeated string uris = 12;</code>
     * @return The count of uris.
     */
    @java.lang.Override
    public int getUrisCount() {
      return uris_.size();
    }
    /**
     * <pre>
     * The URIs of the current node.
     * </pre>
     *
     * <code>repeated string uris = 12;</code>
     * @param index The index of the element to return.
     * @return The uris at the given index.
     */
    @java.lang.Override
    public java.lang.String getUris(int index) {
      return uris_.get(index);
    }
    /**
     * <pre>
     * The URIs of the current node.
     * </pre>
     *
     * <code>repeated string uris = 12;</code>
     * @param index The index of the value to return.
     * @return The bytes of the uris at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUrisBytes(int index) {
      return com.google.protobuf.ByteString.copyFromUtf8(
          uris_.get(index));
    }
    private void ensureUrisIsMutable() {
      com.google.protobuf.Internal.ProtobufList<java.lang.String> tmp =
          uris_;  if (!tmp.isModifiable()) {
        uris_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * The URIs of the current node.
     * </pre>
     *
     * <code>repeated string uris = 12;</code>
     * @param index The index to set the value at.
     * @param value The uris to set.
     */
    private void setUris(
        int index, java.lang.String value) {
      value.getClass();
  ensureUrisIsMutable();
      uris_.set(index, value);
    }
    /**
     * <pre>
     * The URIs of the current node.
     * </pre>
     *
     * <code>repeated string uris = 12;</code>
     * @param value The uris to add.
     */
    private void addUris(
        java.lang.String value) {
      value.getClass();
  ensureUrisIsMutable();
      uris_.add(value);
    }
    /**
     * <pre>
     * The URIs of the current node.
     * </pre>
     *
     * <code>repeated string uris = 12;</code>
     * @param values The uris to add.
     */
    private void addAllUris(
        java.lang.Iterable<java.lang.String> values) {
      ensureUrisIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, uris_);
    }
    /**
     * <pre>
     * The URIs of the current node.
     * </pre>
     *
     * <code>repeated string uris = 12;</code>
     */
    private void clearUris() {
      uris_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    /**
     * <pre>
     * The URIs of the current node.
     * </pre>
     *
     * <code>repeated string uris = 12;</code>
     * @param value The bytes of the uris to add.
     */
    private void addUrisBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      ensureUrisIsMutable();
      uris_.add(value.toStringUtf8());
    }

    public static final int FEATURES_FIELD_NUMBER = 19;
    private static final class FeaturesDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Integer, co.anode.anodium.Rpc.Feature> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Integer, co.anode.anodium.Rpc.Feature>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.UINT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  co.anode.anodium.Rpc.Feature.getDefaultInstance());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Integer, co.anode.anodium.Rpc.Feature> features_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    internalGetFeatures() {
      return features_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    internalGetMutableFeatures() {
      if (!features_.isMutable()) {
        features_ = features_.mutableCopy();
      }
      return features_;
    }
    @java.lang.Override

    public int getFeaturesCount() {
      return internalGetFeatures().size();
    }
    /**
     * <pre>
     *Features that our node has advertised in our init message, node
     *announcements and invoices.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 19;</code>
     */
    @java.lang.Override

    public boolean containsFeatures(
        int key) {
      
      return internalGetFeatures().containsKey(key);
    }
    /**
     * Use {@link #getFeaturesMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeatures() {
      return getFeaturesMap();
    }
    /**
     * <pre>
     *Features that our node has advertised in our init message, node
     *announcements and invoices.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 19;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeaturesMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetFeatures());
    }
    /**
     * <pre>
     *Features that our node has advertised in our init message, node
     *announcements and invoices.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 19;</code>
     */
    @java.lang.Override

    public co.anode.anodium.Rpc.Feature getFeaturesOrDefault(
        int key,
        co.anode.anodium.Rpc.Feature defaultValue) {
      
      java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
          internalGetFeatures();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     *Features that our node has advertised in our init message, node
     *announcements and invoices.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 19;</code>
     */
    @java.lang.Override

    public co.anode.anodium.Rpc.Feature getFeaturesOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
          internalGetFeatures();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     *Features that our node has advertised in our init message, node
     *announcements and invoices.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 19;</code>
     */
    private java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    getMutableFeaturesMap() {
      return internalGetMutableFeatures();
    }

    public static co.anode.anodium.Rpc.GetInfoResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetInfoResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetInfoResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetInfoResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetInfoResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetInfoResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetInfoResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetInfoResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetInfoResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetInfoResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetInfoResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetInfoResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.GetInfoResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.GetInfoResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.GetInfoResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.GetInfoResponse)
        co.anode.anodium.Rpc.GetInfoResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.GetInfoResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The version of the LND software that the node is running.
       * </pre>
       *
       * <code>string version = 14;</code>
       * @return The version.
       */
      @java.lang.Override
      public java.lang.String getVersion() {
        return instance.getVersion();
      }
      /**
       * <pre>
       * The version of the LND software that the node is running.
       * </pre>
       *
       * <code>string version = 14;</code>
       * @return The bytes for version.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getVersionBytes() {
        return instance.getVersionBytes();
      }
      /**
       * <pre>
       * The version of the LND software that the node is running.
       * </pre>
       *
       * <code>string version = 14;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(
          java.lang.String value) {
        copyOnWrite();
        instance.setVersion(value);
        return this;
      }
      /**
       * <pre>
       * The version of the LND software that the node is running.
       * </pre>
       *
       * <code>string version = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        copyOnWrite();
        instance.clearVersion();
        return this;
      }
      /**
       * <pre>
       * The version of the LND software that the node is running.
       * </pre>
       *
       * <code>string version = 14;</code>
       * @param value The bytes for version to set.
       * @return This builder for chaining.
       */
      public Builder setVersionBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setVersionBytes(value);
        return this;
      }

      /**
       * <pre>
       * The SHA1 commit hash that the daemon is compiled with.
       * </pre>
       *
       * <code>string commit_hash = 20;</code>
       * @return The commitHash.
       */
      @java.lang.Override
      public java.lang.String getCommitHash() {
        return instance.getCommitHash();
      }
      /**
       * <pre>
       * The SHA1 commit hash that the daemon is compiled with.
       * </pre>
       *
       * <code>string commit_hash = 20;</code>
       * @return The bytes for commitHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getCommitHashBytes() {
        return instance.getCommitHashBytes();
      }
      /**
       * <pre>
       * The SHA1 commit hash that the daemon is compiled with.
       * </pre>
       *
       * <code>string commit_hash = 20;</code>
       * @param value The commitHash to set.
       * @return This builder for chaining.
       */
      public Builder setCommitHash(
          java.lang.String value) {
        copyOnWrite();
        instance.setCommitHash(value);
        return this;
      }
      /**
       * <pre>
       * The SHA1 commit hash that the daemon is compiled with.
       * </pre>
       *
       * <code>string commit_hash = 20;</code>
       * @return This builder for chaining.
       */
      public Builder clearCommitHash() {
        copyOnWrite();
        instance.clearCommitHash();
        return this;
      }
      /**
       * <pre>
       * The SHA1 commit hash that the daemon is compiled with.
       * </pre>
       *
       * <code>string commit_hash = 20;</code>
       * @param value The bytes for commitHash to set.
       * @return This builder for chaining.
       */
      public Builder setCommitHashBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setCommitHashBytes(value);
        return this;
      }

      /**
       * <pre>
       * The identity pubkey of the current node.
       * </pre>
       *
       * <code>string identity_pubkey = 1;</code>
       * @return The identityPubkey.
       */
      @java.lang.Override
      public java.lang.String getIdentityPubkey() {
        return instance.getIdentityPubkey();
      }
      /**
       * <pre>
       * The identity pubkey of the current node.
       * </pre>
       *
       * <code>string identity_pubkey = 1;</code>
       * @return The bytes for identityPubkey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getIdentityPubkeyBytes() {
        return instance.getIdentityPubkeyBytes();
      }
      /**
       * <pre>
       * The identity pubkey of the current node.
       * </pre>
       *
       * <code>string identity_pubkey = 1;</code>
       * @param value The identityPubkey to set.
       * @return This builder for chaining.
       */
      public Builder setIdentityPubkey(
          java.lang.String value) {
        copyOnWrite();
        instance.setIdentityPubkey(value);
        return this;
      }
      /**
       * <pre>
       * The identity pubkey of the current node.
       * </pre>
       *
       * <code>string identity_pubkey = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearIdentityPubkey() {
        copyOnWrite();
        instance.clearIdentityPubkey();
        return this;
      }
      /**
       * <pre>
       * The identity pubkey of the current node.
       * </pre>
       *
       * <code>string identity_pubkey = 1;</code>
       * @param value The bytes for identityPubkey to set.
       * @return This builder for chaining.
       */
      public Builder setIdentityPubkeyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setIdentityPubkeyBytes(value);
        return this;
      }

      /**
       * <pre>
       * If applicable, the alias of the current node, e.g. "bob"
       * </pre>
       *
       * <code>string alias = 2;</code>
       * @return The alias.
       */
      @java.lang.Override
      public java.lang.String getAlias() {
        return instance.getAlias();
      }
      /**
       * <pre>
       * If applicable, the alias of the current node, e.g. "bob"
       * </pre>
       *
       * <code>string alias = 2;</code>
       * @return The bytes for alias.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getAliasBytes() {
        return instance.getAliasBytes();
      }
      /**
       * <pre>
       * If applicable, the alias of the current node, e.g. "bob"
       * </pre>
       *
       * <code>string alias = 2;</code>
       * @param value The alias to set.
       * @return This builder for chaining.
       */
      public Builder setAlias(
          java.lang.String value) {
        copyOnWrite();
        instance.setAlias(value);
        return this;
      }
      /**
       * <pre>
       * If applicable, the alias of the current node, e.g. "bob"
       * </pre>
       *
       * <code>string alias = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAlias() {
        copyOnWrite();
        instance.clearAlias();
        return this;
      }
      /**
       * <pre>
       * If applicable, the alias of the current node, e.g. "bob"
       * </pre>
       *
       * <code>string alias = 2;</code>
       * @param value The bytes for alias to set.
       * @return This builder for chaining.
       */
      public Builder setAliasBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setAliasBytes(value);
        return this;
      }

      /**
       * <pre>
       * The color of the current node in hex code format
       * </pre>
       *
       * <code>string color = 17;</code>
       * @return The color.
       */
      @java.lang.Override
      public java.lang.String getColor() {
        return instance.getColor();
      }
      /**
       * <pre>
       * The color of the current node in hex code format
       * </pre>
       *
       * <code>string color = 17;</code>
       * @return The bytes for color.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getColorBytes() {
        return instance.getColorBytes();
      }
      /**
       * <pre>
       * The color of the current node in hex code format
       * </pre>
       *
       * <code>string color = 17;</code>
       * @param value The color to set.
       * @return This builder for chaining.
       */
      public Builder setColor(
          java.lang.String value) {
        copyOnWrite();
        instance.setColor(value);
        return this;
      }
      /**
       * <pre>
       * The color of the current node in hex code format
       * </pre>
       *
       * <code>string color = 17;</code>
       * @return This builder for chaining.
       */
      public Builder clearColor() {
        copyOnWrite();
        instance.clearColor();
        return this;
      }
      /**
       * <pre>
       * The color of the current node in hex code format
       * </pre>
       *
       * <code>string color = 17;</code>
       * @param value The bytes for color to set.
       * @return This builder for chaining.
       */
      public Builder setColorBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setColorBytes(value);
        return this;
      }

      /**
       * <pre>
       * Number of pending channels
       * </pre>
       *
       * <code>uint32 num_pending_channels = 3;</code>
       * @return The numPendingChannels.
       */
      @java.lang.Override
      public int getNumPendingChannels() {
        return instance.getNumPendingChannels();
      }
      /**
       * <pre>
       * Number of pending channels
       * </pre>
       *
       * <code>uint32 num_pending_channels = 3;</code>
       * @param value The numPendingChannels to set.
       * @return This builder for chaining.
       */
      public Builder setNumPendingChannels(int value) {
        copyOnWrite();
        instance.setNumPendingChannels(value);
        return this;
      }
      /**
       * <pre>
       * Number of pending channels
       * </pre>
       *
       * <code>uint32 num_pending_channels = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumPendingChannels() {
        copyOnWrite();
        instance.clearNumPendingChannels();
        return this;
      }

      /**
       * <pre>
       * Number of active channels
       * </pre>
       *
       * <code>uint32 num_active_channels = 4;</code>
       * @return The numActiveChannels.
       */
      @java.lang.Override
      public int getNumActiveChannels() {
        return instance.getNumActiveChannels();
      }
      /**
       * <pre>
       * Number of active channels
       * </pre>
       *
       * <code>uint32 num_active_channels = 4;</code>
       * @param value The numActiveChannels to set.
       * @return This builder for chaining.
       */
      public Builder setNumActiveChannels(int value) {
        copyOnWrite();
        instance.setNumActiveChannels(value);
        return this;
      }
      /**
       * <pre>
       * Number of active channels
       * </pre>
       *
       * <code>uint32 num_active_channels = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumActiveChannels() {
        copyOnWrite();
        instance.clearNumActiveChannels();
        return this;
      }

      /**
       * <pre>
       * Number of inactive channels
       * </pre>
       *
       * <code>uint32 num_inactive_channels = 15;</code>
       * @return The numInactiveChannels.
       */
      @java.lang.Override
      public int getNumInactiveChannels() {
        return instance.getNumInactiveChannels();
      }
      /**
       * <pre>
       * Number of inactive channels
       * </pre>
       *
       * <code>uint32 num_inactive_channels = 15;</code>
       * @param value The numInactiveChannels to set.
       * @return This builder for chaining.
       */
      public Builder setNumInactiveChannels(int value) {
        copyOnWrite();
        instance.setNumInactiveChannels(value);
        return this;
      }
      /**
       * <pre>
       * Number of inactive channels
       * </pre>
       *
       * <code>uint32 num_inactive_channels = 15;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumInactiveChannels() {
        copyOnWrite();
        instance.clearNumInactiveChannels();
        return this;
      }

      /**
       * <pre>
       * Number of peers
       * </pre>
       *
       * <code>uint32 num_peers = 5;</code>
       * @return The numPeers.
       */
      @java.lang.Override
      public int getNumPeers() {
        return instance.getNumPeers();
      }
      /**
       * <pre>
       * Number of peers
       * </pre>
       *
       * <code>uint32 num_peers = 5;</code>
       * @param value The numPeers to set.
       * @return This builder for chaining.
       */
      public Builder setNumPeers(int value) {
        copyOnWrite();
        instance.setNumPeers(value);
        return this;
      }
      /**
       * <pre>
       * Number of peers
       * </pre>
       *
       * <code>uint32 num_peers = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumPeers() {
        copyOnWrite();
        instance.clearNumPeers();
        return this;
      }

      /**
       * <pre>
       * The node's current view of the height of the best block
       * </pre>
       *
       * <code>uint32 block_height = 6;</code>
       * @return The blockHeight.
       */
      @java.lang.Override
      public int getBlockHeight() {
        return instance.getBlockHeight();
      }
      /**
       * <pre>
       * The node's current view of the height of the best block
       * </pre>
       *
       * <code>uint32 block_height = 6;</code>
       * @param value The blockHeight to set.
       * @return This builder for chaining.
       */
      public Builder setBlockHeight(int value) {
        copyOnWrite();
        instance.setBlockHeight(value);
        return this;
      }
      /**
       * <pre>
       * The node's current view of the height of the best block
       * </pre>
       *
       * <code>uint32 block_height = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearBlockHeight() {
        copyOnWrite();
        instance.clearBlockHeight();
        return this;
      }

      /**
       * <pre>
       * The node's current view of the hash of the best block
       * </pre>
       *
       * <code>string block_hash = 8;</code>
       * @return The blockHash.
       */
      @java.lang.Override
      public java.lang.String getBlockHash() {
        return instance.getBlockHash();
      }
      /**
       * <pre>
       * The node's current view of the hash of the best block
       * </pre>
       *
       * <code>string block_hash = 8;</code>
       * @return The bytes for blockHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getBlockHashBytes() {
        return instance.getBlockHashBytes();
      }
      /**
       * <pre>
       * The node's current view of the hash of the best block
       * </pre>
       *
       * <code>string block_hash = 8;</code>
       * @param value The blockHash to set.
       * @return This builder for chaining.
       */
      public Builder setBlockHash(
          java.lang.String value) {
        copyOnWrite();
        instance.setBlockHash(value);
        return this;
      }
      /**
       * <pre>
       * The node's current view of the hash of the best block
       * </pre>
       *
       * <code>string block_hash = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearBlockHash() {
        copyOnWrite();
        instance.clearBlockHash();
        return this;
      }
      /**
       * <pre>
       * The node's current view of the hash of the best block
       * </pre>
       *
       * <code>string block_hash = 8;</code>
       * @param value The bytes for blockHash to set.
       * @return This builder for chaining.
       */
      public Builder setBlockHashBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setBlockHashBytes(value);
        return this;
      }

      /**
       * <pre>
       * Timestamp of the block best known to the wallet
       * </pre>
       *
       * <code>int64 best_header_timestamp = 13;</code>
       * @return The bestHeaderTimestamp.
       */
      @java.lang.Override
      public long getBestHeaderTimestamp() {
        return instance.getBestHeaderTimestamp();
      }
      /**
       * <pre>
       * Timestamp of the block best known to the wallet
       * </pre>
       *
       * <code>int64 best_header_timestamp = 13;</code>
       * @param value The bestHeaderTimestamp to set.
       * @return This builder for chaining.
       */
      public Builder setBestHeaderTimestamp(long value) {
        copyOnWrite();
        instance.setBestHeaderTimestamp(value);
        return this;
      }
      /**
       * <pre>
       * Timestamp of the block best known to the wallet
       * </pre>
       *
       * <code>int64 best_header_timestamp = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearBestHeaderTimestamp() {
        copyOnWrite();
        instance.clearBestHeaderTimestamp();
        return this;
      }

      /**
       * <pre>
       * Whether the wallet's view is synced to the main chain
       * </pre>
       *
       * <code>bool synced_to_chain = 9;</code>
       * @return The syncedToChain.
       */
      @java.lang.Override
      public boolean getSyncedToChain() {
        return instance.getSyncedToChain();
      }
      /**
       * <pre>
       * Whether the wallet's view is synced to the main chain
       * </pre>
       *
       * <code>bool synced_to_chain = 9;</code>
       * @param value The syncedToChain to set.
       * @return This builder for chaining.
       */
      public Builder setSyncedToChain(boolean value) {
        copyOnWrite();
        instance.setSyncedToChain(value);
        return this;
      }
      /**
       * <pre>
       * Whether the wallet's view is synced to the main chain
       * </pre>
       *
       * <code>bool synced_to_chain = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearSyncedToChain() {
        copyOnWrite();
        instance.clearSyncedToChain();
        return this;
      }

      /**
       * <pre>
       * Whether we consider ourselves synced with the public channel graph.
       * </pre>
       *
       * <code>bool synced_to_graph = 18;</code>
       * @return The syncedToGraph.
       */
      @java.lang.Override
      public boolean getSyncedToGraph() {
        return instance.getSyncedToGraph();
      }
      /**
       * <pre>
       * Whether we consider ourselves synced with the public channel graph.
       * </pre>
       *
       * <code>bool synced_to_graph = 18;</code>
       * @param value The syncedToGraph to set.
       * @return This builder for chaining.
       */
      public Builder setSyncedToGraph(boolean value) {
        copyOnWrite();
        instance.setSyncedToGraph(value);
        return this;
      }
      /**
       * <pre>
       * Whether we consider ourselves synced with the public channel graph.
       * </pre>
       *
       * <code>bool synced_to_graph = 18;</code>
       * @return This builder for chaining.
       */
      public Builder clearSyncedToGraph() {
        copyOnWrite();
        instance.clearSyncedToGraph();
        return this;
      }

      /**
       * <pre>
       *Whether the current node is connected to testnet. This field is
       *deprecated and the network field should be used instead
       * </pre>
       *
       * <code>bool testnet = 10 [deprecated = true];</code>
       * @return The testnet.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean getTestnet() {
        return instance.getTestnet();
      }
      /**
       * <pre>
       *Whether the current node is connected to testnet. This field is
       *deprecated and the network field should be used instead
       * </pre>
       *
       * <code>bool testnet = 10 [deprecated = true];</code>
       * @param value The testnet to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setTestnet(boolean value) {
        copyOnWrite();
        instance.setTestnet(value);
        return this;
      }
      /**
       * <pre>
       *Whether the current node is connected to testnet. This field is
       *deprecated and the network field should be used instead
       * </pre>
       *
       * <code>bool testnet = 10 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearTestnet() {
        copyOnWrite();
        instance.clearTestnet();
        return this;
      }

      /**
       * <pre>
       * A list of active chains the node is connected to
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.Chain> getChainsList() {
        return java.util.Collections.unmodifiableList(
            instance.getChainsList());
      }
      /**
       * <pre>
       * A list of active chains the node is connected to
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
       */
      @java.lang.Override
      public int getChainsCount() {
        return instance.getChainsCount();
      }/**
       * <pre>
       * A list of active chains the node is connected to
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Chain getChains(int index) {
        return instance.getChains(index);
      }
      /**
       * <pre>
       * A list of active chains the node is connected to
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
       */
      public Builder setChains(
          int index, co.anode.anodium.Rpc.Chain value) {
        copyOnWrite();
        instance.setChains(index, value);
        return this;
      }
      /**
       * <pre>
       * A list of active chains the node is connected to
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
       */
      public Builder setChains(
          int index, co.anode.anodium.Rpc.Chain.Builder builderForValue) {
        copyOnWrite();
        instance.setChains(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A list of active chains the node is connected to
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
       */
      public Builder addChains(co.anode.anodium.Rpc.Chain value) {
        copyOnWrite();
        instance.addChains(value);
        return this;
      }
      /**
       * <pre>
       * A list of active chains the node is connected to
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
       */
      public Builder addChains(
          int index, co.anode.anodium.Rpc.Chain value) {
        copyOnWrite();
        instance.addChains(index, value);
        return this;
      }
      /**
       * <pre>
       * A list of active chains the node is connected to
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
       */
      public Builder addChains(
          co.anode.anodium.Rpc.Chain.Builder builderForValue) {
        copyOnWrite();
        instance.addChains(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A list of active chains the node is connected to
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
       */
      public Builder addChains(
          int index, co.anode.anodium.Rpc.Chain.Builder builderForValue) {
        copyOnWrite();
        instance.addChains(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A list of active chains the node is connected to
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
       */
      public Builder addAllChains(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.Chain> values) {
        copyOnWrite();
        instance.addAllChains(values);
        return this;
      }
      /**
       * <pre>
       * A list of active chains the node is connected to
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
       */
      public Builder clearChains() {
        copyOnWrite();
        instance.clearChains();
        return this;
      }
      /**
       * <pre>
       * A list of active chains the node is connected to
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Chain chains = 16;</code>
       */
      public Builder removeChains(int index) {
        copyOnWrite();
        instance.removeChains(index);
        return this;
      }

      /**
       * <pre>
       * The URIs of the current node.
       * </pre>
       *
       * <code>repeated string uris = 12;</code>
       * @return A list containing the uris.
       */
      @java.lang.Override
      public java.util.List<java.lang.String>
          getUrisList() {
        return java.util.Collections.unmodifiableList(
            instance.getUrisList());
      }
      /**
       * <pre>
       * The URIs of the current node.
       * </pre>
       *
       * <code>repeated string uris = 12;</code>
       * @return The count of uris.
       */
      @java.lang.Override
      public int getUrisCount() {
        return instance.getUrisCount();
      }
      /**
       * <pre>
       * The URIs of the current node.
       * </pre>
       *
       * <code>repeated string uris = 12;</code>
       * @param index The index of the element to return.
       * @return The uris at the given index.
       */
      @java.lang.Override
      public java.lang.String getUris(int index) {
        return instance.getUris(index);
      }
      /**
       * <pre>
       * The URIs of the current node.
       * </pre>
       *
       * <code>repeated string uris = 12;</code>
       * @param index The index of the value to return.
       * @return The bytes of the uris at the given index.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getUrisBytes(int index) {
        return instance.getUrisBytes(index);
      }
      /**
       * <pre>
       * The URIs of the current node.
       * </pre>
       *
       * <code>repeated string uris = 12;</code>
       * @param index The index to set the value at.
       * @param value The uris to set.
       * @return This builder for chaining.
       */
      public Builder setUris(
          int index, java.lang.String value) {
        copyOnWrite();
        instance.setUris(index, value);
        return this;
      }
      /**
       * <pre>
       * The URIs of the current node.
       * </pre>
       *
       * <code>repeated string uris = 12;</code>
       * @param value The uris to add.
       * @return This builder for chaining.
       */
      public Builder addUris(
          java.lang.String value) {
        copyOnWrite();
        instance.addUris(value);
        return this;
      }
      /**
       * <pre>
       * The URIs of the current node.
       * </pre>
       *
       * <code>repeated string uris = 12;</code>
       * @param values The uris to add.
       * @return This builder for chaining.
       */
      public Builder addAllUris(
          java.lang.Iterable<java.lang.String> values) {
        copyOnWrite();
        instance.addAllUris(values);
        return this;
      }
      /**
       * <pre>
       * The URIs of the current node.
       * </pre>
       *
       * <code>repeated string uris = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearUris() {
        copyOnWrite();
        instance.clearUris();
        return this;
      }
      /**
       * <pre>
       * The URIs of the current node.
       * </pre>
       *
       * <code>repeated string uris = 12;</code>
       * @param value The bytes of the uris to add.
       * @return This builder for chaining.
       */
      public Builder addUrisBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addUrisBytes(value);
        return this;
      }

      @java.lang.Override

      public int getFeaturesCount() {
        return instance.getFeaturesMap().size();
      }
      /**
       * <pre>
       *Features that our node has advertised in our init message, node
       *announcements and invoices.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 19;</code>
       */
      @java.lang.Override

      public boolean containsFeatures(
          int key) {
        
        return instance.getFeaturesMap().containsKey(key);
      }

      public Builder clearFeatures() {
        copyOnWrite();
        instance.getMutableFeaturesMap().clear();
        return this;
      }
      /**
       * <pre>
       *Features that our node has advertised in our init message, node
       *announcements and invoices.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 19;</code>
       */

      public Builder removeFeatures(
          int key) {
        
        copyOnWrite();
        instance.getMutableFeaturesMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getFeaturesMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeatures() {
        return getFeaturesMap();
      }
      /**
       * <pre>
       *Features that our node has advertised in our init message, node
       *announcements and invoices.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 19;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeaturesMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getFeaturesMap());
      }
      /**
       * <pre>
       *Features that our node has advertised in our init message, node
       *announcements and invoices.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 19;</code>
       */
      @java.lang.Override

      public co.anode.anodium.Rpc.Feature getFeaturesOrDefault(
          int key,
          co.anode.anodium.Rpc.Feature defaultValue) {
        
        java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
            instance.getFeaturesMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       *Features that our node has advertised in our init message, node
       *announcements and invoices.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 19;</code>
       */
      @java.lang.Override

      public co.anode.anodium.Rpc.Feature getFeaturesOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
            instance.getFeaturesMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       *Features that our node has advertised in our init message, node
       *announcements and invoices.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 19;</code>
       */
      public Builder putFeatures(
          int key,
          co.anode.anodium.Rpc.Feature value) {
        
        value.getClass();
        copyOnWrite();
        instance.getMutableFeaturesMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       *Features that our node has advertised in our init message, node
       *announcements and invoices.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 19;</code>
       */
      public Builder putAllFeatures(
          java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> values) {
        copyOnWrite();
        instance.getMutableFeaturesMap().putAll(values);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.GetInfoResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.GetInfoResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "identityPubkey_",
              "alias_",
              "numPendingChannels_",
              "numActiveChannels_",
              "numPeers_",
              "blockHeight_",
              "blockHash_",
              "syncedToChain_",
              "testnet_",
              "uris_",
              "bestHeaderTimestamp_",
              "version_",
              "numInactiveChannels_",
              "chains_",
              co.anode.anodium.Rpc.Chain.class,
              "color_",
              "syncedToGraph_",
              "features_",
              FeaturesDefaultEntryHolder.defaultEntry,
              "commitHash_",
            };
            java.lang.String info =
                "\u0000\u0012\u0000\u0000\u0001\u0014\u0012\u0001\u0002\u0000\u0001\u0208\u0002\u0208" +
                "\u0003\u000b\u0004\u000b\u0005\u000b\u0006\u000b\b\u0208\t\u0007\n\u0007\f\u021a" +
                "\r\u0002\u000e\u0208\u000f\u000b\u0010\u001b\u0011\u0208\u0012\u0007\u00132\u0014" +
                "\u0208";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.GetInfoResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.GetInfoResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.GetInfoResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.GetInfoResponse)
    private static final co.anode.anodium.Rpc.GetInfoResponse DEFAULT_INSTANCE;
    static {
      GetInfoResponse defaultInstance = new GetInfoResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        GetInfoResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.GetInfoResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<GetInfoResponse> PARSER;

    public static com.google.protobuf.Parser<GetInfoResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface GetRecoveryInfoRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.GetRecoveryInfoRequest)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.GetRecoveryInfoRequest}
   */
  public  static final class GetRecoveryInfoRequest extends
      com.google.protobuf.GeneratedMessageLite<
          GetRecoveryInfoRequest, GetRecoveryInfoRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.GetRecoveryInfoRequest)
      GetRecoveryInfoRequestOrBuilder {
    private GetRecoveryInfoRequest() {
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.GetRecoveryInfoRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.GetRecoveryInfoRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.GetRecoveryInfoRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.GetRecoveryInfoRequest)
        co.anode.anodium.Rpc.GetRecoveryInfoRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.GetRecoveryInfoRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.GetRecoveryInfoRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.GetRecoveryInfoRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.GetRecoveryInfoRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.GetRecoveryInfoRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.GetRecoveryInfoRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.GetRecoveryInfoRequest)
    private static final co.anode.anodium.Rpc.GetRecoveryInfoRequest DEFAULT_INSTANCE;
    static {
      GetRecoveryInfoRequest defaultInstance = new GetRecoveryInfoRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        GetRecoveryInfoRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.GetRecoveryInfoRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<GetRecoveryInfoRequest> PARSER;

    public static com.google.protobuf.Parser<GetRecoveryInfoRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface GetRecoveryInfoResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.GetRecoveryInfoResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Whether the wallet is in recovery mode
     * </pre>
     *
     * <code>bool recovery_mode = 1;</code>
     * @return The recoveryMode.
     */
    boolean getRecoveryMode();

    /**
     * <pre>
     * Whether the wallet recovery progress is finished
     * </pre>
     *
     * <code>bool recovery_finished = 2;</code>
     * @return The recoveryFinished.
     */
    boolean getRecoveryFinished();

    /**
     * <pre>
     * The recovery progress, ranging from 0 to 1.
     * </pre>
     *
     * <code>double progress = 3;</code>
     * @return The progress.
     */
    double getProgress();
  }
  /**
   * Protobuf type {@code co.anode.anodium.GetRecoveryInfoResponse}
   */
  public  static final class GetRecoveryInfoResponse extends
      com.google.protobuf.GeneratedMessageLite<
          GetRecoveryInfoResponse, GetRecoveryInfoResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.GetRecoveryInfoResponse)
      GetRecoveryInfoResponseOrBuilder {
    private GetRecoveryInfoResponse() {
    }
    public static final int RECOVERY_MODE_FIELD_NUMBER = 1;
    private boolean recoveryMode_;
    /**
     * <pre>
     * Whether the wallet is in recovery mode
     * </pre>
     *
     * <code>bool recovery_mode = 1;</code>
     * @return The recoveryMode.
     */
    @java.lang.Override
    public boolean getRecoveryMode() {
      return recoveryMode_;
    }
    /**
     * <pre>
     * Whether the wallet is in recovery mode
     * </pre>
     *
     * <code>bool recovery_mode = 1;</code>
     * @param value The recoveryMode to set.
     */
    private void setRecoveryMode(boolean value) {
      
      recoveryMode_ = value;
    }
    /**
     * <pre>
     * Whether the wallet is in recovery mode
     * </pre>
     *
     * <code>bool recovery_mode = 1;</code>
     */
    private void clearRecoveryMode() {
      
      recoveryMode_ = false;
    }

    public static final int RECOVERY_FINISHED_FIELD_NUMBER = 2;
    private boolean recoveryFinished_;
    /**
     * <pre>
     * Whether the wallet recovery progress is finished
     * </pre>
     *
     * <code>bool recovery_finished = 2;</code>
     * @return The recoveryFinished.
     */
    @java.lang.Override
    public boolean getRecoveryFinished() {
      return recoveryFinished_;
    }
    /**
     * <pre>
     * Whether the wallet recovery progress is finished
     * </pre>
     *
     * <code>bool recovery_finished = 2;</code>
     * @param value The recoveryFinished to set.
     */
    private void setRecoveryFinished(boolean value) {
      
      recoveryFinished_ = value;
    }
    /**
     * <pre>
     * Whether the wallet recovery progress is finished
     * </pre>
     *
     * <code>bool recovery_finished = 2;</code>
     */
    private void clearRecoveryFinished() {
      
      recoveryFinished_ = false;
    }

    public static final int PROGRESS_FIELD_NUMBER = 3;
    private double progress_;
    /**
     * <pre>
     * The recovery progress, ranging from 0 to 1.
     * </pre>
     *
     * <code>double progress = 3;</code>
     * @return The progress.
     */
    @java.lang.Override
    public double getProgress() {
      return progress_;
    }
    /**
     * <pre>
     * The recovery progress, ranging from 0 to 1.
     * </pre>
     *
     * <code>double progress = 3;</code>
     * @param value The progress to set.
     */
    private void setProgress(double value) {
      
      progress_ = value;
    }
    /**
     * <pre>
     * The recovery progress, ranging from 0 to 1.
     * </pre>
     *
     * <code>double progress = 3;</code>
     */
    private void clearProgress() {
      
      progress_ = 0D;
    }

    public static co.anode.anodium.Rpc.GetRecoveryInfoResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetRecoveryInfoResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.GetRecoveryInfoResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.GetRecoveryInfoResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.GetRecoveryInfoResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.GetRecoveryInfoResponse)
        co.anode.anodium.Rpc.GetRecoveryInfoResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.GetRecoveryInfoResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Whether the wallet is in recovery mode
       * </pre>
       *
       * <code>bool recovery_mode = 1;</code>
       * @return The recoveryMode.
       */
      @java.lang.Override
      public boolean getRecoveryMode() {
        return instance.getRecoveryMode();
      }
      /**
       * <pre>
       * Whether the wallet is in recovery mode
       * </pre>
       *
       * <code>bool recovery_mode = 1;</code>
       * @param value The recoveryMode to set.
       * @return This builder for chaining.
       */
      public Builder setRecoveryMode(boolean value) {
        copyOnWrite();
        instance.setRecoveryMode(value);
        return this;
      }
      /**
       * <pre>
       * Whether the wallet is in recovery mode
       * </pre>
       *
       * <code>bool recovery_mode = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRecoveryMode() {
        copyOnWrite();
        instance.clearRecoveryMode();
        return this;
      }

      /**
       * <pre>
       * Whether the wallet recovery progress is finished
       * </pre>
       *
       * <code>bool recovery_finished = 2;</code>
       * @return The recoveryFinished.
       */
      @java.lang.Override
      public boolean getRecoveryFinished() {
        return instance.getRecoveryFinished();
      }
      /**
       * <pre>
       * Whether the wallet recovery progress is finished
       * </pre>
       *
       * <code>bool recovery_finished = 2;</code>
       * @param value The recoveryFinished to set.
       * @return This builder for chaining.
       */
      public Builder setRecoveryFinished(boolean value) {
        copyOnWrite();
        instance.setRecoveryFinished(value);
        return this;
      }
      /**
       * <pre>
       * Whether the wallet recovery progress is finished
       * </pre>
       *
       * <code>bool recovery_finished = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearRecoveryFinished() {
        copyOnWrite();
        instance.clearRecoveryFinished();
        return this;
      }

      /**
       * <pre>
       * The recovery progress, ranging from 0 to 1.
       * </pre>
       *
       * <code>double progress = 3;</code>
       * @return The progress.
       */
      @java.lang.Override
      public double getProgress() {
        return instance.getProgress();
      }
      /**
       * <pre>
       * The recovery progress, ranging from 0 to 1.
       * </pre>
       *
       * <code>double progress = 3;</code>
       * @param value The progress to set.
       * @return This builder for chaining.
       */
      public Builder setProgress(double value) {
        copyOnWrite();
        instance.setProgress(value);
        return this;
      }
      /**
       * <pre>
       * The recovery progress, ranging from 0 to 1.
       * </pre>
       *
       * <code>double progress = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearProgress() {
        copyOnWrite();
        instance.clearProgress();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.GetRecoveryInfoResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.GetRecoveryInfoResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "recoveryMode_",
              "recoveryFinished_",
              "progress_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0003\u0003\u0000\u0000\u0000\u0001\u0007\u0002\u0007" +
                "\u0003\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.GetRecoveryInfoResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.GetRecoveryInfoResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.GetRecoveryInfoResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.GetRecoveryInfoResponse)
    private static final co.anode.anodium.Rpc.GetRecoveryInfoResponse DEFAULT_INSTANCE;
    static {
      GetRecoveryInfoResponse defaultInstance = new GetRecoveryInfoResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        GetRecoveryInfoResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.GetRecoveryInfoResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<GetRecoveryInfoResponse> PARSER;

    public static com.google.protobuf.Parser<GetRecoveryInfoResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChainOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.Chain)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The blockchain the node is on (eg bitcoin, litecoin)
     * </pre>
     *
     * <code>string chain = 1;</code>
     * @return The chain.
     */
    java.lang.String getChain();
    /**
     * <pre>
     * The blockchain the node is on (eg bitcoin, litecoin)
     * </pre>
     *
     * <code>string chain = 1;</code>
     * @return The bytes for chain.
     */
    com.google.protobuf.ByteString
        getChainBytes();

    /**
     * <pre>
     * The network the node is on (eg regtest, testnet, mainnet)
     * </pre>
     *
     * <code>string network = 2;</code>
     * @return The network.
     */
    java.lang.String getNetwork();
    /**
     * <pre>
     * The network the node is on (eg regtest, testnet, mainnet)
     * </pre>
     *
     * <code>string network = 2;</code>
     * @return The bytes for network.
     */
    com.google.protobuf.ByteString
        getNetworkBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.Chain}
   */
  public  static final class Chain extends
      com.google.protobuf.GeneratedMessageLite<
          Chain, Chain.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.Chain)
      ChainOrBuilder {
    private Chain() {
      chain_ = "";
      network_ = "";
    }
    public static final int CHAIN_FIELD_NUMBER = 1;
    private java.lang.String chain_;
    /**
     * <pre>
     * The blockchain the node is on (eg bitcoin, litecoin)
     * </pre>
     *
     * <code>string chain = 1;</code>
     * @return The chain.
     */
    @java.lang.Override
    public java.lang.String getChain() {
      return chain_;
    }
    /**
     * <pre>
     * The blockchain the node is on (eg bitcoin, litecoin)
     * </pre>
     *
     * <code>string chain = 1;</code>
     * @return The bytes for chain.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getChainBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(chain_);
    }
    /**
     * <pre>
     * The blockchain the node is on (eg bitcoin, litecoin)
     * </pre>
     *
     * <code>string chain = 1;</code>
     * @param value The chain to set.
     */
    private void setChain(
        java.lang.String value) {
      value.getClass();
  
      chain_ = value;
    }
    /**
     * <pre>
     * The blockchain the node is on (eg bitcoin, litecoin)
     * </pre>
     *
     * <code>string chain = 1;</code>
     */
    private void clearChain() {
      
      chain_ = getDefaultInstance().getChain();
    }
    /**
     * <pre>
     * The blockchain the node is on (eg bitcoin, litecoin)
     * </pre>
     *
     * <code>string chain = 1;</code>
     * @param value The bytes for chain to set.
     */
    private void setChainBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      chain_ = value.toStringUtf8();
      
    }

    public static final int NETWORK_FIELD_NUMBER = 2;
    private java.lang.String network_;
    /**
     * <pre>
     * The network the node is on (eg regtest, testnet, mainnet)
     * </pre>
     *
     * <code>string network = 2;</code>
     * @return The network.
     */
    @java.lang.Override
    public java.lang.String getNetwork() {
      return network_;
    }
    /**
     * <pre>
     * The network the node is on (eg regtest, testnet, mainnet)
     * </pre>
     *
     * <code>string network = 2;</code>
     * @return The bytes for network.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNetworkBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(network_);
    }
    /**
     * <pre>
     * The network the node is on (eg regtest, testnet, mainnet)
     * </pre>
     *
     * <code>string network = 2;</code>
     * @param value The network to set.
     */
    private void setNetwork(
        java.lang.String value) {
      value.getClass();
  
      network_ = value;
    }
    /**
     * <pre>
     * The network the node is on (eg regtest, testnet, mainnet)
     * </pre>
     *
     * <code>string network = 2;</code>
     */
    private void clearNetwork() {
      
      network_ = getDefaultInstance().getNetwork();
    }
    /**
     * <pre>
     * The network the node is on (eg regtest, testnet, mainnet)
     * </pre>
     *
     * <code>string network = 2;</code>
     * @param value The bytes for network to set.
     */
    private void setNetworkBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      network_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.Chain parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Chain parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Chain parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Chain parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Chain parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Chain parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Chain parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Chain parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Chain parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Chain parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Chain parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Chain parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.Chain prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.Chain}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.Chain, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.Chain)
        co.anode.anodium.Rpc.ChainOrBuilder {
      // Construct using co.anode.anodium.Rpc.Chain.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The blockchain the node is on (eg bitcoin, litecoin)
       * </pre>
       *
       * <code>string chain = 1;</code>
       * @return The chain.
       */
      @java.lang.Override
      public java.lang.String getChain() {
        return instance.getChain();
      }
      /**
       * <pre>
       * The blockchain the node is on (eg bitcoin, litecoin)
       * </pre>
       *
       * <code>string chain = 1;</code>
       * @return The bytes for chain.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getChainBytes() {
        return instance.getChainBytes();
      }
      /**
       * <pre>
       * The blockchain the node is on (eg bitcoin, litecoin)
       * </pre>
       *
       * <code>string chain = 1;</code>
       * @param value The chain to set.
       * @return This builder for chaining.
       */
      public Builder setChain(
          java.lang.String value) {
        copyOnWrite();
        instance.setChain(value);
        return this;
      }
      /**
       * <pre>
       * The blockchain the node is on (eg bitcoin, litecoin)
       * </pre>
       *
       * <code>string chain = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearChain() {
        copyOnWrite();
        instance.clearChain();
        return this;
      }
      /**
       * <pre>
       * The blockchain the node is on (eg bitcoin, litecoin)
       * </pre>
       *
       * <code>string chain = 1;</code>
       * @param value The bytes for chain to set.
       * @return This builder for chaining.
       */
      public Builder setChainBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setChainBytes(value);
        return this;
      }

      /**
       * <pre>
       * The network the node is on (eg regtest, testnet, mainnet)
       * </pre>
       *
       * <code>string network = 2;</code>
       * @return The network.
       */
      @java.lang.Override
      public java.lang.String getNetwork() {
        return instance.getNetwork();
      }
      /**
       * <pre>
       * The network the node is on (eg regtest, testnet, mainnet)
       * </pre>
       *
       * <code>string network = 2;</code>
       * @return The bytes for network.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNetworkBytes() {
        return instance.getNetworkBytes();
      }
      /**
       * <pre>
       * The network the node is on (eg regtest, testnet, mainnet)
       * </pre>
       *
       * <code>string network = 2;</code>
       * @param value The network to set.
       * @return This builder for chaining.
       */
      public Builder setNetwork(
          java.lang.String value) {
        copyOnWrite();
        instance.setNetwork(value);
        return this;
      }
      /**
       * <pre>
       * The network the node is on (eg regtest, testnet, mainnet)
       * </pre>
       *
       * <code>string network = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNetwork() {
        copyOnWrite();
        instance.clearNetwork();
        return this;
      }
      /**
       * <pre>
       * The network the node is on (eg regtest, testnet, mainnet)
       * </pre>
       *
       * <code>string network = 2;</code>
       * @param value The bytes for network to set.
       * @return This builder for chaining.
       */
      public Builder setNetworkBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNetworkBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.Chain)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.Chain();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "chain_",
              "network_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0208\u0002\u0208" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.Chain> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.Chain.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.Chain>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.Chain)
    private static final co.anode.anodium.Rpc.Chain DEFAULT_INSTANCE;
    static {
      Chain defaultInstance = new Chain();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Chain.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.Chain getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Chain> PARSER;

    public static com.google.protobuf.Parser<Chain> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ConfirmationUpdateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ConfirmationUpdate)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>bytes block_sha = 1;</code>
     * @return The blockSha.
     */
    com.google.protobuf.ByteString getBlockSha();

    /**
     * <code>int32 block_height = 2;</code>
     * @return The blockHeight.
     */
    int getBlockHeight();

    /**
     * <code>uint32 num_confs_left = 3;</code>
     * @return The numConfsLeft.
     */
    int getNumConfsLeft();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ConfirmationUpdate}
   */
  public  static final class ConfirmationUpdate extends
      com.google.protobuf.GeneratedMessageLite<
          ConfirmationUpdate, ConfirmationUpdate.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ConfirmationUpdate)
      ConfirmationUpdateOrBuilder {
    private ConfirmationUpdate() {
      blockSha_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int BLOCK_SHA_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString blockSha_;
    /**
     * <code>bytes block_sha = 1;</code>
     * @return The blockSha.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getBlockSha() {
      return blockSha_;
    }
    /**
     * <code>bytes block_sha = 1;</code>
     * @param value The blockSha to set.
     */
    private void setBlockSha(com.google.protobuf.ByteString value) {
      value.getClass();
  
      blockSha_ = value;
    }
    /**
     * <code>bytes block_sha = 1;</code>
     */
    private void clearBlockSha() {
      
      blockSha_ = getDefaultInstance().getBlockSha();
    }

    public static final int BLOCK_HEIGHT_FIELD_NUMBER = 2;
    private int blockHeight_;
    /**
     * <code>int32 block_height = 2;</code>
     * @return The blockHeight.
     */
    @java.lang.Override
    public int getBlockHeight() {
      return blockHeight_;
    }
    /**
     * <code>int32 block_height = 2;</code>
     * @param value The blockHeight to set.
     */
    private void setBlockHeight(int value) {
      
      blockHeight_ = value;
    }
    /**
     * <code>int32 block_height = 2;</code>
     */
    private void clearBlockHeight() {
      
      blockHeight_ = 0;
    }

    public static final int NUM_CONFS_LEFT_FIELD_NUMBER = 3;
    private int numConfsLeft_;
    /**
     * <code>uint32 num_confs_left = 3;</code>
     * @return The numConfsLeft.
     */
    @java.lang.Override
    public int getNumConfsLeft() {
      return numConfsLeft_;
    }
    /**
     * <code>uint32 num_confs_left = 3;</code>
     * @param value The numConfsLeft to set.
     */
    private void setNumConfsLeft(int value) {
      
      numConfsLeft_ = value;
    }
    /**
     * <code>uint32 num_confs_left = 3;</code>
     */
    private void clearNumConfsLeft() {
      
      numConfsLeft_ = 0;
    }

    public static co.anode.anodium.Rpc.ConfirmationUpdate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ConfirmationUpdate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ConfirmationUpdate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ConfirmationUpdate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ConfirmationUpdate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ConfirmationUpdate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ConfirmationUpdate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ConfirmationUpdate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ConfirmationUpdate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ConfirmationUpdate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ConfirmationUpdate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ConfirmationUpdate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ConfirmationUpdate prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ConfirmationUpdate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ConfirmationUpdate, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ConfirmationUpdate)
        co.anode.anodium.Rpc.ConfirmationUpdateOrBuilder {
      // Construct using co.anode.anodium.Rpc.ConfirmationUpdate.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>bytes block_sha = 1;</code>
       * @return The blockSha.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getBlockSha() {
        return instance.getBlockSha();
      }
      /**
       * <code>bytes block_sha = 1;</code>
       * @param value The blockSha to set.
       * @return This builder for chaining.
       */
      public Builder setBlockSha(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setBlockSha(value);
        return this;
      }
      /**
       * <code>bytes block_sha = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearBlockSha() {
        copyOnWrite();
        instance.clearBlockSha();
        return this;
      }

      /**
       * <code>int32 block_height = 2;</code>
       * @return The blockHeight.
       */
      @java.lang.Override
      public int getBlockHeight() {
        return instance.getBlockHeight();
      }
      /**
       * <code>int32 block_height = 2;</code>
       * @param value The blockHeight to set.
       * @return This builder for chaining.
       */
      public Builder setBlockHeight(int value) {
        copyOnWrite();
        instance.setBlockHeight(value);
        return this;
      }
      /**
       * <code>int32 block_height = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearBlockHeight() {
        copyOnWrite();
        instance.clearBlockHeight();
        return this;
      }

      /**
       * <code>uint32 num_confs_left = 3;</code>
       * @return The numConfsLeft.
       */
      @java.lang.Override
      public int getNumConfsLeft() {
        return instance.getNumConfsLeft();
      }
      /**
       * <code>uint32 num_confs_left = 3;</code>
       * @param value The numConfsLeft to set.
       * @return This builder for chaining.
       */
      public Builder setNumConfsLeft(int value) {
        copyOnWrite();
        instance.setNumConfsLeft(value);
        return this;
      }
      /**
       * <code>uint32 num_confs_left = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumConfsLeft() {
        copyOnWrite();
        instance.clearNumConfsLeft();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ConfirmationUpdate)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ConfirmationUpdate();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "blockSha_",
              "blockHeight_",
              "numConfsLeft_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0003\u0003\u0000\u0000\u0000\u0001\n\u0002\u0004" +
                "\u0003\u000b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ConfirmationUpdate> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ConfirmationUpdate.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ConfirmationUpdate>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ConfirmationUpdate)
    private static final co.anode.anodium.Rpc.ConfirmationUpdate DEFAULT_INSTANCE;
    static {
      ConfirmationUpdate defaultInstance = new ConfirmationUpdate();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ConfirmationUpdate.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ConfirmationUpdate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ConfirmationUpdate> PARSER;

    public static com.google.protobuf.Parser<ConfirmationUpdate> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelOpenUpdateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelOpenUpdate)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     * @return Whether the channelPoint field is set.
     */
    boolean hasChannelPoint();
    /**
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     * @return The channelPoint.
     */
    co.anode.anodium.Rpc.ChannelPoint getChannelPoint();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChannelOpenUpdate}
   */
  public  static final class ChannelOpenUpdate extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelOpenUpdate, ChannelOpenUpdate.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelOpenUpdate)
      ChannelOpenUpdateOrBuilder {
    private ChannelOpenUpdate() {
    }
    public static final int CHANNEL_POINT_FIELD_NUMBER = 1;
    private co.anode.anodium.Rpc.ChannelPoint channelPoint_;
    /**
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     */
    @java.lang.Override
    public boolean hasChannelPoint() {
      return channelPoint_ != null;
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelPoint getChannelPoint() {
      return channelPoint_ == null ? co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance() : channelPoint_;
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     */
    private void setChannelPoint(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  channelPoint_ = value;
      
      }
    /**
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeChannelPoint(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  if (channelPoint_ != null &&
          channelPoint_ != co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance()) {
        channelPoint_ =
          co.anode.anodium.Rpc.ChannelPoint.newBuilder(channelPoint_).mergeFrom(value).buildPartial();
      } else {
        channelPoint_ = value;
      }
      
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     */
    private void clearChannelPoint() {  channelPoint_ = null;
      
    }

    public static co.anode.anodium.Rpc.ChannelOpenUpdate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelOpenUpdate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelOpenUpdate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelOpenUpdate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelOpenUpdate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelOpenUpdate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelOpenUpdate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelOpenUpdate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelOpenUpdate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelOpenUpdate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelOpenUpdate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelOpenUpdate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelOpenUpdate prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChannelOpenUpdate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelOpenUpdate, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelOpenUpdate)
        co.anode.anodium.Rpc.ChannelOpenUpdateOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelOpenUpdate.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
       */
      @java.lang.Override
      public boolean hasChannelPoint() {
        return instance.hasChannelPoint();
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelPoint getChannelPoint() {
        return instance.getChannelPoint();
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
       */
      public Builder setChannelPoint(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.setChannelPoint(value);
        return this;
        }
      /**
       * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
       */
      public Builder setChannelPoint(
          co.anode.anodium.Rpc.ChannelPoint.Builder builderForValue) {
        copyOnWrite();
        instance.setChannelPoint(builderForValue.build());
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
       */
      public Builder mergeChannelPoint(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.mergeChannelPoint(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
       */
      public Builder clearChannelPoint() {  copyOnWrite();
        instance.clearChannelPoint();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelOpenUpdate)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelOpenUpdate();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "channelPoint_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\t";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelOpenUpdate> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelOpenUpdate.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelOpenUpdate>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelOpenUpdate)
    private static final co.anode.anodium.Rpc.ChannelOpenUpdate DEFAULT_INSTANCE;
    static {
      ChannelOpenUpdate defaultInstance = new ChannelOpenUpdate();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelOpenUpdate.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelOpenUpdate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelOpenUpdate> PARSER;

    public static com.google.protobuf.Parser<ChannelOpenUpdate> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelCloseUpdateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelCloseUpdate)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>bytes closing_txid = 1;</code>
     * @return The closingTxid.
     */
    com.google.protobuf.ByteString getClosingTxid();

    /**
     * <code>bool success = 2;</code>
     * @return The success.
     */
    boolean getSuccess();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChannelCloseUpdate}
   */
  public  static final class ChannelCloseUpdate extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelCloseUpdate, ChannelCloseUpdate.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelCloseUpdate)
      ChannelCloseUpdateOrBuilder {
    private ChannelCloseUpdate() {
      closingTxid_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int CLOSING_TXID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString closingTxid_;
    /**
     * <code>bytes closing_txid = 1;</code>
     * @return The closingTxid.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getClosingTxid() {
      return closingTxid_;
    }
    /**
     * <code>bytes closing_txid = 1;</code>
     * @param value The closingTxid to set.
     */
    private void setClosingTxid(com.google.protobuf.ByteString value) {
      value.getClass();
  
      closingTxid_ = value;
    }
    /**
     * <code>bytes closing_txid = 1;</code>
     */
    private void clearClosingTxid() {
      
      closingTxid_ = getDefaultInstance().getClosingTxid();
    }

    public static final int SUCCESS_FIELD_NUMBER = 2;
    private boolean success_;
    /**
     * <code>bool success = 2;</code>
     * @return The success.
     */
    @java.lang.Override
    public boolean getSuccess() {
      return success_;
    }
    /**
     * <code>bool success = 2;</code>
     * @param value The success to set.
     */
    private void setSuccess(boolean value) {
      
      success_ = value;
    }
    /**
     * <code>bool success = 2;</code>
     */
    private void clearSuccess() {
      
      success_ = false;
    }

    public static co.anode.anodium.Rpc.ChannelCloseUpdate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelCloseUpdate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelCloseUpdate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelCloseUpdate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelCloseUpdate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelCloseUpdate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelCloseUpdate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelCloseUpdate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelCloseUpdate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelCloseUpdate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelCloseUpdate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelCloseUpdate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelCloseUpdate prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChannelCloseUpdate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelCloseUpdate, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelCloseUpdate)
        co.anode.anodium.Rpc.ChannelCloseUpdateOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelCloseUpdate.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>bytes closing_txid = 1;</code>
       * @return The closingTxid.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getClosingTxid() {
        return instance.getClosingTxid();
      }
      /**
       * <code>bytes closing_txid = 1;</code>
       * @param value The closingTxid to set.
       * @return This builder for chaining.
       */
      public Builder setClosingTxid(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setClosingTxid(value);
        return this;
      }
      /**
       * <code>bytes closing_txid = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearClosingTxid() {
        copyOnWrite();
        instance.clearClosingTxid();
        return this;
      }

      /**
       * <code>bool success = 2;</code>
       * @return The success.
       */
      @java.lang.Override
      public boolean getSuccess() {
        return instance.getSuccess();
      }
      /**
       * <code>bool success = 2;</code>
       * @param value The success to set.
       * @return This builder for chaining.
       */
      public Builder setSuccess(boolean value) {
        copyOnWrite();
        instance.setSuccess(value);
        return this;
      }
      /**
       * <code>bool success = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSuccess() {
        copyOnWrite();
        instance.clearSuccess();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelCloseUpdate)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelCloseUpdate();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "closingTxid_",
              "success_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\n\u0002\u0007" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelCloseUpdate> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelCloseUpdate.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelCloseUpdate>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelCloseUpdate)
    private static final co.anode.anodium.Rpc.ChannelCloseUpdate DEFAULT_INSTANCE;
    static {
      ChannelCloseUpdate defaultInstance = new ChannelCloseUpdate();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelCloseUpdate.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelCloseUpdate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelCloseUpdate> PARSER;

    public static com.google.protobuf.Parser<ChannelCloseUpdate> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface CloseChannelRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.CloseChannelRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The outpoint (txid:index) of the funding transaction. With this value, Bob
     *will be able to generate a signature for Alice's version of the commitment
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     * @return Whether the channelPoint field is set.
     */
    boolean hasChannelPoint();
    /**
     * <pre>
     *The outpoint (txid:index) of the funding transaction. With this value, Bob
     *will be able to generate a signature for Alice's version of the commitment
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     * @return The channelPoint.
     */
    co.anode.anodium.Rpc.ChannelPoint getChannelPoint();

    /**
     * <pre>
     * If true, then the channel will be closed forcibly. This means the
     * current commitment transaction will be signed and broadcast.
     * </pre>
     *
     * <code>bool force = 2;</code>
     * @return The force.
     */
    boolean getForce();

    /**
     * <pre>
     * The target number of blocks that the closure transaction should be
     * confirmed by.
     * </pre>
     *
     * <code>int32 target_conf = 3;</code>
     * @return The targetConf.
     */
    int getTargetConf();

    /**
     * <pre>
     * A manual fee rate set in sat/byte that should be used when crafting the
     * closure transaction.
     * </pre>
     *
     * <code>int64 sat_per_byte = 4;</code>
     * @return The satPerByte.
     */
    long getSatPerByte();

    /**
     * <pre>
     *An optional address to send funds to in the case of a cooperative close.
     *If the channel was opened with an upfront shutdown script and this field
     *is set, the request to close will fail because the channel must pay out
     *to the upfront shutdown addresss.
     * </pre>
     *
     * <code>string delivery_address = 5;</code>
     * @return The deliveryAddress.
     */
    java.lang.String getDeliveryAddress();
    /**
     * <pre>
     *An optional address to send funds to in the case of a cooperative close.
     *If the channel was opened with an upfront shutdown script and this field
     *is set, the request to close will fail because the channel must pay out
     *to the upfront shutdown addresss.
     * </pre>
     *
     * <code>string delivery_address = 5;</code>
     * @return The bytes for deliveryAddress.
     */
    com.google.protobuf.ByteString
        getDeliveryAddressBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.CloseChannelRequest}
   */
  public  static final class CloseChannelRequest extends
      com.google.protobuf.GeneratedMessageLite<
          CloseChannelRequest, CloseChannelRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.CloseChannelRequest)
      CloseChannelRequestOrBuilder {
    private CloseChannelRequest() {
      deliveryAddress_ = "";
    }
    public static final int CHANNEL_POINT_FIELD_NUMBER = 1;
    private co.anode.anodium.Rpc.ChannelPoint channelPoint_;
    /**
     * <pre>
     *The outpoint (txid:index) of the funding transaction. With this value, Bob
     *will be able to generate a signature for Alice's version of the commitment
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     */
    @java.lang.Override
    public boolean hasChannelPoint() {
      return channelPoint_ != null;
    }
    /**
     * <pre>
     *The outpoint (txid:index) of the funding transaction. With this value, Bob
     *will be able to generate a signature for Alice's version of the commitment
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelPoint getChannelPoint() {
      return channelPoint_ == null ? co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance() : channelPoint_;
    }
    /**
     * <pre>
     *The outpoint (txid:index) of the funding transaction. With this value, Bob
     *will be able to generate a signature for Alice's version of the commitment
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     */
    private void setChannelPoint(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  channelPoint_ = value;
      
      }
    /**
     * <pre>
     *The outpoint (txid:index) of the funding transaction. With this value, Bob
     *will be able to generate a signature for Alice's version of the commitment
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeChannelPoint(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  if (channelPoint_ != null &&
          channelPoint_ != co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance()) {
        channelPoint_ =
          co.anode.anodium.Rpc.ChannelPoint.newBuilder(channelPoint_).mergeFrom(value).buildPartial();
      } else {
        channelPoint_ = value;
      }
      
    }
    /**
     * <pre>
     *The outpoint (txid:index) of the funding transaction. With this value, Bob
     *will be able to generate a signature for Alice's version of the commitment
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     */
    private void clearChannelPoint() {  channelPoint_ = null;
      
    }

    public static final int FORCE_FIELD_NUMBER = 2;
    private boolean force_;
    /**
     * <pre>
     * If true, then the channel will be closed forcibly. This means the
     * current commitment transaction will be signed and broadcast.
     * </pre>
     *
     * <code>bool force = 2;</code>
     * @return The force.
     */
    @java.lang.Override
    public boolean getForce() {
      return force_;
    }
    /**
     * <pre>
     * If true, then the channel will be closed forcibly. This means the
     * current commitment transaction will be signed and broadcast.
     * </pre>
     *
     * <code>bool force = 2;</code>
     * @param value The force to set.
     */
    private void setForce(boolean value) {
      
      force_ = value;
    }
    /**
     * <pre>
     * If true, then the channel will be closed forcibly. This means the
     * current commitment transaction will be signed and broadcast.
     * </pre>
     *
     * <code>bool force = 2;</code>
     */
    private void clearForce() {
      
      force_ = false;
    }

    public static final int TARGET_CONF_FIELD_NUMBER = 3;
    private int targetConf_;
    /**
     * <pre>
     * The target number of blocks that the closure transaction should be
     * confirmed by.
     * </pre>
     *
     * <code>int32 target_conf = 3;</code>
     * @return The targetConf.
     */
    @java.lang.Override
    public int getTargetConf() {
      return targetConf_;
    }
    /**
     * <pre>
     * The target number of blocks that the closure transaction should be
     * confirmed by.
     * </pre>
     *
     * <code>int32 target_conf = 3;</code>
     * @param value The targetConf to set.
     */
    private void setTargetConf(int value) {
      
      targetConf_ = value;
    }
    /**
     * <pre>
     * The target number of blocks that the closure transaction should be
     * confirmed by.
     * </pre>
     *
     * <code>int32 target_conf = 3;</code>
     */
    private void clearTargetConf() {
      
      targetConf_ = 0;
    }

    public static final int SAT_PER_BYTE_FIELD_NUMBER = 4;
    private long satPerByte_;
    /**
     * <pre>
     * A manual fee rate set in sat/byte that should be used when crafting the
     * closure transaction.
     * </pre>
     *
     * <code>int64 sat_per_byte = 4;</code>
     * @return The satPerByte.
     */
    @java.lang.Override
    public long getSatPerByte() {
      return satPerByte_;
    }
    /**
     * <pre>
     * A manual fee rate set in sat/byte that should be used when crafting the
     * closure transaction.
     * </pre>
     *
     * <code>int64 sat_per_byte = 4;</code>
     * @param value The satPerByte to set.
     */
    private void setSatPerByte(long value) {
      
      satPerByte_ = value;
    }
    /**
     * <pre>
     * A manual fee rate set in sat/byte that should be used when crafting the
     * closure transaction.
     * </pre>
     *
     * <code>int64 sat_per_byte = 4;</code>
     */
    private void clearSatPerByte() {
      
      satPerByte_ = 0L;
    }

    public static final int DELIVERY_ADDRESS_FIELD_NUMBER = 5;
    private java.lang.String deliveryAddress_;
    /**
     * <pre>
     *An optional address to send funds to in the case of a cooperative close.
     *If the channel was opened with an upfront shutdown script and this field
     *is set, the request to close will fail because the channel must pay out
     *to the upfront shutdown addresss.
     * </pre>
     *
     * <code>string delivery_address = 5;</code>
     * @return The deliveryAddress.
     */
    @java.lang.Override
    public java.lang.String getDeliveryAddress() {
      return deliveryAddress_;
    }
    /**
     * <pre>
     *An optional address to send funds to in the case of a cooperative close.
     *If the channel was opened with an upfront shutdown script and this field
     *is set, the request to close will fail because the channel must pay out
     *to the upfront shutdown addresss.
     * </pre>
     *
     * <code>string delivery_address = 5;</code>
     * @return The bytes for deliveryAddress.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDeliveryAddressBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(deliveryAddress_);
    }
    /**
     * <pre>
     *An optional address to send funds to in the case of a cooperative close.
     *If the channel was opened with an upfront shutdown script and this field
     *is set, the request to close will fail because the channel must pay out
     *to the upfront shutdown addresss.
     * </pre>
     *
     * <code>string delivery_address = 5;</code>
     * @param value The deliveryAddress to set.
     */
    private void setDeliveryAddress(
        java.lang.String value) {
      value.getClass();
  
      deliveryAddress_ = value;
    }
    /**
     * <pre>
     *An optional address to send funds to in the case of a cooperative close.
     *If the channel was opened with an upfront shutdown script and this field
     *is set, the request to close will fail because the channel must pay out
     *to the upfront shutdown addresss.
     * </pre>
     *
     * <code>string delivery_address = 5;</code>
     */
    private void clearDeliveryAddress() {
      
      deliveryAddress_ = getDefaultInstance().getDeliveryAddress();
    }
    /**
     * <pre>
     *An optional address to send funds to in the case of a cooperative close.
     *If the channel was opened with an upfront shutdown script and this field
     *is set, the request to close will fail because the channel must pay out
     *to the upfront shutdown addresss.
     * </pre>
     *
     * <code>string delivery_address = 5;</code>
     * @param value The bytes for deliveryAddress to set.
     */
    private void setDeliveryAddressBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      deliveryAddress_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.CloseChannelRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.CloseChannelRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.CloseChannelRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.CloseChannelRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.CloseChannelRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.CloseChannelRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.CloseChannelRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.CloseChannelRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.CloseChannelRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.CloseChannelRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.CloseChannelRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.CloseChannelRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.CloseChannelRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.CloseChannelRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.CloseChannelRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.CloseChannelRequest)
        co.anode.anodium.Rpc.CloseChannelRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.CloseChannelRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The outpoint (txid:index) of the funding transaction. With this value, Bob
       *will be able to generate a signature for Alice's version of the commitment
       *transaction.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
       */
      @java.lang.Override
      public boolean hasChannelPoint() {
        return instance.hasChannelPoint();
      }
      /**
       * <pre>
       *The outpoint (txid:index) of the funding transaction. With this value, Bob
       *will be able to generate a signature for Alice's version of the commitment
       *transaction.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelPoint getChannelPoint() {
        return instance.getChannelPoint();
      }
      /**
       * <pre>
       *The outpoint (txid:index) of the funding transaction. With this value, Bob
       *will be able to generate a signature for Alice's version of the commitment
       *transaction.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
       */
      public Builder setChannelPoint(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.setChannelPoint(value);
        return this;
        }
      /**
       * <pre>
       *The outpoint (txid:index) of the funding transaction. With this value, Bob
       *will be able to generate a signature for Alice's version of the commitment
       *transaction.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
       */
      public Builder setChannelPoint(
          co.anode.anodium.Rpc.ChannelPoint.Builder builderForValue) {
        copyOnWrite();
        instance.setChannelPoint(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *The outpoint (txid:index) of the funding transaction. With this value, Bob
       *will be able to generate a signature for Alice's version of the commitment
       *transaction.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
       */
      public Builder mergeChannelPoint(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.mergeChannelPoint(value);
        return this;
      }
      /**
       * <pre>
       *The outpoint (txid:index) of the funding transaction. With this value, Bob
       *will be able to generate a signature for Alice's version of the commitment
       *transaction.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
       */
      public Builder clearChannelPoint() {  copyOnWrite();
        instance.clearChannelPoint();
        return this;
      }

      /**
       * <pre>
       * If true, then the channel will be closed forcibly. This means the
       * current commitment transaction will be signed and broadcast.
       * </pre>
       *
       * <code>bool force = 2;</code>
       * @return The force.
       */
      @java.lang.Override
      public boolean getForce() {
        return instance.getForce();
      }
      /**
       * <pre>
       * If true, then the channel will be closed forcibly. This means the
       * current commitment transaction will be signed and broadcast.
       * </pre>
       *
       * <code>bool force = 2;</code>
       * @param value The force to set.
       * @return This builder for chaining.
       */
      public Builder setForce(boolean value) {
        copyOnWrite();
        instance.setForce(value);
        return this;
      }
      /**
       * <pre>
       * If true, then the channel will be closed forcibly. This means the
       * current commitment transaction will be signed and broadcast.
       * </pre>
       *
       * <code>bool force = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearForce() {
        copyOnWrite();
        instance.clearForce();
        return this;
      }

      /**
       * <pre>
       * The target number of blocks that the closure transaction should be
       * confirmed by.
       * </pre>
       *
       * <code>int32 target_conf = 3;</code>
       * @return The targetConf.
       */
      @java.lang.Override
      public int getTargetConf() {
        return instance.getTargetConf();
      }
      /**
       * <pre>
       * The target number of blocks that the closure transaction should be
       * confirmed by.
       * </pre>
       *
       * <code>int32 target_conf = 3;</code>
       * @param value The targetConf to set.
       * @return This builder for chaining.
       */
      public Builder setTargetConf(int value) {
        copyOnWrite();
        instance.setTargetConf(value);
        return this;
      }
      /**
       * <pre>
       * The target number of blocks that the closure transaction should be
       * confirmed by.
       * </pre>
       *
       * <code>int32 target_conf = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearTargetConf() {
        copyOnWrite();
        instance.clearTargetConf();
        return this;
      }

      /**
       * <pre>
       * A manual fee rate set in sat/byte that should be used when crafting the
       * closure transaction.
       * </pre>
       *
       * <code>int64 sat_per_byte = 4;</code>
       * @return The satPerByte.
       */
      @java.lang.Override
      public long getSatPerByte() {
        return instance.getSatPerByte();
      }
      /**
       * <pre>
       * A manual fee rate set in sat/byte that should be used when crafting the
       * closure transaction.
       * </pre>
       *
       * <code>int64 sat_per_byte = 4;</code>
       * @param value The satPerByte to set.
       * @return This builder for chaining.
       */
      public Builder setSatPerByte(long value) {
        copyOnWrite();
        instance.setSatPerByte(value);
        return this;
      }
      /**
       * <pre>
       * A manual fee rate set in sat/byte that should be used when crafting the
       * closure transaction.
       * </pre>
       *
       * <code>int64 sat_per_byte = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearSatPerByte() {
        copyOnWrite();
        instance.clearSatPerByte();
        return this;
      }

      /**
       * <pre>
       *An optional address to send funds to in the case of a cooperative close.
       *If the channel was opened with an upfront shutdown script and this field
       *is set, the request to close will fail because the channel must pay out
       *to the upfront shutdown addresss.
       * </pre>
       *
       * <code>string delivery_address = 5;</code>
       * @return The deliveryAddress.
       */
      @java.lang.Override
      public java.lang.String getDeliveryAddress() {
        return instance.getDeliveryAddress();
      }
      /**
       * <pre>
       *An optional address to send funds to in the case of a cooperative close.
       *If the channel was opened with an upfront shutdown script and this field
       *is set, the request to close will fail because the channel must pay out
       *to the upfront shutdown addresss.
       * </pre>
       *
       * <code>string delivery_address = 5;</code>
       * @return The bytes for deliveryAddress.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getDeliveryAddressBytes() {
        return instance.getDeliveryAddressBytes();
      }
      /**
       * <pre>
       *An optional address to send funds to in the case of a cooperative close.
       *If the channel was opened with an upfront shutdown script and this field
       *is set, the request to close will fail because the channel must pay out
       *to the upfront shutdown addresss.
       * </pre>
       *
       * <code>string delivery_address = 5;</code>
       * @param value The deliveryAddress to set.
       * @return This builder for chaining.
       */
      public Builder setDeliveryAddress(
          java.lang.String value) {
        copyOnWrite();
        instance.setDeliveryAddress(value);
        return this;
      }
      /**
       * <pre>
       *An optional address to send funds to in the case of a cooperative close.
       *If the channel was opened with an upfront shutdown script and this field
       *is set, the request to close will fail because the channel must pay out
       *to the upfront shutdown addresss.
       * </pre>
       *
       * <code>string delivery_address = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeliveryAddress() {
        copyOnWrite();
        instance.clearDeliveryAddress();
        return this;
      }
      /**
       * <pre>
       *An optional address to send funds to in the case of a cooperative close.
       *If the channel was opened with an upfront shutdown script and this field
       *is set, the request to close will fail because the channel must pay out
       *to the upfront shutdown addresss.
       * </pre>
       *
       * <code>string delivery_address = 5;</code>
       * @param value The bytes for deliveryAddress to set.
       * @return This builder for chaining.
       */
      public Builder setDeliveryAddressBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setDeliveryAddressBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.CloseChannelRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.CloseChannelRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "channelPoint_",
              "force_",
              "targetConf_",
              "satPerByte_",
              "deliveryAddress_",
            };
            java.lang.String info =
                "\u0000\u0005\u0000\u0000\u0001\u0005\u0005\u0000\u0000\u0000\u0001\t\u0002\u0007" +
                "\u0003\u0004\u0004\u0002\u0005\u0208";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.CloseChannelRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.CloseChannelRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.CloseChannelRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.CloseChannelRequest)
    private static final co.anode.anodium.Rpc.CloseChannelRequest DEFAULT_INSTANCE;
    static {
      CloseChannelRequest defaultInstance = new CloseChannelRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        CloseChannelRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.CloseChannelRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<CloseChannelRequest> PARSER;

    public static com.google.protobuf.Parser<CloseChannelRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface CloseStatusUpdateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.CloseStatusUpdate)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>.co.anode.anodium.PendingUpdate close_pending = 1;</code>
     * @return Whether the closePending field is set.
     */
    boolean hasClosePending();
    /**
     * <code>.co.anode.anodium.PendingUpdate close_pending = 1;</code>
     * @return The closePending.
     */
    co.anode.anodium.Rpc.PendingUpdate getClosePending();

    /**
     * <code>.co.anode.anodium.ChannelCloseUpdate chan_close = 3;</code>
     * @return Whether the chanClose field is set.
     */
    boolean hasChanClose();
    /**
     * <code>.co.anode.anodium.ChannelCloseUpdate chan_close = 3;</code>
     * @return The chanClose.
     */
    co.anode.anodium.Rpc.ChannelCloseUpdate getChanClose();

    public co.anode.anodium.Rpc.CloseStatusUpdate.UpdateCase getUpdateCase();
  }
  /**
   * Protobuf type {@code co.anode.anodium.CloseStatusUpdate}
   */
  public  static final class CloseStatusUpdate extends
      com.google.protobuf.GeneratedMessageLite<
          CloseStatusUpdate, CloseStatusUpdate.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.CloseStatusUpdate)
      CloseStatusUpdateOrBuilder {
    private CloseStatusUpdate() {
    }
    private int updateCase_ = 0;
    private java.lang.Object update_;
    public enum UpdateCase {
      CLOSE_PENDING(1),
      CHAN_CLOSE(3),
      UPDATE_NOT_SET(0);
      private final int value;
      private UpdateCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static UpdateCase valueOf(int value) {
        return forNumber(value);
      }

      public static UpdateCase forNumber(int value) {
        switch (value) {
          case 1: return CLOSE_PENDING;
          case 3: return CHAN_CLOSE;
          case 0: return UPDATE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    @java.lang.Override
    public UpdateCase
    getUpdateCase() {
      return UpdateCase.forNumber(
          updateCase_);
    }

    private void clearUpdate() {
      updateCase_ = 0;
      update_ = null;
    }

    public static final int CLOSE_PENDING_FIELD_NUMBER = 1;
    /**
     * <code>.co.anode.anodium.PendingUpdate close_pending = 1;</code>
     */
    @java.lang.Override
    public boolean hasClosePending() {
      return updateCase_ == 1;
    }
    /**
     * <code>.co.anode.anodium.PendingUpdate close_pending = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.PendingUpdate getClosePending() {
      if (updateCase_ == 1) {
         return (co.anode.anodium.Rpc.PendingUpdate) update_;
      }
      return co.anode.anodium.Rpc.PendingUpdate.getDefaultInstance();
    }
    /**
     * <code>.co.anode.anodium.PendingUpdate close_pending = 1;</code>
     */
    private void setClosePending(co.anode.anodium.Rpc.PendingUpdate value) {
      value.getClass();
  update_ = value;
      updateCase_ = 1;
    }
    /**
     * <code>.co.anode.anodium.PendingUpdate close_pending = 1;</code>
     */
    private void mergeClosePending(co.anode.anodium.Rpc.PendingUpdate value) {
      value.getClass();
  if (updateCase_ == 1 &&
          update_ != co.anode.anodium.Rpc.PendingUpdate.getDefaultInstance()) {
        update_ = co.anode.anodium.Rpc.PendingUpdate.newBuilder((co.anode.anodium.Rpc.PendingUpdate) update_)
            .mergeFrom(value).buildPartial();
      } else {
        update_ = value;
      }
      updateCase_ = 1;
    }
    /**
     * <code>.co.anode.anodium.PendingUpdate close_pending = 1;</code>
     */
    private void clearClosePending() {
      if (updateCase_ == 1) {
        updateCase_ = 0;
        update_ = null;
      }
    }

    public static final int CHAN_CLOSE_FIELD_NUMBER = 3;
    /**
     * <code>.co.anode.anodium.ChannelCloseUpdate chan_close = 3;</code>
     */
    @java.lang.Override
    public boolean hasChanClose() {
      return updateCase_ == 3;
    }
    /**
     * <code>.co.anode.anodium.ChannelCloseUpdate chan_close = 3;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelCloseUpdate getChanClose() {
      if (updateCase_ == 3) {
         return (co.anode.anodium.Rpc.ChannelCloseUpdate) update_;
      }
      return co.anode.anodium.Rpc.ChannelCloseUpdate.getDefaultInstance();
    }
    /**
     * <code>.co.anode.anodium.ChannelCloseUpdate chan_close = 3;</code>
     */
    private void setChanClose(co.anode.anodium.Rpc.ChannelCloseUpdate value) {
      value.getClass();
  update_ = value;
      updateCase_ = 3;
    }
    /**
     * <code>.co.anode.anodium.ChannelCloseUpdate chan_close = 3;</code>
     */
    private void mergeChanClose(co.anode.anodium.Rpc.ChannelCloseUpdate value) {
      value.getClass();
  if (updateCase_ == 3 &&
          update_ != co.anode.anodium.Rpc.ChannelCloseUpdate.getDefaultInstance()) {
        update_ = co.anode.anodium.Rpc.ChannelCloseUpdate.newBuilder((co.anode.anodium.Rpc.ChannelCloseUpdate) update_)
            .mergeFrom(value).buildPartial();
      } else {
        update_ = value;
      }
      updateCase_ = 3;
    }
    /**
     * <code>.co.anode.anodium.ChannelCloseUpdate chan_close = 3;</code>
     */
    private void clearChanClose() {
      if (updateCase_ == 3) {
        updateCase_ = 0;
        update_ = null;
      }
    }

    public static co.anode.anodium.Rpc.CloseStatusUpdate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.CloseStatusUpdate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.CloseStatusUpdate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.CloseStatusUpdate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.CloseStatusUpdate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.CloseStatusUpdate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.CloseStatusUpdate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.CloseStatusUpdate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.CloseStatusUpdate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.CloseStatusUpdate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.CloseStatusUpdate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.CloseStatusUpdate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.CloseStatusUpdate prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.CloseStatusUpdate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.CloseStatusUpdate, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.CloseStatusUpdate)
        co.anode.anodium.Rpc.CloseStatusUpdateOrBuilder {
      // Construct using co.anode.anodium.Rpc.CloseStatusUpdate.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }

      @java.lang.Override
      public UpdateCase
          getUpdateCase() {
        return instance.getUpdateCase();
      }

      public Builder clearUpdate() {
        copyOnWrite();
        instance.clearUpdate();
        return this;
      }


      /**
       * <code>.co.anode.anodium.PendingUpdate close_pending = 1;</code>
       */
      @java.lang.Override
      public boolean hasClosePending() {
        return instance.hasClosePending();
      }
      /**
       * <code>.co.anode.anodium.PendingUpdate close_pending = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.PendingUpdate getClosePending() {
        return instance.getClosePending();
      }
      /**
       * <code>.co.anode.anodium.PendingUpdate close_pending = 1;</code>
       */
      public Builder setClosePending(co.anode.anodium.Rpc.PendingUpdate value) {
        copyOnWrite();
        instance.setClosePending(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.PendingUpdate close_pending = 1;</code>
       */
      public Builder setClosePending(
          co.anode.anodium.Rpc.PendingUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.setClosePending(builderForValue.build());
        return this;
      }
      /**
       * <code>.co.anode.anodium.PendingUpdate close_pending = 1;</code>
       */
      public Builder mergeClosePending(co.anode.anodium.Rpc.PendingUpdate value) {
        copyOnWrite();
        instance.mergeClosePending(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.PendingUpdate close_pending = 1;</code>
       */
      public Builder clearClosePending() {
        copyOnWrite();
        instance.clearClosePending();
        return this;
      }

      /**
       * <code>.co.anode.anodium.ChannelCloseUpdate chan_close = 3;</code>
       */
      @java.lang.Override
      public boolean hasChanClose() {
        return instance.hasChanClose();
      }
      /**
       * <code>.co.anode.anodium.ChannelCloseUpdate chan_close = 3;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelCloseUpdate getChanClose() {
        return instance.getChanClose();
      }
      /**
       * <code>.co.anode.anodium.ChannelCloseUpdate chan_close = 3;</code>
       */
      public Builder setChanClose(co.anode.anodium.Rpc.ChannelCloseUpdate value) {
        copyOnWrite();
        instance.setChanClose(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelCloseUpdate chan_close = 3;</code>
       */
      public Builder setChanClose(
          co.anode.anodium.Rpc.ChannelCloseUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.setChanClose(builderForValue.build());
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelCloseUpdate chan_close = 3;</code>
       */
      public Builder mergeChanClose(co.anode.anodium.Rpc.ChannelCloseUpdate value) {
        copyOnWrite();
        instance.mergeChanClose(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelCloseUpdate chan_close = 3;</code>
       */
      public Builder clearChanClose() {
        copyOnWrite();
        instance.clearChanClose();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.CloseStatusUpdate)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.CloseStatusUpdate();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "update_",
              "updateCase_",
              co.anode.anodium.Rpc.PendingUpdate.class,
              co.anode.anodium.Rpc.ChannelCloseUpdate.class,
            };
            java.lang.String info =
                "\u0000\u0002\u0001\u0000\u0001\u0003\u0002\u0000\u0000\u0000\u0001<\u0000\u0003<" +
                "\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.CloseStatusUpdate> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.CloseStatusUpdate.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.CloseStatusUpdate>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.CloseStatusUpdate)
    private static final co.anode.anodium.Rpc.CloseStatusUpdate DEFAULT_INSTANCE;
    static {
      CloseStatusUpdate defaultInstance = new CloseStatusUpdate();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        CloseStatusUpdate.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.CloseStatusUpdate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<CloseStatusUpdate> PARSER;

    public static com.google.protobuf.Parser<CloseStatusUpdate> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PendingUpdateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.PendingUpdate)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>bytes txid = 1;</code>
     * @return The txid.
     */
    com.google.protobuf.ByteString getTxid();

    /**
     * <code>uint32 output_index = 2;</code>
     * @return The outputIndex.
     */
    int getOutputIndex();
  }
  /**
   * Protobuf type {@code co.anode.anodium.PendingUpdate}
   */
  public  static final class PendingUpdate extends
      com.google.protobuf.GeneratedMessageLite<
          PendingUpdate, PendingUpdate.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.PendingUpdate)
      PendingUpdateOrBuilder {
    private PendingUpdate() {
      txid_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int TXID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString txid_;
    /**
     * <code>bytes txid = 1;</code>
     * @return The txid.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getTxid() {
      return txid_;
    }
    /**
     * <code>bytes txid = 1;</code>
     * @param value The txid to set.
     */
    private void setTxid(com.google.protobuf.ByteString value) {
      value.getClass();
  
      txid_ = value;
    }
    /**
     * <code>bytes txid = 1;</code>
     */
    private void clearTxid() {
      
      txid_ = getDefaultInstance().getTxid();
    }

    public static final int OUTPUT_INDEX_FIELD_NUMBER = 2;
    private int outputIndex_;
    /**
     * <code>uint32 output_index = 2;</code>
     * @return The outputIndex.
     */
    @java.lang.Override
    public int getOutputIndex() {
      return outputIndex_;
    }
    /**
     * <code>uint32 output_index = 2;</code>
     * @param value The outputIndex to set.
     */
    private void setOutputIndex(int value) {
      
      outputIndex_ = value;
    }
    /**
     * <code>uint32 output_index = 2;</code>
     */
    private void clearOutputIndex() {
      
      outputIndex_ = 0;
    }

    public static co.anode.anodium.Rpc.PendingUpdate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PendingUpdate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingUpdate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PendingUpdate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingUpdate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PendingUpdate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingUpdate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PendingUpdate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingUpdate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PendingUpdate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingUpdate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PendingUpdate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.PendingUpdate prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.PendingUpdate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.PendingUpdate, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.PendingUpdate)
        co.anode.anodium.Rpc.PendingUpdateOrBuilder {
      // Construct using co.anode.anodium.Rpc.PendingUpdate.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>bytes txid = 1;</code>
       * @return The txid.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getTxid() {
        return instance.getTxid();
      }
      /**
       * <code>bytes txid = 1;</code>
       * @param value The txid to set.
       * @return This builder for chaining.
       */
      public Builder setTxid(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTxid(value);
        return this;
      }
      /**
       * <code>bytes txid = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTxid() {
        copyOnWrite();
        instance.clearTxid();
        return this;
      }

      /**
       * <code>uint32 output_index = 2;</code>
       * @return The outputIndex.
       */
      @java.lang.Override
      public int getOutputIndex() {
        return instance.getOutputIndex();
      }
      /**
       * <code>uint32 output_index = 2;</code>
       * @param value The outputIndex to set.
       * @return This builder for chaining.
       */
      public Builder setOutputIndex(int value) {
        copyOnWrite();
        instance.setOutputIndex(value);
        return this;
      }
      /**
       * <code>uint32 output_index = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearOutputIndex() {
        copyOnWrite();
        instance.clearOutputIndex();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.PendingUpdate)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.PendingUpdate();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "txid_",
              "outputIndex_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\n\u0002\u000b" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.PendingUpdate> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.PendingUpdate.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.PendingUpdate>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.PendingUpdate)
    private static final co.anode.anodium.Rpc.PendingUpdate DEFAULT_INSTANCE;
    static {
      PendingUpdate defaultInstance = new PendingUpdate();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        PendingUpdate.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.PendingUpdate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<PendingUpdate> PARSER;

    public static com.google.protobuf.Parser<PendingUpdate> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ReadyForPsbtFundingOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ReadyForPsbtFunding)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The P2WSH address of the channel funding multisig address that the below
     *specified amount in satoshis needs to be sent to.
     * </pre>
     *
     * <code>string funding_address = 1;</code>
     * @return The fundingAddress.
     */
    java.lang.String getFundingAddress();
    /**
     * <pre>
     *The P2WSH address of the channel funding multisig address that the below
     *specified amount in satoshis needs to be sent to.
     * </pre>
     *
     * <code>string funding_address = 1;</code>
     * @return The bytes for fundingAddress.
     */
    com.google.protobuf.ByteString
        getFundingAddressBytes();

    /**
     * <pre>
     *The exact amount in satoshis that needs to be sent to the above address to
     *fund the pending channel.
     * </pre>
     *
     * <code>int64 funding_amount = 2;</code>
     * @return The fundingAmount.
     */
    long getFundingAmount();

    /**
     * <pre>
     *A raw PSBT that contains the pending channel output. If a base PSBT was
     *provided in the PsbtShim, this is the base PSBT with one additional output.
     *If no base PSBT was specified, this is an otherwise empty PSBT with exactly
     *one output.
     * </pre>
     *
     * <code>bytes psbt = 3;</code>
     * @return The psbt.
     */
    com.google.protobuf.ByteString getPsbt();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ReadyForPsbtFunding}
   */
  public  static final class ReadyForPsbtFunding extends
      com.google.protobuf.GeneratedMessageLite<
          ReadyForPsbtFunding, ReadyForPsbtFunding.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ReadyForPsbtFunding)
      ReadyForPsbtFundingOrBuilder {
    private ReadyForPsbtFunding() {
      fundingAddress_ = "";
      psbt_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int FUNDING_ADDRESS_FIELD_NUMBER = 1;
    private java.lang.String fundingAddress_;
    /**
     * <pre>
     *The P2WSH address of the channel funding multisig address that the below
     *specified amount in satoshis needs to be sent to.
     * </pre>
     *
     * <code>string funding_address = 1;</code>
     * @return The fundingAddress.
     */
    @java.lang.Override
    public java.lang.String getFundingAddress() {
      return fundingAddress_;
    }
    /**
     * <pre>
     *The P2WSH address of the channel funding multisig address that the below
     *specified amount in satoshis needs to be sent to.
     * </pre>
     *
     * <code>string funding_address = 1;</code>
     * @return The bytes for fundingAddress.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFundingAddressBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(fundingAddress_);
    }
    /**
     * <pre>
     *The P2WSH address of the channel funding multisig address that the below
     *specified amount in satoshis needs to be sent to.
     * </pre>
     *
     * <code>string funding_address = 1;</code>
     * @param value The fundingAddress to set.
     */
    private void setFundingAddress(
        java.lang.String value) {
      value.getClass();
  
      fundingAddress_ = value;
    }
    /**
     * <pre>
     *The P2WSH address of the channel funding multisig address that the below
     *specified amount in satoshis needs to be sent to.
     * </pre>
     *
     * <code>string funding_address = 1;</code>
     */
    private void clearFundingAddress() {
      
      fundingAddress_ = getDefaultInstance().getFundingAddress();
    }
    /**
     * <pre>
     *The P2WSH address of the channel funding multisig address that the below
     *specified amount in satoshis needs to be sent to.
     * </pre>
     *
     * <code>string funding_address = 1;</code>
     * @param value The bytes for fundingAddress to set.
     */
    private void setFundingAddressBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      fundingAddress_ = value.toStringUtf8();
      
    }

    public static final int FUNDING_AMOUNT_FIELD_NUMBER = 2;
    private long fundingAmount_;
    /**
     * <pre>
     *The exact amount in satoshis that needs to be sent to the above address to
     *fund the pending channel.
     * </pre>
     *
     * <code>int64 funding_amount = 2;</code>
     * @return The fundingAmount.
     */
    @java.lang.Override
    public long getFundingAmount() {
      return fundingAmount_;
    }
    /**
     * <pre>
     *The exact amount in satoshis that needs to be sent to the above address to
     *fund the pending channel.
     * </pre>
     *
     * <code>int64 funding_amount = 2;</code>
     * @param value The fundingAmount to set.
     */
    private void setFundingAmount(long value) {
      
      fundingAmount_ = value;
    }
    /**
     * <pre>
     *The exact amount in satoshis that needs to be sent to the above address to
     *fund the pending channel.
     * </pre>
     *
     * <code>int64 funding_amount = 2;</code>
     */
    private void clearFundingAmount() {
      
      fundingAmount_ = 0L;
    }

    public static final int PSBT_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString psbt_;
    /**
     * <pre>
     *A raw PSBT that contains the pending channel output. If a base PSBT was
     *provided in the PsbtShim, this is the base PSBT with one additional output.
     *If no base PSBT was specified, this is an otherwise empty PSBT with exactly
     *one output.
     * </pre>
     *
     * <code>bytes psbt = 3;</code>
     * @return The psbt.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPsbt() {
      return psbt_;
    }
    /**
     * <pre>
     *A raw PSBT that contains the pending channel output. If a base PSBT was
     *provided in the PsbtShim, this is the base PSBT with one additional output.
     *If no base PSBT was specified, this is an otherwise empty PSBT with exactly
     *one output.
     * </pre>
     *
     * <code>bytes psbt = 3;</code>
     * @param value The psbt to set.
     */
    private void setPsbt(com.google.protobuf.ByteString value) {
      value.getClass();
  
      psbt_ = value;
    }
    /**
     * <pre>
     *A raw PSBT that contains the pending channel output. If a base PSBT was
     *provided in the PsbtShim, this is the base PSBT with one additional output.
     *If no base PSBT was specified, this is an otherwise empty PSBT with exactly
     *one output.
     * </pre>
     *
     * <code>bytes psbt = 3;</code>
     */
    private void clearPsbt() {
      
      psbt_ = getDefaultInstance().getPsbt();
    }

    public static co.anode.anodium.Rpc.ReadyForPsbtFunding parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ReadyForPsbtFunding parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ReadyForPsbtFunding parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ReadyForPsbtFunding parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ReadyForPsbtFunding parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ReadyForPsbtFunding parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ReadyForPsbtFunding parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ReadyForPsbtFunding parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ReadyForPsbtFunding parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ReadyForPsbtFunding parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ReadyForPsbtFunding parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ReadyForPsbtFunding parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ReadyForPsbtFunding prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ReadyForPsbtFunding}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ReadyForPsbtFunding, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ReadyForPsbtFunding)
        co.anode.anodium.Rpc.ReadyForPsbtFundingOrBuilder {
      // Construct using co.anode.anodium.Rpc.ReadyForPsbtFunding.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The P2WSH address of the channel funding multisig address that the below
       *specified amount in satoshis needs to be sent to.
       * </pre>
       *
       * <code>string funding_address = 1;</code>
       * @return The fundingAddress.
       */
      @java.lang.Override
      public java.lang.String getFundingAddress() {
        return instance.getFundingAddress();
      }
      /**
       * <pre>
       *The P2WSH address of the channel funding multisig address that the below
       *specified amount in satoshis needs to be sent to.
       * </pre>
       *
       * <code>string funding_address = 1;</code>
       * @return The bytes for fundingAddress.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getFundingAddressBytes() {
        return instance.getFundingAddressBytes();
      }
      /**
       * <pre>
       *The P2WSH address of the channel funding multisig address that the below
       *specified amount in satoshis needs to be sent to.
       * </pre>
       *
       * <code>string funding_address = 1;</code>
       * @param value The fundingAddress to set.
       * @return This builder for chaining.
       */
      public Builder setFundingAddress(
          java.lang.String value) {
        copyOnWrite();
        instance.setFundingAddress(value);
        return this;
      }
      /**
       * <pre>
       *The P2WSH address of the channel funding multisig address that the below
       *specified amount in satoshis needs to be sent to.
       * </pre>
       *
       * <code>string funding_address = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearFundingAddress() {
        copyOnWrite();
        instance.clearFundingAddress();
        return this;
      }
      /**
       * <pre>
       *The P2WSH address of the channel funding multisig address that the below
       *specified amount in satoshis needs to be sent to.
       * </pre>
       *
       * <code>string funding_address = 1;</code>
       * @param value The bytes for fundingAddress to set.
       * @return This builder for chaining.
       */
      public Builder setFundingAddressBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setFundingAddressBytes(value);
        return this;
      }

      /**
       * <pre>
       *The exact amount in satoshis that needs to be sent to the above address to
       *fund the pending channel.
       * </pre>
       *
       * <code>int64 funding_amount = 2;</code>
       * @return The fundingAmount.
       */
      @java.lang.Override
      public long getFundingAmount() {
        return instance.getFundingAmount();
      }
      /**
       * <pre>
       *The exact amount in satoshis that needs to be sent to the above address to
       *fund the pending channel.
       * </pre>
       *
       * <code>int64 funding_amount = 2;</code>
       * @param value The fundingAmount to set.
       * @return This builder for chaining.
       */
      public Builder setFundingAmount(long value) {
        copyOnWrite();
        instance.setFundingAmount(value);
        return this;
      }
      /**
       * <pre>
       *The exact amount in satoshis that needs to be sent to the above address to
       *fund the pending channel.
       * </pre>
       *
       * <code>int64 funding_amount = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearFundingAmount() {
        copyOnWrite();
        instance.clearFundingAmount();
        return this;
      }

      /**
       * <pre>
       *A raw PSBT that contains the pending channel output. If a base PSBT was
       *provided in the PsbtShim, this is the base PSBT with one additional output.
       *If no base PSBT was specified, this is an otherwise empty PSBT with exactly
       *one output.
       * </pre>
       *
       * <code>bytes psbt = 3;</code>
       * @return The psbt.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPsbt() {
        return instance.getPsbt();
      }
      /**
       * <pre>
       *A raw PSBT that contains the pending channel output. If a base PSBT was
       *provided in the PsbtShim, this is the base PSBT with one additional output.
       *If no base PSBT was specified, this is an otherwise empty PSBT with exactly
       *one output.
       * </pre>
       *
       * <code>bytes psbt = 3;</code>
       * @param value The psbt to set.
       * @return This builder for chaining.
       */
      public Builder setPsbt(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPsbt(value);
        return this;
      }
      /**
       * <pre>
       *A raw PSBT that contains the pending channel output. If a base PSBT was
       *provided in the PsbtShim, this is the base PSBT with one additional output.
       *If no base PSBT was specified, this is an otherwise empty PSBT with exactly
       *one output.
       * </pre>
       *
       * <code>bytes psbt = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearPsbt() {
        copyOnWrite();
        instance.clearPsbt();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ReadyForPsbtFunding)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ReadyForPsbtFunding();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "fundingAddress_",
              "fundingAmount_",
              "psbt_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0003\u0003\u0000\u0000\u0000\u0001\u0208\u0002\u0002" +
                "\u0003\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ReadyForPsbtFunding> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ReadyForPsbtFunding.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ReadyForPsbtFunding>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ReadyForPsbtFunding)
    private static final co.anode.anodium.Rpc.ReadyForPsbtFunding DEFAULT_INSTANCE;
    static {
      ReadyForPsbtFunding defaultInstance = new ReadyForPsbtFunding();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ReadyForPsbtFunding.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ReadyForPsbtFunding getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ReadyForPsbtFunding> PARSER;

    public static com.google.protobuf.Parser<ReadyForPsbtFunding> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface OpenChannelRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.OpenChannelRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The pubkey of the node to open a channel with. When using REST, this field
     *must be encoded as base64.
     * </pre>
     *
     * <code>bytes node_pubkey = 2;</code>
     * @return The nodePubkey.
     */
    com.google.protobuf.ByteString getNodePubkey();

    /**
     * <pre>
     *The hex encoded pubkey of the node to open a channel with. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string node_pubkey_string = 3 [deprecated = true];</code>
     * @return The nodePubkeyString.
     */
    @java.lang.Deprecated java.lang.String getNodePubkeyString();
    /**
     * <pre>
     *The hex encoded pubkey of the node to open a channel with. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string node_pubkey_string = 3 [deprecated = true];</code>
     * @return The bytes for nodePubkeyString.
     */
    @java.lang.Deprecated com.google.protobuf.ByteString
        getNodePubkeyStringBytes();

    /**
     * <pre>
     * The number of satoshis the wallet should commit to the channel
     * </pre>
     *
     * <code>int64 local_funding_amount = 4;</code>
     * @return The localFundingAmount.
     */
    long getLocalFundingAmount();

    /**
     * <pre>
     * The number of satoshis to push to the remote side as part of the initial
     * commitment state
     * </pre>
     *
     * <code>int64 push_sat = 5;</code>
     * @return The pushSat.
     */
    long getPushSat();

    /**
     * <pre>
     * The target number of blocks that the funding transaction should be
     * confirmed by.
     * </pre>
     *
     * <code>int32 target_conf = 6;</code>
     * @return The targetConf.
     */
    int getTargetConf();

    /**
     * <pre>
     * A manual fee rate set in sat/byte that should be used when crafting the
     * funding transaction.
     * </pre>
     *
     * <code>int64 sat_per_byte = 7;</code>
     * @return The satPerByte.
     */
    long getSatPerByte();

    /**
     * <pre>
     * Whether this channel should be private, not announced to the greater
     * network.
     * </pre>
     *
     * <code>bool private = 8;</code>
     * @return The private.
     */
    boolean getPrivate();

    /**
     * <pre>
     * The minimum value in millisatoshi we will require for incoming HTLCs on
     * the channel.
     * </pre>
     *
     * <code>int64 min_htlc_msat = 9;</code>
     * @return The minHtlcMsat.
     */
    long getMinHtlcMsat();

    /**
     * <pre>
     * The delay we require on the remote's commitment transaction. If this is
     * not set, it will be scaled automatically with the channel size.
     * </pre>
     *
     * <code>uint32 remote_csv_delay = 10;</code>
     * @return The remoteCsvDelay.
     */
    int getRemoteCsvDelay();

    /**
     * <pre>
     * The minimum number of confirmations each one of your outputs used for
     * the funding transaction must satisfy.
     * </pre>
     *
     * <code>int32 min_confs = 11;</code>
     * @return The minConfs.
     */
    int getMinConfs();

    /**
     * <pre>
     * Whether unconfirmed outputs should be used as inputs for the funding
     * transaction.
     * </pre>
     *
     * <code>bool spend_unconfirmed = 12;</code>
     * @return The spendUnconfirmed.
     */
    boolean getSpendUnconfirmed();

    /**
     * <pre>
     *Close address is an optional address which specifies the address to which
     *funds should be paid out to upon cooperative close. This field may only be
     *set if the peer supports the option upfront feature bit (call listpeers
     *to check). The remote peer will only accept cooperative closes to this
     *address if it is set.
     *Note: If this value is set on channel creation, you will *not* be able to
     *cooperatively close out to a different address.
     * </pre>
     *
     * <code>string close_address = 13;</code>
     * @return The closeAddress.
     */
    java.lang.String getCloseAddress();
    /**
     * <pre>
     *Close address is an optional address which specifies the address to which
     *funds should be paid out to upon cooperative close. This field may only be
     *set if the peer supports the option upfront feature bit (call listpeers
     *to check). The remote peer will only accept cooperative closes to this
     *address if it is set.
     *Note: If this value is set on channel creation, you will *not* be able to
     *cooperatively close out to a different address.
     * </pre>
     *
     * <code>string close_address = 13;</code>
     * @return The bytes for closeAddress.
     */
    com.google.protobuf.ByteString
        getCloseAddressBytes();

    /**
     * <pre>
     *Funding shims are an optional argument that allow the caller to intercept
     *certain funding functionality. For example, a shim can be provided to use a
     *particular key for the commitment key (ideally cold) rather than use one
     *that is generated by the wallet as normal, or signal that signing will be
     *carried out in an interactive manner (PSBT based).
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShim funding_shim = 14;</code>
     * @return Whether the fundingShim field is set.
     */
    boolean hasFundingShim();
    /**
     * <pre>
     *Funding shims are an optional argument that allow the caller to intercept
     *certain funding functionality. For example, a shim can be provided to use a
     *particular key for the commitment key (ideally cold) rather than use one
     *that is generated by the wallet as normal, or signal that signing will be
     *carried out in an interactive manner (PSBT based).
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShim funding_shim = 14;</code>
     * @return The fundingShim.
     */
    co.anode.anodium.Rpc.FundingShim getFundingShim();

    /**
     * <pre>
     *The maximum amount of coins in millisatoshi that can be pending within
     *the channel. It only applies to the remote party.
     * </pre>
     *
     * <code>uint64 remote_max_value_in_flight_msat = 15;</code>
     * @return The remoteMaxValueInFlightMsat.
     */
    long getRemoteMaxValueInFlightMsat();

    /**
     * <pre>
     *The maximum number of concurrent HTLCs we will allow the remote party to add
     *to the commitment transaction.
     * </pre>
     *
     * <code>uint32 remote_max_htlcs = 16;</code>
     * @return The remoteMaxHtlcs.
     */
    int getRemoteMaxHtlcs();

    /**
     * <pre>
     *Max local csv is the maximum csv delay we will allow for our own commitment
     *transaction.
     * </pre>
     *
     * <code>uint32 max_local_csv = 17;</code>
     * @return The maxLocalCsv.
     */
    int getMaxLocalCsv();
  }
  /**
   * Protobuf type {@code co.anode.anodium.OpenChannelRequest}
   */
  public  static final class OpenChannelRequest extends
      com.google.protobuf.GeneratedMessageLite<
          OpenChannelRequest, OpenChannelRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.OpenChannelRequest)
      OpenChannelRequestOrBuilder {
    private OpenChannelRequest() {
      nodePubkey_ = com.google.protobuf.ByteString.EMPTY;
      nodePubkeyString_ = "";
      closeAddress_ = "";
    }
    public static final int NODE_PUBKEY_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString nodePubkey_;
    /**
     * <pre>
     *The pubkey of the node to open a channel with. When using REST, this field
     *must be encoded as base64.
     * </pre>
     *
     * <code>bytes node_pubkey = 2;</code>
     * @return The nodePubkey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getNodePubkey() {
      return nodePubkey_;
    }
    /**
     * <pre>
     *The pubkey of the node to open a channel with. When using REST, this field
     *must be encoded as base64.
     * </pre>
     *
     * <code>bytes node_pubkey = 2;</code>
     * @param value The nodePubkey to set.
     */
    private void setNodePubkey(com.google.protobuf.ByteString value) {
      value.getClass();
  
      nodePubkey_ = value;
    }
    /**
     * <pre>
     *The pubkey of the node to open a channel with. When using REST, this field
     *must be encoded as base64.
     * </pre>
     *
     * <code>bytes node_pubkey = 2;</code>
     */
    private void clearNodePubkey() {
      
      nodePubkey_ = getDefaultInstance().getNodePubkey();
    }

    public static final int NODE_PUBKEY_STRING_FIELD_NUMBER = 3;
    private java.lang.String nodePubkeyString_;
    /**
     * <pre>
     *The hex encoded pubkey of the node to open a channel with. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string node_pubkey_string = 3 [deprecated = true];</code>
     * @return The nodePubkeyString.
     */
    @java.lang.Override
    @java.lang.Deprecated public java.lang.String getNodePubkeyString() {
      return nodePubkeyString_;
    }
    /**
     * <pre>
     *The hex encoded pubkey of the node to open a channel with. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string node_pubkey_string = 3 [deprecated = true];</code>
     * @return The bytes for nodePubkeyString.
     */
    @java.lang.Override
    @java.lang.Deprecated public com.google.protobuf.ByteString
        getNodePubkeyStringBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(nodePubkeyString_);
    }
    /**
     * <pre>
     *The hex encoded pubkey of the node to open a channel with. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string node_pubkey_string = 3 [deprecated = true];</code>
     * @param value The nodePubkeyString to set.
     */
    private void setNodePubkeyString(
        java.lang.String value) {
      value.getClass();
  
      nodePubkeyString_ = value;
    }
    /**
     * <pre>
     *The hex encoded pubkey of the node to open a channel with. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string node_pubkey_string = 3 [deprecated = true];</code>
     */
    private void clearNodePubkeyString() {
      
      nodePubkeyString_ = getDefaultInstance().getNodePubkeyString();
    }
    /**
     * <pre>
     *The hex encoded pubkey of the node to open a channel with. Deprecated now
     *that the REST gateway supports base64 encoding of bytes fields.
     * </pre>
     *
     * <code>string node_pubkey_string = 3 [deprecated = true];</code>
     * @param value The bytes for nodePubkeyString to set.
     */
    private void setNodePubkeyStringBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      nodePubkeyString_ = value.toStringUtf8();
      
    }

    public static final int LOCAL_FUNDING_AMOUNT_FIELD_NUMBER = 4;
    private long localFundingAmount_;
    /**
     * <pre>
     * The number of satoshis the wallet should commit to the channel
     * </pre>
     *
     * <code>int64 local_funding_amount = 4;</code>
     * @return The localFundingAmount.
     */
    @java.lang.Override
    public long getLocalFundingAmount() {
      return localFundingAmount_;
    }
    /**
     * <pre>
     * The number of satoshis the wallet should commit to the channel
     * </pre>
     *
     * <code>int64 local_funding_amount = 4;</code>
     * @param value The localFundingAmount to set.
     */
    private void setLocalFundingAmount(long value) {
      
      localFundingAmount_ = value;
    }
    /**
     * <pre>
     * The number of satoshis the wallet should commit to the channel
     * </pre>
     *
     * <code>int64 local_funding_amount = 4;</code>
     */
    private void clearLocalFundingAmount() {
      
      localFundingAmount_ = 0L;
    }

    public static final int PUSH_SAT_FIELD_NUMBER = 5;
    private long pushSat_;
    /**
     * <pre>
     * The number of satoshis to push to the remote side as part of the initial
     * commitment state
     * </pre>
     *
     * <code>int64 push_sat = 5;</code>
     * @return The pushSat.
     */
    @java.lang.Override
    public long getPushSat() {
      return pushSat_;
    }
    /**
     * <pre>
     * The number of satoshis to push to the remote side as part of the initial
     * commitment state
     * </pre>
     *
     * <code>int64 push_sat = 5;</code>
     * @param value The pushSat to set.
     */
    private void setPushSat(long value) {
      
      pushSat_ = value;
    }
    /**
     * <pre>
     * The number of satoshis to push to the remote side as part of the initial
     * commitment state
     * </pre>
     *
     * <code>int64 push_sat = 5;</code>
     */
    private void clearPushSat() {
      
      pushSat_ = 0L;
    }

    public static final int TARGET_CONF_FIELD_NUMBER = 6;
    private int targetConf_;
    /**
     * <pre>
     * The target number of blocks that the funding transaction should be
     * confirmed by.
     * </pre>
     *
     * <code>int32 target_conf = 6;</code>
     * @return The targetConf.
     */
    @java.lang.Override
    public int getTargetConf() {
      return targetConf_;
    }
    /**
     * <pre>
     * The target number of blocks that the funding transaction should be
     * confirmed by.
     * </pre>
     *
     * <code>int32 target_conf = 6;</code>
     * @param value The targetConf to set.
     */
    private void setTargetConf(int value) {
      
      targetConf_ = value;
    }
    /**
     * <pre>
     * The target number of blocks that the funding transaction should be
     * confirmed by.
     * </pre>
     *
     * <code>int32 target_conf = 6;</code>
     */
    private void clearTargetConf() {
      
      targetConf_ = 0;
    }

    public static final int SAT_PER_BYTE_FIELD_NUMBER = 7;
    private long satPerByte_;
    /**
     * <pre>
     * A manual fee rate set in sat/byte that should be used when crafting the
     * funding transaction.
     * </pre>
     *
     * <code>int64 sat_per_byte = 7;</code>
     * @return The satPerByte.
     */
    @java.lang.Override
    public long getSatPerByte() {
      return satPerByte_;
    }
    /**
     * <pre>
     * A manual fee rate set in sat/byte that should be used when crafting the
     * funding transaction.
     * </pre>
     *
     * <code>int64 sat_per_byte = 7;</code>
     * @param value The satPerByte to set.
     */
    private void setSatPerByte(long value) {
      
      satPerByte_ = value;
    }
    /**
     * <pre>
     * A manual fee rate set in sat/byte that should be used when crafting the
     * funding transaction.
     * </pre>
     *
     * <code>int64 sat_per_byte = 7;</code>
     */
    private void clearSatPerByte() {
      
      satPerByte_ = 0L;
    }

    public static final int PRIVATE_FIELD_NUMBER = 8;
    private boolean private_;
    /**
     * <pre>
     * Whether this channel should be private, not announced to the greater
     * network.
     * </pre>
     *
     * <code>bool private = 8;</code>
     * @return The private.
     */
    @java.lang.Override
    public boolean getPrivate() {
      return private_;
    }
    /**
     * <pre>
     * Whether this channel should be private, not announced to the greater
     * network.
     * </pre>
     *
     * <code>bool private = 8;</code>
     * @param value The private to set.
     */
    private void setPrivate(boolean value) {
      
      private_ = value;
    }
    /**
     * <pre>
     * Whether this channel should be private, not announced to the greater
     * network.
     * </pre>
     *
     * <code>bool private = 8;</code>
     */
    private void clearPrivate() {
      
      private_ = false;
    }

    public static final int MIN_HTLC_MSAT_FIELD_NUMBER = 9;
    private long minHtlcMsat_;
    /**
     * <pre>
     * The minimum value in millisatoshi we will require for incoming HTLCs on
     * the channel.
     * </pre>
     *
     * <code>int64 min_htlc_msat = 9;</code>
     * @return The minHtlcMsat.
     */
    @java.lang.Override
    public long getMinHtlcMsat() {
      return minHtlcMsat_;
    }
    /**
     * <pre>
     * The minimum value in millisatoshi we will require for incoming HTLCs on
     * the channel.
     * </pre>
     *
     * <code>int64 min_htlc_msat = 9;</code>
     * @param value The minHtlcMsat to set.
     */
    private void setMinHtlcMsat(long value) {
      
      minHtlcMsat_ = value;
    }
    /**
     * <pre>
     * The minimum value in millisatoshi we will require for incoming HTLCs on
     * the channel.
     * </pre>
     *
     * <code>int64 min_htlc_msat = 9;</code>
     */
    private void clearMinHtlcMsat() {
      
      minHtlcMsat_ = 0L;
    }

    public static final int REMOTE_CSV_DELAY_FIELD_NUMBER = 10;
    private int remoteCsvDelay_;
    /**
     * <pre>
     * The delay we require on the remote's commitment transaction. If this is
     * not set, it will be scaled automatically with the channel size.
     * </pre>
     *
     * <code>uint32 remote_csv_delay = 10;</code>
     * @return The remoteCsvDelay.
     */
    @java.lang.Override
    public int getRemoteCsvDelay() {
      return remoteCsvDelay_;
    }
    /**
     * <pre>
     * The delay we require on the remote's commitment transaction. If this is
     * not set, it will be scaled automatically with the channel size.
     * </pre>
     *
     * <code>uint32 remote_csv_delay = 10;</code>
     * @param value The remoteCsvDelay to set.
     */
    private void setRemoteCsvDelay(int value) {
      
      remoteCsvDelay_ = value;
    }
    /**
     * <pre>
     * The delay we require on the remote's commitment transaction. If this is
     * not set, it will be scaled automatically with the channel size.
     * </pre>
     *
     * <code>uint32 remote_csv_delay = 10;</code>
     */
    private void clearRemoteCsvDelay() {
      
      remoteCsvDelay_ = 0;
    }

    public static final int MIN_CONFS_FIELD_NUMBER = 11;
    private int minConfs_;
    /**
     * <pre>
     * The minimum number of confirmations each one of your outputs used for
     * the funding transaction must satisfy.
     * </pre>
     *
     * <code>int32 min_confs = 11;</code>
     * @return The minConfs.
     */
    @java.lang.Override
    public int getMinConfs() {
      return minConfs_;
    }
    /**
     * <pre>
     * The minimum number of confirmations each one of your outputs used for
     * the funding transaction must satisfy.
     * </pre>
     *
     * <code>int32 min_confs = 11;</code>
     * @param value The minConfs to set.
     */
    private void setMinConfs(int value) {
      
      minConfs_ = value;
    }
    /**
     * <pre>
     * The minimum number of confirmations each one of your outputs used for
     * the funding transaction must satisfy.
     * </pre>
     *
     * <code>int32 min_confs = 11;</code>
     */
    private void clearMinConfs() {
      
      minConfs_ = 0;
    }

    public static final int SPEND_UNCONFIRMED_FIELD_NUMBER = 12;
    private boolean spendUnconfirmed_;
    /**
     * <pre>
     * Whether unconfirmed outputs should be used as inputs for the funding
     * transaction.
     * </pre>
     *
     * <code>bool spend_unconfirmed = 12;</code>
     * @return The spendUnconfirmed.
     */
    @java.lang.Override
    public boolean getSpendUnconfirmed() {
      return spendUnconfirmed_;
    }
    /**
     * <pre>
     * Whether unconfirmed outputs should be used as inputs for the funding
     * transaction.
     * </pre>
     *
     * <code>bool spend_unconfirmed = 12;</code>
     * @param value The spendUnconfirmed to set.
     */
    private void setSpendUnconfirmed(boolean value) {
      
      spendUnconfirmed_ = value;
    }
    /**
     * <pre>
     * Whether unconfirmed outputs should be used as inputs for the funding
     * transaction.
     * </pre>
     *
     * <code>bool spend_unconfirmed = 12;</code>
     */
    private void clearSpendUnconfirmed() {
      
      spendUnconfirmed_ = false;
    }

    public static final int CLOSE_ADDRESS_FIELD_NUMBER = 13;
    private java.lang.String closeAddress_;
    /**
     * <pre>
     *Close address is an optional address which specifies the address to which
     *funds should be paid out to upon cooperative close. This field may only be
     *set if the peer supports the option upfront feature bit (call listpeers
     *to check). The remote peer will only accept cooperative closes to this
     *address if it is set.
     *Note: If this value is set on channel creation, you will *not* be able to
     *cooperatively close out to a different address.
     * </pre>
     *
     * <code>string close_address = 13;</code>
     * @return The closeAddress.
     */
    @java.lang.Override
    public java.lang.String getCloseAddress() {
      return closeAddress_;
    }
    /**
     * <pre>
     *Close address is an optional address which specifies the address to which
     *funds should be paid out to upon cooperative close. This field may only be
     *set if the peer supports the option upfront feature bit (call listpeers
     *to check). The remote peer will only accept cooperative closes to this
     *address if it is set.
     *Note: If this value is set on channel creation, you will *not* be able to
     *cooperatively close out to a different address.
     * </pre>
     *
     * <code>string close_address = 13;</code>
     * @return The bytes for closeAddress.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getCloseAddressBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(closeAddress_);
    }
    /**
     * <pre>
     *Close address is an optional address which specifies the address to which
     *funds should be paid out to upon cooperative close. This field may only be
     *set if the peer supports the option upfront feature bit (call listpeers
     *to check). The remote peer will only accept cooperative closes to this
     *address if it is set.
     *Note: If this value is set on channel creation, you will *not* be able to
     *cooperatively close out to a different address.
     * </pre>
     *
     * <code>string close_address = 13;</code>
     * @param value The closeAddress to set.
     */
    private void setCloseAddress(
        java.lang.String value) {
      value.getClass();
  
      closeAddress_ = value;
    }
    /**
     * <pre>
     *Close address is an optional address which specifies the address to which
     *funds should be paid out to upon cooperative close. This field may only be
     *set if the peer supports the option upfront feature bit (call listpeers
     *to check). The remote peer will only accept cooperative closes to this
     *address if it is set.
     *Note: If this value is set on channel creation, you will *not* be able to
     *cooperatively close out to a different address.
     * </pre>
     *
     * <code>string close_address = 13;</code>
     */
    private void clearCloseAddress() {
      
      closeAddress_ = getDefaultInstance().getCloseAddress();
    }
    /**
     * <pre>
     *Close address is an optional address which specifies the address to which
     *funds should be paid out to upon cooperative close. This field may only be
     *set if the peer supports the option upfront feature bit (call listpeers
     *to check). The remote peer will only accept cooperative closes to this
     *address if it is set.
     *Note: If this value is set on channel creation, you will *not* be able to
     *cooperatively close out to a different address.
     * </pre>
     *
     * <code>string close_address = 13;</code>
     * @param value The bytes for closeAddress to set.
     */
    private void setCloseAddressBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      closeAddress_ = value.toStringUtf8();
      
    }

    public static final int FUNDING_SHIM_FIELD_NUMBER = 14;
    private co.anode.anodium.Rpc.FundingShim fundingShim_;
    /**
     * <pre>
     *Funding shims are an optional argument that allow the caller to intercept
     *certain funding functionality. For example, a shim can be provided to use a
     *particular key for the commitment key (ideally cold) rather than use one
     *that is generated by the wallet as normal, or signal that signing will be
     *carried out in an interactive manner (PSBT based).
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShim funding_shim = 14;</code>
     */
    @java.lang.Override
    public boolean hasFundingShim() {
      return fundingShim_ != null;
    }
    /**
     * <pre>
     *Funding shims are an optional argument that allow the caller to intercept
     *certain funding functionality. For example, a shim can be provided to use a
     *particular key for the commitment key (ideally cold) rather than use one
     *that is generated by the wallet as normal, or signal that signing will be
     *carried out in an interactive manner (PSBT based).
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShim funding_shim = 14;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.FundingShim getFundingShim() {
      return fundingShim_ == null ? co.anode.anodium.Rpc.FundingShim.getDefaultInstance() : fundingShim_;
    }
    /**
     * <pre>
     *Funding shims are an optional argument that allow the caller to intercept
     *certain funding functionality. For example, a shim can be provided to use a
     *particular key for the commitment key (ideally cold) rather than use one
     *that is generated by the wallet as normal, or signal that signing will be
     *carried out in an interactive manner (PSBT based).
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShim funding_shim = 14;</code>
     */
    private void setFundingShim(co.anode.anodium.Rpc.FundingShim value) {
      value.getClass();
  fundingShim_ = value;
      
      }
    /**
     * <pre>
     *Funding shims are an optional argument that allow the caller to intercept
     *certain funding functionality. For example, a shim can be provided to use a
     *particular key for the commitment key (ideally cold) rather than use one
     *that is generated by the wallet as normal, or signal that signing will be
     *carried out in an interactive manner (PSBT based).
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShim funding_shim = 14;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeFundingShim(co.anode.anodium.Rpc.FundingShim value) {
      value.getClass();
  if (fundingShim_ != null &&
          fundingShim_ != co.anode.anodium.Rpc.FundingShim.getDefaultInstance()) {
        fundingShim_ =
          co.anode.anodium.Rpc.FundingShim.newBuilder(fundingShim_).mergeFrom(value).buildPartial();
      } else {
        fundingShim_ = value;
      }
      
    }
    /**
     * <pre>
     *Funding shims are an optional argument that allow the caller to intercept
     *certain funding functionality. For example, a shim can be provided to use a
     *particular key for the commitment key (ideally cold) rather than use one
     *that is generated by the wallet as normal, or signal that signing will be
     *carried out in an interactive manner (PSBT based).
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShim funding_shim = 14;</code>
     */
    private void clearFundingShim() {  fundingShim_ = null;
      
    }

    public static final int REMOTE_MAX_VALUE_IN_FLIGHT_MSAT_FIELD_NUMBER = 15;
    private long remoteMaxValueInFlightMsat_;
    /**
     * <pre>
     *The maximum amount of coins in millisatoshi that can be pending within
     *the channel. It only applies to the remote party.
     * </pre>
     *
     * <code>uint64 remote_max_value_in_flight_msat = 15;</code>
     * @return The remoteMaxValueInFlightMsat.
     */
    @java.lang.Override
    public long getRemoteMaxValueInFlightMsat() {
      return remoteMaxValueInFlightMsat_;
    }
    /**
     * <pre>
     *The maximum amount of coins in millisatoshi that can be pending within
     *the channel. It only applies to the remote party.
     * </pre>
     *
     * <code>uint64 remote_max_value_in_flight_msat = 15;</code>
     * @param value The remoteMaxValueInFlightMsat to set.
     */
    private void setRemoteMaxValueInFlightMsat(long value) {
      
      remoteMaxValueInFlightMsat_ = value;
    }
    /**
     * <pre>
     *The maximum amount of coins in millisatoshi that can be pending within
     *the channel. It only applies to the remote party.
     * </pre>
     *
     * <code>uint64 remote_max_value_in_flight_msat = 15;</code>
     */
    private void clearRemoteMaxValueInFlightMsat() {
      
      remoteMaxValueInFlightMsat_ = 0L;
    }

    public static final int REMOTE_MAX_HTLCS_FIELD_NUMBER = 16;
    private int remoteMaxHtlcs_;
    /**
     * <pre>
     *The maximum number of concurrent HTLCs we will allow the remote party to add
     *to the commitment transaction.
     * </pre>
     *
     * <code>uint32 remote_max_htlcs = 16;</code>
     * @return The remoteMaxHtlcs.
     */
    @java.lang.Override
    public int getRemoteMaxHtlcs() {
      return remoteMaxHtlcs_;
    }
    /**
     * <pre>
     *The maximum number of concurrent HTLCs we will allow the remote party to add
     *to the commitment transaction.
     * </pre>
     *
     * <code>uint32 remote_max_htlcs = 16;</code>
     * @param value The remoteMaxHtlcs to set.
     */
    private void setRemoteMaxHtlcs(int value) {
      
      remoteMaxHtlcs_ = value;
    }
    /**
     * <pre>
     *The maximum number of concurrent HTLCs we will allow the remote party to add
     *to the commitment transaction.
     * </pre>
     *
     * <code>uint32 remote_max_htlcs = 16;</code>
     */
    private void clearRemoteMaxHtlcs() {
      
      remoteMaxHtlcs_ = 0;
    }

    public static final int MAX_LOCAL_CSV_FIELD_NUMBER = 17;
    private int maxLocalCsv_;
    /**
     * <pre>
     *Max local csv is the maximum csv delay we will allow for our own commitment
     *transaction.
     * </pre>
     *
     * <code>uint32 max_local_csv = 17;</code>
     * @return The maxLocalCsv.
     */
    @java.lang.Override
    public int getMaxLocalCsv() {
      return maxLocalCsv_;
    }
    /**
     * <pre>
     *Max local csv is the maximum csv delay we will allow for our own commitment
     *transaction.
     * </pre>
     *
     * <code>uint32 max_local_csv = 17;</code>
     * @param value The maxLocalCsv to set.
     */
    private void setMaxLocalCsv(int value) {
      
      maxLocalCsv_ = value;
    }
    /**
     * <pre>
     *Max local csv is the maximum csv delay we will allow for our own commitment
     *transaction.
     * </pre>
     *
     * <code>uint32 max_local_csv = 17;</code>
     */
    private void clearMaxLocalCsv() {
      
      maxLocalCsv_ = 0;
    }

    public static co.anode.anodium.Rpc.OpenChannelRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.OpenChannelRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.OpenChannelRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.OpenChannelRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.OpenChannelRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.OpenChannelRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.OpenChannelRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.OpenChannelRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.OpenChannelRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.OpenChannelRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.OpenChannelRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.OpenChannelRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.OpenChannelRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.OpenChannelRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.OpenChannelRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.OpenChannelRequest)
        co.anode.anodium.Rpc.OpenChannelRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.OpenChannelRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The pubkey of the node to open a channel with. When using REST, this field
       *must be encoded as base64.
       * </pre>
       *
       * <code>bytes node_pubkey = 2;</code>
       * @return The nodePubkey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getNodePubkey() {
        return instance.getNodePubkey();
      }
      /**
       * <pre>
       *The pubkey of the node to open a channel with. When using REST, this field
       *must be encoded as base64.
       * </pre>
       *
       * <code>bytes node_pubkey = 2;</code>
       * @param value The nodePubkey to set.
       * @return This builder for chaining.
       */
      public Builder setNodePubkey(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNodePubkey(value);
        return this;
      }
      /**
       * <pre>
       *The pubkey of the node to open a channel with. When using REST, this field
       *must be encoded as base64.
       * </pre>
       *
       * <code>bytes node_pubkey = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNodePubkey() {
        copyOnWrite();
        instance.clearNodePubkey();
        return this;
      }

      /**
       * <pre>
       *The hex encoded pubkey of the node to open a channel with. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string node_pubkey_string = 3 [deprecated = true];</code>
       * @return The nodePubkeyString.
       */
      @java.lang.Override
      @java.lang.Deprecated public java.lang.String getNodePubkeyString() {
        return instance.getNodePubkeyString();
      }
      /**
       * <pre>
       *The hex encoded pubkey of the node to open a channel with. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string node_pubkey_string = 3 [deprecated = true];</code>
       * @return The bytes for nodePubkeyString.
       */
      @java.lang.Override
      @java.lang.Deprecated public com.google.protobuf.ByteString
          getNodePubkeyStringBytes() {
        return instance.getNodePubkeyStringBytes();
      }
      /**
       * <pre>
       *The hex encoded pubkey of the node to open a channel with. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string node_pubkey_string = 3 [deprecated = true];</code>
       * @param value The nodePubkeyString to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setNodePubkeyString(
          java.lang.String value) {
        copyOnWrite();
        instance.setNodePubkeyString(value);
        return this;
      }
      /**
       * <pre>
       *The hex encoded pubkey of the node to open a channel with. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string node_pubkey_string = 3 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearNodePubkeyString() {
        copyOnWrite();
        instance.clearNodePubkeyString();
        return this;
      }
      /**
       * <pre>
       *The hex encoded pubkey of the node to open a channel with. Deprecated now
       *that the REST gateway supports base64 encoding of bytes fields.
       * </pre>
       *
       * <code>string node_pubkey_string = 3 [deprecated = true];</code>
       * @param value The bytes for nodePubkeyString to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setNodePubkeyStringBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNodePubkeyStringBytes(value);
        return this;
      }

      /**
       * <pre>
       * The number of satoshis the wallet should commit to the channel
       * </pre>
       *
       * <code>int64 local_funding_amount = 4;</code>
       * @return The localFundingAmount.
       */
      @java.lang.Override
      public long getLocalFundingAmount() {
        return instance.getLocalFundingAmount();
      }
      /**
       * <pre>
       * The number of satoshis the wallet should commit to the channel
       * </pre>
       *
       * <code>int64 local_funding_amount = 4;</code>
       * @param value The localFundingAmount to set.
       * @return This builder for chaining.
       */
      public Builder setLocalFundingAmount(long value) {
        copyOnWrite();
        instance.setLocalFundingAmount(value);
        return this;
      }
      /**
       * <pre>
       * The number of satoshis the wallet should commit to the channel
       * </pre>
       *
       * <code>int64 local_funding_amount = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearLocalFundingAmount() {
        copyOnWrite();
        instance.clearLocalFundingAmount();
        return this;
      }

      /**
       * <pre>
       * The number of satoshis to push to the remote side as part of the initial
       * commitment state
       * </pre>
       *
       * <code>int64 push_sat = 5;</code>
       * @return The pushSat.
       */
      @java.lang.Override
      public long getPushSat() {
        return instance.getPushSat();
      }
      /**
       * <pre>
       * The number of satoshis to push to the remote side as part of the initial
       * commitment state
       * </pre>
       *
       * <code>int64 push_sat = 5;</code>
       * @param value The pushSat to set.
       * @return This builder for chaining.
       */
      public Builder setPushSat(long value) {
        copyOnWrite();
        instance.setPushSat(value);
        return this;
      }
      /**
       * <pre>
       * The number of satoshis to push to the remote side as part of the initial
       * commitment state
       * </pre>
       *
       * <code>int64 push_sat = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearPushSat() {
        copyOnWrite();
        instance.clearPushSat();
        return this;
      }

      /**
       * <pre>
       * The target number of blocks that the funding transaction should be
       * confirmed by.
       * </pre>
       *
       * <code>int32 target_conf = 6;</code>
       * @return The targetConf.
       */
      @java.lang.Override
      public int getTargetConf() {
        return instance.getTargetConf();
      }
      /**
       * <pre>
       * The target number of blocks that the funding transaction should be
       * confirmed by.
       * </pre>
       *
       * <code>int32 target_conf = 6;</code>
       * @param value The targetConf to set.
       * @return This builder for chaining.
       */
      public Builder setTargetConf(int value) {
        copyOnWrite();
        instance.setTargetConf(value);
        return this;
      }
      /**
       * <pre>
       * The target number of blocks that the funding transaction should be
       * confirmed by.
       * </pre>
       *
       * <code>int32 target_conf = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearTargetConf() {
        copyOnWrite();
        instance.clearTargetConf();
        return this;
      }

      /**
       * <pre>
       * A manual fee rate set in sat/byte that should be used when crafting the
       * funding transaction.
       * </pre>
       *
       * <code>int64 sat_per_byte = 7;</code>
       * @return The satPerByte.
       */
      @java.lang.Override
      public long getSatPerByte() {
        return instance.getSatPerByte();
      }
      /**
       * <pre>
       * A manual fee rate set in sat/byte that should be used when crafting the
       * funding transaction.
       * </pre>
       *
       * <code>int64 sat_per_byte = 7;</code>
       * @param value The satPerByte to set.
       * @return This builder for chaining.
       */
      public Builder setSatPerByte(long value) {
        copyOnWrite();
        instance.setSatPerByte(value);
        return this;
      }
      /**
       * <pre>
       * A manual fee rate set in sat/byte that should be used when crafting the
       * funding transaction.
       * </pre>
       *
       * <code>int64 sat_per_byte = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearSatPerByte() {
        copyOnWrite();
        instance.clearSatPerByte();
        return this;
      }

      /**
       * <pre>
       * Whether this channel should be private, not announced to the greater
       * network.
       * </pre>
       *
       * <code>bool private = 8;</code>
       * @return The private.
       */
      @java.lang.Override
      public boolean getPrivate() {
        return instance.getPrivate();
      }
      /**
       * <pre>
       * Whether this channel should be private, not announced to the greater
       * network.
       * </pre>
       *
       * <code>bool private = 8;</code>
       * @param value The private to set.
       * @return This builder for chaining.
       */
      public Builder setPrivate(boolean value) {
        copyOnWrite();
        instance.setPrivate(value);
        return this;
      }
      /**
       * <pre>
       * Whether this channel should be private, not announced to the greater
       * network.
       * </pre>
       *
       * <code>bool private = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearPrivate() {
        copyOnWrite();
        instance.clearPrivate();
        return this;
      }

      /**
       * <pre>
       * The minimum value in millisatoshi we will require for incoming HTLCs on
       * the channel.
       * </pre>
       *
       * <code>int64 min_htlc_msat = 9;</code>
       * @return The minHtlcMsat.
       */
      @java.lang.Override
      public long getMinHtlcMsat() {
        return instance.getMinHtlcMsat();
      }
      /**
       * <pre>
       * The minimum value in millisatoshi we will require for incoming HTLCs on
       * the channel.
       * </pre>
       *
       * <code>int64 min_htlc_msat = 9;</code>
       * @param value The minHtlcMsat to set.
       * @return This builder for chaining.
       */
      public Builder setMinHtlcMsat(long value) {
        copyOnWrite();
        instance.setMinHtlcMsat(value);
        return this;
      }
      /**
       * <pre>
       * The minimum value in millisatoshi we will require for incoming HTLCs on
       * the channel.
       * </pre>
       *
       * <code>int64 min_htlc_msat = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinHtlcMsat() {
        copyOnWrite();
        instance.clearMinHtlcMsat();
        return this;
      }

      /**
       * <pre>
       * The delay we require on the remote's commitment transaction. If this is
       * not set, it will be scaled automatically with the channel size.
       * </pre>
       *
       * <code>uint32 remote_csv_delay = 10;</code>
       * @return The remoteCsvDelay.
       */
      @java.lang.Override
      public int getRemoteCsvDelay() {
        return instance.getRemoteCsvDelay();
      }
      /**
       * <pre>
       * The delay we require on the remote's commitment transaction. If this is
       * not set, it will be scaled automatically with the channel size.
       * </pre>
       *
       * <code>uint32 remote_csv_delay = 10;</code>
       * @param value The remoteCsvDelay to set.
       * @return This builder for chaining.
       */
      public Builder setRemoteCsvDelay(int value) {
        copyOnWrite();
        instance.setRemoteCsvDelay(value);
        return this;
      }
      /**
       * <pre>
       * The delay we require on the remote's commitment transaction. If this is
       * not set, it will be scaled automatically with the channel size.
       * </pre>
       *
       * <code>uint32 remote_csv_delay = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearRemoteCsvDelay() {
        copyOnWrite();
        instance.clearRemoteCsvDelay();
        return this;
      }

      /**
       * <pre>
       * The minimum number of confirmations each one of your outputs used for
       * the funding transaction must satisfy.
       * </pre>
       *
       * <code>int32 min_confs = 11;</code>
       * @return The minConfs.
       */
      @java.lang.Override
      public int getMinConfs() {
        return instance.getMinConfs();
      }
      /**
       * <pre>
       * The minimum number of confirmations each one of your outputs used for
       * the funding transaction must satisfy.
       * </pre>
       *
       * <code>int32 min_confs = 11;</code>
       * @param value The minConfs to set.
       * @return This builder for chaining.
       */
      public Builder setMinConfs(int value) {
        copyOnWrite();
        instance.setMinConfs(value);
        return this;
      }
      /**
       * <pre>
       * The minimum number of confirmations each one of your outputs used for
       * the funding transaction must satisfy.
       * </pre>
       *
       * <code>int32 min_confs = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinConfs() {
        copyOnWrite();
        instance.clearMinConfs();
        return this;
      }

      /**
       * <pre>
       * Whether unconfirmed outputs should be used as inputs for the funding
       * transaction.
       * </pre>
       *
       * <code>bool spend_unconfirmed = 12;</code>
       * @return The spendUnconfirmed.
       */
      @java.lang.Override
      public boolean getSpendUnconfirmed() {
        return instance.getSpendUnconfirmed();
      }
      /**
       * <pre>
       * Whether unconfirmed outputs should be used as inputs for the funding
       * transaction.
       * </pre>
       *
       * <code>bool spend_unconfirmed = 12;</code>
       * @param value The spendUnconfirmed to set.
       * @return This builder for chaining.
       */
      public Builder setSpendUnconfirmed(boolean value) {
        copyOnWrite();
        instance.setSpendUnconfirmed(value);
        return this;
      }
      /**
       * <pre>
       * Whether unconfirmed outputs should be used as inputs for the funding
       * transaction.
       * </pre>
       *
       * <code>bool spend_unconfirmed = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearSpendUnconfirmed() {
        copyOnWrite();
        instance.clearSpendUnconfirmed();
        return this;
      }

      /**
       * <pre>
       *Close address is an optional address which specifies the address to which
       *funds should be paid out to upon cooperative close. This field may only be
       *set if the peer supports the option upfront feature bit (call listpeers
       *to check). The remote peer will only accept cooperative closes to this
       *address if it is set.
       *Note: If this value is set on channel creation, you will *not* be able to
       *cooperatively close out to a different address.
       * </pre>
       *
       * <code>string close_address = 13;</code>
       * @return The closeAddress.
       */
      @java.lang.Override
      public java.lang.String getCloseAddress() {
        return instance.getCloseAddress();
      }
      /**
       * <pre>
       *Close address is an optional address which specifies the address to which
       *funds should be paid out to upon cooperative close. This field may only be
       *set if the peer supports the option upfront feature bit (call listpeers
       *to check). The remote peer will only accept cooperative closes to this
       *address if it is set.
       *Note: If this value is set on channel creation, you will *not* be able to
       *cooperatively close out to a different address.
       * </pre>
       *
       * <code>string close_address = 13;</code>
       * @return The bytes for closeAddress.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getCloseAddressBytes() {
        return instance.getCloseAddressBytes();
      }
      /**
       * <pre>
       *Close address is an optional address which specifies the address to which
       *funds should be paid out to upon cooperative close. This field may only be
       *set if the peer supports the option upfront feature bit (call listpeers
       *to check). The remote peer will only accept cooperative closes to this
       *address if it is set.
       *Note: If this value is set on channel creation, you will *not* be able to
       *cooperatively close out to a different address.
       * </pre>
       *
       * <code>string close_address = 13;</code>
       * @param value The closeAddress to set.
       * @return This builder for chaining.
       */
      public Builder setCloseAddress(
          java.lang.String value) {
        copyOnWrite();
        instance.setCloseAddress(value);
        return this;
      }
      /**
       * <pre>
       *Close address is an optional address which specifies the address to which
       *funds should be paid out to upon cooperative close. This field may only be
       *set if the peer supports the option upfront feature bit (call listpeers
       *to check). The remote peer will only accept cooperative closes to this
       *address if it is set.
       *Note: If this value is set on channel creation, you will *not* be able to
       *cooperatively close out to a different address.
       * </pre>
       *
       * <code>string close_address = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearCloseAddress() {
        copyOnWrite();
        instance.clearCloseAddress();
        return this;
      }
      /**
       * <pre>
       *Close address is an optional address which specifies the address to which
       *funds should be paid out to upon cooperative close. This field may only be
       *set if the peer supports the option upfront feature bit (call listpeers
       *to check). The remote peer will only accept cooperative closes to this
       *address if it is set.
       *Note: If this value is set on channel creation, you will *not* be able to
       *cooperatively close out to a different address.
       * </pre>
       *
       * <code>string close_address = 13;</code>
       * @param value The bytes for closeAddress to set.
       * @return This builder for chaining.
       */
      public Builder setCloseAddressBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setCloseAddressBytes(value);
        return this;
      }

      /**
       * <pre>
       *Funding shims are an optional argument that allow the caller to intercept
       *certain funding functionality. For example, a shim can be provided to use a
       *particular key for the commitment key (ideally cold) rather than use one
       *that is generated by the wallet as normal, or signal that signing will be
       *carried out in an interactive manner (PSBT based).
       * </pre>
       *
       * <code>.co.anode.anodium.FundingShim funding_shim = 14;</code>
       */
      @java.lang.Override
      public boolean hasFundingShim() {
        return instance.hasFundingShim();
      }
      /**
       * <pre>
       *Funding shims are an optional argument that allow the caller to intercept
       *certain funding functionality. For example, a shim can be provided to use a
       *particular key for the commitment key (ideally cold) rather than use one
       *that is generated by the wallet as normal, or signal that signing will be
       *carried out in an interactive manner (PSBT based).
       * </pre>
       *
       * <code>.co.anode.anodium.FundingShim funding_shim = 14;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.FundingShim getFundingShim() {
        return instance.getFundingShim();
      }
      /**
       * <pre>
       *Funding shims are an optional argument that allow the caller to intercept
       *certain funding functionality. For example, a shim can be provided to use a
       *particular key for the commitment key (ideally cold) rather than use one
       *that is generated by the wallet as normal, or signal that signing will be
       *carried out in an interactive manner (PSBT based).
       * </pre>
       *
       * <code>.co.anode.anodium.FundingShim funding_shim = 14;</code>
       */
      public Builder setFundingShim(co.anode.anodium.Rpc.FundingShim value) {
        copyOnWrite();
        instance.setFundingShim(value);
        return this;
        }
      /**
       * <pre>
       *Funding shims are an optional argument that allow the caller to intercept
       *certain funding functionality. For example, a shim can be provided to use a
       *particular key for the commitment key (ideally cold) rather than use one
       *that is generated by the wallet as normal, or signal that signing will be
       *carried out in an interactive manner (PSBT based).
       * </pre>
       *
       * <code>.co.anode.anodium.FundingShim funding_shim = 14;</code>
       */
      public Builder setFundingShim(
          co.anode.anodium.Rpc.FundingShim.Builder builderForValue) {
        copyOnWrite();
        instance.setFundingShim(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Funding shims are an optional argument that allow the caller to intercept
       *certain funding functionality. For example, a shim can be provided to use a
       *particular key for the commitment key (ideally cold) rather than use one
       *that is generated by the wallet as normal, or signal that signing will be
       *carried out in an interactive manner (PSBT based).
       * </pre>
       *
       * <code>.co.anode.anodium.FundingShim funding_shim = 14;</code>
       */
      public Builder mergeFundingShim(co.anode.anodium.Rpc.FundingShim value) {
        copyOnWrite();
        instance.mergeFundingShim(value);
        return this;
      }
      /**
       * <pre>
       *Funding shims are an optional argument that allow the caller to intercept
       *certain funding functionality. For example, a shim can be provided to use a
       *particular key for the commitment key (ideally cold) rather than use one
       *that is generated by the wallet as normal, or signal that signing will be
       *carried out in an interactive manner (PSBT based).
       * </pre>
       *
       * <code>.co.anode.anodium.FundingShim funding_shim = 14;</code>
       */
      public Builder clearFundingShim() {  copyOnWrite();
        instance.clearFundingShim();
        return this;
      }

      /**
       * <pre>
       *The maximum amount of coins in millisatoshi that can be pending within
       *the channel. It only applies to the remote party.
       * </pre>
       *
       * <code>uint64 remote_max_value_in_flight_msat = 15;</code>
       * @return The remoteMaxValueInFlightMsat.
       */
      @java.lang.Override
      public long getRemoteMaxValueInFlightMsat() {
        return instance.getRemoteMaxValueInFlightMsat();
      }
      /**
       * <pre>
       *The maximum amount of coins in millisatoshi that can be pending within
       *the channel. It only applies to the remote party.
       * </pre>
       *
       * <code>uint64 remote_max_value_in_flight_msat = 15;</code>
       * @param value The remoteMaxValueInFlightMsat to set.
       * @return This builder for chaining.
       */
      public Builder setRemoteMaxValueInFlightMsat(long value) {
        copyOnWrite();
        instance.setRemoteMaxValueInFlightMsat(value);
        return this;
      }
      /**
       * <pre>
       *The maximum amount of coins in millisatoshi that can be pending within
       *the channel. It only applies to the remote party.
       * </pre>
       *
       * <code>uint64 remote_max_value_in_flight_msat = 15;</code>
       * @return This builder for chaining.
       */
      public Builder clearRemoteMaxValueInFlightMsat() {
        copyOnWrite();
        instance.clearRemoteMaxValueInFlightMsat();
        return this;
      }

      /**
       * <pre>
       *The maximum number of concurrent HTLCs we will allow the remote party to add
       *to the commitment transaction.
       * </pre>
       *
       * <code>uint32 remote_max_htlcs = 16;</code>
       * @return The remoteMaxHtlcs.
       */
      @java.lang.Override
      public int getRemoteMaxHtlcs() {
        return instance.getRemoteMaxHtlcs();
      }
      /**
       * <pre>
       *The maximum number of concurrent HTLCs we will allow the remote party to add
       *to the commitment transaction.
       * </pre>
       *
       * <code>uint32 remote_max_htlcs = 16;</code>
       * @param value The remoteMaxHtlcs to set.
       * @return This builder for chaining.
       */
      public Builder setRemoteMaxHtlcs(int value) {
        copyOnWrite();
        instance.setRemoteMaxHtlcs(value);
        return this;
      }
      /**
       * <pre>
       *The maximum number of concurrent HTLCs we will allow the remote party to add
       *to the commitment transaction.
       * </pre>
       *
       * <code>uint32 remote_max_htlcs = 16;</code>
       * @return This builder for chaining.
       */
      public Builder clearRemoteMaxHtlcs() {
        copyOnWrite();
        instance.clearRemoteMaxHtlcs();
        return this;
      }

      /**
       * <pre>
       *Max local csv is the maximum csv delay we will allow for our own commitment
       *transaction.
       * </pre>
       *
       * <code>uint32 max_local_csv = 17;</code>
       * @return The maxLocalCsv.
       */
      @java.lang.Override
      public int getMaxLocalCsv() {
        return instance.getMaxLocalCsv();
      }
      /**
       * <pre>
       *Max local csv is the maximum csv delay we will allow for our own commitment
       *transaction.
       * </pre>
       *
       * <code>uint32 max_local_csv = 17;</code>
       * @param value The maxLocalCsv to set.
       * @return This builder for chaining.
       */
      public Builder setMaxLocalCsv(int value) {
        copyOnWrite();
        instance.setMaxLocalCsv(value);
        return this;
      }
      /**
       * <pre>
       *Max local csv is the maximum csv delay we will allow for our own commitment
       *transaction.
       * </pre>
       *
       * <code>uint32 max_local_csv = 17;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxLocalCsv() {
        copyOnWrite();
        instance.clearMaxLocalCsv();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.OpenChannelRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.OpenChannelRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "nodePubkey_",
              "nodePubkeyString_",
              "localFundingAmount_",
              "pushSat_",
              "targetConf_",
              "satPerByte_",
              "private_",
              "minHtlcMsat_",
              "remoteCsvDelay_",
              "minConfs_",
              "spendUnconfirmed_",
              "closeAddress_",
              "fundingShim_",
              "remoteMaxValueInFlightMsat_",
              "remoteMaxHtlcs_",
              "maxLocalCsv_",
            };
            java.lang.String info =
                "\u0000\u0010\u0000\u0000\u0002\u0011\u0010\u0000\u0000\u0000\u0002\n\u0003\u0208" +
                "\u0004\u0002\u0005\u0002\u0006\u0004\u0007\u0002\b\u0007\t\u0002\n\u000b\u000b\u0004" +
                "\f\u0007\r\u0208\u000e\t\u000f\u0003\u0010\u000b\u0011\u000b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.OpenChannelRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.OpenChannelRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.OpenChannelRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.OpenChannelRequest)
    private static final co.anode.anodium.Rpc.OpenChannelRequest DEFAULT_INSTANCE;
    static {
      OpenChannelRequest defaultInstance = new OpenChannelRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        OpenChannelRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.OpenChannelRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<OpenChannelRequest> PARSER;

    public static com.google.protobuf.Parser<OpenChannelRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface OpenStatusUpdateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.OpenStatusUpdate)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *Signals that the channel is now fully negotiated and the funding
     *transaction published.
     * </pre>
     *
     * <code>.co.anode.anodium.PendingUpdate chan_pending = 1;</code>
     * @return Whether the chanPending field is set.
     */
    boolean hasChanPending();
    /**
     * <pre>
     *Signals that the channel is now fully negotiated and the funding
     *transaction published.
     * </pre>
     *
     * <code>.co.anode.anodium.PendingUpdate chan_pending = 1;</code>
     * @return The chanPending.
     */
    co.anode.anodium.Rpc.PendingUpdate getChanPending();

    /**
     * <pre>
     *Signals that the channel's funding transaction has now reached the
     *required number of confirmations on chain and can be used.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelOpenUpdate chan_open = 3;</code>
     * @return Whether the chanOpen field is set.
     */
    boolean hasChanOpen();
    /**
     * <pre>
     *Signals that the channel's funding transaction has now reached the
     *required number of confirmations on chain and can be used.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelOpenUpdate chan_open = 3;</code>
     * @return The chanOpen.
     */
    co.anode.anodium.Rpc.ChannelOpenUpdate getChanOpen();

    /**
     * <pre>
     *Signals that the funding process has been suspended and the construction
     *of a PSBT that funds the channel PK script is now required.
     * </pre>
     *
     * <code>.co.anode.anodium.ReadyForPsbtFunding psbt_fund = 5;</code>
     * @return Whether the psbtFund field is set.
     */
    boolean hasPsbtFund();
    /**
     * <pre>
     *Signals that the funding process has been suspended and the construction
     *of a PSBT that funds the channel PK script is now required.
     * </pre>
     *
     * <code>.co.anode.anodium.ReadyForPsbtFunding psbt_fund = 5;</code>
     * @return The psbtFund.
     */
    co.anode.anodium.Rpc.ReadyForPsbtFunding getPsbtFund();

    /**
     * <pre>
     *The pending channel ID of the created channel. This value may be used to
     *further the funding flow manually via the FundingStateStep method.
     * </pre>
     *
     * <code>bytes pending_chan_id = 4;</code>
     * @return The pendingChanId.
     */
    com.google.protobuf.ByteString getPendingChanId();

    public co.anode.anodium.Rpc.OpenStatusUpdate.UpdateCase getUpdateCase();
  }
  /**
   * Protobuf type {@code co.anode.anodium.OpenStatusUpdate}
   */
  public  static final class OpenStatusUpdate extends
      com.google.protobuf.GeneratedMessageLite<
          OpenStatusUpdate, OpenStatusUpdate.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.OpenStatusUpdate)
      OpenStatusUpdateOrBuilder {
    private OpenStatusUpdate() {
      pendingChanId_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int updateCase_ = 0;
    private java.lang.Object update_;
    public enum UpdateCase {
      CHAN_PENDING(1),
      CHAN_OPEN(3),
      PSBT_FUND(5),
      UPDATE_NOT_SET(0);
      private final int value;
      private UpdateCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static UpdateCase valueOf(int value) {
        return forNumber(value);
      }

      public static UpdateCase forNumber(int value) {
        switch (value) {
          case 1: return CHAN_PENDING;
          case 3: return CHAN_OPEN;
          case 5: return PSBT_FUND;
          case 0: return UPDATE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    @java.lang.Override
    public UpdateCase
    getUpdateCase() {
      return UpdateCase.forNumber(
          updateCase_);
    }

    private void clearUpdate() {
      updateCase_ = 0;
      update_ = null;
    }

    public static final int CHAN_PENDING_FIELD_NUMBER = 1;
    /**
     * <pre>
     *Signals that the channel is now fully negotiated and the funding
     *transaction published.
     * </pre>
     *
     * <code>.co.anode.anodium.PendingUpdate chan_pending = 1;</code>
     */
    @java.lang.Override
    public boolean hasChanPending() {
      return updateCase_ == 1;
    }
    /**
     * <pre>
     *Signals that the channel is now fully negotiated and the funding
     *transaction published.
     * </pre>
     *
     * <code>.co.anode.anodium.PendingUpdate chan_pending = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.PendingUpdate getChanPending() {
      if (updateCase_ == 1) {
         return (co.anode.anodium.Rpc.PendingUpdate) update_;
      }
      return co.anode.anodium.Rpc.PendingUpdate.getDefaultInstance();
    }
    /**
     * <pre>
     *Signals that the channel is now fully negotiated and the funding
     *transaction published.
     * </pre>
     *
     * <code>.co.anode.anodium.PendingUpdate chan_pending = 1;</code>
     */
    private void setChanPending(co.anode.anodium.Rpc.PendingUpdate value) {
      value.getClass();
  update_ = value;
      updateCase_ = 1;
    }
    /**
     * <pre>
     *Signals that the channel is now fully negotiated and the funding
     *transaction published.
     * </pre>
     *
     * <code>.co.anode.anodium.PendingUpdate chan_pending = 1;</code>
     */
    private void mergeChanPending(co.anode.anodium.Rpc.PendingUpdate value) {
      value.getClass();
  if (updateCase_ == 1 &&
          update_ != co.anode.anodium.Rpc.PendingUpdate.getDefaultInstance()) {
        update_ = co.anode.anodium.Rpc.PendingUpdate.newBuilder((co.anode.anodium.Rpc.PendingUpdate) update_)
            .mergeFrom(value).buildPartial();
      } else {
        update_ = value;
      }
      updateCase_ = 1;
    }
    /**
     * <pre>
     *Signals that the channel is now fully negotiated and the funding
     *transaction published.
     * </pre>
     *
     * <code>.co.anode.anodium.PendingUpdate chan_pending = 1;</code>
     */
    private void clearChanPending() {
      if (updateCase_ == 1) {
        updateCase_ = 0;
        update_ = null;
      }
    }

    public static final int CHAN_OPEN_FIELD_NUMBER = 3;
    /**
     * <pre>
     *Signals that the channel's funding transaction has now reached the
     *required number of confirmations on chain and can be used.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelOpenUpdate chan_open = 3;</code>
     */
    @java.lang.Override
    public boolean hasChanOpen() {
      return updateCase_ == 3;
    }
    /**
     * <pre>
     *Signals that the channel's funding transaction has now reached the
     *required number of confirmations on chain and can be used.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelOpenUpdate chan_open = 3;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelOpenUpdate getChanOpen() {
      if (updateCase_ == 3) {
         return (co.anode.anodium.Rpc.ChannelOpenUpdate) update_;
      }
      return co.anode.anodium.Rpc.ChannelOpenUpdate.getDefaultInstance();
    }
    /**
     * <pre>
     *Signals that the channel's funding transaction has now reached the
     *required number of confirmations on chain and can be used.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelOpenUpdate chan_open = 3;</code>
     */
    private void setChanOpen(co.anode.anodium.Rpc.ChannelOpenUpdate value) {
      value.getClass();
  update_ = value;
      updateCase_ = 3;
    }
    /**
     * <pre>
     *Signals that the channel's funding transaction has now reached the
     *required number of confirmations on chain and can be used.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelOpenUpdate chan_open = 3;</code>
     */
    private void mergeChanOpen(co.anode.anodium.Rpc.ChannelOpenUpdate value) {
      value.getClass();
  if (updateCase_ == 3 &&
          update_ != co.anode.anodium.Rpc.ChannelOpenUpdate.getDefaultInstance()) {
        update_ = co.anode.anodium.Rpc.ChannelOpenUpdate.newBuilder((co.anode.anodium.Rpc.ChannelOpenUpdate) update_)
            .mergeFrom(value).buildPartial();
      } else {
        update_ = value;
      }
      updateCase_ = 3;
    }
    /**
     * <pre>
     *Signals that the channel's funding transaction has now reached the
     *required number of confirmations on chain and can be used.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelOpenUpdate chan_open = 3;</code>
     */
    private void clearChanOpen() {
      if (updateCase_ == 3) {
        updateCase_ = 0;
        update_ = null;
      }
    }

    public static final int PSBT_FUND_FIELD_NUMBER = 5;
    /**
     * <pre>
     *Signals that the funding process has been suspended and the construction
     *of a PSBT that funds the channel PK script is now required.
     * </pre>
     *
     * <code>.co.anode.anodium.ReadyForPsbtFunding psbt_fund = 5;</code>
     */
    @java.lang.Override
    public boolean hasPsbtFund() {
      return updateCase_ == 5;
    }
    /**
     * <pre>
     *Signals that the funding process has been suspended and the construction
     *of a PSBT that funds the channel PK script is now required.
     * </pre>
     *
     * <code>.co.anode.anodium.ReadyForPsbtFunding psbt_fund = 5;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ReadyForPsbtFunding getPsbtFund() {
      if (updateCase_ == 5) {
         return (co.anode.anodium.Rpc.ReadyForPsbtFunding) update_;
      }
      return co.anode.anodium.Rpc.ReadyForPsbtFunding.getDefaultInstance();
    }
    /**
     * <pre>
     *Signals that the funding process has been suspended and the construction
     *of a PSBT that funds the channel PK script is now required.
     * </pre>
     *
     * <code>.co.anode.anodium.ReadyForPsbtFunding psbt_fund = 5;</code>
     */
    private void setPsbtFund(co.anode.anodium.Rpc.ReadyForPsbtFunding value) {
      value.getClass();
  update_ = value;
      updateCase_ = 5;
    }
    /**
     * <pre>
     *Signals that the funding process has been suspended and the construction
     *of a PSBT that funds the channel PK script is now required.
     * </pre>
     *
     * <code>.co.anode.anodium.ReadyForPsbtFunding psbt_fund = 5;</code>
     */
    private void mergePsbtFund(co.anode.anodium.Rpc.ReadyForPsbtFunding value) {
      value.getClass();
  if (updateCase_ == 5 &&
          update_ != co.anode.anodium.Rpc.ReadyForPsbtFunding.getDefaultInstance()) {
        update_ = co.anode.anodium.Rpc.ReadyForPsbtFunding.newBuilder((co.anode.anodium.Rpc.ReadyForPsbtFunding) update_)
            .mergeFrom(value).buildPartial();
      } else {
        update_ = value;
      }
      updateCase_ = 5;
    }
    /**
     * <pre>
     *Signals that the funding process has been suspended and the construction
     *of a PSBT that funds the channel PK script is now required.
     * </pre>
     *
     * <code>.co.anode.anodium.ReadyForPsbtFunding psbt_fund = 5;</code>
     */
    private void clearPsbtFund() {
      if (updateCase_ == 5) {
        updateCase_ = 0;
        update_ = null;
      }
    }

    public static final int PENDING_CHAN_ID_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString pendingChanId_;
    /**
     * <pre>
     *The pending channel ID of the created channel. This value may be used to
     *further the funding flow manually via the FundingStateStep method.
     * </pre>
     *
     * <code>bytes pending_chan_id = 4;</code>
     * @return The pendingChanId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPendingChanId() {
      return pendingChanId_;
    }
    /**
     * <pre>
     *The pending channel ID of the created channel. This value may be used to
     *further the funding flow manually via the FundingStateStep method.
     * </pre>
     *
     * <code>bytes pending_chan_id = 4;</code>
     * @param value The pendingChanId to set.
     */
    private void setPendingChanId(com.google.protobuf.ByteString value) {
      value.getClass();
  
      pendingChanId_ = value;
    }
    /**
     * <pre>
     *The pending channel ID of the created channel. This value may be used to
     *further the funding flow manually via the FundingStateStep method.
     * </pre>
     *
     * <code>bytes pending_chan_id = 4;</code>
     */
    private void clearPendingChanId() {
      
      pendingChanId_ = getDefaultInstance().getPendingChanId();
    }

    public static co.anode.anodium.Rpc.OpenStatusUpdate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.OpenStatusUpdate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.OpenStatusUpdate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.OpenStatusUpdate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.OpenStatusUpdate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.OpenStatusUpdate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.OpenStatusUpdate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.OpenStatusUpdate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.OpenStatusUpdate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.OpenStatusUpdate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.OpenStatusUpdate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.OpenStatusUpdate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.OpenStatusUpdate prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.OpenStatusUpdate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.OpenStatusUpdate, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.OpenStatusUpdate)
        co.anode.anodium.Rpc.OpenStatusUpdateOrBuilder {
      // Construct using co.anode.anodium.Rpc.OpenStatusUpdate.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }

      @java.lang.Override
      public UpdateCase
          getUpdateCase() {
        return instance.getUpdateCase();
      }

      public Builder clearUpdate() {
        copyOnWrite();
        instance.clearUpdate();
        return this;
      }


      /**
       * <pre>
       *Signals that the channel is now fully negotiated and the funding
       *transaction published.
       * </pre>
       *
       * <code>.co.anode.anodium.PendingUpdate chan_pending = 1;</code>
       */
      @java.lang.Override
      public boolean hasChanPending() {
        return instance.hasChanPending();
      }
      /**
       * <pre>
       *Signals that the channel is now fully negotiated and the funding
       *transaction published.
       * </pre>
       *
       * <code>.co.anode.anodium.PendingUpdate chan_pending = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.PendingUpdate getChanPending() {
        return instance.getChanPending();
      }
      /**
       * <pre>
       *Signals that the channel is now fully negotiated and the funding
       *transaction published.
       * </pre>
       *
       * <code>.co.anode.anodium.PendingUpdate chan_pending = 1;</code>
       */
      public Builder setChanPending(co.anode.anodium.Rpc.PendingUpdate value) {
        copyOnWrite();
        instance.setChanPending(value);
        return this;
      }
      /**
       * <pre>
       *Signals that the channel is now fully negotiated and the funding
       *transaction published.
       * </pre>
       *
       * <code>.co.anode.anodium.PendingUpdate chan_pending = 1;</code>
       */
      public Builder setChanPending(
          co.anode.anodium.Rpc.PendingUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.setChanPending(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Signals that the channel is now fully negotiated and the funding
       *transaction published.
       * </pre>
       *
       * <code>.co.anode.anodium.PendingUpdate chan_pending = 1;</code>
       */
      public Builder mergeChanPending(co.anode.anodium.Rpc.PendingUpdate value) {
        copyOnWrite();
        instance.mergeChanPending(value);
        return this;
      }
      /**
       * <pre>
       *Signals that the channel is now fully negotiated and the funding
       *transaction published.
       * </pre>
       *
       * <code>.co.anode.anodium.PendingUpdate chan_pending = 1;</code>
       */
      public Builder clearChanPending() {
        copyOnWrite();
        instance.clearChanPending();
        return this;
      }

      /**
       * <pre>
       *Signals that the channel's funding transaction has now reached the
       *required number of confirmations on chain and can be used.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelOpenUpdate chan_open = 3;</code>
       */
      @java.lang.Override
      public boolean hasChanOpen() {
        return instance.hasChanOpen();
      }
      /**
       * <pre>
       *Signals that the channel's funding transaction has now reached the
       *required number of confirmations on chain and can be used.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelOpenUpdate chan_open = 3;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelOpenUpdate getChanOpen() {
        return instance.getChanOpen();
      }
      /**
       * <pre>
       *Signals that the channel's funding transaction has now reached the
       *required number of confirmations on chain and can be used.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelOpenUpdate chan_open = 3;</code>
       */
      public Builder setChanOpen(co.anode.anodium.Rpc.ChannelOpenUpdate value) {
        copyOnWrite();
        instance.setChanOpen(value);
        return this;
      }
      /**
       * <pre>
       *Signals that the channel's funding transaction has now reached the
       *required number of confirmations on chain and can be used.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelOpenUpdate chan_open = 3;</code>
       */
      public Builder setChanOpen(
          co.anode.anodium.Rpc.ChannelOpenUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.setChanOpen(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Signals that the channel's funding transaction has now reached the
       *required number of confirmations on chain and can be used.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelOpenUpdate chan_open = 3;</code>
       */
      public Builder mergeChanOpen(co.anode.anodium.Rpc.ChannelOpenUpdate value) {
        copyOnWrite();
        instance.mergeChanOpen(value);
        return this;
      }
      /**
       * <pre>
       *Signals that the channel's funding transaction has now reached the
       *required number of confirmations on chain and can be used.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelOpenUpdate chan_open = 3;</code>
       */
      public Builder clearChanOpen() {
        copyOnWrite();
        instance.clearChanOpen();
        return this;
      }

      /**
       * <pre>
       *Signals that the funding process has been suspended and the construction
       *of a PSBT that funds the channel PK script is now required.
       * </pre>
       *
       * <code>.co.anode.anodium.ReadyForPsbtFunding psbt_fund = 5;</code>
       */
      @java.lang.Override
      public boolean hasPsbtFund() {
        return instance.hasPsbtFund();
      }
      /**
       * <pre>
       *Signals that the funding process has been suspended and the construction
       *of a PSBT that funds the channel PK script is now required.
       * </pre>
       *
       * <code>.co.anode.anodium.ReadyForPsbtFunding psbt_fund = 5;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ReadyForPsbtFunding getPsbtFund() {
        return instance.getPsbtFund();
      }
      /**
       * <pre>
       *Signals that the funding process has been suspended and the construction
       *of a PSBT that funds the channel PK script is now required.
       * </pre>
       *
       * <code>.co.anode.anodium.ReadyForPsbtFunding psbt_fund = 5;</code>
       */
      public Builder setPsbtFund(co.anode.anodium.Rpc.ReadyForPsbtFunding value) {
        copyOnWrite();
        instance.setPsbtFund(value);
        return this;
      }
      /**
       * <pre>
       *Signals that the funding process has been suspended and the construction
       *of a PSBT that funds the channel PK script is now required.
       * </pre>
       *
       * <code>.co.anode.anodium.ReadyForPsbtFunding psbt_fund = 5;</code>
       */
      public Builder setPsbtFund(
          co.anode.anodium.Rpc.ReadyForPsbtFunding.Builder builderForValue) {
        copyOnWrite();
        instance.setPsbtFund(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Signals that the funding process has been suspended and the construction
       *of a PSBT that funds the channel PK script is now required.
       * </pre>
       *
       * <code>.co.anode.anodium.ReadyForPsbtFunding psbt_fund = 5;</code>
       */
      public Builder mergePsbtFund(co.anode.anodium.Rpc.ReadyForPsbtFunding value) {
        copyOnWrite();
        instance.mergePsbtFund(value);
        return this;
      }
      /**
       * <pre>
       *Signals that the funding process has been suspended and the construction
       *of a PSBT that funds the channel PK script is now required.
       * </pre>
       *
       * <code>.co.anode.anodium.ReadyForPsbtFunding psbt_fund = 5;</code>
       */
      public Builder clearPsbtFund() {
        copyOnWrite();
        instance.clearPsbtFund();
        return this;
      }

      /**
       * <pre>
       *The pending channel ID of the created channel. This value may be used to
       *further the funding flow manually via the FundingStateStep method.
       * </pre>
       *
       * <code>bytes pending_chan_id = 4;</code>
       * @return The pendingChanId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPendingChanId() {
        return instance.getPendingChanId();
      }
      /**
       * <pre>
       *The pending channel ID of the created channel. This value may be used to
       *further the funding flow manually via the FundingStateStep method.
       * </pre>
       *
       * <code>bytes pending_chan_id = 4;</code>
       * @param value The pendingChanId to set.
       * @return This builder for chaining.
       */
      public Builder setPendingChanId(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPendingChanId(value);
        return this;
      }
      /**
       * <pre>
       *The pending channel ID of the created channel. This value may be used to
       *further the funding flow manually via the FundingStateStep method.
       * </pre>
       *
       * <code>bytes pending_chan_id = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearPendingChanId() {
        copyOnWrite();
        instance.clearPendingChanId();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.OpenStatusUpdate)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.OpenStatusUpdate();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "update_",
              "updateCase_",
              co.anode.anodium.Rpc.PendingUpdate.class,
              co.anode.anodium.Rpc.ChannelOpenUpdate.class,
              "pendingChanId_",
              co.anode.anodium.Rpc.ReadyForPsbtFunding.class,
            };
            java.lang.String info =
                "\u0000\u0004\u0001\u0000\u0001\u0005\u0004\u0000\u0000\u0000\u0001<\u0000\u0003<" +
                "\u0000\u0004\n\u0005<\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.OpenStatusUpdate> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.OpenStatusUpdate.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.OpenStatusUpdate>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.OpenStatusUpdate)
    private static final co.anode.anodium.Rpc.OpenStatusUpdate DEFAULT_INSTANCE;
    static {
      OpenStatusUpdate defaultInstance = new OpenStatusUpdate();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        OpenStatusUpdate.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.OpenStatusUpdate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<OpenStatusUpdate> PARSER;

    public static com.google.protobuf.Parser<OpenStatusUpdate> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface KeyLocatorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.KeyLocator)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The family of key being identified.
     * </pre>
     *
     * <code>int32 key_family = 1;</code>
     * @return The keyFamily.
     */
    int getKeyFamily();

    /**
     * <pre>
     * The precise index of the key being identified.
     * </pre>
     *
     * <code>int32 key_index = 2;</code>
     * @return The keyIndex.
     */
    int getKeyIndex();
  }
  /**
   * Protobuf type {@code co.anode.anodium.KeyLocator}
   */
  public  static final class KeyLocator extends
      com.google.protobuf.GeneratedMessageLite<
          KeyLocator, KeyLocator.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.KeyLocator)
      KeyLocatorOrBuilder {
    private KeyLocator() {
    }
    public static final int KEY_FAMILY_FIELD_NUMBER = 1;
    private int keyFamily_;
    /**
     * <pre>
     * The family of key being identified.
     * </pre>
     *
     * <code>int32 key_family = 1;</code>
     * @return The keyFamily.
     */
    @java.lang.Override
    public int getKeyFamily() {
      return keyFamily_;
    }
    /**
     * <pre>
     * The family of key being identified.
     * </pre>
     *
     * <code>int32 key_family = 1;</code>
     * @param value The keyFamily to set.
     */
    private void setKeyFamily(int value) {
      
      keyFamily_ = value;
    }
    /**
     * <pre>
     * The family of key being identified.
     * </pre>
     *
     * <code>int32 key_family = 1;</code>
     */
    private void clearKeyFamily() {
      
      keyFamily_ = 0;
    }

    public static final int KEY_INDEX_FIELD_NUMBER = 2;
    private int keyIndex_;
    /**
     * <pre>
     * The precise index of the key being identified.
     * </pre>
     *
     * <code>int32 key_index = 2;</code>
     * @return The keyIndex.
     */
    @java.lang.Override
    public int getKeyIndex() {
      return keyIndex_;
    }
    /**
     * <pre>
     * The precise index of the key being identified.
     * </pre>
     *
     * <code>int32 key_index = 2;</code>
     * @param value The keyIndex to set.
     */
    private void setKeyIndex(int value) {
      
      keyIndex_ = value;
    }
    /**
     * <pre>
     * The precise index of the key being identified.
     * </pre>
     *
     * <code>int32 key_index = 2;</code>
     */
    private void clearKeyIndex() {
      
      keyIndex_ = 0;
    }

    public static co.anode.anodium.Rpc.KeyLocator parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.KeyLocator parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.KeyLocator parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.KeyLocator parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.KeyLocator parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.KeyLocator parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.KeyLocator parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.KeyLocator parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.KeyLocator parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.KeyLocator parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.KeyLocator parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.KeyLocator parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.KeyLocator prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.KeyLocator}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.KeyLocator, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.KeyLocator)
        co.anode.anodium.Rpc.KeyLocatorOrBuilder {
      // Construct using co.anode.anodium.Rpc.KeyLocator.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The family of key being identified.
       * </pre>
       *
       * <code>int32 key_family = 1;</code>
       * @return The keyFamily.
       */
      @java.lang.Override
      public int getKeyFamily() {
        return instance.getKeyFamily();
      }
      /**
       * <pre>
       * The family of key being identified.
       * </pre>
       *
       * <code>int32 key_family = 1;</code>
       * @param value The keyFamily to set.
       * @return This builder for chaining.
       */
      public Builder setKeyFamily(int value) {
        copyOnWrite();
        instance.setKeyFamily(value);
        return this;
      }
      /**
       * <pre>
       * The family of key being identified.
       * </pre>
       *
       * <code>int32 key_family = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeyFamily() {
        copyOnWrite();
        instance.clearKeyFamily();
        return this;
      }

      /**
       * <pre>
       * The precise index of the key being identified.
       * </pre>
       *
       * <code>int32 key_index = 2;</code>
       * @return The keyIndex.
       */
      @java.lang.Override
      public int getKeyIndex() {
        return instance.getKeyIndex();
      }
      /**
       * <pre>
       * The precise index of the key being identified.
       * </pre>
       *
       * <code>int32 key_index = 2;</code>
       * @param value The keyIndex to set.
       * @return This builder for chaining.
       */
      public Builder setKeyIndex(int value) {
        copyOnWrite();
        instance.setKeyIndex(value);
        return this;
      }
      /**
       * <pre>
       * The precise index of the key being identified.
       * </pre>
       *
       * <code>int32 key_index = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeyIndex() {
        copyOnWrite();
        instance.clearKeyIndex();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.KeyLocator)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.KeyLocator();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "keyFamily_",
              "keyIndex_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0004\u0002\u0004" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.KeyLocator> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.KeyLocator.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.KeyLocator>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.KeyLocator)
    private static final co.anode.anodium.Rpc.KeyLocator DEFAULT_INSTANCE;
    static {
      KeyLocator defaultInstance = new KeyLocator();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        KeyLocator.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.KeyLocator getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<KeyLocator> PARSER;

    public static com.google.protobuf.Parser<KeyLocator> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface KeyDescriptorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.KeyDescriptor)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The raw bytes of the key being identified.
     * </pre>
     *
     * <code>bytes raw_key_bytes = 1;</code>
     * @return The rawKeyBytes.
     */
    com.google.protobuf.ByteString getRawKeyBytes();

    /**
     * <pre>
     *The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.co.anode.anodium.KeyLocator key_loc = 2;</code>
     * @return Whether the keyLoc field is set.
     */
    boolean hasKeyLoc();
    /**
     * <pre>
     *The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.co.anode.anodium.KeyLocator key_loc = 2;</code>
     * @return The keyLoc.
     */
    co.anode.anodium.Rpc.KeyLocator getKeyLoc();
  }
  /**
   * Protobuf type {@code co.anode.anodium.KeyDescriptor}
   */
  public  static final class KeyDescriptor extends
      com.google.protobuf.GeneratedMessageLite<
          KeyDescriptor, KeyDescriptor.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.KeyDescriptor)
      KeyDescriptorOrBuilder {
    private KeyDescriptor() {
      rawKeyBytes_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int RAW_KEY_BYTES_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString rawKeyBytes_;
    /**
     * <pre>
     *The raw bytes of the key being identified.
     * </pre>
     *
     * <code>bytes raw_key_bytes = 1;</code>
     * @return The rawKeyBytes.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getRawKeyBytes() {
      return rawKeyBytes_;
    }
    /**
     * <pre>
     *The raw bytes of the key being identified.
     * </pre>
     *
     * <code>bytes raw_key_bytes = 1;</code>
     * @param value The rawKeyBytes to set.
     */
    private void setRawKeyBytes(com.google.protobuf.ByteString value) {
      value.getClass();
  
      rawKeyBytes_ = value;
    }
    /**
     * <pre>
     *The raw bytes of the key being identified.
     * </pre>
     *
     * <code>bytes raw_key_bytes = 1;</code>
     */
    private void clearRawKeyBytes() {
      
      rawKeyBytes_ = getDefaultInstance().getRawKeyBytes();
    }

    public static final int KEY_LOC_FIELD_NUMBER = 2;
    private co.anode.anodium.Rpc.KeyLocator keyLoc_;
    /**
     * <pre>
     *The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.co.anode.anodium.KeyLocator key_loc = 2;</code>
     */
    @java.lang.Override
    public boolean hasKeyLoc() {
      return keyLoc_ != null;
    }
    /**
     * <pre>
     *The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.co.anode.anodium.KeyLocator key_loc = 2;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.KeyLocator getKeyLoc() {
      return keyLoc_ == null ? co.anode.anodium.Rpc.KeyLocator.getDefaultInstance() : keyLoc_;
    }
    /**
     * <pre>
     *The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.co.anode.anodium.KeyLocator key_loc = 2;</code>
     */
    private void setKeyLoc(co.anode.anodium.Rpc.KeyLocator value) {
      value.getClass();
  keyLoc_ = value;
      
      }
    /**
     * <pre>
     *The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.co.anode.anodium.KeyLocator key_loc = 2;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeKeyLoc(co.anode.anodium.Rpc.KeyLocator value) {
      value.getClass();
  if (keyLoc_ != null &&
          keyLoc_ != co.anode.anodium.Rpc.KeyLocator.getDefaultInstance()) {
        keyLoc_ =
          co.anode.anodium.Rpc.KeyLocator.newBuilder(keyLoc_).mergeFrom(value).buildPartial();
      } else {
        keyLoc_ = value;
      }
      
    }
    /**
     * <pre>
     *The key locator that identifies which key to use for signing.
     * </pre>
     *
     * <code>.co.anode.anodium.KeyLocator key_loc = 2;</code>
     */
    private void clearKeyLoc() {  keyLoc_ = null;
      
    }

    public static co.anode.anodium.Rpc.KeyDescriptor parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.KeyDescriptor parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.KeyDescriptor parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.KeyDescriptor parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.KeyDescriptor parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.KeyDescriptor parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.KeyDescriptor parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.KeyDescriptor parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.KeyDescriptor parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.KeyDescriptor parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.KeyDescriptor parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.KeyDescriptor parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.KeyDescriptor prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.KeyDescriptor}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.KeyDescriptor, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.KeyDescriptor)
        co.anode.anodium.Rpc.KeyDescriptorOrBuilder {
      // Construct using co.anode.anodium.Rpc.KeyDescriptor.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The raw bytes of the key being identified.
       * </pre>
       *
       * <code>bytes raw_key_bytes = 1;</code>
       * @return The rawKeyBytes.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getRawKeyBytes() {
        return instance.getRawKeyBytes();
      }
      /**
       * <pre>
       *The raw bytes of the key being identified.
       * </pre>
       *
       * <code>bytes raw_key_bytes = 1;</code>
       * @param value The rawKeyBytes to set.
       * @return This builder for chaining.
       */
      public Builder setRawKeyBytes(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setRawKeyBytes(value);
        return this;
      }
      /**
       * <pre>
       *The raw bytes of the key being identified.
       * </pre>
       *
       * <code>bytes raw_key_bytes = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRawKeyBytes() {
        copyOnWrite();
        instance.clearRawKeyBytes();
        return this;
      }

      /**
       * <pre>
       *The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.co.anode.anodium.KeyLocator key_loc = 2;</code>
       */
      @java.lang.Override
      public boolean hasKeyLoc() {
        return instance.hasKeyLoc();
      }
      /**
       * <pre>
       *The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.co.anode.anodium.KeyLocator key_loc = 2;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.KeyLocator getKeyLoc() {
        return instance.getKeyLoc();
      }
      /**
       * <pre>
       *The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.co.anode.anodium.KeyLocator key_loc = 2;</code>
       */
      public Builder setKeyLoc(co.anode.anodium.Rpc.KeyLocator value) {
        copyOnWrite();
        instance.setKeyLoc(value);
        return this;
        }
      /**
       * <pre>
       *The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.co.anode.anodium.KeyLocator key_loc = 2;</code>
       */
      public Builder setKeyLoc(
          co.anode.anodium.Rpc.KeyLocator.Builder builderForValue) {
        copyOnWrite();
        instance.setKeyLoc(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.co.anode.anodium.KeyLocator key_loc = 2;</code>
       */
      public Builder mergeKeyLoc(co.anode.anodium.Rpc.KeyLocator value) {
        copyOnWrite();
        instance.mergeKeyLoc(value);
        return this;
      }
      /**
       * <pre>
       *The key locator that identifies which key to use for signing.
       * </pre>
       *
       * <code>.co.anode.anodium.KeyLocator key_loc = 2;</code>
       */
      public Builder clearKeyLoc() {  copyOnWrite();
        instance.clearKeyLoc();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.KeyDescriptor)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.KeyDescriptor();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "rawKeyBytes_",
              "keyLoc_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\n\u0002\t";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.KeyDescriptor> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.KeyDescriptor.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.KeyDescriptor>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.KeyDescriptor)
    private static final co.anode.anodium.Rpc.KeyDescriptor DEFAULT_INSTANCE;
    static {
      KeyDescriptor defaultInstance = new KeyDescriptor();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        KeyDescriptor.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.KeyDescriptor getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<KeyDescriptor> PARSER;

    public static com.google.protobuf.Parser<KeyDescriptor> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChanPointShimOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChanPointShim)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The size of the pre-crafted output to be used as the channel point for this
     *channel funding.
     * </pre>
     *
     * <code>int64 amt = 1;</code>
     * @return The amt.
     */
    long getAmt();

    /**
     * <pre>
     * The target channel point to refrence in created commitment transactions.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     * @return Whether the chanPoint field is set.
     */
    boolean hasChanPoint();
    /**
     * <pre>
     * The target channel point to refrence in created commitment transactions.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     * @return The chanPoint.
     */
    co.anode.anodium.Rpc.ChannelPoint getChanPoint();

    /**
     * <pre>
     * Our local key to use when creating the multi-sig output.
     * </pre>
     *
     * <code>.co.anode.anodium.KeyDescriptor local_key = 3;</code>
     * @return Whether the localKey field is set.
     */
    boolean hasLocalKey();
    /**
     * <pre>
     * Our local key to use when creating the multi-sig output.
     * </pre>
     *
     * <code>.co.anode.anodium.KeyDescriptor local_key = 3;</code>
     * @return The localKey.
     */
    co.anode.anodium.Rpc.KeyDescriptor getLocalKey();

    /**
     * <pre>
     * The key of the remote party to use when creating the multi-sig output.
     * </pre>
     *
     * <code>bytes remote_key = 4;</code>
     * @return The remoteKey.
     */
    com.google.protobuf.ByteString getRemoteKey();

    /**
     * <pre>
     *If non-zero, then this will be used as the pending channel ID on the wire
     *protocol to initate the funding request. This is an optional field, and
     *should only be set if the responder is already expecting a specific pending
     *channel ID.
     * </pre>
     *
     * <code>bytes pending_chan_id = 5;</code>
     * @return The pendingChanId.
     */
    com.google.protobuf.ByteString getPendingChanId();

    /**
     * <pre>
     *This uint32 indicates if this channel is to be considered 'frozen'. A frozen
     *channel does not allow a cooperative channel close by the initiator. The
     *thaw_height is the height that this restriction stops applying to the
     *channel. The height can be interpreted in two ways: as a relative height if
     *the value is less than 500,000, or as an absolute height otherwise.
     * </pre>
     *
     * <code>uint32 thaw_height = 6;</code>
     * @return The thawHeight.
     */
    int getThawHeight();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChanPointShim}
   */
  public  static final class ChanPointShim extends
      com.google.protobuf.GeneratedMessageLite<
          ChanPointShim, ChanPointShim.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChanPointShim)
      ChanPointShimOrBuilder {
    private ChanPointShim() {
      remoteKey_ = com.google.protobuf.ByteString.EMPTY;
      pendingChanId_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int AMT_FIELD_NUMBER = 1;
    private long amt_;
    /**
     * <pre>
     *The size of the pre-crafted output to be used as the channel point for this
     *channel funding.
     * </pre>
     *
     * <code>int64 amt = 1;</code>
     * @return The amt.
     */
    @java.lang.Override
    public long getAmt() {
      return amt_;
    }
    /**
     * <pre>
     *The size of the pre-crafted output to be used as the channel point for this
     *channel funding.
     * </pre>
     *
     * <code>int64 amt = 1;</code>
     * @param value The amt to set.
     */
    private void setAmt(long value) {
      
      amt_ = value;
    }
    /**
     * <pre>
     *The size of the pre-crafted output to be used as the channel point for this
     *channel funding.
     * </pre>
     *
     * <code>int64 amt = 1;</code>
     */
    private void clearAmt() {
      
      amt_ = 0L;
    }

    public static final int CHAN_POINT_FIELD_NUMBER = 2;
    private co.anode.anodium.Rpc.ChannelPoint chanPoint_;
    /**
     * <pre>
     * The target channel point to refrence in created commitment transactions.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     */
    @java.lang.Override
    public boolean hasChanPoint() {
      return chanPoint_ != null;
    }
    /**
     * <pre>
     * The target channel point to refrence in created commitment transactions.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelPoint getChanPoint() {
      return chanPoint_ == null ? co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance() : chanPoint_;
    }
    /**
     * <pre>
     * The target channel point to refrence in created commitment transactions.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     */
    private void setChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  chanPoint_ = value;
      
      }
    /**
     * <pre>
     * The target channel point to refrence in created commitment transactions.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  if (chanPoint_ != null &&
          chanPoint_ != co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance()) {
        chanPoint_ =
          co.anode.anodium.Rpc.ChannelPoint.newBuilder(chanPoint_).mergeFrom(value).buildPartial();
      } else {
        chanPoint_ = value;
      }
      
    }
    /**
     * <pre>
     * The target channel point to refrence in created commitment transactions.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     */
    private void clearChanPoint() {  chanPoint_ = null;
      
    }

    public static final int LOCAL_KEY_FIELD_NUMBER = 3;
    private co.anode.anodium.Rpc.KeyDescriptor localKey_;
    /**
     * <pre>
     * Our local key to use when creating the multi-sig output.
     * </pre>
     *
     * <code>.co.anode.anodium.KeyDescriptor local_key = 3;</code>
     */
    @java.lang.Override
    public boolean hasLocalKey() {
      return localKey_ != null;
    }
    /**
     * <pre>
     * Our local key to use when creating the multi-sig output.
     * </pre>
     *
     * <code>.co.anode.anodium.KeyDescriptor local_key = 3;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.KeyDescriptor getLocalKey() {
      return localKey_ == null ? co.anode.anodium.Rpc.KeyDescriptor.getDefaultInstance() : localKey_;
    }
    /**
     * <pre>
     * Our local key to use when creating the multi-sig output.
     * </pre>
     *
     * <code>.co.anode.anodium.KeyDescriptor local_key = 3;</code>
     */
    private void setLocalKey(co.anode.anodium.Rpc.KeyDescriptor value) {
      value.getClass();
  localKey_ = value;
      
      }
    /**
     * <pre>
     * Our local key to use when creating the multi-sig output.
     * </pre>
     *
     * <code>.co.anode.anodium.KeyDescriptor local_key = 3;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeLocalKey(co.anode.anodium.Rpc.KeyDescriptor value) {
      value.getClass();
  if (localKey_ != null &&
          localKey_ != co.anode.anodium.Rpc.KeyDescriptor.getDefaultInstance()) {
        localKey_ =
          co.anode.anodium.Rpc.KeyDescriptor.newBuilder(localKey_).mergeFrom(value).buildPartial();
      } else {
        localKey_ = value;
      }
      
    }
    /**
     * <pre>
     * Our local key to use when creating the multi-sig output.
     * </pre>
     *
     * <code>.co.anode.anodium.KeyDescriptor local_key = 3;</code>
     */
    private void clearLocalKey() {  localKey_ = null;
      
    }

    public static final int REMOTE_KEY_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString remoteKey_;
    /**
     * <pre>
     * The key of the remote party to use when creating the multi-sig output.
     * </pre>
     *
     * <code>bytes remote_key = 4;</code>
     * @return The remoteKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getRemoteKey() {
      return remoteKey_;
    }
    /**
     * <pre>
     * The key of the remote party to use when creating the multi-sig output.
     * </pre>
     *
     * <code>bytes remote_key = 4;</code>
     * @param value The remoteKey to set.
     */
    private void setRemoteKey(com.google.protobuf.ByteString value) {
      value.getClass();
  
      remoteKey_ = value;
    }
    /**
     * <pre>
     * The key of the remote party to use when creating the multi-sig output.
     * </pre>
     *
     * <code>bytes remote_key = 4;</code>
     */
    private void clearRemoteKey() {
      
      remoteKey_ = getDefaultInstance().getRemoteKey();
    }

    public static final int PENDING_CHAN_ID_FIELD_NUMBER = 5;
    private com.google.protobuf.ByteString pendingChanId_;
    /**
     * <pre>
     *If non-zero, then this will be used as the pending channel ID on the wire
     *protocol to initate the funding request. This is an optional field, and
     *should only be set if the responder is already expecting a specific pending
     *channel ID.
     * </pre>
     *
     * <code>bytes pending_chan_id = 5;</code>
     * @return The pendingChanId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPendingChanId() {
      return pendingChanId_;
    }
    /**
     * <pre>
     *If non-zero, then this will be used as the pending channel ID on the wire
     *protocol to initate the funding request. This is an optional field, and
     *should only be set if the responder is already expecting a specific pending
     *channel ID.
     * </pre>
     *
     * <code>bytes pending_chan_id = 5;</code>
     * @param value The pendingChanId to set.
     */
    private void setPendingChanId(com.google.protobuf.ByteString value) {
      value.getClass();
  
      pendingChanId_ = value;
    }
    /**
     * <pre>
     *If non-zero, then this will be used as the pending channel ID on the wire
     *protocol to initate the funding request. This is an optional field, and
     *should only be set if the responder is already expecting a specific pending
     *channel ID.
     * </pre>
     *
     * <code>bytes pending_chan_id = 5;</code>
     */
    private void clearPendingChanId() {
      
      pendingChanId_ = getDefaultInstance().getPendingChanId();
    }

    public static final int THAW_HEIGHT_FIELD_NUMBER = 6;
    private int thawHeight_;
    /**
     * <pre>
     *This uint32 indicates if this channel is to be considered 'frozen'. A frozen
     *channel does not allow a cooperative channel close by the initiator. The
     *thaw_height is the height that this restriction stops applying to the
     *channel. The height can be interpreted in two ways: as a relative height if
     *the value is less than 500,000, or as an absolute height otherwise.
     * </pre>
     *
     * <code>uint32 thaw_height = 6;</code>
     * @return The thawHeight.
     */
    @java.lang.Override
    public int getThawHeight() {
      return thawHeight_;
    }
    /**
     * <pre>
     *This uint32 indicates if this channel is to be considered 'frozen'. A frozen
     *channel does not allow a cooperative channel close by the initiator. The
     *thaw_height is the height that this restriction stops applying to the
     *channel. The height can be interpreted in two ways: as a relative height if
     *the value is less than 500,000, or as an absolute height otherwise.
     * </pre>
     *
     * <code>uint32 thaw_height = 6;</code>
     * @param value The thawHeight to set.
     */
    private void setThawHeight(int value) {
      
      thawHeight_ = value;
    }
    /**
     * <pre>
     *This uint32 indicates if this channel is to be considered 'frozen'. A frozen
     *channel does not allow a cooperative channel close by the initiator. The
     *thaw_height is the height that this restriction stops applying to the
     *channel. The height can be interpreted in two ways: as a relative height if
     *the value is less than 500,000, or as an absolute height otherwise.
     * </pre>
     *
     * <code>uint32 thaw_height = 6;</code>
     */
    private void clearThawHeight() {
      
      thawHeight_ = 0;
    }

    public static co.anode.anodium.Rpc.ChanPointShim parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChanPointShim parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanPointShim parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChanPointShim parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanPointShim parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChanPointShim parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanPointShim parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChanPointShim parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanPointShim parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChanPointShim parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanPointShim parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChanPointShim parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChanPointShim prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChanPointShim}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChanPointShim, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChanPointShim)
        co.anode.anodium.Rpc.ChanPointShimOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChanPointShim.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The size of the pre-crafted output to be used as the channel point for this
       *channel funding.
       * </pre>
       *
       * <code>int64 amt = 1;</code>
       * @return The amt.
       */
      @java.lang.Override
      public long getAmt() {
        return instance.getAmt();
      }
      /**
       * <pre>
       *The size of the pre-crafted output to be used as the channel point for this
       *channel funding.
       * </pre>
       *
       * <code>int64 amt = 1;</code>
       * @param value The amt to set.
       * @return This builder for chaining.
       */
      public Builder setAmt(long value) {
        copyOnWrite();
        instance.setAmt(value);
        return this;
      }
      /**
       * <pre>
       *The size of the pre-crafted output to be used as the channel point for this
       *channel funding.
       * </pre>
       *
       * <code>int64 amt = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmt() {
        copyOnWrite();
        instance.clearAmt();
        return this;
      }

      /**
       * <pre>
       * The target channel point to refrence in created commitment transactions.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
       */
      @java.lang.Override
      public boolean hasChanPoint() {
        return instance.hasChanPoint();
      }
      /**
       * <pre>
       * The target channel point to refrence in created commitment transactions.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelPoint getChanPoint() {
        return instance.getChanPoint();
      }
      /**
       * <pre>
       * The target channel point to refrence in created commitment transactions.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
       */
      public Builder setChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.setChanPoint(value);
        return this;
        }
      /**
       * <pre>
       * The target channel point to refrence in created commitment transactions.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
       */
      public Builder setChanPoint(
          co.anode.anodium.Rpc.ChannelPoint.Builder builderForValue) {
        copyOnWrite();
        instance.setChanPoint(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The target channel point to refrence in created commitment transactions.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
       */
      public Builder mergeChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.mergeChanPoint(value);
        return this;
      }
      /**
       * <pre>
       * The target channel point to refrence in created commitment transactions.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
       */
      public Builder clearChanPoint() {  copyOnWrite();
        instance.clearChanPoint();
        return this;
      }

      /**
       * <pre>
       * Our local key to use when creating the multi-sig output.
       * </pre>
       *
       * <code>.co.anode.anodium.KeyDescriptor local_key = 3;</code>
       */
      @java.lang.Override
      public boolean hasLocalKey() {
        return instance.hasLocalKey();
      }
      /**
       * <pre>
       * Our local key to use when creating the multi-sig output.
       * </pre>
       *
       * <code>.co.anode.anodium.KeyDescriptor local_key = 3;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.KeyDescriptor getLocalKey() {
        return instance.getLocalKey();
      }
      /**
       * <pre>
       * Our local key to use when creating the multi-sig output.
       * </pre>
       *
       * <code>.co.anode.anodium.KeyDescriptor local_key = 3;</code>
       */
      public Builder setLocalKey(co.anode.anodium.Rpc.KeyDescriptor value) {
        copyOnWrite();
        instance.setLocalKey(value);
        return this;
        }
      /**
       * <pre>
       * Our local key to use when creating the multi-sig output.
       * </pre>
       *
       * <code>.co.anode.anodium.KeyDescriptor local_key = 3;</code>
       */
      public Builder setLocalKey(
          co.anode.anodium.Rpc.KeyDescriptor.Builder builderForValue) {
        copyOnWrite();
        instance.setLocalKey(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Our local key to use when creating the multi-sig output.
       * </pre>
       *
       * <code>.co.anode.anodium.KeyDescriptor local_key = 3;</code>
       */
      public Builder mergeLocalKey(co.anode.anodium.Rpc.KeyDescriptor value) {
        copyOnWrite();
        instance.mergeLocalKey(value);
        return this;
      }
      /**
       * <pre>
       * Our local key to use when creating the multi-sig output.
       * </pre>
       *
       * <code>.co.anode.anodium.KeyDescriptor local_key = 3;</code>
       */
      public Builder clearLocalKey() {  copyOnWrite();
        instance.clearLocalKey();
        return this;
      }

      /**
       * <pre>
       * The key of the remote party to use when creating the multi-sig output.
       * </pre>
       *
       * <code>bytes remote_key = 4;</code>
       * @return The remoteKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getRemoteKey() {
        return instance.getRemoteKey();
      }
      /**
       * <pre>
       * The key of the remote party to use when creating the multi-sig output.
       * </pre>
       *
       * <code>bytes remote_key = 4;</code>
       * @param value The remoteKey to set.
       * @return This builder for chaining.
       */
      public Builder setRemoteKey(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setRemoteKey(value);
        return this;
      }
      /**
       * <pre>
       * The key of the remote party to use when creating the multi-sig output.
       * </pre>
       *
       * <code>bytes remote_key = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearRemoteKey() {
        copyOnWrite();
        instance.clearRemoteKey();
        return this;
      }

      /**
       * <pre>
       *If non-zero, then this will be used as the pending channel ID on the wire
       *protocol to initate the funding request. This is an optional field, and
       *should only be set if the responder is already expecting a specific pending
       *channel ID.
       * </pre>
       *
       * <code>bytes pending_chan_id = 5;</code>
       * @return The pendingChanId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPendingChanId() {
        return instance.getPendingChanId();
      }
      /**
       * <pre>
       *If non-zero, then this will be used as the pending channel ID on the wire
       *protocol to initate the funding request. This is an optional field, and
       *should only be set if the responder is already expecting a specific pending
       *channel ID.
       * </pre>
       *
       * <code>bytes pending_chan_id = 5;</code>
       * @param value The pendingChanId to set.
       * @return This builder for chaining.
       */
      public Builder setPendingChanId(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPendingChanId(value);
        return this;
      }
      /**
       * <pre>
       *If non-zero, then this will be used as the pending channel ID on the wire
       *protocol to initate the funding request. This is an optional field, and
       *should only be set if the responder is already expecting a specific pending
       *channel ID.
       * </pre>
       *
       * <code>bytes pending_chan_id = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearPendingChanId() {
        copyOnWrite();
        instance.clearPendingChanId();
        return this;
      }

      /**
       * <pre>
       *This uint32 indicates if this channel is to be considered 'frozen'. A frozen
       *channel does not allow a cooperative channel close by the initiator. The
       *thaw_height is the height that this restriction stops applying to the
       *channel. The height can be interpreted in two ways: as a relative height if
       *the value is less than 500,000, or as an absolute height otherwise.
       * </pre>
       *
       * <code>uint32 thaw_height = 6;</code>
       * @return The thawHeight.
       */
      @java.lang.Override
      public int getThawHeight() {
        return instance.getThawHeight();
      }
      /**
       * <pre>
       *This uint32 indicates if this channel is to be considered 'frozen'. A frozen
       *channel does not allow a cooperative channel close by the initiator. The
       *thaw_height is the height that this restriction stops applying to the
       *channel. The height can be interpreted in two ways: as a relative height if
       *the value is less than 500,000, or as an absolute height otherwise.
       * </pre>
       *
       * <code>uint32 thaw_height = 6;</code>
       * @param value The thawHeight to set.
       * @return This builder for chaining.
       */
      public Builder setThawHeight(int value) {
        copyOnWrite();
        instance.setThawHeight(value);
        return this;
      }
      /**
       * <pre>
       *This uint32 indicates if this channel is to be considered 'frozen'. A frozen
       *channel does not allow a cooperative channel close by the initiator. The
       *thaw_height is the height that this restriction stops applying to the
       *channel. The height can be interpreted in two ways: as a relative height if
       *the value is less than 500,000, or as an absolute height otherwise.
       * </pre>
       *
       * <code>uint32 thaw_height = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearThawHeight() {
        copyOnWrite();
        instance.clearThawHeight();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChanPointShim)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChanPointShim();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "amt_",
              "chanPoint_",
              "localKey_",
              "remoteKey_",
              "pendingChanId_",
              "thawHeight_",
            };
            java.lang.String info =
                "\u0000\u0006\u0000\u0000\u0001\u0006\u0006\u0000\u0000\u0000\u0001\u0002\u0002\t" +
                "\u0003\t\u0004\n\u0005\n\u0006\u000b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChanPointShim> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChanPointShim.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChanPointShim>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChanPointShim)
    private static final co.anode.anodium.Rpc.ChanPointShim DEFAULT_INSTANCE;
    static {
      ChanPointShim defaultInstance = new ChanPointShim();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChanPointShim.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChanPointShim getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChanPointShim> PARSER;

    public static com.google.protobuf.Parser<ChanPointShim> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PsbtShimOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.PsbtShim)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *A unique identifier of 32 random bytes that will be used as the pending
     *channel ID to identify the PSBT state machine when interacting with it and
     *on the wire protocol to initiate the funding request.
     * </pre>
     *
     * <code>bytes pending_chan_id = 1;</code>
     * @return The pendingChanId.
     */
    com.google.protobuf.ByteString getPendingChanId();

    /**
     * <pre>
     *An optional base PSBT the new channel output will be added to. If this is
     *non-empty, it must be a binary serialized PSBT.
     * </pre>
     *
     * <code>bytes base_psbt = 2;</code>
     * @return The basePsbt.
     */
    com.google.protobuf.ByteString getBasePsbt();

    /**
     * <pre>
     *If a channel should be part of a batch (multiple channel openings in one
     *transaction), it can be dangerous if the whole batch transaction is
     *published too early before all channel opening negotiations are completed.
     *This flag prevents this particular channel from broadcasting the transaction
     *after the negotiation with the remote peer. In a batch of channel openings
     *this flag should be set to true for every channel but the very last.
     * </pre>
     *
     * <code>bool no_publish = 3;</code>
     * @return The noPublish.
     */
    boolean getNoPublish();
  }
  /**
   * Protobuf type {@code co.anode.anodium.PsbtShim}
   */
  public  static final class PsbtShim extends
      com.google.protobuf.GeneratedMessageLite<
          PsbtShim, PsbtShim.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.PsbtShim)
      PsbtShimOrBuilder {
    private PsbtShim() {
      pendingChanId_ = com.google.protobuf.ByteString.EMPTY;
      basePsbt_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int PENDING_CHAN_ID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString pendingChanId_;
    /**
     * <pre>
     *A unique identifier of 32 random bytes that will be used as the pending
     *channel ID to identify the PSBT state machine when interacting with it and
     *on the wire protocol to initiate the funding request.
     * </pre>
     *
     * <code>bytes pending_chan_id = 1;</code>
     * @return The pendingChanId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPendingChanId() {
      return pendingChanId_;
    }
    /**
     * <pre>
     *A unique identifier of 32 random bytes that will be used as the pending
     *channel ID to identify the PSBT state machine when interacting with it and
     *on the wire protocol to initiate the funding request.
     * </pre>
     *
     * <code>bytes pending_chan_id = 1;</code>
     * @param value The pendingChanId to set.
     */
    private void setPendingChanId(com.google.protobuf.ByteString value) {
      value.getClass();
  
      pendingChanId_ = value;
    }
    /**
     * <pre>
     *A unique identifier of 32 random bytes that will be used as the pending
     *channel ID to identify the PSBT state machine when interacting with it and
     *on the wire protocol to initiate the funding request.
     * </pre>
     *
     * <code>bytes pending_chan_id = 1;</code>
     */
    private void clearPendingChanId() {
      
      pendingChanId_ = getDefaultInstance().getPendingChanId();
    }

    public static final int BASE_PSBT_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString basePsbt_;
    /**
     * <pre>
     *An optional base PSBT the new channel output will be added to. If this is
     *non-empty, it must be a binary serialized PSBT.
     * </pre>
     *
     * <code>bytes base_psbt = 2;</code>
     * @return The basePsbt.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getBasePsbt() {
      return basePsbt_;
    }
    /**
     * <pre>
     *An optional base PSBT the new channel output will be added to. If this is
     *non-empty, it must be a binary serialized PSBT.
     * </pre>
     *
     * <code>bytes base_psbt = 2;</code>
     * @param value The basePsbt to set.
     */
    private void setBasePsbt(com.google.protobuf.ByteString value) {
      value.getClass();
  
      basePsbt_ = value;
    }
    /**
     * <pre>
     *An optional base PSBT the new channel output will be added to. If this is
     *non-empty, it must be a binary serialized PSBT.
     * </pre>
     *
     * <code>bytes base_psbt = 2;</code>
     */
    private void clearBasePsbt() {
      
      basePsbt_ = getDefaultInstance().getBasePsbt();
    }

    public static final int NO_PUBLISH_FIELD_NUMBER = 3;
    private boolean noPublish_;
    /**
     * <pre>
     *If a channel should be part of a batch (multiple channel openings in one
     *transaction), it can be dangerous if the whole batch transaction is
     *published too early before all channel opening negotiations are completed.
     *This flag prevents this particular channel from broadcasting the transaction
     *after the negotiation with the remote peer. In a batch of channel openings
     *this flag should be set to true for every channel but the very last.
     * </pre>
     *
     * <code>bool no_publish = 3;</code>
     * @return The noPublish.
     */
    @java.lang.Override
    public boolean getNoPublish() {
      return noPublish_;
    }
    /**
     * <pre>
     *If a channel should be part of a batch (multiple channel openings in one
     *transaction), it can be dangerous if the whole batch transaction is
     *published too early before all channel opening negotiations are completed.
     *This flag prevents this particular channel from broadcasting the transaction
     *after the negotiation with the remote peer. In a batch of channel openings
     *this flag should be set to true for every channel but the very last.
     * </pre>
     *
     * <code>bool no_publish = 3;</code>
     * @param value The noPublish to set.
     */
    private void setNoPublish(boolean value) {
      
      noPublish_ = value;
    }
    /**
     * <pre>
     *If a channel should be part of a batch (multiple channel openings in one
     *transaction), it can be dangerous if the whole batch transaction is
     *published too early before all channel opening negotiations are completed.
     *This flag prevents this particular channel from broadcasting the transaction
     *after the negotiation with the remote peer. In a batch of channel openings
     *this flag should be set to true for every channel but the very last.
     * </pre>
     *
     * <code>bool no_publish = 3;</code>
     */
    private void clearNoPublish() {
      
      noPublish_ = false;
    }

    public static co.anode.anodium.Rpc.PsbtShim parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PsbtShim parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PsbtShim parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PsbtShim parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PsbtShim parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PsbtShim parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PsbtShim parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PsbtShim parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PsbtShim parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PsbtShim parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PsbtShim parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PsbtShim parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.PsbtShim prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.PsbtShim}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.PsbtShim, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.PsbtShim)
        co.anode.anodium.Rpc.PsbtShimOrBuilder {
      // Construct using co.anode.anodium.Rpc.PsbtShim.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *A unique identifier of 32 random bytes that will be used as the pending
       *channel ID to identify the PSBT state machine when interacting with it and
       *on the wire protocol to initiate the funding request.
       * </pre>
       *
       * <code>bytes pending_chan_id = 1;</code>
       * @return The pendingChanId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPendingChanId() {
        return instance.getPendingChanId();
      }
      /**
       * <pre>
       *A unique identifier of 32 random bytes that will be used as the pending
       *channel ID to identify the PSBT state machine when interacting with it and
       *on the wire protocol to initiate the funding request.
       * </pre>
       *
       * <code>bytes pending_chan_id = 1;</code>
       * @param value The pendingChanId to set.
       * @return This builder for chaining.
       */
      public Builder setPendingChanId(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPendingChanId(value);
        return this;
      }
      /**
       * <pre>
       *A unique identifier of 32 random bytes that will be used as the pending
       *channel ID to identify the PSBT state machine when interacting with it and
       *on the wire protocol to initiate the funding request.
       * </pre>
       *
       * <code>bytes pending_chan_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPendingChanId() {
        copyOnWrite();
        instance.clearPendingChanId();
        return this;
      }

      /**
       * <pre>
       *An optional base PSBT the new channel output will be added to. If this is
       *non-empty, it must be a binary serialized PSBT.
       * </pre>
       *
       * <code>bytes base_psbt = 2;</code>
       * @return The basePsbt.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getBasePsbt() {
        return instance.getBasePsbt();
      }
      /**
       * <pre>
       *An optional base PSBT the new channel output will be added to. If this is
       *non-empty, it must be a binary serialized PSBT.
       * </pre>
       *
       * <code>bytes base_psbt = 2;</code>
       * @param value The basePsbt to set.
       * @return This builder for chaining.
       */
      public Builder setBasePsbt(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setBasePsbt(value);
        return this;
      }
      /**
       * <pre>
       *An optional base PSBT the new channel output will be added to. If this is
       *non-empty, it must be a binary serialized PSBT.
       * </pre>
       *
       * <code>bytes base_psbt = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearBasePsbt() {
        copyOnWrite();
        instance.clearBasePsbt();
        return this;
      }

      /**
       * <pre>
       *If a channel should be part of a batch (multiple channel openings in one
       *transaction), it can be dangerous if the whole batch transaction is
       *published too early before all channel opening negotiations are completed.
       *This flag prevents this particular channel from broadcasting the transaction
       *after the negotiation with the remote peer. In a batch of channel openings
       *this flag should be set to true for every channel but the very last.
       * </pre>
       *
       * <code>bool no_publish = 3;</code>
       * @return The noPublish.
       */
      @java.lang.Override
      public boolean getNoPublish() {
        return instance.getNoPublish();
      }
      /**
       * <pre>
       *If a channel should be part of a batch (multiple channel openings in one
       *transaction), it can be dangerous if the whole batch transaction is
       *published too early before all channel opening negotiations are completed.
       *This flag prevents this particular channel from broadcasting the transaction
       *after the negotiation with the remote peer. In a batch of channel openings
       *this flag should be set to true for every channel but the very last.
       * </pre>
       *
       * <code>bool no_publish = 3;</code>
       * @param value The noPublish to set.
       * @return This builder for chaining.
       */
      public Builder setNoPublish(boolean value) {
        copyOnWrite();
        instance.setNoPublish(value);
        return this;
      }
      /**
       * <pre>
       *If a channel should be part of a batch (multiple channel openings in one
       *transaction), it can be dangerous if the whole batch transaction is
       *published too early before all channel opening negotiations are completed.
       *This flag prevents this particular channel from broadcasting the transaction
       *after the negotiation with the remote peer. In a batch of channel openings
       *this flag should be set to true for every channel but the very last.
       * </pre>
       *
       * <code>bool no_publish = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearNoPublish() {
        copyOnWrite();
        instance.clearNoPublish();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.PsbtShim)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.PsbtShim();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "pendingChanId_",
              "basePsbt_",
              "noPublish_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0003\u0003\u0000\u0000\u0000\u0001\n\u0002\n\u0003" +
                "\u0007";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.PsbtShim> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.PsbtShim.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.PsbtShim>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.PsbtShim)
    private static final co.anode.anodium.Rpc.PsbtShim DEFAULT_INSTANCE;
    static {
      PsbtShim defaultInstance = new PsbtShim();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        PsbtShim.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.PsbtShim getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<PsbtShim> PARSER;

    public static com.google.protobuf.Parser<PsbtShim> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FundingShimOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.FundingShim)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *A channel shim where the channel point was fully constructed outside
     *of lnd's wallet and the transaction might already be published.
     * </pre>
     *
     * <code>.co.anode.anodium.ChanPointShim chan_point_shim = 1;</code>
     * @return Whether the chanPointShim field is set.
     */
    boolean hasChanPointShim();
    /**
     * <pre>
     *A channel shim where the channel point was fully constructed outside
     *of lnd's wallet and the transaction might already be published.
     * </pre>
     *
     * <code>.co.anode.anodium.ChanPointShim chan_point_shim = 1;</code>
     * @return The chanPointShim.
     */
    co.anode.anodium.Rpc.ChanPointShim getChanPointShim();

    /**
     * <pre>
     *A channel shim that uses a PSBT to fund and sign the channel funding
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.PsbtShim psbt_shim = 2;</code>
     * @return Whether the psbtShim field is set.
     */
    boolean hasPsbtShim();
    /**
     * <pre>
     *A channel shim that uses a PSBT to fund and sign the channel funding
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.PsbtShim psbt_shim = 2;</code>
     * @return The psbtShim.
     */
    co.anode.anodium.Rpc.PsbtShim getPsbtShim();

    public co.anode.anodium.Rpc.FundingShim.ShimCase getShimCase();
  }
  /**
   * Protobuf type {@code co.anode.anodium.FundingShim}
   */
  public  static final class FundingShim extends
      com.google.protobuf.GeneratedMessageLite<
          FundingShim, FundingShim.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.FundingShim)
      FundingShimOrBuilder {
    private FundingShim() {
    }
    private int shimCase_ = 0;
    private java.lang.Object shim_;
    public enum ShimCase {
      CHAN_POINT_SHIM(1),
      PSBT_SHIM(2),
      SHIM_NOT_SET(0);
      private final int value;
      private ShimCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ShimCase valueOf(int value) {
        return forNumber(value);
      }

      public static ShimCase forNumber(int value) {
        switch (value) {
          case 1: return CHAN_POINT_SHIM;
          case 2: return PSBT_SHIM;
          case 0: return SHIM_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    @java.lang.Override
    public ShimCase
    getShimCase() {
      return ShimCase.forNumber(
          shimCase_);
    }

    private void clearShim() {
      shimCase_ = 0;
      shim_ = null;
    }

    public static final int CHAN_POINT_SHIM_FIELD_NUMBER = 1;
    /**
     * <pre>
     *A channel shim where the channel point was fully constructed outside
     *of lnd's wallet and the transaction might already be published.
     * </pre>
     *
     * <code>.co.anode.anodium.ChanPointShim chan_point_shim = 1;</code>
     */
    @java.lang.Override
    public boolean hasChanPointShim() {
      return shimCase_ == 1;
    }
    /**
     * <pre>
     *A channel shim where the channel point was fully constructed outside
     *of lnd's wallet and the transaction might already be published.
     * </pre>
     *
     * <code>.co.anode.anodium.ChanPointShim chan_point_shim = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChanPointShim getChanPointShim() {
      if (shimCase_ == 1) {
         return (co.anode.anodium.Rpc.ChanPointShim) shim_;
      }
      return co.anode.anodium.Rpc.ChanPointShim.getDefaultInstance();
    }
    /**
     * <pre>
     *A channel shim where the channel point was fully constructed outside
     *of lnd's wallet and the transaction might already be published.
     * </pre>
     *
     * <code>.co.anode.anodium.ChanPointShim chan_point_shim = 1;</code>
     */
    private void setChanPointShim(co.anode.anodium.Rpc.ChanPointShim value) {
      value.getClass();
  shim_ = value;
      shimCase_ = 1;
    }
    /**
     * <pre>
     *A channel shim where the channel point was fully constructed outside
     *of lnd's wallet and the transaction might already be published.
     * </pre>
     *
     * <code>.co.anode.anodium.ChanPointShim chan_point_shim = 1;</code>
     */
    private void mergeChanPointShim(co.anode.anodium.Rpc.ChanPointShim value) {
      value.getClass();
  if (shimCase_ == 1 &&
          shim_ != co.anode.anodium.Rpc.ChanPointShim.getDefaultInstance()) {
        shim_ = co.anode.anodium.Rpc.ChanPointShim.newBuilder((co.anode.anodium.Rpc.ChanPointShim) shim_)
            .mergeFrom(value).buildPartial();
      } else {
        shim_ = value;
      }
      shimCase_ = 1;
    }
    /**
     * <pre>
     *A channel shim where the channel point was fully constructed outside
     *of lnd's wallet and the transaction might already be published.
     * </pre>
     *
     * <code>.co.anode.anodium.ChanPointShim chan_point_shim = 1;</code>
     */
    private void clearChanPointShim() {
      if (shimCase_ == 1) {
        shimCase_ = 0;
        shim_ = null;
      }
    }

    public static final int PSBT_SHIM_FIELD_NUMBER = 2;
    /**
     * <pre>
     *A channel shim that uses a PSBT to fund and sign the channel funding
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.PsbtShim psbt_shim = 2;</code>
     */
    @java.lang.Override
    public boolean hasPsbtShim() {
      return shimCase_ == 2;
    }
    /**
     * <pre>
     *A channel shim that uses a PSBT to fund and sign the channel funding
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.PsbtShim psbt_shim = 2;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.PsbtShim getPsbtShim() {
      if (shimCase_ == 2) {
         return (co.anode.anodium.Rpc.PsbtShim) shim_;
      }
      return co.anode.anodium.Rpc.PsbtShim.getDefaultInstance();
    }
    /**
     * <pre>
     *A channel shim that uses a PSBT to fund and sign the channel funding
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.PsbtShim psbt_shim = 2;</code>
     */
    private void setPsbtShim(co.anode.anodium.Rpc.PsbtShim value) {
      value.getClass();
  shim_ = value;
      shimCase_ = 2;
    }
    /**
     * <pre>
     *A channel shim that uses a PSBT to fund and sign the channel funding
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.PsbtShim psbt_shim = 2;</code>
     */
    private void mergePsbtShim(co.anode.anodium.Rpc.PsbtShim value) {
      value.getClass();
  if (shimCase_ == 2 &&
          shim_ != co.anode.anodium.Rpc.PsbtShim.getDefaultInstance()) {
        shim_ = co.anode.anodium.Rpc.PsbtShim.newBuilder((co.anode.anodium.Rpc.PsbtShim) shim_)
            .mergeFrom(value).buildPartial();
      } else {
        shim_ = value;
      }
      shimCase_ = 2;
    }
    /**
     * <pre>
     *A channel shim that uses a PSBT to fund and sign the channel funding
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.PsbtShim psbt_shim = 2;</code>
     */
    private void clearPsbtShim() {
      if (shimCase_ == 2) {
        shimCase_ = 0;
        shim_ = null;
      }
    }

    public static co.anode.anodium.Rpc.FundingShim parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FundingShim parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingShim parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FundingShim parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingShim parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FundingShim parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingShim parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FundingShim parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingShim parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FundingShim parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingShim parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FundingShim parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.FundingShim prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.FundingShim}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.FundingShim, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.FundingShim)
        co.anode.anodium.Rpc.FundingShimOrBuilder {
      // Construct using co.anode.anodium.Rpc.FundingShim.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }

      @java.lang.Override
      public ShimCase
          getShimCase() {
        return instance.getShimCase();
      }

      public Builder clearShim() {
        copyOnWrite();
        instance.clearShim();
        return this;
      }


      /**
       * <pre>
       *A channel shim where the channel point was fully constructed outside
       *of lnd's wallet and the transaction might already be published.
       * </pre>
       *
       * <code>.co.anode.anodium.ChanPointShim chan_point_shim = 1;</code>
       */
      @java.lang.Override
      public boolean hasChanPointShim() {
        return instance.hasChanPointShim();
      }
      /**
       * <pre>
       *A channel shim where the channel point was fully constructed outside
       *of lnd's wallet and the transaction might already be published.
       * </pre>
       *
       * <code>.co.anode.anodium.ChanPointShim chan_point_shim = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChanPointShim getChanPointShim() {
        return instance.getChanPointShim();
      }
      /**
       * <pre>
       *A channel shim where the channel point was fully constructed outside
       *of lnd's wallet and the transaction might already be published.
       * </pre>
       *
       * <code>.co.anode.anodium.ChanPointShim chan_point_shim = 1;</code>
       */
      public Builder setChanPointShim(co.anode.anodium.Rpc.ChanPointShim value) {
        copyOnWrite();
        instance.setChanPointShim(value);
        return this;
      }
      /**
       * <pre>
       *A channel shim where the channel point was fully constructed outside
       *of lnd's wallet and the transaction might already be published.
       * </pre>
       *
       * <code>.co.anode.anodium.ChanPointShim chan_point_shim = 1;</code>
       */
      public Builder setChanPointShim(
          co.anode.anodium.Rpc.ChanPointShim.Builder builderForValue) {
        copyOnWrite();
        instance.setChanPointShim(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *A channel shim where the channel point was fully constructed outside
       *of lnd's wallet and the transaction might already be published.
       * </pre>
       *
       * <code>.co.anode.anodium.ChanPointShim chan_point_shim = 1;</code>
       */
      public Builder mergeChanPointShim(co.anode.anodium.Rpc.ChanPointShim value) {
        copyOnWrite();
        instance.mergeChanPointShim(value);
        return this;
      }
      /**
       * <pre>
       *A channel shim where the channel point was fully constructed outside
       *of lnd's wallet and the transaction might already be published.
       * </pre>
       *
       * <code>.co.anode.anodium.ChanPointShim chan_point_shim = 1;</code>
       */
      public Builder clearChanPointShim() {
        copyOnWrite();
        instance.clearChanPointShim();
        return this;
      }

      /**
       * <pre>
       *A channel shim that uses a PSBT to fund and sign the channel funding
       *transaction.
       * </pre>
       *
       * <code>.co.anode.anodium.PsbtShim psbt_shim = 2;</code>
       */
      @java.lang.Override
      public boolean hasPsbtShim() {
        return instance.hasPsbtShim();
      }
      /**
       * <pre>
       *A channel shim that uses a PSBT to fund and sign the channel funding
       *transaction.
       * </pre>
       *
       * <code>.co.anode.anodium.PsbtShim psbt_shim = 2;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.PsbtShim getPsbtShim() {
        return instance.getPsbtShim();
      }
      /**
       * <pre>
       *A channel shim that uses a PSBT to fund and sign the channel funding
       *transaction.
       * </pre>
       *
       * <code>.co.anode.anodium.PsbtShim psbt_shim = 2;</code>
       */
      public Builder setPsbtShim(co.anode.anodium.Rpc.PsbtShim value) {
        copyOnWrite();
        instance.setPsbtShim(value);
        return this;
      }
      /**
       * <pre>
       *A channel shim that uses a PSBT to fund and sign the channel funding
       *transaction.
       * </pre>
       *
       * <code>.co.anode.anodium.PsbtShim psbt_shim = 2;</code>
       */
      public Builder setPsbtShim(
          co.anode.anodium.Rpc.PsbtShim.Builder builderForValue) {
        copyOnWrite();
        instance.setPsbtShim(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *A channel shim that uses a PSBT to fund and sign the channel funding
       *transaction.
       * </pre>
       *
       * <code>.co.anode.anodium.PsbtShim psbt_shim = 2;</code>
       */
      public Builder mergePsbtShim(co.anode.anodium.Rpc.PsbtShim value) {
        copyOnWrite();
        instance.mergePsbtShim(value);
        return this;
      }
      /**
       * <pre>
       *A channel shim that uses a PSBT to fund and sign the channel funding
       *transaction.
       * </pre>
       *
       * <code>.co.anode.anodium.PsbtShim psbt_shim = 2;</code>
       */
      public Builder clearPsbtShim() {
        copyOnWrite();
        instance.clearPsbtShim();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.FundingShim)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.FundingShim();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "shim_",
              "shimCase_",
              co.anode.anodium.Rpc.ChanPointShim.class,
              co.anode.anodium.Rpc.PsbtShim.class,
            };
            java.lang.String info =
                "\u0000\u0002\u0001\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001<\u0000\u0002<" +
                "\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.FundingShim> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.FundingShim.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.FundingShim>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.FundingShim)
    private static final co.anode.anodium.Rpc.FundingShim DEFAULT_INSTANCE;
    static {
      FundingShim defaultInstance = new FundingShim();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        FundingShim.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.FundingShim getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FundingShim> PARSER;

    public static com.google.protobuf.Parser<FundingShim> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FundingShimCancelOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.FundingShimCancel)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The pending channel ID of the channel to cancel the funding shim for.
     * </pre>
     *
     * <code>bytes pending_chan_id = 1;</code>
     * @return The pendingChanId.
     */
    com.google.protobuf.ByteString getPendingChanId();
  }
  /**
   * Protobuf type {@code co.anode.anodium.FundingShimCancel}
   */
  public  static final class FundingShimCancel extends
      com.google.protobuf.GeneratedMessageLite<
          FundingShimCancel, FundingShimCancel.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.FundingShimCancel)
      FundingShimCancelOrBuilder {
    private FundingShimCancel() {
      pendingChanId_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int PENDING_CHAN_ID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString pendingChanId_;
    /**
     * <pre>
     * The pending channel ID of the channel to cancel the funding shim for.
     * </pre>
     *
     * <code>bytes pending_chan_id = 1;</code>
     * @return The pendingChanId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPendingChanId() {
      return pendingChanId_;
    }
    /**
     * <pre>
     * The pending channel ID of the channel to cancel the funding shim for.
     * </pre>
     *
     * <code>bytes pending_chan_id = 1;</code>
     * @param value The pendingChanId to set.
     */
    private void setPendingChanId(com.google.protobuf.ByteString value) {
      value.getClass();
  
      pendingChanId_ = value;
    }
    /**
     * <pre>
     * The pending channel ID of the channel to cancel the funding shim for.
     * </pre>
     *
     * <code>bytes pending_chan_id = 1;</code>
     */
    private void clearPendingChanId() {
      
      pendingChanId_ = getDefaultInstance().getPendingChanId();
    }

    public static co.anode.anodium.Rpc.FundingShimCancel parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FundingShimCancel parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingShimCancel parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FundingShimCancel parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingShimCancel parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FundingShimCancel parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingShimCancel parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FundingShimCancel parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingShimCancel parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FundingShimCancel parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingShimCancel parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FundingShimCancel parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.FundingShimCancel prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.FundingShimCancel}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.FundingShimCancel, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.FundingShimCancel)
        co.anode.anodium.Rpc.FundingShimCancelOrBuilder {
      // Construct using co.anode.anodium.Rpc.FundingShimCancel.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The pending channel ID of the channel to cancel the funding shim for.
       * </pre>
       *
       * <code>bytes pending_chan_id = 1;</code>
       * @return The pendingChanId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPendingChanId() {
        return instance.getPendingChanId();
      }
      /**
       * <pre>
       * The pending channel ID of the channel to cancel the funding shim for.
       * </pre>
       *
       * <code>bytes pending_chan_id = 1;</code>
       * @param value The pendingChanId to set.
       * @return This builder for chaining.
       */
      public Builder setPendingChanId(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPendingChanId(value);
        return this;
      }
      /**
       * <pre>
       * The pending channel ID of the channel to cancel the funding shim for.
       * </pre>
       *
       * <code>bytes pending_chan_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPendingChanId() {
        copyOnWrite();
        instance.clearPendingChanId();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.FundingShimCancel)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.FundingShimCancel();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "pendingChanId_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.FundingShimCancel> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.FundingShimCancel.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.FundingShimCancel>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.FundingShimCancel)
    private static final co.anode.anodium.Rpc.FundingShimCancel DEFAULT_INSTANCE;
    static {
      FundingShimCancel defaultInstance = new FundingShimCancel();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        FundingShimCancel.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.FundingShimCancel getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FundingShimCancel> PARSER;

    public static com.google.protobuf.Parser<FundingShimCancel> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FundingPsbtVerifyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.FundingPsbtVerify)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The funded but not yet signed PSBT that sends the exact channel capacity
     *amount to the PK script returned in the open channel message in a previous
     *step.
     * </pre>
     *
     * <code>bytes funded_psbt = 1;</code>
     * @return The fundedPsbt.
     */
    com.google.protobuf.ByteString getFundedPsbt();

    /**
     * <pre>
     * The pending channel ID of the channel to get the PSBT for.
     * </pre>
     *
     * <code>bytes pending_chan_id = 2;</code>
     * @return The pendingChanId.
     */
    com.google.protobuf.ByteString getPendingChanId();
  }
  /**
   * Protobuf type {@code co.anode.anodium.FundingPsbtVerify}
   */
  public  static final class FundingPsbtVerify extends
      com.google.protobuf.GeneratedMessageLite<
          FundingPsbtVerify, FundingPsbtVerify.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.FundingPsbtVerify)
      FundingPsbtVerifyOrBuilder {
    private FundingPsbtVerify() {
      fundedPsbt_ = com.google.protobuf.ByteString.EMPTY;
      pendingChanId_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int FUNDED_PSBT_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString fundedPsbt_;
    /**
     * <pre>
     *The funded but not yet signed PSBT that sends the exact channel capacity
     *amount to the PK script returned in the open channel message in a previous
     *step.
     * </pre>
     *
     * <code>bytes funded_psbt = 1;</code>
     * @return The fundedPsbt.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getFundedPsbt() {
      return fundedPsbt_;
    }
    /**
     * <pre>
     *The funded but not yet signed PSBT that sends the exact channel capacity
     *amount to the PK script returned in the open channel message in a previous
     *step.
     * </pre>
     *
     * <code>bytes funded_psbt = 1;</code>
     * @param value The fundedPsbt to set.
     */
    private void setFundedPsbt(com.google.protobuf.ByteString value) {
      value.getClass();
  
      fundedPsbt_ = value;
    }
    /**
     * <pre>
     *The funded but not yet signed PSBT that sends the exact channel capacity
     *amount to the PK script returned in the open channel message in a previous
     *step.
     * </pre>
     *
     * <code>bytes funded_psbt = 1;</code>
     */
    private void clearFundedPsbt() {
      
      fundedPsbt_ = getDefaultInstance().getFundedPsbt();
    }

    public static final int PENDING_CHAN_ID_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString pendingChanId_;
    /**
     * <pre>
     * The pending channel ID of the channel to get the PSBT for.
     * </pre>
     *
     * <code>bytes pending_chan_id = 2;</code>
     * @return The pendingChanId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPendingChanId() {
      return pendingChanId_;
    }
    /**
     * <pre>
     * The pending channel ID of the channel to get the PSBT for.
     * </pre>
     *
     * <code>bytes pending_chan_id = 2;</code>
     * @param value The pendingChanId to set.
     */
    private void setPendingChanId(com.google.protobuf.ByteString value) {
      value.getClass();
  
      pendingChanId_ = value;
    }
    /**
     * <pre>
     * The pending channel ID of the channel to get the PSBT for.
     * </pre>
     *
     * <code>bytes pending_chan_id = 2;</code>
     */
    private void clearPendingChanId() {
      
      pendingChanId_ = getDefaultInstance().getPendingChanId();
    }

    public static co.anode.anodium.Rpc.FundingPsbtVerify parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FundingPsbtVerify parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingPsbtVerify parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FundingPsbtVerify parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingPsbtVerify parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FundingPsbtVerify parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingPsbtVerify parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FundingPsbtVerify parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingPsbtVerify parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FundingPsbtVerify parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingPsbtVerify parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FundingPsbtVerify parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.FundingPsbtVerify prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.FundingPsbtVerify}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.FundingPsbtVerify, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.FundingPsbtVerify)
        co.anode.anodium.Rpc.FundingPsbtVerifyOrBuilder {
      // Construct using co.anode.anodium.Rpc.FundingPsbtVerify.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The funded but not yet signed PSBT that sends the exact channel capacity
       *amount to the PK script returned in the open channel message in a previous
       *step.
       * </pre>
       *
       * <code>bytes funded_psbt = 1;</code>
       * @return The fundedPsbt.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getFundedPsbt() {
        return instance.getFundedPsbt();
      }
      /**
       * <pre>
       *The funded but not yet signed PSBT that sends the exact channel capacity
       *amount to the PK script returned in the open channel message in a previous
       *step.
       * </pre>
       *
       * <code>bytes funded_psbt = 1;</code>
       * @param value The fundedPsbt to set.
       * @return This builder for chaining.
       */
      public Builder setFundedPsbt(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setFundedPsbt(value);
        return this;
      }
      /**
       * <pre>
       *The funded but not yet signed PSBT that sends the exact channel capacity
       *amount to the PK script returned in the open channel message in a previous
       *step.
       * </pre>
       *
       * <code>bytes funded_psbt = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearFundedPsbt() {
        copyOnWrite();
        instance.clearFundedPsbt();
        return this;
      }

      /**
       * <pre>
       * The pending channel ID of the channel to get the PSBT for.
       * </pre>
       *
       * <code>bytes pending_chan_id = 2;</code>
       * @return The pendingChanId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPendingChanId() {
        return instance.getPendingChanId();
      }
      /**
       * <pre>
       * The pending channel ID of the channel to get the PSBT for.
       * </pre>
       *
       * <code>bytes pending_chan_id = 2;</code>
       * @param value The pendingChanId to set.
       * @return This builder for chaining.
       */
      public Builder setPendingChanId(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPendingChanId(value);
        return this;
      }
      /**
       * <pre>
       * The pending channel ID of the channel to get the PSBT for.
       * </pre>
       *
       * <code>bytes pending_chan_id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPendingChanId() {
        copyOnWrite();
        instance.clearPendingChanId();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.FundingPsbtVerify)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.FundingPsbtVerify();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "fundedPsbt_",
              "pendingChanId_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\n\u0002\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.FundingPsbtVerify> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.FundingPsbtVerify.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.FundingPsbtVerify>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.FundingPsbtVerify)
    private static final co.anode.anodium.Rpc.FundingPsbtVerify DEFAULT_INSTANCE;
    static {
      FundingPsbtVerify defaultInstance = new FundingPsbtVerify();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        FundingPsbtVerify.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.FundingPsbtVerify getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FundingPsbtVerify> PARSER;

    public static com.google.protobuf.Parser<FundingPsbtVerify> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FundingPsbtFinalizeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.FundingPsbtFinalize)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The funded PSBT that contains all witness data to send the exact channel
     *capacity amount to the PK script returned in the open channel message in a
     *previous step. Cannot be set at the same time as final_raw_tx.
     * </pre>
     *
     * <code>bytes signed_psbt = 1;</code>
     * @return The signedPsbt.
     */
    com.google.protobuf.ByteString getSignedPsbt();

    /**
     * <pre>
     * The pending channel ID of the channel to get the PSBT for.
     * </pre>
     *
     * <code>bytes pending_chan_id = 2;</code>
     * @return The pendingChanId.
     */
    com.google.protobuf.ByteString getPendingChanId();

    /**
     * <pre>
     *As an alternative to the signed PSBT with all witness data, the final raw
     *wire format transaction can also be specified directly. Cannot be set at the
     *same time as signed_psbt.
     * </pre>
     *
     * <code>bytes final_raw_tx = 3;</code>
     * @return The finalRawTx.
     */
    com.google.protobuf.ByteString getFinalRawTx();
  }
  /**
   * Protobuf type {@code co.anode.anodium.FundingPsbtFinalize}
   */
  public  static final class FundingPsbtFinalize extends
      com.google.protobuf.GeneratedMessageLite<
          FundingPsbtFinalize, FundingPsbtFinalize.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.FundingPsbtFinalize)
      FundingPsbtFinalizeOrBuilder {
    private FundingPsbtFinalize() {
      signedPsbt_ = com.google.protobuf.ByteString.EMPTY;
      pendingChanId_ = com.google.protobuf.ByteString.EMPTY;
      finalRawTx_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int SIGNED_PSBT_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString signedPsbt_;
    /**
     * <pre>
     *The funded PSBT that contains all witness data to send the exact channel
     *capacity amount to the PK script returned in the open channel message in a
     *previous step. Cannot be set at the same time as final_raw_tx.
     * </pre>
     *
     * <code>bytes signed_psbt = 1;</code>
     * @return The signedPsbt.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSignedPsbt() {
      return signedPsbt_;
    }
    /**
     * <pre>
     *The funded PSBT that contains all witness data to send the exact channel
     *capacity amount to the PK script returned in the open channel message in a
     *previous step. Cannot be set at the same time as final_raw_tx.
     * </pre>
     *
     * <code>bytes signed_psbt = 1;</code>
     * @param value The signedPsbt to set.
     */
    private void setSignedPsbt(com.google.protobuf.ByteString value) {
      value.getClass();
  
      signedPsbt_ = value;
    }
    /**
     * <pre>
     *The funded PSBT that contains all witness data to send the exact channel
     *capacity amount to the PK script returned in the open channel message in a
     *previous step. Cannot be set at the same time as final_raw_tx.
     * </pre>
     *
     * <code>bytes signed_psbt = 1;</code>
     */
    private void clearSignedPsbt() {
      
      signedPsbt_ = getDefaultInstance().getSignedPsbt();
    }

    public static final int PENDING_CHAN_ID_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString pendingChanId_;
    /**
     * <pre>
     * The pending channel ID of the channel to get the PSBT for.
     * </pre>
     *
     * <code>bytes pending_chan_id = 2;</code>
     * @return The pendingChanId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPendingChanId() {
      return pendingChanId_;
    }
    /**
     * <pre>
     * The pending channel ID of the channel to get the PSBT for.
     * </pre>
     *
     * <code>bytes pending_chan_id = 2;</code>
     * @param value The pendingChanId to set.
     */
    private void setPendingChanId(com.google.protobuf.ByteString value) {
      value.getClass();
  
      pendingChanId_ = value;
    }
    /**
     * <pre>
     * The pending channel ID of the channel to get the PSBT for.
     * </pre>
     *
     * <code>bytes pending_chan_id = 2;</code>
     */
    private void clearPendingChanId() {
      
      pendingChanId_ = getDefaultInstance().getPendingChanId();
    }

    public static final int FINAL_RAW_TX_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString finalRawTx_;
    /**
     * <pre>
     *As an alternative to the signed PSBT with all witness data, the final raw
     *wire format transaction can also be specified directly. Cannot be set at the
     *same time as signed_psbt.
     * </pre>
     *
     * <code>bytes final_raw_tx = 3;</code>
     * @return The finalRawTx.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getFinalRawTx() {
      return finalRawTx_;
    }
    /**
     * <pre>
     *As an alternative to the signed PSBT with all witness data, the final raw
     *wire format transaction can also be specified directly. Cannot be set at the
     *same time as signed_psbt.
     * </pre>
     *
     * <code>bytes final_raw_tx = 3;</code>
     * @param value The finalRawTx to set.
     */
    private void setFinalRawTx(com.google.protobuf.ByteString value) {
      value.getClass();
  
      finalRawTx_ = value;
    }
    /**
     * <pre>
     *As an alternative to the signed PSBT with all witness data, the final raw
     *wire format transaction can also be specified directly. Cannot be set at the
     *same time as signed_psbt.
     * </pre>
     *
     * <code>bytes final_raw_tx = 3;</code>
     */
    private void clearFinalRawTx() {
      
      finalRawTx_ = getDefaultInstance().getFinalRawTx();
    }

    public static co.anode.anodium.Rpc.FundingPsbtFinalize parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FundingPsbtFinalize parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingPsbtFinalize parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FundingPsbtFinalize parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingPsbtFinalize parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FundingPsbtFinalize parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingPsbtFinalize parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FundingPsbtFinalize parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingPsbtFinalize parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FundingPsbtFinalize parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingPsbtFinalize parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FundingPsbtFinalize parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.FundingPsbtFinalize prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.FundingPsbtFinalize}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.FundingPsbtFinalize, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.FundingPsbtFinalize)
        co.anode.anodium.Rpc.FundingPsbtFinalizeOrBuilder {
      // Construct using co.anode.anodium.Rpc.FundingPsbtFinalize.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The funded PSBT that contains all witness data to send the exact channel
       *capacity amount to the PK script returned in the open channel message in a
       *previous step. Cannot be set at the same time as final_raw_tx.
       * </pre>
       *
       * <code>bytes signed_psbt = 1;</code>
       * @return The signedPsbt.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSignedPsbt() {
        return instance.getSignedPsbt();
      }
      /**
       * <pre>
       *The funded PSBT that contains all witness data to send the exact channel
       *capacity amount to the PK script returned in the open channel message in a
       *previous step. Cannot be set at the same time as final_raw_tx.
       * </pre>
       *
       * <code>bytes signed_psbt = 1;</code>
       * @param value The signedPsbt to set.
       * @return This builder for chaining.
       */
      public Builder setSignedPsbt(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSignedPsbt(value);
        return this;
      }
      /**
       * <pre>
       *The funded PSBT that contains all witness data to send the exact channel
       *capacity amount to the PK script returned in the open channel message in a
       *previous step. Cannot be set at the same time as final_raw_tx.
       * </pre>
       *
       * <code>bytes signed_psbt = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignedPsbt() {
        copyOnWrite();
        instance.clearSignedPsbt();
        return this;
      }

      /**
       * <pre>
       * The pending channel ID of the channel to get the PSBT for.
       * </pre>
       *
       * <code>bytes pending_chan_id = 2;</code>
       * @return The pendingChanId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPendingChanId() {
        return instance.getPendingChanId();
      }
      /**
       * <pre>
       * The pending channel ID of the channel to get the PSBT for.
       * </pre>
       *
       * <code>bytes pending_chan_id = 2;</code>
       * @param value The pendingChanId to set.
       * @return This builder for chaining.
       */
      public Builder setPendingChanId(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPendingChanId(value);
        return this;
      }
      /**
       * <pre>
       * The pending channel ID of the channel to get the PSBT for.
       * </pre>
       *
       * <code>bytes pending_chan_id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPendingChanId() {
        copyOnWrite();
        instance.clearPendingChanId();
        return this;
      }

      /**
       * <pre>
       *As an alternative to the signed PSBT with all witness data, the final raw
       *wire format transaction can also be specified directly. Cannot be set at the
       *same time as signed_psbt.
       * </pre>
       *
       * <code>bytes final_raw_tx = 3;</code>
       * @return The finalRawTx.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getFinalRawTx() {
        return instance.getFinalRawTx();
      }
      /**
       * <pre>
       *As an alternative to the signed PSBT with all witness data, the final raw
       *wire format transaction can also be specified directly. Cannot be set at the
       *same time as signed_psbt.
       * </pre>
       *
       * <code>bytes final_raw_tx = 3;</code>
       * @param value The finalRawTx to set.
       * @return This builder for chaining.
       */
      public Builder setFinalRawTx(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setFinalRawTx(value);
        return this;
      }
      /**
       * <pre>
       *As an alternative to the signed PSBT with all witness data, the final raw
       *wire format transaction can also be specified directly. Cannot be set at the
       *same time as signed_psbt.
       * </pre>
       *
       * <code>bytes final_raw_tx = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearFinalRawTx() {
        copyOnWrite();
        instance.clearFinalRawTx();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.FundingPsbtFinalize)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.FundingPsbtFinalize();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "signedPsbt_",
              "pendingChanId_",
              "finalRawTx_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0003\u0003\u0000\u0000\u0000\u0001\n\u0002\n\u0003" +
                "\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.FundingPsbtFinalize> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.FundingPsbtFinalize.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.FundingPsbtFinalize>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.FundingPsbtFinalize)
    private static final co.anode.anodium.Rpc.FundingPsbtFinalize DEFAULT_INSTANCE;
    static {
      FundingPsbtFinalize defaultInstance = new FundingPsbtFinalize();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        FundingPsbtFinalize.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.FundingPsbtFinalize getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FundingPsbtFinalize> PARSER;

    public static com.google.protobuf.Parser<FundingPsbtFinalize> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FundingTransitionMsgOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.FundingTransitionMsg)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The funding shim to register. This should be used before any
     *channel funding has began by the remote party, as it is intended as a
     *preparatory step for the full channel funding.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShim shim_register = 1;</code>
     * @return Whether the shimRegister field is set.
     */
    boolean hasShimRegister();
    /**
     * <pre>
     *The funding shim to register. This should be used before any
     *channel funding has began by the remote party, as it is intended as a
     *preparatory step for the full channel funding.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShim shim_register = 1;</code>
     * @return The shimRegister.
     */
    co.anode.anodium.Rpc.FundingShim getShimRegister();

    /**
     * <pre>
     * Used to cancel an existing registered funding shim.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShimCancel shim_cancel = 2;</code>
     * @return Whether the shimCancel field is set.
     */
    boolean hasShimCancel();
    /**
     * <pre>
     * Used to cancel an existing registered funding shim.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShimCancel shim_cancel = 2;</code>
     * @return The shimCancel.
     */
    co.anode.anodium.Rpc.FundingShimCancel getShimCancel();

    /**
     * <pre>
     *Used to continue a funding flow that was initiated to be executed
     *through a PSBT. This step verifies that the PSBT contains the correct
     *outputs to fund the channel.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingPsbtVerify psbt_verify = 3;</code>
     * @return Whether the psbtVerify field is set.
     */
    boolean hasPsbtVerify();
    /**
     * <pre>
     *Used to continue a funding flow that was initiated to be executed
     *through a PSBT. This step verifies that the PSBT contains the correct
     *outputs to fund the channel.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingPsbtVerify psbt_verify = 3;</code>
     * @return The psbtVerify.
     */
    co.anode.anodium.Rpc.FundingPsbtVerify getPsbtVerify();

    /**
     * <pre>
     *Used to continue a funding flow that was initiated to be executed
     *through a PSBT. This step finalizes the funded and signed PSBT, finishes
     *negotiation with the peer and finally publishes the resulting funding
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingPsbtFinalize psbt_finalize = 4;</code>
     * @return Whether the psbtFinalize field is set.
     */
    boolean hasPsbtFinalize();
    /**
     * <pre>
     *Used to continue a funding flow that was initiated to be executed
     *through a PSBT. This step finalizes the funded and signed PSBT, finishes
     *negotiation with the peer and finally publishes the resulting funding
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingPsbtFinalize psbt_finalize = 4;</code>
     * @return The psbtFinalize.
     */
    co.anode.anodium.Rpc.FundingPsbtFinalize getPsbtFinalize();

    public co.anode.anodium.Rpc.FundingTransitionMsg.TriggerCase getTriggerCase();
  }
  /**
   * Protobuf type {@code co.anode.anodium.FundingTransitionMsg}
   */
  public  static final class FundingTransitionMsg extends
      com.google.protobuf.GeneratedMessageLite<
          FundingTransitionMsg, FundingTransitionMsg.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.FundingTransitionMsg)
      FundingTransitionMsgOrBuilder {
    private FundingTransitionMsg() {
    }
    private int triggerCase_ = 0;
    private java.lang.Object trigger_;
    public enum TriggerCase {
      SHIM_REGISTER(1),
      SHIM_CANCEL(2),
      PSBT_VERIFY(3),
      PSBT_FINALIZE(4),
      TRIGGER_NOT_SET(0);
      private final int value;
      private TriggerCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static TriggerCase valueOf(int value) {
        return forNumber(value);
      }

      public static TriggerCase forNumber(int value) {
        switch (value) {
          case 1: return SHIM_REGISTER;
          case 2: return SHIM_CANCEL;
          case 3: return PSBT_VERIFY;
          case 4: return PSBT_FINALIZE;
          case 0: return TRIGGER_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    @java.lang.Override
    public TriggerCase
    getTriggerCase() {
      return TriggerCase.forNumber(
          triggerCase_);
    }

    private void clearTrigger() {
      triggerCase_ = 0;
      trigger_ = null;
    }

    public static final int SHIM_REGISTER_FIELD_NUMBER = 1;
    /**
     * <pre>
     *The funding shim to register. This should be used before any
     *channel funding has began by the remote party, as it is intended as a
     *preparatory step for the full channel funding.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShim shim_register = 1;</code>
     */
    @java.lang.Override
    public boolean hasShimRegister() {
      return triggerCase_ == 1;
    }
    /**
     * <pre>
     *The funding shim to register. This should be used before any
     *channel funding has began by the remote party, as it is intended as a
     *preparatory step for the full channel funding.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShim shim_register = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.FundingShim getShimRegister() {
      if (triggerCase_ == 1) {
         return (co.anode.anodium.Rpc.FundingShim) trigger_;
      }
      return co.anode.anodium.Rpc.FundingShim.getDefaultInstance();
    }
    /**
     * <pre>
     *The funding shim to register. This should be used before any
     *channel funding has began by the remote party, as it is intended as a
     *preparatory step for the full channel funding.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShim shim_register = 1;</code>
     */
    private void setShimRegister(co.anode.anodium.Rpc.FundingShim value) {
      value.getClass();
  trigger_ = value;
      triggerCase_ = 1;
    }
    /**
     * <pre>
     *The funding shim to register. This should be used before any
     *channel funding has began by the remote party, as it is intended as a
     *preparatory step for the full channel funding.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShim shim_register = 1;</code>
     */
    private void mergeShimRegister(co.anode.anodium.Rpc.FundingShim value) {
      value.getClass();
  if (triggerCase_ == 1 &&
          trigger_ != co.anode.anodium.Rpc.FundingShim.getDefaultInstance()) {
        trigger_ = co.anode.anodium.Rpc.FundingShim.newBuilder((co.anode.anodium.Rpc.FundingShim) trigger_)
            .mergeFrom(value).buildPartial();
      } else {
        trigger_ = value;
      }
      triggerCase_ = 1;
    }
    /**
     * <pre>
     *The funding shim to register. This should be used before any
     *channel funding has began by the remote party, as it is intended as a
     *preparatory step for the full channel funding.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShim shim_register = 1;</code>
     */
    private void clearShimRegister() {
      if (triggerCase_ == 1) {
        triggerCase_ = 0;
        trigger_ = null;
      }
    }

    public static final int SHIM_CANCEL_FIELD_NUMBER = 2;
    /**
     * <pre>
     * Used to cancel an existing registered funding shim.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShimCancel shim_cancel = 2;</code>
     */
    @java.lang.Override
    public boolean hasShimCancel() {
      return triggerCase_ == 2;
    }
    /**
     * <pre>
     * Used to cancel an existing registered funding shim.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShimCancel shim_cancel = 2;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.FundingShimCancel getShimCancel() {
      if (triggerCase_ == 2) {
         return (co.anode.anodium.Rpc.FundingShimCancel) trigger_;
      }
      return co.anode.anodium.Rpc.FundingShimCancel.getDefaultInstance();
    }
    /**
     * <pre>
     * Used to cancel an existing registered funding shim.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShimCancel shim_cancel = 2;</code>
     */
    private void setShimCancel(co.anode.anodium.Rpc.FundingShimCancel value) {
      value.getClass();
  trigger_ = value;
      triggerCase_ = 2;
    }
    /**
     * <pre>
     * Used to cancel an existing registered funding shim.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShimCancel shim_cancel = 2;</code>
     */
    private void mergeShimCancel(co.anode.anodium.Rpc.FundingShimCancel value) {
      value.getClass();
  if (triggerCase_ == 2 &&
          trigger_ != co.anode.anodium.Rpc.FundingShimCancel.getDefaultInstance()) {
        trigger_ = co.anode.anodium.Rpc.FundingShimCancel.newBuilder((co.anode.anodium.Rpc.FundingShimCancel) trigger_)
            .mergeFrom(value).buildPartial();
      } else {
        trigger_ = value;
      }
      triggerCase_ = 2;
    }
    /**
     * <pre>
     * Used to cancel an existing registered funding shim.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingShimCancel shim_cancel = 2;</code>
     */
    private void clearShimCancel() {
      if (triggerCase_ == 2) {
        triggerCase_ = 0;
        trigger_ = null;
      }
    }

    public static final int PSBT_VERIFY_FIELD_NUMBER = 3;
    /**
     * <pre>
     *Used to continue a funding flow that was initiated to be executed
     *through a PSBT. This step verifies that the PSBT contains the correct
     *outputs to fund the channel.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingPsbtVerify psbt_verify = 3;</code>
     */
    @java.lang.Override
    public boolean hasPsbtVerify() {
      return triggerCase_ == 3;
    }
    /**
     * <pre>
     *Used to continue a funding flow that was initiated to be executed
     *through a PSBT. This step verifies that the PSBT contains the correct
     *outputs to fund the channel.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingPsbtVerify psbt_verify = 3;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.FundingPsbtVerify getPsbtVerify() {
      if (triggerCase_ == 3) {
         return (co.anode.anodium.Rpc.FundingPsbtVerify) trigger_;
      }
      return co.anode.anodium.Rpc.FundingPsbtVerify.getDefaultInstance();
    }
    /**
     * <pre>
     *Used to continue a funding flow that was initiated to be executed
     *through a PSBT. This step verifies that the PSBT contains the correct
     *outputs to fund the channel.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingPsbtVerify psbt_verify = 3;</code>
     */
    private void setPsbtVerify(co.anode.anodium.Rpc.FundingPsbtVerify value) {
      value.getClass();
  trigger_ = value;
      triggerCase_ = 3;
    }
    /**
     * <pre>
     *Used to continue a funding flow that was initiated to be executed
     *through a PSBT. This step verifies that the PSBT contains the correct
     *outputs to fund the channel.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingPsbtVerify psbt_verify = 3;</code>
     */
    private void mergePsbtVerify(co.anode.anodium.Rpc.FundingPsbtVerify value) {
      value.getClass();
  if (triggerCase_ == 3 &&
          trigger_ != co.anode.anodium.Rpc.FundingPsbtVerify.getDefaultInstance()) {
        trigger_ = co.anode.anodium.Rpc.FundingPsbtVerify.newBuilder((co.anode.anodium.Rpc.FundingPsbtVerify) trigger_)
            .mergeFrom(value).buildPartial();
      } else {
        trigger_ = value;
      }
      triggerCase_ = 3;
    }
    /**
     * <pre>
     *Used to continue a funding flow that was initiated to be executed
     *through a PSBT. This step verifies that the PSBT contains the correct
     *outputs to fund the channel.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingPsbtVerify psbt_verify = 3;</code>
     */
    private void clearPsbtVerify() {
      if (triggerCase_ == 3) {
        triggerCase_ = 0;
        trigger_ = null;
      }
    }

    public static final int PSBT_FINALIZE_FIELD_NUMBER = 4;
    /**
     * <pre>
     *Used to continue a funding flow that was initiated to be executed
     *through a PSBT. This step finalizes the funded and signed PSBT, finishes
     *negotiation with the peer and finally publishes the resulting funding
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingPsbtFinalize psbt_finalize = 4;</code>
     */
    @java.lang.Override
    public boolean hasPsbtFinalize() {
      return triggerCase_ == 4;
    }
    /**
     * <pre>
     *Used to continue a funding flow that was initiated to be executed
     *through a PSBT. This step finalizes the funded and signed PSBT, finishes
     *negotiation with the peer and finally publishes the resulting funding
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingPsbtFinalize psbt_finalize = 4;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.FundingPsbtFinalize getPsbtFinalize() {
      if (triggerCase_ == 4) {
         return (co.anode.anodium.Rpc.FundingPsbtFinalize) trigger_;
      }
      return co.anode.anodium.Rpc.FundingPsbtFinalize.getDefaultInstance();
    }
    /**
     * <pre>
     *Used to continue a funding flow that was initiated to be executed
     *through a PSBT. This step finalizes the funded and signed PSBT, finishes
     *negotiation with the peer and finally publishes the resulting funding
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingPsbtFinalize psbt_finalize = 4;</code>
     */
    private void setPsbtFinalize(co.anode.anodium.Rpc.FundingPsbtFinalize value) {
      value.getClass();
  trigger_ = value;
      triggerCase_ = 4;
    }
    /**
     * <pre>
     *Used to continue a funding flow that was initiated to be executed
     *through a PSBT. This step finalizes the funded and signed PSBT, finishes
     *negotiation with the peer and finally publishes the resulting funding
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingPsbtFinalize psbt_finalize = 4;</code>
     */
    private void mergePsbtFinalize(co.anode.anodium.Rpc.FundingPsbtFinalize value) {
      value.getClass();
  if (triggerCase_ == 4 &&
          trigger_ != co.anode.anodium.Rpc.FundingPsbtFinalize.getDefaultInstance()) {
        trigger_ = co.anode.anodium.Rpc.FundingPsbtFinalize.newBuilder((co.anode.anodium.Rpc.FundingPsbtFinalize) trigger_)
            .mergeFrom(value).buildPartial();
      } else {
        trigger_ = value;
      }
      triggerCase_ = 4;
    }
    /**
     * <pre>
     *Used to continue a funding flow that was initiated to be executed
     *through a PSBT. This step finalizes the funded and signed PSBT, finishes
     *negotiation with the peer and finally publishes the resulting funding
     *transaction.
     * </pre>
     *
     * <code>.co.anode.anodium.FundingPsbtFinalize psbt_finalize = 4;</code>
     */
    private void clearPsbtFinalize() {
      if (triggerCase_ == 4) {
        triggerCase_ = 0;
        trigger_ = null;
      }
    }

    public static co.anode.anodium.Rpc.FundingTransitionMsg parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FundingTransitionMsg parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingTransitionMsg parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FundingTransitionMsg parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingTransitionMsg parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FundingTransitionMsg parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingTransitionMsg parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FundingTransitionMsg parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingTransitionMsg parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FundingTransitionMsg parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingTransitionMsg parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FundingTransitionMsg parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.FundingTransitionMsg prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.FundingTransitionMsg}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.FundingTransitionMsg, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.FundingTransitionMsg)
        co.anode.anodium.Rpc.FundingTransitionMsgOrBuilder {
      // Construct using co.anode.anodium.Rpc.FundingTransitionMsg.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }

      @java.lang.Override
      public TriggerCase
          getTriggerCase() {
        return instance.getTriggerCase();
      }

      public Builder clearTrigger() {
        copyOnWrite();
        instance.clearTrigger();
        return this;
      }


      /**
       * <pre>
       *The funding shim to register. This should be used before any
       *channel funding has began by the remote party, as it is intended as a
       *preparatory step for the full channel funding.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingShim shim_register = 1;</code>
       */
      @java.lang.Override
      public boolean hasShimRegister() {
        return instance.hasShimRegister();
      }
      /**
       * <pre>
       *The funding shim to register. This should be used before any
       *channel funding has began by the remote party, as it is intended as a
       *preparatory step for the full channel funding.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingShim shim_register = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.FundingShim getShimRegister() {
        return instance.getShimRegister();
      }
      /**
       * <pre>
       *The funding shim to register. This should be used before any
       *channel funding has began by the remote party, as it is intended as a
       *preparatory step for the full channel funding.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingShim shim_register = 1;</code>
       */
      public Builder setShimRegister(co.anode.anodium.Rpc.FundingShim value) {
        copyOnWrite();
        instance.setShimRegister(value);
        return this;
      }
      /**
       * <pre>
       *The funding shim to register. This should be used before any
       *channel funding has began by the remote party, as it is intended as a
       *preparatory step for the full channel funding.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingShim shim_register = 1;</code>
       */
      public Builder setShimRegister(
          co.anode.anodium.Rpc.FundingShim.Builder builderForValue) {
        copyOnWrite();
        instance.setShimRegister(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *The funding shim to register. This should be used before any
       *channel funding has began by the remote party, as it is intended as a
       *preparatory step for the full channel funding.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingShim shim_register = 1;</code>
       */
      public Builder mergeShimRegister(co.anode.anodium.Rpc.FundingShim value) {
        copyOnWrite();
        instance.mergeShimRegister(value);
        return this;
      }
      /**
       * <pre>
       *The funding shim to register. This should be used before any
       *channel funding has began by the remote party, as it is intended as a
       *preparatory step for the full channel funding.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingShim shim_register = 1;</code>
       */
      public Builder clearShimRegister() {
        copyOnWrite();
        instance.clearShimRegister();
        return this;
      }

      /**
       * <pre>
       * Used to cancel an existing registered funding shim.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingShimCancel shim_cancel = 2;</code>
       */
      @java.lang.Override
      public boolean hasShimCancel() {
        return instance.hasShimCancel();
      }
      /**
       * <pre>
       * Used to cancel an existing registered funding shim.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingShimCancel shim_cancel = 2;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.FundingShimCancel getShimCancel() {
        return instance.getShimCancel();
      }
      /**
       * <pre>
       * Used to cancel an existing registered funding shim.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingShimCancel shim_cancel = 2;</code>
       */
      public Builder setShimCancel(co.anode.anodium.Rpc.FundingShimCancel value) {
        copyOnWrite();
        instance.setShimCancel(value);
        return this;
      }
      /**
       * <pre>
       * Used to cancel an existing registered funding shim.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingShimCancel shim_cancel = 2;</code>
       */
      public Builder setShimCancel(
          co.anode.anodium.Rpc.FundingShimCancel.Builder builderForValue) {
        copyOnWrite();
        instance.setShimCancel(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Used to cancel an existing registered funding shim.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingShimCancel shim_cancel = 2;</code>
       */
      public Builder mergeShimCancel(co.anode.anodium.Rpc.FundingShimCancel value) {
        copyOnWrite();
        instance.mergeShimCancel(value);
        return this;
      }
      /**
       * <pre>
       * Used to cancel an existing registered funding shim.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingShimCancel shim_cancel = 2;</code>
       */
      public Builder clearShimCancel() {
        copyOnWrite();
        instance.clearShimCancel();
        return this;
      }

      /**
       * <pre>
       *Used to continue a funding flow that was initiated to be executed
       *through a PSBT. This step verifies that the PSBT contains the correct
       *outputs to fund the channel.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingPsbtVerify psbt_verify = 3;</code>
       */
      @java.lang.Override
      public boolean hasPsbtVerify() {
        return instance.hasPsbtVerify();
      }
      /**
       * <pre>
       *Used to continue a funding flow that was initiated to be executed
       *through a PSBT. This step verifies that the PSBT contains the correct
       *outputs to fund the channel.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingPsbtVerify psbt_verify = 3;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.FundingPsbtVerify getPsbtVerify() {
        return instance.getPsbtVerify();
      }
      /**
       * <pre>
       *Used to continue a funding flow that was initiated to be executed
       *through a PSBT. This step verifies that the PSBT contains the correct
       *outputs to fund the channel.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingPsbtVerify psbt_verify = 3;</code>
       */
      public Builder setPsbtVerify(co.anode.anodium.Rpc.FundingPsbtVerify value) {
        copyOnWrite();
        instance.setPsbtVerify(value);
        return this;
      }
      /**
       * <pre>
       *Used to continue a funding flow that was initiated to be executed
       *through a PSBT. This step verifies that the PSBT contains the correct
       *outputs to fund the channel.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingPsbtVerify psbt_verify = 3;</code>
       */
      public Builder setPsbtVerify(
          co.anode.anodium.Rpc.FundingPsbtVerify.Builder builderForValue) {
        copyOnWrite();
        instance.setPsbtVerify(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Used to continue a funding flow that was initiated to be executed
       *through a PSBT. This step verifies that the PSBT contains the correct
       *outputs to fund the channel.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingPsbtVerify psbt_verify = 3;</code>
       */
      public Builder mergePsbtVerify(co.anode.anodium.Rpc.FundingPsbtVerify value) {
        copyOnWrite();
        instance.mergePsbtVerify(value);
        return this;
      }
      /**
       * <pre>
       *Used to continue a funding flow that was initiated to be executed
       *through a PSBT. This step verifies that the PSBT contains the correct
       *outputs to fund the channel.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingPsbtVerify psbt_verify = 3;</code>
       */
      public Builder clearPsbtVerify() {
        copyOnWrite();
        instance.clearPsbtVerify();
        return this;
      }

      /**
       * <pre>
       *Used to continue a funding flow that was initiated to be executed
       *through a PSBT. This step finalizes the funded and signed PSBT, finishes
       *negotiation with the peer and finally publishes the resulting funding
       *transaction.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingPsbtFinalize psbt_finalize = 4;</code>
       */
      @java.lang.Override
      public boolean hasPsbtFinalize() {
        return instance.hasPsbtFinalize();
      }
      /**
       * <pre>
       *Used to continue a funding flow that was initiated to be executed
       *through a PSBT. This step finalizes the funded and signed PSBT, finishes
       *negotiation with the peer and finally publishes the resulting funding
       *transaction.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingPsbtFinalize psbt_finalize = 4;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.FundingPsbtFinalize getPsbtFinalize() {
        return instance.getPsbtFinalize();
      }
      /**
       * <pre>
       *Used to continue a funding flow that was initiated to be executed
       *through a PSBT. This step finalizes the funded and signed PSBT, finishes
       *negotiation with the peer and finally publishes the resulting funding
       *transaction.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingPsbtFinalize psbt_finalize = 4;</code>
       */
      public Builder setPsbtFinalize(co.anode.anodium.Rpc.FundingPsbtFinalize value) {
        copyOnWrite();
        instance.setPsbtFinalize(value);
        return this;
      }
      /**
       * <pre>
       *Used to continue a funding flow that was initiated to be executed
       *through a PSBT. This step finalizes the funded and signed PSBT, finishes
       *negotiation with the peer and finally publishes the resulting funding
       *transaction.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingPsbtFinalize psbt_finalize = 4;</code>
       */
      public Builder setPsbtFinalize(
          co.anode.anodium.Rpc.FundingPsbtFinalize.Builder builderForValue) {
        copyOnWrite();
        instance.setPsbtFinalize(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Used to continue a funding flow that was initiated to be executed
       *through a PSBT. This step finalizes the funded and signed PSBT, finishes
       *negotiation with the peer and finally publishes the resulting funding
       *transaction.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingPsbtFinalize psbt_finalize = 4;</code>
       */
      public Builder mergePsbtFinalize(co.anode.anodium.Rpc.FundingPsbtFinalize value) {
        copyOnWrite();
        instance.mergePsbtFinalize(value);
        return this;
      }
      /**
       * <pre>
       *Used to continue a funding flow that was initiated to be executed
       *through a PSBT. This step finalizes the funded and signed PSBT, finishes
       *negotiation with the peer and finally publishes the resulting funding
       *transaction.
       * </pre>
       *
       * <code>.co.anode.anodium.FundingPsbtFinalize psbt_finalize = 4;</code>
       */
      public Builder clearPsbtFinalize() {
        copyOnWrite();
        instance.clearPsbtFinalize();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.FundingTransitionMsg)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.FundingTransitionMsg();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "trigger_",
              "triggerCase_",
              co.anode.anodium.Rpc.FundingShim.class,
              co.anode.anodium.Rpc.FundingShimCancel.class,
              co.anode.anodium.Rpc.FundingPsbtVerify.class,
              co.anode.anodium.Rpc.FundingPsbtFinalize.class,
            };
            java.lang.String info =
                "\u0000\u0004\u0001\u0000\u0001\u0004\u0004\u0000\u0000\u0000\u0001<\u0000\u0002<" +
                "\u0000\u0003<\u0000\u0004<\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.FundingTransitionMsg> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.FundingTransitionMsg.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.FundingTransitionMsg>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.FundingTransitionMsg)
    private static final co.anode.anodium.Rpc.FundingTransitionMsg DEFAULT_INSTANCE;
    static {
      FundingTransitionMsg defaultInstance = new FundingTransitionMsg();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        FundingTransitionMsg.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.FundingTransitionMsg getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FundingTransitionMsg> PARSER;

    public static com.google.protobuf.Parser<FundingTransitionMsg> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FundingStateStepRespOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.FundingStateStepResp)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.FundingStateStepResp}
   */
  public  static final class FundingStateStepResp extends
      com.google.protobuf.GeneratedMessageLite<
          FundingStateStepResp, FundingStateStepResp.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.FundingStateStepResp)
      FundingStateStepRespOrBuilder {
    private FundingStateStepResp() {
    }
    public static co.anode.anodium.Rpc.FundingStateStepResp parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FundingStateStepResp parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingStateStepResp parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FundingStateStepResp parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingStateStepResp parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FundingStateStepResp parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingStateStepResp parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FundingStateStepResp parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingStateStepResp parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FundingStateStepResp parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FundingStateStepResp parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FundingStateStepResp parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.FundingStateStepResp prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.FundingStateStepResp}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.FundingStateStepResp, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.FundingStateStepResp)
        co.anode.anodium.Rpc.FundingStateStepRespOrBuilder {
      // Construct using co.anode.anodium.Rpc.FundingStateStepResp.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.FundingStateStepResp)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.FundingStateStepResp();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.FundingStateStepResp> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.FundingStateStepResp.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.FundingStateStepResp>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.FundingStateStepResp)
    private static final co.anode.anodium.Rpc.FundingStateStepResp DEFAULT_INSTANCE;
    static {
      FundingStateStepResp defaultInstance = new FundingStateStepResp();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        FundingStateStepResp.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.FundingStateStepResp getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FundingStateStepResp> PARSER;

    public static com.google.protobuf.Parser<FundingStateStepResp> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PendingHTLCOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.PendingHTLC)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The direction within the channel that the htlc was sent
     * </pre>
     *
     * <code>bool incoming = 1;</code>
     * @return The incoming.
     */
    boolean getIncoming();

    /**
     * <pre>
     * The total value of the htlc
     * </pre>
     *
     * <code>int64 amount = 2;</code>
     * @return The amount.
     */
    long getAmount();

    /**
     * <pre>
     * The final output to be swept back to the user's wallet
     * </pre>
     *
     * <code>string outpoint = 3;</code>
     * @return The outpoint.
     */
    java.lang.String getOutpoint();
    /**
     * <pre>
     * The final output to be swept back to the user's wallet
     * </pre>
     *
     * <code>string outpoint = 3;</code>
     * @return The bytes for outpoint.
     */
    com.google.protobuf.ByteString
        getOutpointBytes();

    /**
     * <pre>
     * The next block height at which we can spend the current stage
     * </pre>
     *
     * <code>uint32 maturity_height = 4;</code>
     * @return The maturityHeight.
     */
    int getMaturityHeight();

    /**
     * <pre>
     *The number of blocks remaining until the current stage can be swept.
     *Negative values indicate how many blocks have passed since becoming
     *mature.
     * </pre>
     *
     * <code>int32 blocks_til_maturity = 5;</code>
     * @return The blocksTilMaturity.
     */
    int getBlocksTilMaturity();

    /**
     * <pre>
     * Indicates whether the htlc is in its first or second stage of recovery
     * </pre>
     *
     * <code>uint32 stage = 6;</code>
     * @return The stage.
     */
    int getStage();
  }
  /**
   * Protobuf type {@code co.anode.anodium.PendingHTLC}
   */
  public  static final class PendingHTLC extends
      com.google.protobuf.GeneratedMessageLite<
          PendingHTLC, PendingHTLC.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.PendingHTLC)
      PendingHTLCOrBuilder {
    private PendingHTLC() {
      outpoint_ = "";
    }
    public static final int INCOMING_FIELD_NUMBER = 1;
    private boolean incoming_;
    /**
     * <pre>
     * The direction within the channel that the htlc was sent
     * </pre>
     *
     * <code>bool incoming = 1;</code>
     * @return The incoming.
     */
    @java.lang.Override
    public boolean getIncoming() {
      return incoming_;
    }
    /**
     * <pre>
     * The direction within the channel that the htlc was sent
     * </pre>
     *
     * <code>bool incoming = 1;</code>
     * @param value The incoming to set.
     */
    private void setIncoming(boolean value) {
      
      incoming_ = value;
    }
    /**
     * <pre>
     * The direction within the channel that the htlc was sent
     * </pre>
     *
     * <code>bool incoming = 1;</code>
     */
    private void clearIncoming() {
      
      incoming_ = false;
    }

    public static final int AMOUNT_FIELD_NUMBER = 2;
    private long amount_;
    /**
     * <pre>
     * The total value of the htlc
     * </pre>
     *
     * <code>int64 amount = 2;</code>
     * @return The amount.
     */
    @java.lang.Override
    public long getAmount() {
      return amount_;
    }
    /**
     * <pre>
     * The total value of the htlc
     * </pre>
     *
     * <code>int64 amount = 2;</code>
     * @param value The amount to set.
     */
    private void setAmount(long value) {
      
      amount_ = value;
    }
    /**
     * <pre>
     * The total value of the htlc
     * </pre>
     *
     * <code>int64 amount = 2;</code>
     */
    private void clearAmount() {
      
      amount_ = 0L;
    }

    public static final int OUTPOINT_FIELD_NUMBER = 3;
    private java.lang.String outpoint_;
    /**
     * <pre>
     * The final output to be swept back to the user's wallet
     * </pre>
     *
     * <code>string outpoint = 3;</code>
     * @return The outpoint.
     */
    @java.lang.Override
    public java.lang.String getOutpoint() {
      return outpoint_;
    }
    /**
     * <pre>
     * The final output to be swept back to the user's wallet
     * </pre>
     *
     * <code>string outpoint = 3;</code>
     * @return The bytes for outpoint.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getOutpointBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(outpoint_);
    }
    /**
     * <pre>
     * The final output to be swept back to the user's wallet
     * </pre>
     *
     * <code>string outpoint = 3;</code>
     * @param value The outpoint to set.
     */
    private void setOutpoint(
        java.lang.String value) {
      value.getClass();
  
      outpoint_ = value;
    }
    /**
     * <pre>
     * The final output to be swept back to the user's wallet
     * </pre>
     *
     * <code>string outpoint = 3;</code>
     */
    private void clearOutpoint() {
      
      outpoint_ = getDefaultInstance().getOutpoint();
    }
    /**
     * <pre>
     * The final output to be swept back to the user's wallet
     * </pre>
     *
     * <code>string outpoint = 3;</code>
     * @param value The bytes for outpoint to set.
     */
    private void setOutpointBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      outpoint_ = value.toStringUtf8();
      
    }

    public static final int MATURITY_HEIGHT_FIELD_NUMBER = 4;
    private int maturityHeight_;
    /**
     * <pre>
     * The next block height at which we can spend the current stage
     * </pre>
     *
     * <code>uint32 maturity_height = 4;</code>
     * @return The maturityHeight.
     */
    @java.lang.Override
    public int getMaturityHeight() {
      return maturityHeight_;
    }
    /**
     * <pre>
     * The next block height at which we can spend the current stage
     * </pre>
     *
     * <code>uint32 maturity_height = 4;</code>
     * @param value The maturityHeight to set.
     */
    private void setMaturityHeight(int value) {
      
      maturityHeight_ = value;
    }
    /**
     * <pre>
     * The next block height at which we can spend the current stage
     * </pre>
     *
     * <code>uint32 maturity_height = 4;</code>
     */
    private void clearMaturityHeight() {
      
      maturityHeight_ = 0;
    }

    public static final int BLOCKS_TIL_MATURITY_FIELD_NUMBER = 5;
    private int blocksTilMaturity_;
    /**
     * <pre>
     *The number of blocks remaining until the current stage can be swept.
     *Negative values indicate how many blocks have passed since becoming
     *mature.
     * </pre>
     *
     * <code>int32 blocks_til_maturity = 5;</code>
     * @return The blocksTilMaturity.
     */
    @java.lang.Override
    public int getBlocksTilMaturity() {
      return blocksTilMaturity_;
    }
    /**
     * <pre>
     *The number of blocks remaining until the current stage can be swept.
     *Negative values indicate how many blocks have passed since becoming
     *mature.
     * </pre>
     *
     * <code>int32 blocks_til_maturity = 5;</code>
     * @param value The blocksTilMaturity to set.
     */
    private void setBlocksTilMaturity(int value) {
      
      blocksTilMaturity_ = value;
    }
    /**
     * <pre>
     *The number of blocks remaining until the current stage can be swept.
     *Negative values indicate how many blocks have passed since becoming
     *mature.
     * </pre>
     *
     * <code>int32 blocks_til_maturity = 5;</code>
     */
    private void clearBlocksTilMaturity() {
      
      blocksTilMaturity_ = 0;
    }

    public static final int STAGE_FIELD_NUMBER = 6;
    private int stage_;
    /**
     * <pre>
     * Indicates whether the htlc is in its first or second stage of recovery
     * </pre>
     *
     * <code>uint32 stage = 6;</code>
     * @return The stage.
     */
    @java.lang.Override
    public int getStage() {
      return stage_;
    }
    /**
     * <pre>
     * Indicates whether the htlc is in its first or second stage of recovery
     * </pre>
     *
     * <code>uint32 stage = 6;</code>
     * @param value The stage to set.
     */
    private void setStage(int value) {
      
      stage_ = value;
    }
    /**
     * <pre>
     * Indicates whether the htlc is in its first or second stage of recovery
     * </pre>
     *
     * <code>uint32 stage = 6;</code>
     */
    private void clearStage() {
      
      stage_ = 0;
    }

    public static co.anode.anodium.Rpc.PendingHTLC parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PendingHTLC parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingHTLC parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PendingHTLC parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingHTLC parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PendingHTLC parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingHTLC parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PendingHTLC parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingHTLC parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PendingHTLC parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingHTLC parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PendingHTLC parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.PendingHTLC prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.PendingHTLC}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.PendingHTLC, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.PendingHTLC)
        co.anode.anodium.Rpc.PendingHTLCOrBuilder {
      // Construct using co.anode.anodium.Rpc.PendingHTLC.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The direction within the channel that the htlc was sent
       * </pre>
       *
       * <code>bool incoming = 1;</code>
       * @return The incoming.
       */
      @java.lang.Override
      public boolean getIncoming() {
        return instance.getIncoming();
      }
      /**
       * <pre>
       * The direction within the channel that the htlc was sent
       * </pre>
       *
       * <code>bool incoming = 1;</code>
       * @param value The incoming to set.
       * @return This builder for chaining.
       */
      public Builder setIncoming(boolean value) {
        copyOnWrite();
        instance.setIncoming(value);
        return this;
      }
      /**
       * <pre>
       * The direction within the channel that the htlc was sent
       * </pre>
       *
       * <code>bool incoming = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearIncoming() {
        copyOnWrite();
        instance.clearIncoming();
        return this;
      }

      /**
       * <pre>
       * The total value of the htlc
       * </pre>
       *
       * <code>int64 amount = 2;</code>
       * @return The amount.
       */
      @java.lang.Override
      public long getAmount() {
        return instance.getAmount();
      }
      /**
       * <pre>
       * The total value of the htlc
       * </pre>
       *
       * <code>int64 amount = 2;</code>
       * @param value The amount to set.
       * @return This builder for chaining.
       */
      public Builder setAmount(long value) {
        copyOnWrite();
        instance.setAmount(value);
        return this;
      }
      /**
       * <pre>
       * The total value of the htlc
       * </pre>
       *
       * <code>int64 amount = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmount() {
        copyOnWrite();
        instance.clearAmount();
        return this;
      }

      /**
       * <pre>
       * The final output to be swept back to the user's wallet
       * </pre>
       *
       * <code>string outpoint = 3;</code>
       * @return The outpoint.
       */
      @java.lang.Override
      public java.lang.String getOutpoint() {
        return instance.getOutpoint();
      }
      /**
       * <pre>
       * The final output to be swept back to the user's wallet
       * </pre>
       *
       * <code>string outpoint = 3;</code>
       * @return The bytes for outpoint.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getOutpointBytes() {
        return instance.getOutpointBytes();
      }
      /**
       * <pre>
       * The final output to be swept back to the user's wallet
       * </pre>
       *
       * <code>string outpoint = 3;</code>
       * @param value The outpoint to set.
       * @return This builder for chaining.
       */
      public Builder setOutpoint(
          java.lang.String value) {
        copyOnWrite();
        instance.setOutpoint(value);
        return this;
      }
      /**
       * <pre>
       * The final output to be swept back to the user's wallet
       * </pre>
       *
       * <code>string outpoint = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearOutpoint() {
        copyOnWrite();
        instance.clearOutpoint();
        return this;
      }
      /**
       * <pre>
       * The final output to be swept back to the user's wallet
       * </pre>
       *
       * <code>string outpoint = 3;</code>
       * @param value The bytes for outpoint to set.
       * @return This builder for chaining.
       */
      public Builder setOutpointBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setOutpointBytes(value);
        return this;
      }

      /**
       * <pre>
       * The next block height at which we can spend the current stage
       * </pre>
       *
       * <code>uint32 maturity_height = 4;</code>
       * @return The maturityHeight.
       */
      @java.lang.Override
      public int getMaturityHeight() {
        return instance.getMaturityHeight();
      }
      /**
       * <pre>
       * The next block height at which we can spend the current stage
       * </pre>
       *
       * <code>uint32 maturity_height = 4;</code>
       * @param value The maturityHeight to set.
       * @return This builder for chaining.
       */
      public Builder setMaturityHeight(int value) {
        copyOnWrite();
        instance.setMaturityHeight(value);
        return this;
      }
      /**
       * <pre>
       * The next block height at which we can spend the current stage
       * </pre>
       *
       * <code>uint32 maturity_height = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaturityHeight() {
        copyOnWrite();
        instance.clearMaturityHeight();
        return this;
      }

      /**
       * <pre>
       *The number of blocks remaining until the current stage can be swept.
       *Negative values indicate how many blocks have passed since becoming
       *mature.
       * </pre>
       *
       * <code>int32 blocks_til_maturity = 5;</code>
       * @return The blocksTilMaturity.
       */
      @java.lang.Override
      public int getBlocksTilMaturity() {
        return instance.getBlocksTilMaturity();
      }
      /**
       * <pre>
       *The number of blocks remaining until the current stage can be swept.
       *Negative values indicate how many blocks have passed since becoming
       *mature.
       * </pre>
       *
       * <code>int32 blocks_til_maturity = 5;</code>
       * @param value The blocksTilMaturity to set.
       * @return This builder for chaining.
       */
      public Builder setBlocksTilMaturity(int value) {
        copyOnWrite();
        instance.setBlocksTilMaturity(value);
        return this;
      }
      /**
       * <pre>
       *The number of blocks remaining until the current stage can be swept.
       *Negative values indicate how many blocks have passed since becoming
       *mature.
       * </pre>
       *
       * <code>int32 blocks_til_maturity = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearBlocksTilMaturity() {
        copyOnWrite();
        instance.clearBlocksTilMaturity();
        return this;
      }

      /**
       * <pre>
       * Indicates whether the htlc is in its first or second stage of recovery
       * </pre>
       *
       * <code>uint32 stage = 6;</code>
       * @return The stage.
       */
      @java.lang.Override
      public int getStage() {
        return instance.getStage();
      }
      /**
       * <pre>
       * Indicates whether the htlc is in its first or second stage of recovery
       * </pre>
       *
       * <code>uint32 stage = 6;</code>
       * @param value The stage to set.
       * @return This builder for chaining.
       */
      public Builder setStage(int value) {
        copyOnWrite();
        instance.setStage(value);
        return this;
      }
      /**
       * <pre>
       * Indicates whether the htlc is in its first or second stage of recovery
       * </pre>
       *
       * <code>uint32 stage = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearStage() {
        copyOnWrite();
        instance.clearStage();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.PendingHTLC)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.PendingHTLC();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "incoming_",
              "amount_",
              "outpoint_",
              "maturityHeight_",
              "blocksTilMaturity_",
              "stage_",
            };
            java.lang.String info =
                "\u0000\u0006\u0000\u0000\u0001\u0006\u0006\u0000\u0000\u0000\u0001\u0007\u0002\u0002" +
                "\u0003\u0208\u0004\u000b\u0005\u0004\u0006\u000b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.PendingHTLC> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.PendingHTLC.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.PendingHTLC>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.PendingHTLC)
    private static final co.anode.anodium.Rpc.PendingHTLC DEFAULT_INSTANCE;
    static {
      PendingHTLC defaultInstance = new PendingHTLC();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        PendingHTLC.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.PendingHTLC getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<PendingHTLC> PARSER;

    public static com.google.protobuf.Parser<PendingHTLC> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PendingChannelsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.PendingChannelsRequest)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.PendingChannelsRequest}
   */
  public  static final class PendingChannelsRequest extends
      com.google.protobuf.GeneratedMessageLite<
          PendingChannelsRequest, PendingChannelsRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.PendingChannelsRequest)
      PendingChannelsRequestOrBuilder {
    private PendingChannelsRequest() {
    }
    public static co.anode.anodium.Rpc.PendingChannelsRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PendingChannelsRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingChannelsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PendingChannelsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingChannelsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PendingChannelsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingChannelsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PendingChannelsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingChannelsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PendingChannelsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingChannelsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PendingChannelsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.PendingChannelsRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.PendingChannelsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.PendingChannelsRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.PendingChannelsRequest)
        co.anode.anodium.Rpc.PendingChannelsRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.PendingChannelsRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.PendingChannelsRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.PendingChannelsRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.PendingChannelsRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.PendingChannelsRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.PendingChannelsRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.PendingChannelsRequest)
    private static final co.anode.anodium.Rpc.PendingChannelsRequest DEFAULT_INSTANCE;
    static {
      PendingChannelsRequest defaultInstance = new PendingChannelsRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        PendingChannelsRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.PendingChannelsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<PendingChannelsRequest> PARSER;

    public static com.google.protobuf.Parser<PendingChannelsRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PendingChannelsResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.PendingChannelsResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The balance in satoshis encumbered in pending channels
     * </pre>
     *
     * <code>int64 total_limbo_balance = 1;</code>
     * @return The totalLimboBalance.
     */
    long getTotalLimboBalance();

    /**
     * <pre>
     * Channels pending opening
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
     */
    java.util.List<co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel> 
        getPendingOpenChannelsList();
    /**
     * <pre>
     * Channels pending opening
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
     */
    co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel getPendingOpenChannels(int index);
    /**
     * <pre>
     * Channels pending opening
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
     */
    int getPendingOpenChannelsCount();

    /**
     * <pre>
     *Deprecated: Channels pending closing previously contained cooperatively
     *closed channels with a single confirmation. These channels are now
     *considered closed from the time we see them on chain.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
     */
    @java.lang.Deprecated java.util.List<co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel> 
        getPendingClosingChannelsList();
    /**
     * <pre>
     *Deprecated: Channels pending closing previously contained cooperatively
     *closed channels with a single confirmation. These channels are now
     *considered closed from the time we see them on chain.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
     */
    @java.lang.Deprecated co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel getPendingClosingChannels(int index);
    /**
     * <pre>
     *Deprecated: Channels pending closing previously contained cooperatively
     *closed channels with a single confirmation. These channels are now
     *considered closed from the time we see them on chain.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
     */
    @java.lang.Deprecated int getPendingClosingChannelsCount();

    /**
     * <pre>
     * Channels pending force closing
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
     */
    java.util.List<co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel> 
        getPendingForceClosingChannelsList();
    /**
     * <pre>
     * Channels pending force closing
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
     */
    co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel getPendingForceClosingChannels(int index);
    /**
     * <pre>
     * Channels pending force closing
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
     */
    int getPendingForceClosingChannelsCount();

    /**
     * <pre>
     * Channels waiting for closing tx to confirm
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
     */
    java.util.List<co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel> 
        getWaitingCloseChannelsList();
    /**
     * <pre>
     * Channels waiting for closing tx to confirm
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
     */
    co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel getWaitingCloseChannels(int index);
    /**
     * <pre>
     * Channels waiting for closing tx to confirm
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
     */
    int getWaitingCloseChannelsCount();
  }
  /**
   * Protobuf type {@code co.anode.anodium.PendingChannelsResponse}
   */
  public  static final class PendingChannelsResponse extends
      com.google.protobuf.GeneratedMessageLite<
          PendingChannelsResponse, PendingChannelsResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.PendingChannelsResponse)
      PendingChannelsResponseOrBuilder {
    private PendingChannelsResponse() {
      pendingOpenChannels_ = emptyProtobufList();
      pendingClosingChannels_ = emptyProtobufList();
      pendingForceClosingChannels_ = emptyProtobufList();
      waitingCloseChannels_ = emptyProtobufList();
    }
    public interface PendingChannelOrBuilder extends
        // @@protoc_insertion_point(interface_extends:co.anode.anodium.PendingChannelsResponse.PendingChannel)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <code>string remote_node_pub = 1;</code>
       * @return The remoteNodePub.
       */
      java.lang.String getRemoteNodePub();
      /**
       * <code>string remote_node_pub = 1;</code>
       * @return The bytes for remoteNodePub.
       */
      com.google.protobuf.ByteString
          getRemoteNodePubBytes();

      /**
       * <code>string channel_point = 2;</code>
       * @return The channelPoint.
       */
      java.lang.String getChannelPoint();
      /**
       * <code>string channel_point = 2;</code>
       * @return The bytes for channelPoint.
       */
      com.google.protobuf.ByteString
          getChannelPointBytes();

      /**
       * <code>int64 capacity = 3;</code>
       * @return The capacity.
       */
      long getCapacity();

      /**
       * <code>int64 local_balance = 4;</code>
       * @return The localBalance.
       */
      long getLocalBalance();

      /**
       * <code>int64 remote_balance = 5;</code>
       * @return The remoteBalance.
       */
      long getRemoteBalance();

      /**
       * <pre>
       * The minimum satoshis this node is required to reserve in its
       * balance.
       * </pre>
       *
       * <code>int64 local_chan_reserve_sat = 6;</code>
       * @return The localChanReserveSat.
       */
      long getLocalChanReserveSat();

      /**
       * <pre>
       *The minimum satoshis the other node is required to reserve in its
       *balance.
       * </pre>
       *
       * <code>int64 remote_chan_reserve_sat = 7;</code>
       * @return The remoteChanReserveSat.
       */
      long getRemoteChanReserveSat();

      /**
       * <pre>
       * The party that initiated opening the channel.
       * </pre>
       *
       * <code>.co.anode.anodium.Initiator initiator = 8;</code>
       * @return The enum numeric value on the wire for initiator.
       */
      int getInitiatorValue();
      /**
       * <pre>
       * The party that initiated opening the channel.
       * </pre>
       *
       * <code>.co.anode.anodium.Initiator initiator = 8;</code>
       * @return The initiator.
       */
      co.anode.anodium.Rpc.Initiator getInitiator();

      /**
       * <pre>
       * The commitment type used by this channel.
       * </pre>
       *
       * <code>.co.anode.anodium.CommitmentType commitment_type = 9;</code>
       * @return The enum numeric value on the wire for commitmentType.
       */
      int getCommitmentTypeValue();
      /**
       * <pre>
       * The commitment type used by this channel.
       * </pre>
       *
       * <code>.co.anode.anodium.CommitmentType commitment_type = 9;</code>
       * @return The commitmentType.
       */
      co.anode.anodium.Rpc.CommitmentType getCommitmentType();
    }
    /**
     * Protobuf type {@code co.anode.anodium.PendingChannelsResponse.PendingChannel}
     */
    public  static final class PendingChannel extends
        com.google.protobuf.GeneratedMessageLite<
            PendingChannel, PendingChannel.Builder> implements
        // @@protoc_insertion_point(message_implements:co.anode.anodium.PendingChannelsResponse.PendingChannel)
        PendingChannelOrBuilder {
      private PendingChannel() {
        remoteNodePub_ = "";
        channelPoint_ = "";
      }
      public static final int REMOTE_NODE_PUB_FIELD_NUMBER = 1;
      private java.lang.String remoteNodePub_;
      /**
       * <code>string remote_node_pub = 1;</code>
       * @return The remoteNodePub.
       */
      @java.lang.Override
      public java.lang.String getRemoteNodePub() {
        return remoteNodePub_;
      }
      /**
       * <code>string remote_node_pub = 1;</code>
       * @return The bytes for remoteNodePub.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getRemoteNodePubBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(remoteNodePub_);
      }
      /**
       * <code>string remote_node_pub = 1;</code>
       * @param value The remoteNodePub to set.
       */
      private void setRemoteNodePub(
          java.lang.String value) {
        value.getClass();
  
        remoteNodePub_ = value;
      }
      /**
       * <code>string remote_node_pub = 1;</code>
       */
      private void clearRemoteNodePub() {
        
        remoteNodePub_ = getDefaultInstance().getRemoteNodePub();
      }
      /**
       * <code>string remote_node_pub = 1;</code>
       * @param value The bytes for remoteNodePub to set.
       */
      private void setRemoteNodePubBytes(
          com.google.protobuf.ByteString value) {
        checkByteStringIsUtf8(value);
        remoteNodePub_ = value.toStringUtf8();
        
      }

      public static final int CHANNEL_POINT_FIELD_NUMBER = 2;
      private java.lang.String channelPoint_;
      /**
       * <code>string channel_point = 2;</code>
       * @return The channelPoint.
       */
      @java.lang.Override
      public java.lang.String getChannelPoint() {
        return channelPoint_;
      }
      /**
       * <code>string channel_point = 2;</code>
       * @return The bytes for channelPoint.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getChannelPointBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(channelPoint_);
      }
      /**
       * <code>string channel_point = 2;</code>
       * @param value The channelPoint to set.
       */
      private void setChannelPoint(
          java.lang.String value) {
        value.getClass();
  
        channelPoint_ = value;
      }
      /**
       * <code>string channel_point = 2;</code>
       */
      private void clearChannelPoint() {
        
        channelPoint_ = getDefaultInstance().getChannelPoint();
      }
      /**
       * <code>string channel_point = 2;</code>
       * @param value The bytes for channelPoint to set.
       */
      private void setChannelPointBytes(
          com.google.protobuf.ByteString value) {
        checkByteStringIsUtf8(value);
        channelPoint_ = value.toStringUtf8();
        
      }

      public static final int CAPACITY_FIELD_NUMBER = 3;
      private long capacity_;
      /**
       * <code>int64 capacity = 3;</code>
       * @return The capacity.
       */
      @java.lang.Override
      public long getCapacity() {
        return capacity_;
      }
      /**
       * <code>int64 capacity = 3;</code>
       * @param value The capacity to set.
       */
      private void setCapacity(long value) {
        
        capacity_ = value;
      }
      /**
       * <code>int64 capacity = 3;</code>
       */
      private void clearCapacity() {
        
        capacity_ = 0L;
      }

      public static final int LOCAL_BALANCE_FIELD_NUMBER = 4;
      private long localBalance_;
      /**
       * <code>int64 local_balance = 4;</code>
       * @return The localBalance.
       */
      @java.lang.Override
      public long getLocalBalance() {
        return localBalance_;
      }
      /**
       * <code>int64 local_balance = 4;</code>
       * @param value The localBalance to set.
       */
      private void setLocalBalance(long value) {
        
        localBalance_ = value;
      }
      /**
       * <code>int64 local_balance = 4;</code>
       */
      private void clearLocalBalance() {
        
        localBalance_ = 0L;
      }

      public static final int REMOTE_BALANCE_FIELD_NUMBER = 5;
      private long remoteBalance_;
      /**
       * <code>int64 remote_balance = 5;</code>
       * @return The remoteBalance.
       */
      @java.lang.Override
      public long getRemoteBalance() {
        return remoteBalance_;
      }
      /**
       * <code>int64 remote_balance = 5;</code>
       * @param value The remoteBalance to set.
       */
      private void setRemoteBalance(long value) {
        
        remoteBalance_ = value;
      }
      /**
       * <code>int64 remote_balance = 5;</code>
       */
      private void clearRemoteBalance() {
        
        remoteBalance_ = 0L;
      }

      public static final int LOCAL_CHAN_RESERVE_SAT_FIELD_NUMBER = 6;
      private long localChanReserveSat_;
      /**
       * <pre>
       * The minimum satoshis this node is required to reserve in its
       * balance.
       * </pre>
       *
       * <code>int64 local_chan_reserve_sat = 6;</code>
       * @return The localChanReserveSat.
       */
      @java.lang.Override
      public long getLocalChanReserveSat() {
        return localChanReserveSat_;
      }
      /**
       * <pre>
       * The minimum satoshis this node is required to reserve in its
       * balance.
       * </pre>
       *
       * <code>int64 local_chan_reserve_sat = 6;</code>
       * @param value The localChanReserveSat to set.
       */
      private void setLocalChanReserveSat(long value) {
        
        localChanReserveSat_ = value;
      }
      /**
       * <pre>
       * The minimum satoshis this node is required to reserve in its
       * balance.
       * </pre>
       *
       * <code>int64 local_chan_reserve_sat = 6;</code>
       */
      private void clearLocalChanReserveSat() {
        
        localChanReserveSat_ = 0L;
      }

      public static final int REMOTE_CHAN_RESERVE_SAT_FIELD_NUMBER = 7;
      private long remoteChanReserveSat_;
      /**
       * <pre>
       *The minimum satoshis the other node is required to reserve in its
       *balance.
       * </pre>
       *
       * <code>int64 remote_chan_reserve_sat = 7;</code>
       * @return The remoteChanReserveSat.
       */
      @java.lang.Override
      public long getRemoteChanReserveSat() {
        return remoteChanReserveSat_;
      }
      /**
       * <pre>
       *The minimum satoshis the other node is required to reserve in its
       *balance.
       * </pre>
       *
       * <code>int64 remote_chan_reserve_sat = 7;</code>
       * @param value The remoteChanReserveSat to set.
       */
      private void setRemoteChanReserveSat(long value) {
        
        remoteChanReserveSat_ = value;
      }
      /**
       * <pre>
       *The minimum satoshis the other node is required to reserve in its
       *balance.
       * </pre>
       *
       * <code>int64 remote_chan_reserve_sat = 7;</code>
       */
      private void clearRemoteChanReserveSat() {
        
        remoteChanReserveSat_ = 0L;
      }

      public static final int INITIATOR_FIELD_NUMBER = 8;
      private int initiator_;
      /**
       * <pre>
       * The party that initiated opening the channel.
       * </pre>
       *
       * <code>.co.anode.anodium.Initiator initiator = 8;</code>
       * @return The enum numeric value on the wire for initiator.
       */
      @java.lang.Override
      public int getInitiatorValue() {
        return initiator_;
      }
      /**
       * <pre>
       * The party that initiated opening the channel.
       * </pre>
       *
       * <code>.co.anode.anodium.Initiator initiator = 8;</code>
       * @return The initiator.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Initiator getInitiator() {
        co.anode.anodium.Rpc.Initiator result = co.anode.anodium.Rpc.Initiator.forNumber(initiator_);
        return result == null ? co.anode.anodium.Rpc.Initiator.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * The party that initiated opening the channel.
       * </pre>
       *
       * <code>.co.anode.anodium.Initiator initiator = 8;</code>
       * @param value The enum numeric value on the wire for initiator to set.
       */
      private void setInitiatorValue(int value) {
          initiator_ = value;
      }
      /**
       * <pre>
       * The party that initiated opening the channel.
       * </pre>
       *
       * <code>.co.anode.anodium.Initiator initiator = 8;</code>
       * @param value The initiator to set.
       */
      private void setInitiator(co.anode.anodium.Rpc.Initiator value) {
        initiator_ = value.getNumber();
        
      }
      /**
       * <pre>
       * The party that initiated opening the channel.
       * </pre>
       *
       * <code>.co.anode.anodium.Initiator initiator = 8;</code>
       */
      private void clearInitiator() {
        
        initiator_ = 0;
      }

      public static final int COMMITMENT_TYPE_FIELD_NUMBER = 9;
      private int commitmentType_;
      /**
       * <pre>
       * The commitment type used by this channel.
       * </pre>
       *
       * <code>.co.anode.anodium.CommitmentType commitment_type = 9;</code>
       * @return The enum numeric value on the wire for commitmentType.
       */
      @java.lang.Override
      public int getCommitmentTypeValue() {
        return commitmentType_;
      }
      /**
       * <pre>
       * The commitment type used by this channel.
       * </pre>
       *
       * <code>.co.anode.anodium.CommitmentType commitment_type = 9;</code>
       * @return The commitmentType.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.CommitmentType getCommitmentType() {
        co.anode.anodium.Rpc.CommitmentType result = co.anode.anodium.Rpc.CommitmentType.forNumber(commitmentType_);
        return result == null ? co.anode.anodium.Rpc.CommitmentType.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * The commitment type used by this channel.
       * </pre>
       *
       * <code>.co.anode.anodium.CommitmentType commitment_type = 9;</code>
       * @param value The enum numeric value on the wire for commitmentType to set.
       */
      private void setCommitmentTypeValue(int value) {
          commitmentType_ = value;
      }
      /**
       * <pre>
       * The commitment type used by this channel.
       * </pre>
       *
       * <code>.co.anode.anodium.CommitmentType commitment_type = 9;</code>
       * @param value The commitmentType to set.
       */
      private void setCommitmentType(co.anode.anodium.Rpc.CommitmentType value) {
        commitmentType_ = value.getNumber();
        
      }
      /**
       * <pre>
       * The commitment type used by this channel.
       * </pre>
       *
       * <code>.co.anode.anodium.CommitmentType commitment_type = 9;</code>
       */
      private void clearCommitmentType() {
        
        commitmentType_ = 0;
      }

      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code co.anode.anodium.PendingChannelsResponse.PendingChannel}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel, Builder> implements
          // @@protoc_insertion_point(builder_implements:co.anode.anodium.PendingChannelsResponse.PendingChannel)
          co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannelOrBuilder {
        // Construct using co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <code>string remote_node_pub = 1;</code>
         * @return The remoteNodePub.
         */
        @java.lang.Override
        public java.lang.String getRemoteNodePub() {
          return instance.getRemoteNodePub();
        }
        /**
         * <code>string remote_node_pub = 1;</code>
         * @return The bytes for remoteNodePub.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getRemoteNodePubBytes() {
          return instance.getRemoteNodePubBytes();
        }
        /**
         * <code>string remote_node_pub = 1;</code>
         * @param value The remoteNodePub to set.
         * @return This builder for chaining.
         */
        public Builder setRemoteNodePub(
            java.lang.String value) {
          copyOnWrite();
          instance.setRemoteNodePub(value);
          return this;
        }
        /**
         * <code>string remote_node_pub = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearRemoteNodePub() {
          copyOnWrite();
          instance.clearRemoteNodePub();
          return this;
        }
        /**
         * <code>string remote_node_pub = 1;</code>
         * @param value The bytes for remoteNodePub to set.
         * @return This builder for chaining.
         */
        public Builder setRemoteNodePubBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setRemoteNodePubBytes(value);
          return this;
        }

        /**
         * <code>string channel_point = 2;</code>
         * @return The channelPoint.
         */
        @java.lang.Override
        public java.lang.String getChannelPoint() {
          return instance.getChannelPoint();
        }
        /**
         * <code>string channel_point = 2;</code>
         * @return The bytes for channelPoint.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getChannelPointBytes() {
          return instance.getChannelPointBytes();
        }
        /**
         * <code>string channel_point = 2;</code>
         * @param value The channelPoint to set.
         * @return This builder for chaining.
         */
        public Builder setChannelPoint(
            java.lang.String value) {
          copyOnWrite();
          instance.setChannelPoint(value);
          return this;
        }
        /**
         * <code>string channel_point = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearChannelPoint() {
          copyOnWrite();
          instance.clearChannelPoint();
          return this;
        }
        /**
         * <code>string channel_point = 2;</code>
         * @param value The bytes for channelPoint to set.
         * @return This builder for chaining.
         */
        public Builder setChannelPointBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setChannelPointBytes(value);
          return this;
        }

        /**
         * <code>int64 capacity = 3;</code>
         * @return The capacity.
         */
        @java.lang.Override
        public long getCapacity() {
          return instance.getCapacity();
        }
        /**
         * <code>int64 capacity = 3;</code>
         * @param value The capacity to set.
         * @return This builder for chaining.
         */
        public Builder setCapacity(long value) {
          copyOnWrite();
          instance.setCapacity(value);
          return this;
        }
        /**
         * <code>int64 capacity = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearCapacity() {
          copyOnWrite();
          instance.clearCapacity();
          return this;
        }

        /**
         * <code>int64 local_balance = 4;</code>
         * @return The localBalance.
         */
        @java.lang.Override
        public long getLocalBalance() {
          return instance.getLocalBalance();
        }
        /**
         * <code>int64 local_balance = 4;</code>
         * @param value The localBalance to set.
         * @return This builder for chaining.
         */
        public Builder setLocalBalance(long value) {
          copyOnWrite();
          instance.setLocalBalance(value);
          return this;
        }
        /**
         * <code>int64 local_balance = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearLocalBalance() {
          copyOnWrite();
          instance.clearLocalBalance();
          return this;
        }

        /**
         * <code>int64 remote_balance = 5;</code>
         * @return The remoteBalance.
         */
        @java.lang.Override
        public long getRemoteBalance() {
          return instance.getRemoteBalance();
        }
        /**
         * <code>int64 remote_balance = 5;</code>
         * @param value The remoteBalance to set.
         * @return This builder for chaining.
         */
        public Builder setRemoteBalance(long value) {
          copyOnWrite();
          instance.setRemoteBalance(value);
          return this;
        }
        /**
         * <code>int64 remote_balance = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearRemoteBalance() {
          copyOnWrite();
          instance.clearRemoteBalance();
          return this;
        }

        /**
         * <pre>
         * The minimum satoshis this node is required to reserve in its
         * balance.
         * </pre>
         *
         * <code>int64 local_chan_reserve_sat = 6;</code>
         * @return The localChanReserveSat.
         */
        @java.lang.Override
        public long getLocalChanReserveSat() {
          return instance.getLocalChanReserveSat();
        }
        /**
         * <pre>
         * The minimum satoshis this node is required to reserve in its
         * balance.
         * </pre>
         *
         * <code>int64 local_chan_reserve_sat = 6;</code>
         * @param value The localChanReserveSat to set.
         * @return This builder for chaining.
         */
        public Builder setLocalChanReserveSat(long value) {
          copyOnWrite();
          instance.setLocalChanReserveSat(value);
          return this;
        }
        /**
         * <pre>
         * The minimum satoshis this node is required to reserve in its
         * balance.
         * </pre>
         *
         * <code>int64 local_chan_reserve_sat = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearLocalChanReserveSat() {
          copyOnWrite();
          instance.clearLocalChanReserveSat();
          return this;
        }

        /**
         * <pre>
         *The minimum satoshis the other node is required to reserve in its
         *balance.
         * </pre>
         *
         * <code>int64 remote_chan_reserve_sat = 7;</code>
         * @return The remoteChanReserveSat.
         */
        @java.lang.Override
        public long getRemoteChanReserveSat() {
          return instance.getRemoteChanReserveSat();
        }
        /**
         * <pre>
         *The minimum satoshis the other node is required to reserve in its
         *balance.
         * </pre>
         *
         * <code>int64 remote_chan_reserve_sat = 7;</code>
         * @param value The remoteChanReserveSat to set.
         * @return This builder for chaining.
         */
        public Builder setRemoteChanReserveSat(long value) {
          copyOnWrite();
          instance.setRemoteChanReserveSat(value);
          return this;
        }
        /**
         * <pre>
         *The minimum satoshis the other node is required to reserve in its
         *balance.
         * </pre>
         *
         * <code>int64 remote_chan_reserve_sat = 7;</code>
         * @return This builder for chaining.
         */
        public Builder clearRemoteChanReserveSat() {
          copyOnWrite();
          instance.clearRemoteChanReserveSat();
          return this;
        }

        /**
         * <pre>
         * The party that initiated opening the channel.
         * </pre>
         *
         * <code>.co.anode.anodium.Initiator initiator = 8;</code>
         * @return The enum numeric value on the wire for initiator.
         */
        @java.lang.Override
        public int getInitiatorValue() {
          return instance.getInitiatorValue();
        }
        /**
         * <pre>
         * The party that initiated opening the channel.
         * </pre>
         *
         * <code>.co.anode.anodium.Initiator initiator = 8;</code>
         * @param value The initiator to set.
         * @return This builder for chaining.
         */
        public Builder setInitiatorValue(int value) {
          copyOnWrite();
          instance.setInitiatorValue(value);
          return this;
        }
        /**
         * <pre>
         * The party that initiated opening the channel.
         * </pre>
         *
         * <code>.co.anode.anodium.Initiator initiator = 8;</code>
         * @return The initiator.
         */
        @java.lang.Override
        public co.anode.anodium.Rpc.Initiator getInitiator() {
          return instance.getInitiator();
        }
        /**
         * <pre>
         * The party that initiated opening the channel.
         * </pre>
         *
         * <code>.co.anode.anodium.Initiator initiator = 8;</code>
         * @param value The enum numeric value on the wire for initiator to set.
         * @return This builder for chaining.
         */
        public Builder setInitiator(co.anode.anodium.Rpc.Initiator value) {
          copyOnWrite();
          instance.setInitiator(value);
          return this;
        }
        /**
         * <pre>
         * The party that initiated opening the channel.
         * </pre>
         *
         * <code>.co.anode.anodium.Initiator initiator = 8;</code>
         * @return This builder for chaining.
         */
        public Builder clearInitiator() {
          copyOnWrite();
          instance.clearInitiator();
          return this;
        }

        /**
         * <pre>
         * The commitment type used by this channel.
         * </pre>
         *
         * <code>.co.anode.anodium.CommitmentType commitment_type = 9;</code>
         * @return The enum numeric value on the wire for commitmentType.
         */
        @java.lang.Override
        public int getCommitmentTypeValue() {
          return instance.getCommitmentTypeValue();
        }
        /**
         * <pre>
         * The commitment type used by this channel.
         * </pre>
         *
         * <code>.co.anode.anodium.CommitmentType commitment_type = 9;</code>
         * @param value The commitmentType to set.
         * @return This builder for chaining.
         */
        public Builder setCommitmentTypeValue(int value) {
          copyOnWrite();
          instance.setCommitmentTypeValue(value);
          return this;
        }
        /**
         * <pre>
         * The commitment type used by this channel.
         * </pre>
         *
         * <code>.co.anode.anodium.CommitmentType commitment_type = 9;</code>
         * @return The commitmentType.
         */
        @java.lang.Override
        public co.anode.anodium.Rpc.CommitmentType getCommitmentType() {
          return instance.getCommitmentType();
        }
        /**
         * <pre>
         * The commitment type used by this channel.
         * </pre>
         *
         * <code>.co.anode.anodium.CommitmentType commitment_type = 9;</code>
         * @param value The enum numeric value on the wire for commitmentType to set.
         * @return This builder for chaining.
         */
        public Builder setCommitmentType(co.anode.anodium.Rpc.CommitmentType value) {
          copyOnWrite();
          instance.setCommitmentType(value);
          return this;
        }
        /**
         * <pre>
         * The commitment type used by this channel.
         * </pre>
         *
         * <code>.co.anode.anodium.CommitmentType commitment_type = 9;</code>
         * @return This builder for chaining.
         */
        public Builder clearCommitmentType() {
          copyOnWrite();
          instance.clearCommitmentType();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:co.anode.anodium.PendingChannelsResponse.PendingChannel)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "remoteNodePub_",
                "channelPoint_",
                "capacity_",
                "localBalance_",
                "remoteBalance_",
                "localChanReserveSat_",
                "remoteChanReserveSat_",
                "initiator_",
                "commitmentType_",
              };
              java.lang.String info =
                  "\u0000\t\u0000\u0000\u0001\t\t\u0000\u0000\u0000\u0001\u0208\u0002\u0208\u0003\u0002" +
                  "\u0004\u0002\u0005\u0002\u0006\u0002\u0007\u0002\b\f\t\f";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel> parser = PARSER;
            if (parser == null) {
              synchronized (co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:co.anode.anodium.PendingChannelsResponse.PendingChannel)
      private static final co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel DEFAULT_INSTANCE;
      static {
        PendingChannel defaultInstance = new PendingChannel();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          PendingChannel.class, defaultInstance);
      }

      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<PendingChannel> PARSER;

      public static com.google.protobuf.Parser<PendingChannel> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public interface PendingOpenChannelOrBuilder extends
        // @@protoc_insertion_point(interface_extends:co.anode.anodium.PendingChannelsResponse.PendingOpenChannel)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * The pending channel
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       * @return Whether the channel field is set.
       */
      boolean hasChannel();
      /**
       * <pre>
       * The pending channel
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       * @return The channel.
       */
      co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel getChannel();

      /**
       * <pre>
       * The height at which this channel will be confirmed
       * </pre>
       *
       * <code>uint32 confirmation_height = 2;</code>
       * @return The confirmationHeight.
       */
      int getConfirmationHeight();

      /**
       * <pre>
       *The amount calculated to be paid in fees for the current set of
       *commitment transactions. The fee amount is persisted with the channel
       *in order to allow the fee amount to be removed and recalculated with
       *each channel state update, including updates that happen after a system
       *restart.
       * </pre>
       *
       * <code>int64 commit_fee = 4;</code>
       * @return The commitFee.
       */
      long getCommitFee();

      /**
       * <pre>
       * The weight of the commitment transaction
       * </pre>
       *
       * <code>int64 commit_weight = 5;</code>
       * @return The commitWeight.
       */
      long getCommitWeight();

      /**
       * <pre>
       *The required number of satoshis per kilo-weight that the requester will
       *pay at all times, for both the funding transaction and commitment
       *transaction. This value can later be updated once the channel is open.
       * </pre>
       *
       * <code>int64 fee_per_kw = 6;</code>
       * @return The feePerKw.
       */
      long getFeePerKw();
    }
    /**
     * Protobuf type {@code co.anode.anodium.PendingChannelsResponse.PendingOpenChannel}
     */
    public  static final class PendingOpenChannel extends
        com.google.protobuf.GeneratedMessageLite<
            PendingOpenChannel, PendingOpenChannel.Builder> implements
        // @@protoc_insertion_point(message_implements:co.anode.anodium.PendingChannelsResponse.PendingOpenChannel)
        PendingOpenChannelOrBuilder {
      private PendingOpenChannel() {
      }
      public static final int CHANNEL_FIELD_NUMBER = 1;
      private co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel channel_;
      /**
       * <pre>
       * The pending channel
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      @java.lang.Override
      public boolean hasChannel() {
        return channel_ != null;
      }
      /**
       * <pre>
       * The pending channel
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel getChannel() {
        return channel_ == null ? co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel.getDefaultInstance() : channel_;
      }
      /**
       * <pre>
       * The pending channel
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      private void setChannel(co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel value) {
        value.getClass();
  channel_ = value;
        
        }
      /**
       * <pre>
       * The pending channel
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      @java.lang.SuppressWarnings({"ReferenceEquality"})
      private void mergeChannel(co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel value) {
        value.getClass();
  if (channel_ != null &&
            channel_ != co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel.getDefaultInstance()) {
          channel_ =
            co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel.newBuilder(channel_).mergeFrom(value).buildPartial();
        } else {
          channel_ = value;
        }
        
      }
      /**
       * <pre>
       * The pending channel
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      private void clearChannel() {  channel_ = null;
        
      }

      public static final int CONFIRMATION_HEIGHT_FIELD_NUMBER = 2;
      private int confirmationHeight_;
      /**
       * <pre>
       * The height at which this channel will be confirmed
       * </pre>
       *
       * <code>uint32 confirmation_height = 2;</code>
       * @return The confirmationHeight.
       */
      @java.lang.Override
      public int getConfirmationHeight() {
        return confirmationHeight_;
      }
      /**
       * <pre>
       * The height at which this channel will be confirmed
       * </pre>
       *
       * <code>uint32 confirmation_height = 2;</code>
       * @param value The confirmationHeight to set.
       */
      private void setConfirmationHeight(int value) {
        
        confirmationHeight_ = value;
      }
      /**
       * <pre>
       * The height at which this channel will be confirmed
       * </pre>
       *
       * <code>uint32 confirmation_height = 2;</code>
       */
      private void clearConfirmationHeight() {
        
        confirmationHeight_ = 0;
      }

      public static final int COMMIT_FEE_FIELD_NUMBER = 4;
      private long commitFee_;
      /**
       * <pre>
       *The amount calculated to be paid in fees for the current set of
       *commitment transactions. The fee amount is persisted with the channel
       *in order to allow the fee amount to be removed and recalculated with
       *each channel state update, including updates that happen after a system
       *restart.
       * </pre>
       *
       * <code>int64 commit_fee = 4;</code>
       * @return The commitFee.
       */
      @java.lang.Override
      public long getCommitFee() {
        return commitFee_;
      }
      /**
       * <pre>
       *The amount calculated to be paid in fees for the current set of
       *commitment transactions. The fee amount is persisted with the channel
       *in order to allow the fee amount to be removed and recalculated with
       *each channel state update, including updates that happen after a system
       *restart.
       * </pre>
       *
       * <code>int64 commit_fee = 4;</code>
       * @param value The commitFee to set.
       */
      private void setCommitFee(long value) {
        
        commitFee_ = value;
      }
      /**
       * <pre>
       *The amount calculated to be paid in fees for the current set of
       *commitment transactions. The fee amount is persisted with the channel
       *in order to allow the fee amount to be removed and recalculated with
       *each channel state update, including updates that happen after a system
       *restart.
       * </pre>
       *
       * <code>int64 commit_fee = 4;</code>
       */
      private void clearCommitFee() {
        
        commitFee_ = 0L;
      }

      public static final int COMMIT_WEIGHT_FIELD_NUMBER = 5;
      private long commitWeight_;
      /**
       * <pre>
       * The weight of the commitment transaction
       * </pre>
       *
       * <code>int64 commit_weight = 5;</code>
       * @return The commitWeight.
       */
      @java.lang.Override
      public long getCommitWeight() {
        return commitWeight_;
      }
      /**
       * <pre>
       * The weight of the commitment transaction
       * </pre>
       *
       * <code>int64 commit_weight = 5;</code>
       * @param value The commitWeight to set.
       */
      private void setCommitWeight(long value) {
        
        commitWeight_ = value;
      }
      /**
       * <pre>
       * The weight of the commitment transaction
       * </pre>
       *
       * <code>int64 commit_weight = 5;</code>
       */
      private void clearCommitWeight() {
        
        commitWeight_ = 0L;
      }

      public static final int FEE_PER_KW_FIELD_NUMBER = 6;
      private long feePerKw_;
      /**
       * <pre>
       *The required number of satoshis per kilo-weight that the requester will
       *pay at all times, for both the funding transaction and commitment
       *transaction. This value can later be updated once the channel is open.
       * </pre>
       *
       * <code>int64 fee_per_kw = 6;</code>
       * @return The feePerKw.
       */
      @java.lang.Override
      public long getFeePerKw() {
        return feePerKw_;
      }
      /**
       * <pre>
       *The required number of satoshis per kilo-weight that the requester will
       *pay at all times, for both the funding transaction and commitment
       *transaction. This value can later be updated once the channel is open.
       * </pre>
       *
       * <code>int64 fee_per_kw = 6;</code>
       * @param value The feePerKw to set.
       */
      private void setFeePerKw(long value) {
        
        feePerKw_ = value;
      }
      /**
       * <pre>
       *The required number of satoshis per kilo-weight that the requester will
       *pay at all times, for both the funding transaction and commitment
       *transaction. This value can later be updated once the channel is open.
       * </pre>
       *
       * <code>int64 fee_per_kw = 6;</code>
       */
      private void clearFeePerKw() {
        
        feePerKw_ = 0L;
      }

      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code co.anode.anodium.PendingChannelsResponse.PendingOpenChannel}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel, Builder> implements
          // @@protoc_insertion_point(builder_implements:co.anode.anodium.PendingChannelsResponse.PendingOpenChannel)
          co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannelOrBuilder {
        // Construct using co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * The pending channel
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        @java.lang.Override
        public boolean hasChannel() {
          return instance.hasChannel();
        }
        /**
         * <pre>
         * The pending channel
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        @java.lang.Override
        public co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel getChannel() {
          return instance.getChannel();
        }
        /**
         * <pre>
         * The pending channel
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        public Builder setChannel(co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel value) {
          copyOnWrite();
          instance.setChannel(value);
          return this;
          }
        /**
         * <pre>
         * The pending channel
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        public Builder setChannel(
            co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel.Builder builderForValue) {
          copyOnWrite();
          instance.setChannel(builderForValue.build());
          return this;
        }
        /**
         * <pre>
         * The pending channel
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        public Builder mergeChannel(co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel value) {
          copyOnWrite();
          instance.mergeChannel(value);
          return this;
        }
        /**
         * <pre>
         * The pending channel
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        public Builder clearChannel() {  copyOnWrite();
          instance.clearChannel();
          return this;
        }

        /**
         * <pre>
         * The height at which this channel will be confirmed
         * </pre>
         *
         * <code>uint32 confirmation_height = 2;</code>
         * @return The confirmationHeight.
         */
        @java.lang.Override
        public int getConfirmationHeight() {
          return instance.getConfirmationHeight();
        }
        /**
         * <pre>
         * The height at which this channel will be confirmed
         * </pre>
         *
         * <code>uint32 confirmation_height = 2;</code>
         * @param value The confirmationHeight to set.
         * @return This builder for chaining.
         */
        public Builder setConfirmationHeight(int value) {
          copyOnWrite();
          instance.setConfirmationHeight(value);
          return this;
        }
        /**
         * <pre>
         * The height at which this channel will be confirmed
         * </pre>
         *
         * <code>uint32 confirmation_height = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearConfirmationHeight() {
          copyOnWrite();
          instance.clearConfirmationHeight();
          return this;
        }

        /**
         * <pre>
         *The amount calculated to be paid in fees for the current set of
         *commitment transactions. The fee amount is persisted with the channel
         *in order to allow the fee amount to be removed and recalculated with
         *each channel state update, including updates that happen after a system
         *restart.
         * </pre>
         *
         * <code>int64 commit_fee = 4;</code>
         * @return The commitFee.
         */
        @java.lang.Override
        public long getCommitFee() {
          return instance.getCommitFee();
        }
        /**
         * <pre>
         *The amount calculated to be paid in fees for the current set of
         *commitment transactions. The fee amount is persisted with the channel
         *in order to allow the fee amount to be removed and recalculated with
         *each channel state update, including updates that happen after a system
         *restart.
         * </pre>
         *
         * <code>int64 commit_fee = 4;</code>
         * @param value The commitFee to set.
         * @return This builder for chaining.
         */
        public Builder setCommitFee(long value) {
          copyOnWrite();
          instance.setCommitFee(value);
          return this;
        }
        /**
         * <pre>
         *The amount calculated to be paid in fees for the current set of
         *commitment transactions. The fee amount is persisted with the channel
         *in order to allow the fee amount to be removed and recalculated with
         *each channel state update, including updates that happen after a system
         *restart.
         * </pre>
         *
         * <code>int64 commit_fee = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearCommitFee() {
          copyOnWrite();
          instance.clearCommitFee();
          return this;
        }

        /**
         * <pre>
         * The weight of the commitment transaction
         * </pre>
         *
         * <code>int64 commit_weight = 5;</code>
         * @return The commitWeight.
         */
        @java.lang.Override
        public long getCommitWeight() {
          return instance.getCommitWeight();
        }
        /**
         * <pre>
         * The weight of the commitment transaction
         * </pre>
         *
         * <code>int64 commit_weight = 5;</code>
         * @param value The commitWeight to set.
         * @return This builder for chaining.
         */
        public Builder setCommitWeight(long value) {
          copyOnWrite();
          instance.setCommitWeight(value);
          return this;
        }
        /**
         * <pre>
         * The weight of the commitment transaction
         * </pre>
         *
         * <code>int64 commit_weight = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearCommitWeight() {
          copyOnWrite();
          instance.clearCommitWeight();
          return this;
        }

        /**
         * <pre>
         *The required number of satoshis per kilo-weight that the requester will
         *pay at all times, for both the funding transaction and commitment
         *transaction. This value can later be updated once the channel is open.
         * </pre>
         *
         * <code>int64 fee_per_kw = 6;</code>
         * @return The feePerKw.
         */
        @java.lang.Override
        public long getFeePerKw() {
          return instance.getFeePerKw();
        }
        /**
         * <pre>
         *The required number of satoshis per kilo-weight that the requester will
         *pay at all times, for both the funding transaction and commitment
         *transaction. This value can later be updated once the channel is open.
         * </pre>
         *
         * <code>int64 fee_per_kw = 6;</code>
         * @param value The feePerKw to set.
         * @return This builder for chaining.
         */
        public Builder setFeePerKw(long value) {
          copyOnWrite();
          instance.setFeePerKw(value);
          return this;
        }
        /**
         * <pre>
         *The required number of satoshis per kilo-weight that the requester will
         *pay at all times, for both the funding transaction and commitment
         *transaction. This value can later be updated once the channel is open.
         * </pre>
         *
         * <code>int64 fee_per_kw = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearFeePerKw() {
          copyOnWrite();
          instance.clearFeePerKw();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:co.anode.anodium.PendingChannelsResponse.PendingOpenChannel)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "channel_",
                "confirmationHeight_",
                "commitFee_",
                "commitWeight_",
                "feePerKw_",
              };
              java.lang.String info =
                  "\u0000\u0005\u0000\u0000\u0001\u0006\u0005\u0000\u0000\u0000\u0001\t\u0002\u000b" +
                  "\u0004\u0002\u0005\u0002\u0006\u0002";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel> parser = PARSER;
            if (parser == null) {
              synchronized (co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:co.anode.anodium.PendingChannelsResponse.PendingOpenChannel)
      private static final co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel DEFAULT_INSTANCE;
      static {
        PendingOpenChannel defaultInstance = new PendingOpenChannel();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          PendingOpenChannel.class, defaultInstance);
      }

      public static co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<PendingOpenChannel> PARSER;

      public static com.google.protobuf.Parser<PendingOpenChannel> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public interface WaitingCloseChannelOrBuilder extends
        // @@protoc_insertion_point(interface_extends:co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * The pending channel waiting for closing tx to confirm
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       * @return Whether the channel field is set.
       */
      boolean hasChannel();
      /**
       * <pre>
       * The pending channel waiting for closing tx to confirm
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       * @return The channel.
       */
      co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel getChannel();

      /**
       * <pre>
       * The balance in satoshis encumbered in this channel
       * </pre>
       *
       * <code>int64 limbo_balance = 2;</code>
       * @return The limboBalance.
       */
      long getLimboBalance();

      /**
       * <pre>
       *A list of valid commitment transactions. Any of these can confirm at
       *this point.
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.Commitments commitments = 3;</code>
       * @return Whether the commitments field is set.
       */
      boolean hasCommitments();
      /**
       * <pre>
       *A list of valid commitment transactions. Any of these can confirm at
       *this point.
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.Commitments commitments = 3;</code>
       * @return The commitments.
       */
      co.anode.anodium.Rpc.PendingChannelsResponse.Commitments getCommitments();
    }
    /**
     * Protobuf type {@code co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel}
     */
    public  static final class WaitingCloseChannel extends
        com.google.protobuf.GeneratedMessageLite<
            WaitingCloseChannel, WaitingCloseChannel.Builder> implements
        // @@protoc_insertion_point(message_implements:co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel)
        WaitingCloseChannelOrBuilder {
      private WaitingCloseChannel() {
      }
      public static final int CHANNEL_FIELD_NUMBER = 1;
      private co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel channel_;
      /**
       * <pre>
       * The pending channel waiting for closing tx to confirm
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      @java.lang.Override
      public boolean hasChannel() {
        return channel_ != null;
      }
      /**
       * <pre>
       * The pending channel waiting for closing tx to confirm
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel getChannel() {
        return channel_ == null ? co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel.getDefaultInstance() : channel_;
      }
      /**
       * <pre>
       * The pending channel waiting for closing tx to confirm
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      private void setChannel(co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel value) {
        value.getClass();
  channel_ = value;
        
        }
      /**
       * <pre>
       * The pending channel waiting for closing tx to confirm
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      @java.lang.SuppressWarnings({"ReferenceEquality"})
      private void mergeChannel(co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel value) {
        value.getClass();
  if (channel_ != null &&
            channel_ != co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel.getDefaultInstance()) {
          channel_ =
            co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel.newBuilder(channel_).mergeFrom(value).buildPartial();
        } else {
          channel_ = value;
        }
        
      }
      /**
       * <pre>
       * The pending channel waiting for closing tx to confirm
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      private void clearChannel() {  channel_ = null;
        
      }

      public static final int LIMBO_BALANCE_FIELD_NUMBER = 2;
      private long limboBalance_;
      /**
       * <pre>
       * The balance in satoshis encumbered in this channel
       * </pre>
       *
       * <code>int64 limbo_balance = 2;</code>
       * @return The limboBalance.
       */
      @java.lang.Override
      public long getLimboBalance() {
        return limboBalance_;
      }
      /**
       * <pre>
       * The balance in satoshis encumbered in this channel
       * </pre>
       *
       * <code>int64 limbo_balance = 2;</code>
       * @param value The limboBalance to set.
       */
      private void setLimboBalance(long value) {
        
        limboBalance_ = value;
      }
      /**
       * <pre>
       * The balance in satoshis encumbered in this channel
       * </pre>
       *
       * <code>int64 limbo_balance = 2;</code>
       */
      private void clearLimboBalance() {
        
        limboBalance_ = 0L;
      }

      public static final int COMMITMENTS_FIELD_NUMBER = 3;
      private co.anode.anodium.Rpc.PendingChannelsResponse.Commitments commitments_;
      /**
       * <pre>
       *A list of valid commitment transactions. Any of these can confirm at
       *this point.
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.Commitments commitments = 3;</code>
       */
      @java.lang.Override
      public boolean hasCommitments() {
        return commitments_ != null;
      }
      /**
       * <pre>
       *A list of valid commitment transactions. Any of these can confirm at
       *this point.
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.Commitments commitments = 3;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.PendingChannelsResponse.Commitments getCommitments() {
        return commitments_ == null ? co.anode.anodium.Rpc.PendingChannelsResponse.Commitments.getDefaultInstance() : commitments_;
      }
      /**
       * <pre>
       *A list of valid commitment transactions. Any of these can confirm at
       *this point.
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.Commitments commitments = 3;</code>
       */
      private void setCommitments(co.anode.anodium.Rpc.PendingChannelsResponse.Commitments value) {
        value.getClass();
  commitments_ = value;
        
        }
      /**
       * <pre>
       *A list of valid commitment transactions. Any of these can confirm at
       *this point.
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.Commitments commitments = 3;</code>
       */
      @java.lang.SuppressWarnings({"ReferenceEquality"})
      private void mergeCommitments(co.anode.anodium.Rpc.PendingChannelsResponse.Commitments value) {
        value.getClass();
  if (commitments_ != null &&
            commitments_ != co.anode.anodium.Rpc.PendingChannelsResponse.Commitments.getDefaultInstance()) {
          commitments_ =
            co.anode.anodium.Rpc.PendingChannelsResponse.Commitments.newBuilder(commitments_).mergeFrom(value).buildPartial();
        } else {
          commitments_ = value;
        }
        
      }
      /**
       * <pre>
       *A list of valid commitment transactions. Any of these can confirm at
       *this point.
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.Commitments commitments = 3;</code>
       */
      private void clearCommitments() {  commitments_ = null;
        
      }

      public static co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel, Builder> implements
          // @@protoc_insertion_point(builder_implements:co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel)
          co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannelOrBuilder {
        // Construct using co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * The pending channel waiting for closing tx to confirm
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        @java.lang.Override
        public boolean hasChannel() {
          return instance.hasChannel();
        }
        /**
         * <pre>
         * The pending channel waiting for closing tx to confirm
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        @java.lang.Override
        public co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel getChannel() {
          return instance.getChannel();
        }
        /**
         * <pre>
         * The pending channel waiting for closing tx to confirm
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        public Builder setChannel(co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel value) {
          copyOnWrite();
          instance.setChannel(value);
          return this;
          }
        /**
         * <pre>
         * The pending channel waiting for closing tx to confirm
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        public Builder setChannel(
            co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel.Builder builderForValue) {
          copyOnWrite();
          instance.setChannel(builderForValue.build());
          return this;
        }
        /**
         * <pre>
         * The pending channel waiting for closing tx to confirm
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        public Builder mergeChannel(co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel value) {
          copyOnWrite();
          instance.mergeChannel(value);
          return this;
        }
        /**
         * <pre>
         * The pending channel waiting for closing tx to confirm
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        public Builder clearChannel() {  copyOnWrite();
          instance.clearChannel();
          return this;
        }

        /**
         * <pre>
         * The balance in satoshis encumbered in this channel
         * </pre>
         *
         * <code>int64 limbo_balance = 2;</code>
         * @return The limboBalance.
         */
        @java.lang.Override
        public long getLimboBalance() {
          return instance.getLimboBalance();
        }
        /**
         * <pre>
         * The balance in satoshis encumbered in this channel
         * </pre>
         *
         * <code>int64 limbo_balance = 2;</code>
         * @param value The limboBalance to set.
         * @return This builder for chaining.
         */
        public Builder setLimboBalance(long value) {
          copyOnWrite();
          instance.setLimboBalance(value);
          return this;
        }
        /**
         * <pre>
         * The balance in satoshis encumbered in this channel
         * </pre>
         *
         * <code>int64 limbo_balance = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearLimboBalance() {
          copyOnWrite();
          instance.clearLimboBalance();
          return this;
        }

        /**
         * <pre>
         *A list of valid commitment transactions. Any of these can confirm at
         *this point.
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.Commitments commitments = 3;</code>
         */
        @java.lang.Override
        public boolean hasCommitments() {
          return instance.hasCommitments();
        }
        /**
         * <pre>
         *A list of valid commitment transactions. Any of these can confirm at
         *this point.
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.Commitments commitments = 3;</code>
         */
        @java.lang.Override
        public co.anode.anodium.Rpc.PendingChannelsResponse.Commitments getCommitments() {
          return instance.getCommitments();
        }
        /**
         * <pre>
         *A list of valid commitment transactions. Any of these can confirm at
         *this point.
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.Commitments commitments = 3;</code>
         */
        public Builder setCommitments(co.anode.anodium.Rpc.PendingChannelsResponse.Commitments value) {
          copyOnWrite();
          instance.setCommitments(value);
          return this;
          }
        /**
         * <pre>
         *A list of valid commitment transactions. Any of these can confirm at
         *this point.
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.Commitments commitments = 3;</code>
         */
        public Builder setCommitments(
            co.anode.anodium.Rpc.PendingChannelsResponse.Commitments.Builder builderForValue) {
          copyOnWrite();
          instance.setCommitments(builderForValue.build());
          return this;
        }
        /**
         * <pre>
         *A list of valid commitment transactions. Any of these can confirm at
         *this point.
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.Commitments commitments = 3;</code>
         */
        public Builder mergeCommitments(co.anode.anodium.Rpc.PendingChannelsResponse.Commitments value) {
          copyOnWrite();
          instance.mergeCommitments(value);
          return this;
        }
        /**
         * <pre>
         *A list of valid commitment transactions. Any of these can confirm at
         *this point.
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.Commitments commitments = 3;</code>
         */
        public Builder clearCommitments() {  copyOnWrite();
          instance.clearCommitments();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "channel_",
                "limboBalance_",
                "commitments_",
              };
              java.lang.String info =
                  "\u0000\u0003\u0000\u0000\u0001\u0003\u0003\u0000\u0000\u0000\u0001\t\u0002\u0002" +
                  "\u0003\t";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel> parser = PARSER;
            if (parser == null) {
              synchronized (co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel)
      private static final co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel DEFAULT_INSTANCE;
      static {
        WaitingCloseChannel defaultInstance = new WaitingCloseChannel();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          WaitingCloseChannel.class, defaultInstance);
      }

      public static co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<WaitingCloseChannel> PARSER;

      public static com.google.protobuf.Parser<WaitingCloseChannel> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public interface CommitmentsOrBuilder extends
        // @@protoc_insertion_point(interface_extends:co.anode.anodium.PendingChannelsResponse.Commitments)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * Hash of the local version of the commitment tx.
       * </pre>
       *
       * <code>string local_txid = 1;</code>
       * @return The localTxid.
       */
      java.lang.String getLocalTxid();
      /**
       * <pre>
       * Hash of the local version of the commitment tx.
       * </pre>
       *
       * <code>string local_txid = 1;</code>
       * @return The bytes for localTxid.
       */
      com.google.protobuf.ByteString
          getLocalTxidBytes();

      /**
       * <pre>
       * Hash of the remote version of the commitment tx.
       * </pre>
       *
       * <code>string remote_txid = 2;</code>
       * @return The remoteTxid.
       */
      java.lang.String getRemoteTxid();
      /**
       * <pre>
       * Hash of the remote version of the commitment tx.
       * </pre>
       *
       * <code>string remote_txid = 2;</code>
       * @return The bytes for remoteTxid.
       */
      com.google.protobuf.ByteString
          getRemoteTxidBytes();

      /**
       * <pre>
       * Hash of the remote pending version of the commitment tx.
       * </pre>
       *
       * <code>string remote_pending_txid = 3;</code>
       * @return The remotePendingTxid.
       */
      java.lang.String getRemotePendingTxid();
      /**
       * <pre>
       * Hash of the remote pending version of the commitment tx.
       * </pre>
       *
       * <code>string remote_pending_txid = 3;</code>
       * @return The bytes for remotePendingTxid.
       */
      com.google.protobuf.ByteString
          getRemotePendingTxidBytes();

      /**
       * <pre>
       *The amount in satoshis calculated to be paid in fees for the local
       *commitment.
       * </pre>
       *
       * <code>uint64 local_commit_fee_sat = 4;</code>
       * @return The localCommitFeeSat.
       */
      long getLocalCommitFeeSat();

      /**
       * <pre>
       *The amount in satoshis calculated to be paid in fees for the remote
       *commitment.
       * </pre>
       *
       * <code>uint64 remote_commit_fee_sat = 5;</code>
       * @return The remoteCommitFeeSat.
       */
      long getRemoteCommitFeeSat();

      /**
       * <pre>
       *The amount in satoshis calculated to be paid in fees for the remote
       *pending commitment.
       * </pre>
       *
       * <code>uint64 remote_pending_commit_fee_sat = 6;</code>
       * @return The remotePendingCommitFeeSat.
       */
      long getRemotePendingCommitFeeSat();
    }
    /**
     * Protobuf type {@code co.anode.anodium.PendingChannelsResponse.Commitments}
     */
    public  static final class Commitments extends
        com.google.protobuf.GeneratedMessageLite<
            Commitments, Commitments.Builder> implements
        // @@protoc_insertion_point(message_implements:co.anode.anodium.PendingChannelsResponse.Commitments)
        CommitmentsOrBuilder {
      private Commitments() {
        localTxid_ = "";
        remoteTxid_ = "";
        remotePendingTxid_ = "";
      }
      public static final int LOCAL_TXID_FIELD_NUMBER = 1;
      private java.lang.String localTxid_;
      /**
       * <pre>
       * Hash of the local version of the commitment tx.
       * </pre>
       *
       * <code>string local_txid = 1;</code>
       * @return The localTxid.
       */
      @java.lang.Override
      public java.lang.String getLocalTxid() {
        return localTxid_;
      }
      /**
       * <pre>
       * Hash of the local version of the commitment tx.
       * </pre>
       *
       * <code>string local_txid = 1;</code>
       * @return The bytes for localTxid.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getLocalTxidBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(localTxid_);
      }
      /**
       * <pre>
       * Hash of the local version of the commitment tx.
       * </pre>
       *
       * <code>string local_txid = 1;</code>
       * @param value The localTxid to set.
       */
      private void setLocalTxid(
          java.lang.String value) {
        value.getClass();
  
        localTxid_ = value;
      }
      /**
       * <pre>
       * Hash of the local version of the commitment tx.
       * </pre>
       *
       * <code>string local_txid = 1;</code>
       */
      private void clearLocalTxid() {
        
        localTxid_ = getDefaultInstance().getLocalTxid();
      }
      /**
       * <pre>
       * Hash of the local version of the commitment tx.
       * </pre>
       *
       * <code>string local_txid = 1;</code>
       * @param value The bytes for localTxid to set.
       */
      private void setLocalTxidBytes(
          com.google.protobuf.ByteString value) {
        checkByteStringIsUtf8(value);
        localTxid_ = value.toStringUtf8();
        
      }

      public static final int REMOTE_TXID_FIELD_NUMBER = 2;
      private java.lang.String remoteTxid_;
      /**
       * <pre>
       * Hash of the remote version of the commitment tx.
       * </pre>
       *
       * <code>string remote_txid = 2;</code>
       * @return The remoteTxid.
       */
      @java.lang.Override
      public java.lang.String getRemoteTxid() {
        return remoteTxid_;
      }
      /**
       * <pre>
       * Hash of the remote version of the commitment tx.
       * </pre>
       *
       * <code>string remote_txid = 2;</code>
       * @return The bytes for remoteTxid.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getRemoteTxidBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(remoteTxid_);
      }
      /**
       * <pre>
       * Hash of the remote version of the commitment tx.
       * </pre>
       *
       * <code>string remote_txid = 2;</code>
       * @param value The remoteTxid to set.
       */
      private void setRemoteTxid(
          java.lang.String value) {
        value.getClass();
  
        remoteTxid_ = value;
      }
      /**
       * <pre>
       * Hash of the remote version of the commitment tx.
       * </pre>
       *
       * <code>string remote_txid = 2;</code>
       */
      private void clearRemoteTxid() {
        
        remoteTxid_ = getDefaultInstance().getRemoteTxid();
      }
      /**
       * <pre>
       * Hash of the remote version of the commitment tx.
       * </pre>
       *
       * <code>string remote_txid = 2;</code>
       * @param value The bytes for remoteTxid to set.
       */
      private void setRemoteTxidBytes(
          com.google.protobuf.ByteString value) {
        checkByteStringIsUtf8(value);
        remoteTxid_ = value.toStringUtf8();
        
      }

      public static final int REMOTE_PENDING_TXID_FIELD_NUMBER = 3;
      private java.lang.String remotePendingTxid_;
      /**
       * <pre>
       * Hash of the remote pending version of the commitment tx.
       * </pre>
       *
       * <code>string remote_pending_txid = 3;</code>
       * @return The remotePendingTxid.
       */
      @java.lang.Override
      public java.lang.String getRemotePendingTxid() {
        return remotePendingTxid_;
      }
      /**
       * <pre>
       * Hash of the remote pending version of the commitment tx.
       * </pre>
       *
       * <code>string remote_pending_txid = 3;</code>
       * @return The bytes for remotePendingTxid.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getRemotePendingTxidBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(remotePendingTxid_);
      }
      /**
       * <pre>
       * Hash of the remote pending version of the commitment tx.
       * </pre>
       *
       * <code>string remote_pending_txid = 3;</code>
       * @param value The remotePendingTxid to set.
       */
      private void setRemotePendingTxid(
          java.lang.String value) {
        value.getClass();
  
        remotePendingTxid_ = value;
      }
      /**
       * <pre>
       * Hash of the remote pending version of the commitment tx.
       * </pre>
       *
       * <code>string remote_pending_txid = 3;</code>
       */
      private void clearRemotePendingTxid() {
        
        remotePendingTxid_ = getDefaultInstance().getRemotePendingTxid();
      }
      /**
       * <pre>
       * Hash of the remote pending version of the commitment tx.
       * </pre>
       *
       * <code>string remote_pending_txid = 3;</code>
       * @param value The bytes for remotePendingTxid to set.
       */
      private void setRemotePendingTxidBytes(
          com.google.protobuf.ByteString value) {
        checkByteStringIsUtf8(value);
        remotePendingTxid_ = value.toStringUtf8();
        
      }

      public static final int LOCAL_COMMIT_FEE_SAT_FIELD_NUMBER = 4;
      private long localCommitFeeSat_;
      /**
       * <pre>
       *The amount in satoshis calculated to be paid in fees for the local
       *commitment.
       * </pre>
       *
       * <code>uint64 local_commit_fee_sat = 4;</code>
       * @return The localCommitFeeSat.
       */
      @java.lang.Override
      public long getLocalCommitFeeSat() {
        return localCommitFeeSat_;
      }
      /**
       * <pre>
       *The amount in satoshis calculated to be paid in fees for the local
       *commitment.
       * </pre>
       *
       * <code>uint64 local_commit_fee_sat = 4;</code>
       * @param value The localCommitFeeSat to set.
       */
      private void setLocalCommitFeeSat(long value) {
        
        localCommitFeeSat_ = value;
      }
      /**
       * <pre>
       *The amount in satoshis calculated to be paid in fees for the local
       *commitment.
       * </pre>
       *
       * <code>uint64 local_commit_fee_sat = 4;</code>
       */
      private void clearLocalCommitFeeSat() {
        
        localCommitFeeSat_ = 0L;
      }

      public static final int REMOTE_COMMIT_FEE_SAT_FIELD_NUMBER = 5;
      private long remoteCommitFeeSat_;
      /**
       * <pre>
       *The amount in satoshis calculated to be paid in fees for the remote
       *commitment.
       * </pre>
       *
       * <code>uint64 remote_commit_fee_sat = 5;</code>
       * @return The remoteCommitFeeSat.
       */
      @java.lang.Override
      public long getRemoteCommitFeeSat() {
        return remoteCommitFeeSat_;
      }
      /**
       * <pre>
       *The amount in satoshis calculated to be paid in fees for the remote
       *commitment.
       * </pre>
       *
       * <code>uint64 remote_commit_fee_sat = 5;</code>
       * @param value The remoteCommitFeeSat to set.
       */
      private void setRemoteCommitFeeSat(long value) {
        
        remoteCommitFeeSat_ = value;
      }
      /**
       * <pre>
       *The amount in satoshis calculated to be paid in fees for the remote
       *commitment.
       * </pre>
       *
       * <code>uint64 remote_commit_fee_sat = 5;</code>
       */
      private void clearRemoteCommitFeeSat() {
        
        remoteCommitFeeSat_ = 0L;
      }

      public static final int REMOTE_PENDING_COMMIT_FEE_SAT_FIELD_NUMBER = 6;
      private long remotePendingCommitFeeSat_;
      /**
       * <pre>
       *The amount in satoshis calculated to be paid in fees for the remote
       *pending commitment.
       * </pre>
       *
       * <code>uint64 remote_pending_commit_fee_sat = 6;</code>
       * @return The remotePendingCommitFeeSat.
       */
      @java.lang.Override
      public long getRemotePendingCommitFeeSat() {
        return remotePendingCommitFeeSat_;
      }
      /**
       * <pre>
       *The amount in satoshis calculated to be paid in fees for the remote
       *pending commitment.
       * </pre>
       *
       * <code>uint64 remote_pending_commit_fee_sat = 6;</code>
       * @param value The remotePendingCommitFeeSat to set.
       */
      private void setRemotePendingCommitFeeSat(long value) {
        
        remotePendingCommitFeeSat_ = value;
      }
      /**
       * <pre>
       *The amount in satoshis calculated to be paid in fees for the remote
       *pending commitment.
       * </pre>
       *
       * <code>uint64 remote_pending_commit_fee_sat = 6;</code>
       */
      private void clearRemotePendingCommitFeeSat() {
        
        remotePendingCommitFeeSat_ = 0L;
      }

      public static co.anode.anodium.Rpc.PendingChannelsResponse.Commitments parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.Commitments parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.Commitments parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.Commitments parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.Commitments parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.Commitments parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.Commitments parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.Commitments parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.Commitments parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.Commitments parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.Commitments parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.Commitments parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(co.anode.anodium.Rpc.PendingChannelsResponse.Commitments prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code co.anode.anodium.PendingChannelsResponse.Commitments}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            co.anode.anodium.Rpc.PendingChannelsResponse.Commitments, Builder> implements
          // @@protoc_insertion_point(builder_implements:co.anode.anodium.PendingChannelsResponse.Commitments)
          co.anode.anodium.Rpc.PendingChannelsResponse.CommitmentsOrBuilder {
        // Construct using co.anode.anodium.Rpc.PendingChannelsResponse.Commitments.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * Hash of the local version of the commitment tx.
         * </pre>
         *
         * <code>string local_txid = 1;</code>
         * @return The localTxid.
         */
        @java.lang.Override
        public java.lang.String getLocalTxid() {
          return instance.getLocalTxid();
        }
        /**
         * <pre>
         * Hash of the local version of the commitment tx.
         * </pre>
         *
         * <code>string local_txid = 1;</code>
         * @return The bytes for localTxid.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getLocalTxidBytes() {
          return instance.getLocalTxidBytes();
        }
        /**
         * <pre>
         * Hash of the local version of the commitment tx.
         * </pre>
         *
         * <code>string local_txid = 1;</code>
         * @param value The localTxid to set.
         * @return This builder for chaining.
         */
        public Builder setLocalTxid(
            java.lang.String value) {
          copyOnWrite();
          instance.setLocalTxid(value);
          return this;
        }
        /**
         * <pre>
         * Hash of the local version of the commitment tx.
         * </pre>
         *
         * <code>string local_txid = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearLocalTxid() {
          copyOnWrite();
          instance.clearLocalTxid();
          return this;
        }
        /**
         * <pre>
         * Hash of the local version of the commitment tx.
         * </pre>
         *
         * <code>string local_txid = 1;</code>
         * @param value The bytes for localTxid to set.
         * @return This builder for chaining.
         */
        public Builder setLocalTxidBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setLocalTxidBytes(value);
          return this;
        }

        /**
         * <pre>
         * Hash of the remote version of the commitment tx.
         * </pre>
         *
         * <code>string remote_txid = 2;</code>
         * @return The remoteTxid.
         */
        @java.lang.Override
        public java.lang.String getRemoteTxid() {
          return instance.getRemoteTxid();
        }
        /**
         * <pre>
         * Hash of the remote version of the commitment tx.
         * </pre>
         *
         * <code>string remote_txid = 2;</code>
         * @return The bytes for remoteTxid.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getRemoteTxidBytes() {
          return instance.getRemoteTxidBytes();
        }
        /**
         * <pre>
         * Hash of the remote version of the commitment tx.
         * </pre>
         *
         * <code>string remote_txid = 2;</code>
         * @param value The remoteTxid to set.
         * @return This builder for chaining.
         */
        public Builder setRemoteTxid(
            java.lang.String value) {
          copyOnWrite();
          instance.setRemoteTxid(value);
          return this;
        }
        /**
         * <pre>
         * Hash of the remote version of the commitment tx.
         * </pre>
         *
         * <code>string remote_txid = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearRemoteTxid() {
          copyOnWrite();
          instance.clearRemoteTxid();
          return this;
        }
        /**
         * <pre>
         * Hash of the remote version of the commitment tx.
         * </pre>
         *
         * <code>string remote_txid = 2;</code>
         * @param value The bytes for remoteTxid to set.
         * @return This builder for chaining.
         */
        public Builder setRemoteTxidBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setRemoteTxidBytes(value);
          return this;
        }

        /**
         * <pre>
         * Hash of the remote pending version of the commitment tx.
         * </pre>
         *
         * <code>string remote_pending_txid = 3;</code>
         * @return The remotePendingTxid.
         */
        @java.lang.Override
        public java.lang.String getRemotePendingTxid() {
          return instance.getRemotePendingTxid();
        }
        /**
         * <pre>
         * Hash of the remote pending version of the commitment tx.
         * </pre>
         *
         * <code>string remote_pending_txid = 3;</code>
         * @return The bytes for remotePendingTxid.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getRemotePendingTxidBytes() {
          return instance.getRemotePendingTxidBytes();
        }
        /**
         * <pre>
         * Hash of the remote pending version of the commitment tx.
         * </pre>
         *
         * <code>string remote_pending_txid = 3;</code>
         * @param value The remotePendingTxid to set.
         * @return This builder for chaining.
         */
        public Builder setRemotePendingTxid(
            java.lang.String value) {
          copyOnWrite();
          instance.setRemotePendingTxid(value);
          return this;
        }
        /**
         * <pre>
         * Hash of the remote pending version of the commitment tx.
         * </pre>
         *
         * <code>string remote_pending_txid = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearRemotePendingTxid() {
          copyOnWrite();
          instance.clearRemotePendingTxid();
          return this;
        }
        /**
         * <pre>
         * Hash of the remote pending version of the commitment tx.
         * </pre>
         *
         * <code>string remote_pending_txid = 3;</code>
         * @param value The bytes for remotePendingTxid to set.
         * @return This builder for chaining.
         */
        public Builder setRemotePendingTxidBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setRemotePendingTxidBytes(value);
          return this;
        }

        /**
         * <pre>
         *The amount in satoshis calculated to be paid in fees for the local
         *commitment.
         * </pre>
         *
         * <code>uint64 local_commit_fee_sat = 4;</code>
         * @return The localCommitFeeSat.
         */
        @java.lang.Override
        public long getLocalCommitFeeSat() {
          return instance.getLocalCommitFeeSat();
        }
        /**
         * <pre>
         *The amount in satoshis calculated to be paid in fees for the local
         *commitment.
         * </pre>
         *
         * <code>uint64 local_commit_fee_sat = 4;</code>
         * @param value The localCommitFeeSat to set.
         * @return This builder for chaining.
         */
        public Builder setLocalCommitFeeSat(long value) {
          copyOnWrite();
          instance.setLocalCommitFeeSat(value);
          return this;
        }
        /**
         * <pre>
         *The amount in satoshis calculated to be paid in fees for the local
         *commitment.
         * </pre>
         *
         * <code>uint64 local_commit_fee_sat = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearLocalCommitFeeSat() {
          copyOnWrite();
          instance.clearLocalCommitFeeSat();
          return this;
        }

        /**
         * <pre>
         *The amount in satoshis calculated to be paid in fees for the remote
         *commitment.
         * </pre>
         *
         * <code>uint64 remote_commit_fee_sat = 5;</code>
         * @return The remoteCommitFeeSat.
         */
        @java.lang.Override
        public long getRemoteCommitFeeSat() {
          return instance.getRemoteCommitFeeSat();
        }
        /**
         * <pre>
         *The amount in satoshis calculated to be paid in fees for the remote
         *commitment.
         * </pre>
         *
         * <code>uint64 remote_commit_fee_sat = 5;</code>
         * @param value The remoteCommitFeeSat to set.
         * @return This builder for chaining.
         */
        public Builder setRemoteCommitFeeSat(long value) {
          copyOnWrite();
          instance.setRemoteCommitFeeSat(value);
          return this;
        }
        /**
         * <pre>
         *The amount in satoshis calculated to be paid in fees for the remote
         *commitment.
         * </pre>
         *
         * <code>uint64 remote_commit_fee_sat = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearRemoteCommitFeeSat() {
          copyOnWrite();
          instance.clearRemoteCommitFeeSat();
          return this;
        }

        /**
         * <pre>
         *The amount in satoshis calculated to be paid in fees for the remote
         *pending commitment.
         * </pre>
         *
         * <code>uint64 remote_pending_commit_fee_sat = 6;</code>
         * @return The remotePendingCommitFeeSat.
         */
        @java.lang.Override
        public long getRemotePendingCommitFeeSat() {
          return instance.getRemotePendingCommitFeeSat();
        }
        /**
         * <pre>
         *The amount in satoshis calculated to be paid in fees for the remote
         *pending commitment.
         * </pre>
         *
         * <code>uint64 remote_pending_commit_fee_sat = 6;</code>
         * @param value The remotePendingCommitFeeSat to set.
         * @return This builder for chaining.
         */
        public Builder setRemotePendingCommitFeeSat(long value) {
          copyOnWrite();
          instance.setRemotePendingCommitFeeSat(value);
          return this;
        }
        /**
         * <pre>
         *The amount in satoshis calculated to be paid in fees for the remote
         *pending commitment.
         * </pre>
         *
         * <code>uint64 remote_pending_commit_fee_sat = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearRemotePendingCommitFeeSat() {
          copyOnWrite();
          instance.clearRemotePendingCommitFeeSat();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:co.anode.anodium.PendingChannelsResponse.Commitments)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new co.anode.anodium.Rpc.PendingChannelsResponse.Commitments();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "localTxid_",
                "remoteTxid_",
                "remotePendingTxid_",
                "localCommitFeeSat_",
                "remoteCommitFeeSat_",
                "remotePendingCommitFeeSat_",
              };
              java.lang.String info =
                  "\u0000\u0006\u0000\u0000\u0001\u0006\u0006\u0000\u0000\u0000\u0001\u0208\u0002\u0208" +
                  "\u0003\u0208\u0004\u0003\u0005\u0003\u0006\u0003";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<co.anode.anodium.Rpc.PendingChannelsResponse.Commitments> parser = PARSER;
            if (parser == null) {
              synchronized (co.anode.anodium.Rpc.PendingChannelsResponse.Commitments.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<co.anode.anodium.Rpc.PendingChannelsResponse.Commitments>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:co.anode.anodium.PendingChannelsResponse.Commitments)
      private static final co.anode.anodium.Rpc.PendingChannelsResponse.Commitments DEFAULT_INSTANCE;
      static {
        Commitments defaultInstance = new Commitments();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          Commitments.class, defaultInstance);
      }

      public static co.anode.anodium.Rpc.PendingChannelsResponse.Commitments getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<Commitments> PARSER;

      public static com.google.protobuf.Parser<Commitments> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public interface ClosedChannelOrBuilder extends
        // @@protoc_insertion_point(interface_extends:co.anode.anodium.PendingChannelsResponse.ClosedChannel)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * The pending channel to be closed
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       * @return Whether the channel field is set.
       */
      boolean hasChannel();
      /**
       * <pre>
       * The pending channel to be closed
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       * @return The channel.
       */
      co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel getChannel();

      /**
       * <pre>
       * The transaction id of the closing transaction
       * </pre>
       *
       * <code>string closing_txid = 2;</code>
       * @return The closingTxid.
       */
      java.lang.String getClosingTxid();
      /**
       * <pre>
       * The transaction id of the closing transaction
       * </pre>
       *
       * <code>string closing_txid = 2;</code>
       * @return The bytes for closingTxid.
       */
      com.google.protobuf.ByteString
          getClosingTxidBytes();
    }
    /**
     * Protobuf type {@code co.anode.anodium.PendingChannelsResponse.ClosedChannel}
     */
    public  static final class ClosedChannel extends
        com.google.protobuf.GeneratedMessageLite<
            ClosedChannel, ClosedChannel.Builder> implements
        // @@protoc_insertion_point(message_implements:co.anode.anodium.PendingChannelsResponse.ClosedChannel)
        ClosedChannelOrBuilder {
      private ClosedChannel() {
        closingTxid_ = "";
      }
      public static final int CHANNEL_FIELD_NUMBER = 1;
      private co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel channel_;
      /**
       * <pre>
       * The pending channel to be closed
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      @java.lang.Override
      public boolean hasChannel() {
        return channel_ != null;
      }
      /**
       * <pre>
       * The pending channel to be closed
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel getChannel() {
        return channel_ == null ? co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel.getDefaultInstance() : channel_;
      }
      /**
       * <pre>
       * The pending channel to be closed
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      private void setChannel(co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel value) {
        value.getClass();
  channel_ = value;
        
        }
      /**
       * <pre>
       * The pending channel to be closed
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      @java.lang.SuppressWarnings({"ReferenceEquality"})
      private void mergeChannel(co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel value) {
        value.getClass();
  if (channel_ != null &&
            channel_ != co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel.getDefaultInstance()) {
          channel_ =
            co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel.newBuilder(channel_).mergeFrom(value).buildPartial();
        } else {
          channel_ = value;
        }
        
      }
      /**
       * <pre>
       * The pending channel to be closed
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      private void clearChannel() {  channel_ = null;
        
      }

      public static final int CLOSING_TXID_FIELD_NUMBER = 2;
      private java.lang.String closingTxid_;
      /**
       * <pre>
       * The transaction id of the closing transaction
       * </pre>
       *
       * <code>string closing_txid = 2;</code>
       * @return The closingTxid.
       */
      @java.lang.Override
      public java.lang.String getClosingTxid() {
        return closingTxid_;
      }
      /**
       * <pre>
       * The transaction id of the closing transaction
       * </pre>
       *
       * <code>string closing_txid = 2;</code>
       * @return The bytes for closingTxid.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getClosingTxidBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(closingTxid_);
      }
      /**
       * <pre>
       * The transaction id of the closing transaction
       * </pre>
       *
       * <code>string closing_txid = 2;</code>
       * @param value The closingTxid to set.
       */
      private void setClosingTxid(
          java.lang.String value) {
        value.getClass();
  
        closingTxid_ = value;
      }
      /**
       * <pre>
       * The transaction id of the closing transaction
       * </pre>
       *
       * <code>string closing_txid = 2;</code>
       */
      private void clearClosingTxid() {
        
        closingTxid_ = getDefaultInstance().getClosingTxid();
      }
      /**
       * <pre>
       * The transaction id of the closing transaction
       * </pre>
       *
       * <code>string closing_txid = 2;</code>
       * @param value The bytes for closingTxid to set.
       */
      private void setClosingTxidBytes(
          com.google.protobuf.ByteString value) {
        checkByteStringIsUtf8(value);
        closingTxid_ = value.toStringUtf8();
        
      }

      public static co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code co.anode.anodium.PendingChannelsResponse.ClosedChannel}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel, Builder> implements
          // @@protoc_insertion_point(builder_implements:co.anode.anodium.PendingChannelsResponse.ClosedChannel)
          co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannelOrBuilder {
        // Construct using co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * The pending channel to be closed
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        @java.lang.Override
        public boolean hasChannel() {
          return instance.hasChannel();
        }
        /**
         * <pre>
         * The pending channel to be closed
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        @java.lang.Override
        public co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel getChannel() {
          return instance.getChannel();
        }
        /**
         * <pre>
         * The pending channel to be closed
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        public Builder setChannel(co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel value) {
          copyOnWrite();
          instance.setChannel(value);
          return this;
          }
        /**
         * <pre>
         * The pending channel to be closed
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        public Builder setChannel(
            co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel.Builder builderForValue) {
          copyOnWrite();
          instance.setChannel(builderForValue.build());
          return this;
        }
        /**
         * <pre>
         * The pending channel to be closed
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        public Builder mergeChannel(co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel value) {
          copyOnWrite();
          instance.mergeChannel(value);
          return this;
        }
        /**
         * <pre>
         * The pending channel to be closed
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        public Builder clearChannel() {  copyOnWrite();
          instance.clearChannel();
          return this;
        }

        /**
         * <pre>
         * The transaction id of the closing transaction
         * </pre>
         *
         * <code>string closing_txid = 2;</code>
         * @return The closingTxid.
         */
        @java.lang.Override
        public java.lang.String getClosingTxid() {
          return instance.getClosingTxid();
        }
        /**
         * <pre>
         * The transaction id of the closing transaction
         * </pre>
         *
         * <code>string closing_txid = 2;</code>
         * @return The bytes for closingTxid.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getClosingTxidBytes() {
          return instance.getClosingTxidBytes();
        }
        /**
         * <pre>
         * The transaction id of the closing transaction
         * </pre>
         *
         * <code>string closing_txid = 2;</code>
         * @param value The closingTxid to set.
         * @return This builder for chaining.
         */
        public Builder setClosingTxid(
            java.lang.String value) {
          copyOnWrite();
          instance.setClosingTxid(value);
          return this;
        }
        /**
         * <pre>
         * The transaction id of the closing transaction
         * </pre>
         *
         * <code>string closing_txid = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearClosingTxid() {
          copyOnWrite();
          instance.clearClosingTxid();
          return this;
        }
        /**
         * <pre>
         * The transaction id of the closing transaction
         * </pre>
         *
         * <code>string closing_txid = 2;</code>
         * @param value The bytes for closingTxid to set.
         * @return This builder for chaining.
         */
        public Builder setClosingTxidBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setClosingTxidBytes(value);
          return this;
        }

        // @@protoc_insertion_point(builder_scope:co.anode.anodium.PendingChannelsResponse.ClosedChannel)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "channel_",
                "closingTxid_",
              };
              java.lang.String info =
                  "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\t\u0002\u0208" +
                  "";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel> parser = PARSER;
            if (parser == null) {
              synchronized (co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:co.anode.anodium.PendingChannelsResponse.ClosedChannel)
      private static final co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel DEFAULT_INSTANCE;
      static {
        ClosedChannel defaultInstance = new ClosedChannel();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          ClosedChannel.class, defaultInstance);
      }

      public static co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<ClosedChannel> PARSER;

      public static com.google.protobuf.Parser<ClosedChannel> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public interface ForceClosedChannelOrBuilder extends
        // @@protoc_insertion_point(interface_extends:co.anode.anodium.PendingChannelsResponse.ForceClosedChannel)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * The pending channel to be force closed
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       * @return Whether the channel field is set.
       */
      boolean hasChannel();
      /**
       * <pre>
       * The pending channel to be force closed
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       * @return The channel.
       */
      co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel getChannel();

      /**
       * <pre>
       * The transaction id of the closing transaction
       * </pre>
       *
       * <code>string closing_txid = 2;</code>
       * @return The closingTxid.
       */
      java.lang.String getClosingTxid();
      /**
       * <pre>
       * The transaction id of the closing transaction
       * </pre>
       *
       * <code>string closing_txid = 2;</code>
       * @return The bytes for closingTxid.
       */
      com.google.protobuf.ByteString
          getClosingTxidBytes();

      /**
       * <pre>
       * The balance in satoshis encumbered in this pending channel
       * </pre>
       *
       * <code>int64 limbo_balance = 3;</code>
       * @return The limboBalance.
       */
      long getLimboBalance();

      /**
       * <pre>
       * The height at which funds can be swept into the wallet
       * </pre>
       *
       * <code>uint32 maturity_height = 4;</code>
       * @return The maturityHeight.
       */
      int getMaturityHeight();

      /**
       * <pre>
       *Remaining # of blocks until the commitment output can be swept.
       *Negative values indicate how many blocks have passed since becoming
       *mature.
       * </pre>
       *
       * <code>int32 blocks_til_maturity = 5;</code>
       * @return The blocksTilMaturity.
       */
      int getBlocksTilMaturity();

      /**
       * <pre>
       * The total value of funds successfully recovered from this channel
       * </pre>
       *
       * <code>int64 recovered_balance = 6;</code>
       * @return The recoveredBalance.
       */
      long getRecoveredBalance();

      /**
       * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
       */
      java.util.List<co.anode.anodium.Rpc.PendingHTLC> 
          getPendingHtlcsList();
      /**
       * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
       */
      co.anode.anodium.Rpc.PendingHTLC getPendingHtlcs(int index);
      /**
       * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
       */
      int getPendingHtlcsCount();

      /**
       * <code>.co.anode.anodium.PendingChannelsResponse.ForceClosedChannel.AnchorState anchor = 9;</code>
       * @return The enum numeric value on the wire for anchor.
       */
      int getAnchorValue();
      /**
       * <code>.co.anode.anodium.PendingChannelsResponse.ForceClosedChannel.AnchorState anchor = 9;</code>
       * @return The anchor.
       */
      co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel.AnchorState getAnchor();
    }
    /**
     * Protobuf type {@code co.anode.anodium.PendingChannelsResponse.ForceClosedChannel}
     */
    public  static final class ForceClosedChannel extends
        com.google.protobuf.GeneratedMessageLite<
            ForceClosedChannel, ForceClosedChannel.Builder> implements
        // @@protoc_insertion_point(message_implements:co.anode.anodium.PendingChannelsResponse.ForceClosedChannel)
        ForceClosedChannelOrBuilder {
      private ForceClosedChannel() {
        closingTxid_ = "";
        pendingHtlcs_ = emptyProtobufList();
      }
      /**
       * Protobuf enum {@code co.anode.anodium.PendingChannelsResponse.ForceClosedChannel.AnchorState}
       */
      public enum AnchorState
          implements com.google.protobuf.Internal.EnumLite {
        /**
         * <code>LIMBO = 0;</code>
         */
        LIMBO(0),
        /**
         * <code>RECOVERED = 1;</code>
         */
        RECOVERED(1),
        /**
         * <code>LOST = 2;</code>
         */
        LOST(2),
        UNRECOGNIZED(-1),
        ;

        /**
         * <code>LIMBO = 0;</code>
         */
        public static final int LIMBO_VALUE = 0;
        /**
         * <code>RECOVERED = 1;</code>
         */
        public static final int RECOVERED_VALUE = 1;
        /**
         * <code>LOST = 2;</code>
         */
        public static final int LOST_VALUE = 2;


        @java.lang.Override
        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The number of the enum to look for.
         * @return The enum associated with the given number.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static AnchorState valueOf(int value) {
          return forNumber(value);
        }

        public static AnchorState forNumber(int value) {
          switch (value) {
            case 0: return LIMBO;
            case 1: return RECOVERED;
            case 2: return LOST;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<AnchorState>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            AnchorState> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<AnchorState>() {
                @java.lang.Override
                public AnchorState findValueByNumber(int number) {
                  return AnchorState.forNumber(number);
                }
              };

        public static com.google.protobuf.Internal.EnumVerifier 
            internalGetVerifier() {
          return AnchorStateVerifier.INSTANCE;
        }

        private static final class AnchorStateVerifier implements 
             com.google.protobuf.Internal.EnumVerifier { 
                static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new AnchorStateVerifier();
                @java.lang.Override
                public boolean isInRange(int number) {
                  return AnchorState.forNumber(number) != null;
                }
              };

        private final int value;

        private AnchorState(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:co.anode.anodium.PendingChannelsResponse.ForceClosedChannel.AnchorState)
      }

      public static final int CHANNEL_FIELD_NUMBER = 1;
      private co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel channel_;
      /**
       * <pre>
       * The pending channel to be force closed
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      @java.lang.Override
      public boolean hasChannel() {
        return channel_ != null;
      }
      /**
       * <pre>
       * The pending channel to be force closed
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel getChannel() {
        return channel_ == null ? co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel.getDefaultInstance() : channel_;
      }
      /**
       * <pre>
       * The pending channel to be force closed
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      private void setChannel(co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel value) {
        value.getClass();
  channel_ = value;
        
        }
      /**
       * <pre>
       * The pending channel to be force closed
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      @java.lang.SuppressWarnings({"ReferenceEquality"})
      private void mergeChannel(co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel value) {
        value.getClass();
  if (channel_ != null &&
            channel_ != co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel.getDefaultInstance()) {
          channel_ =
            co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel.newBuilder(channel_).mergeFrom(value).buildPartial();
        } else {
          channel_ = value;
        }
        
      }
      /**
       * <pre>
       * The pending channel to be force closed
       * </pre>
       *
       * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
       */
      private void clearChannel() {  channel_ = null;
        
      }

      public static final int CLOSING_TXID_FIELD_NUMBER = 2;
      private java.lang.String closingTxid_;
      /**
       * <pre>
       * The transaction id of the closing transaction
       * </pre>
       *
       * <code>string closing_txid = 2;</code>
       * @return The closingTxid.
       */
      @java.lang.Override
      public java.lang.String getClosingTxid() {
        return closingTxid_;
      }
      /**
       * <pre>
       * The transaction id of the closing transaction
       * </pre>
       *
       * <code>string closing_txid = 2;</code>
       * @return The bytes for closingTxid.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getClosingTxidBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(closingTxid_);
      }
      /**
       * <pre>
       * The transaction id of the closing transaction
       * </pre>
       *
       * <code>string closing_txid = 2;</code>
       * @param value The closingTxid to set.
       */
      private void setClosingTxid(
          java.lang.String value) {
        value.getClass();
  
        closingTxid_ = value;
      }
      /**
       * <pre>
       * The transaction id of the closing transaction
       * </pre>
       *
       * <code>string closing_txid = 2;</code>
       */
      private void clearClosingTxid() {
        
        closingTxid_ = getDefaultInstance().getClosingTxid();
      }
      /**
       * <pre>
       * The transaction id of the closing transaction
       * </pre>
       *
       * <code>string closing_txid = 2;</code>
       * @param value The bytes for closingTxid to set.
       */
      private void setClosingTxidBytes(
          com.google.protobuf.ByteString value) {
        checkByteStringIsUtf8(value);
        closingTxid_ = value.toStringUtf8();
        
      }

      public static final int LIMBO_BALANCE_FIELD_NUMBER = 3;
      private long limboBalance_;
      /**
       * <pre>
       * The balance in satoshis encumbered in this pending channel
       * </pre>
       *
       * <code>int64 limbo_balance = 3;</code>
       * @return The limboBalance.
       */
      @java.lang.Override
      public long getLimboBalance() {
        return limboBalance_;
      }
      /**
       * <pre>
       * The balance in satoshis encumbered in this pending channel
       * </pre>
       *
       * <code>int64 limbo_balance = 3;</code>
       * @param value The limboBalance to set.
       */
      private void setLimboBalance(long value) {
        
        limboBalance_ = value;
      }
      /**
       * <pre>
       * The balance in satoshis encumbered in this pending channel
       * </pre>
       *
       * <code>int64 limbo_balance = 3;</code>
       */
      private void clearLimboBalance() {
        
        limboBalance_ = 0L;
      }

      public static final int MATURITY_HEIGHT_FIELD_NUMBER = 4;
      private int maturityHeight_;
      /**
       * <pre>
       * The height at which funds can be swept into the wallet
       * </pre>
       *
       * <code>uint32 maturity_height = 4;</code>
       * @return The maturityHeight.
       */
      @java.lang.Override
      public int getMaturityHeight() {
        return maturityHeight_;
      }
      /**
       * <pre>
       * The height at which funds can be swept into the wallet
       * </pre>
       *
       * <code>uint32 maturity_height = 4;</code>
       * @param value The maturityHeight to set.
       */
      private void setMaturityHeight(int value) {
        
        maturityHeight_ = value;
      }
      /**
       * <pre>
       * The height at which funds can be swept into the wallet
       * </pre>
       *
       * <code>uint32 maturity_height = 4;</code>
       */
      private void clearMaturityHeight() {
        
        maturityHeight_ = 0;
      }

      public static final int BLOCKS_TIL_MATURITY_FIELD_NUMBER = 5;
      private int blocksTilMaturity_;
      /**
       * <pre>
       *Remaining # of blocks until the commitment output can be swept.
       *Negative values indicate how many blocks have passed since becoming
       *mature.
       * </pre>
       *
       * <code>int32 blocks_til_maturity = 5;</code>
       * @return The blocksTilMaturity.
       */
      @java.lang.Override
      public int getBlocksTilMaturity() {
        return blocksTilMaturity_;
      }
      /**
       * <pre>
       *Remaining # of blocks until the commitment output can be swept.
       *Negative values indicate how many blocks have passed since becoming
       *mature.
       * </pre>
       *
       * <code>int32 blocks_til_maturity = 5;</code>
       * @param value The blocksTilMaturity to set.
       */
      private void setBlocksTilMaturity(int value) {
        
        blocksTilMaturity_ = value;
      }
      /**
       * <pre>
       *Remaining # of blocks until the commitment output can be swept.
       *Negative values indicate how many blocks have passed since becoming
       *mature.
       * </pre>
       *
       * <code>int32 blocks_til_maturity = 5;</code>
       */
      private void clearBlocksTilMaturity() {
        
        blocksTilMaturity_ = 0;
      }

      public static final int RECOVERED_BALANCE_FIELD_NUMBER = 6;
      private long recoveredBalance_;
      /**
       * <pre>
       * The total value of funds successfully recovered from this channel
       * </pre>
       *
       * <code>int64 recovered_balance = 6;</code>
       * @return The recoveredBalance.
       */
      @java.lang.Override
      public long getRecoveredBalance() {
        return recoveredBalance_;
      }
      /**
       * <pre>
       * The total value of funds successfully recovered from this channel
       * </pre>
       *
       * <code>int64 recovered_balance = 6;</code>
       * @param value The recoveredBalance to set.
       */
      private void setRecoveredBalance(long value) {
        
        recoveredBalance_ = value;
      }
      /**
       * <pre>
       * The total value of funds successfully recovered from this channel
       * </pre>
       *
       * <code>int64 recovered_balance = 6;</code>
       */
      private void clearRecoveredBalance() {
        
        recoveredBalance_ = 0L;
      }

      public static final int PENDING_HTLCS_FIELD_NUMBER = 8;
      private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.PendingHTLC> pendingHtlcs_;
      /**
       * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.PendingHTLC> getPendingHtlcsList() {
        return pendingHtlcs_;
      }
      /**
       * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
       */
      public java.util.List<? extends co.anode.anodium.Rpc.PendingHTLCOrBuilder> 
          getPendingHtlcsOrBuilderList() {
        return pendingHtlcs_;
      }
      /**
       * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
       */
      @java.lang.Override
      public int getPendingHtlcsCount() {
        return pendingHtlcs_.size();
      }
      /**
       * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.PendingHTLC getPendingHtlcs(int index) {
        return pendingHtlcs_.get(index);
      }
      /**
       * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
       */
      public co.anode.anodium.Rpc.PendingHTLCOrBuilder getPendingHtlcsOrBuilder(
          int index) {
        return pendingHtlcs_.get(index);
      }
      private void ensurePendingHtlcsIsMutable() {
        com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.PendingHTLC> tmp = pendingHtlcs_;
        if (!tmp.isModifiable()) {
          pendingHtlcs_ =
              com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
         }
      }

      /**
       * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
       */
      private void setPendingHtlcs(
          int index, co.anode.anodium.Rpc.PendingHTLC value) {
        value.getClass();
  ensurePendingHtlcsIsMutable();
        pendingHtlcs_.set(index, value);
      }
      /**
       * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
       */
      private void addPendingHtlcs(co.anode.anodium.Rpc.PendingHTLC value) {
        value.getClass();
  ensurePendingHtlcsIsMutable();
        pendingHtlcs_.add(value);
      }
      /**
       * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
       */
      private void addPendingHtlcs(
          int index, co.anode.anodium.Rpc.PendingHTLC value) {
        value.getClass();
  ensurePendingHtlcsIsMutable();
        pendingHtlcs_.add(index, value);
      }
      /**
       * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
       */
      private void addAllPendingHtlcs(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.PendingHTLC> values) {
        ensurePendingHtlcsIsMutable();
        com.google.protobuf.AbstractMessageLite.addAll(
            values, pendingHtlcs_);
      }
      /**
       * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
       */
      private void clearPendingHtlcs() {
        pendingHtlcs_ = emptyProtobufList();
      }
      /**
       * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
       */
      private void removePendingHtlcs(int index) {
        ensurePendingHtlcsIsMutable();
        pendingHtlcs_.remove(index);
      }

      public static final int ANCHOR_FIELD_NUMBER = 9;
      private int anchor_;
      /**
       * <code>.co.anode.anodium.PendingChannelsResponse.ForceClosedChannel.AnchorState anchor = 9;</code>
       * @return The enum numeric value on the wire for anchor.
       */
      @java.lang.Override
      public int getAnchorValue() {
        return anchor_;
      }
      /**
       * <code>.co.anode.anodium.PendingChannelsResponse.ForceClosedChannel.AnchorState anchor = 9;</code>
       * @return The anchor.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel.AnchorState getAnchor() {
        co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel.AnchorState result = co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel.AnchorState.forNumber(anchor_);
        return result == null ? co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel.AnchorState.UNRECOGNIZED : result;
      }
      /**
       * <code>.co.anode.anodium.PendingChannelsResponse.ForceClosedChannel.AnchorState anchor = 9;</code>
       * @param value The enum numeric value on the wire for anchor to set.
       */
      private void setAnchorValue(int value) {
          anchor_ = value;
      }
      /**
       * <code>.co.anode.anodium.PendingChannelsResponse.ForceClosedChannel.AnchorState anchor = 9;</code>
       * @param value The anchor to set.
       */
      private void setAnchor(co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel.AnchorState value) {
        anchor_ = value.getNumber();
        
      }
      /**
       * <code>.co.anode.anodium.PendingChannelsResponse.ForceClosedChannel.AnchorState anchor = 9;</code>
       */
      private void clearAnchor() {
        
        anchor_ = 0;
      }

      public static co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code co.anode.anodium.PendingChannelsResponse.ForceClosedChannel}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel, Builder> implements
          // @@protoc_insertion_point(builder_implements:co.anode.anodium.PendingChannelsResponse.ForceClosedChannel)
          co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannelOrBuilder {
        // Construct using co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * The pending channel to be force closed
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        @java.lang.Override
        public boolean hasChannel() {
          return instance.hasChannel();
        }
        /**
         * <pre>
         * The pending channel to be force closed
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        @java.lang.Override
        public co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel getChannel() {
          return instance.getChannel();
        }
        /**
         * <pre>
         * The pending channel to be force closed
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        public Builder setChannel(co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel value) {
          copyOnWrite();
          instance.setChannel(value);
          return this;
          }
        /**
         * <pre>
         * The pending channel to be force closed
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        public Builder setChannel(
            co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel.Builder builderForValue) {
          copyOnWrite();
          instance.setChannel(builderForValue.build());
          return this;
        }
        /**
         * <pre>
         * The pending channel to be force closed
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        public Builder mergeChannel(co.anode.anodium.Rpc.PendingChannelsResponse.PendingChannel value) {
          copyOnWrite();
          instance.mergeChannel(value);
          return this;
        }
        /**
         * <pre>
         * The pending channel to be force closed
         * </pre>
         *
         * <code>.co.anode.anodium.PendingChannelsResponse.PendingChannel channel = 1;</code>
         */
        public Builder clearChannel() {  copyOnWrite();
          instance.clearChannel();
          return this;
        }

        /**
         * <pre>
         * The transaction id of the closing transaction
         * </pre>
         *
         * <code>string closing_txid = 2;</code>
         * @return The closingTxid.
         */
        @java.lang.Override
        public java.lang.String getClosingTxid() {
          return instance.getClosingTxid();
        }
        /**
         * <pre>
         * The transaction id of the closing transaction
         * </pre>
         *
         * <code>string closing_txid = 2;</code>
         * @return The bytes for closingTxid.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getClosingTxidBytes() {
          return instance.getClosingTxidBytes();
        }
        /**
         * <pre>
         * The transaction id of the closing transaction
         * </pre>
         *
         * <code>string closing_txid = 2;</code>
         * @param value The closingTxid to set.
         * @return This builder for chaining.
         */
        public Builder setClosingTxid(
            java.lang.String value) {
          copyOnWrite();
          instance.setClosingTxid(value);
          return this;
        }
        /**
         * <pre>
         * The transaction id of the closing transaction
         * </pre>
         *
         * <code>string closing_txid = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearClosingTxid() {
          copyOnWrite();
          instance.clearClosingTxid();
          return this;
        }
        /**
         * <pre>
         * The transaction id of the closing transaction
         * </pre>
         *
         * <code>string closing_txid = 2;</code>
         * @param value The bytes for closingTxid to set.
         * @return This builder for chaining.
         */
        public Builder setClosingTxidBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setClosingTxidBytes(value);
          return this;
        }

        /**
         * <pre>
         * The balance in satoshis encumbered in this pending channel
         * </pre>
         *
         * <code>int64 limbo_balance = 3;</code>
         * @return The limboBalance.
         */
        @java.lang.Override
        public long getLimboBalance() {
          return instance.getLimboBalance();
        }
        /**
         * <pre>
         * The balance in satoshis encumbered in this pending channel
         * </pre>
         *
         * <code>int64 limbo_balance = 3;</code>
         * @param value The limboBalance to set.
         * @return This builder for chaining.
         */
        public Builder setLimboBalance(long value) {
          copyOnWrite();
          instance.setLimboBalance(value);
          return this;
        }
        /**
         * <pre>
         * The balance in satoshis encumbered in this pending channel
         * </pre>
         *
         * <code>int64 limbo_balance = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearLimboBalance() {
          copyOnWrite();
          instance.clearLimboBalance();
          return this;
        }

        /**
         * <pre>
         * The height at which funds can be swept into the wallet
         * </pre>
         *
         * <code>uint32 maturity_height = 4;</code>
         * @return The maturityHeight.
         */
        @java.lang.Override
        public int getMaturityHeight() {
          return instance.getMaturityHeight();
        }
        /**
         * <pre>
         * The height at which funds can be swept into the wallet
         * </pre>
         *
         * <code>uint32 maturity_height = 4;</code>
         * @param value The maturityHeight to set.
         * @return This builder for chaining.
         */
        public Builder setMaturityHeight(int value) {
          copyOnWrite();
          instance.setMaturityHeight(value);
          return this;
        }
        /**
         * <pre>
         * The height at which funds can be swept into the wallet
         * </pre>
         *
         * <code>uint32 maturity_height = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearMaturityHeight() {
          copyOnWrite();
          instance.clearMaturityHeight();
          return this;
        }

        /**
         * <pre>
         *Remaining # of blocks until the commitment output can be swept.
         *Negative values indicate how many blocks have passed since becoming
         *mature.
         * </pre>
         *
         * <code>int32 blocks_til_maturity = 5;</code>
         * @return The blocksTilMaturity.
         */
        @java.lang.Override
        public int getBlocksTilMaturity() {
          return instance.getBlocksTilMaturity();
        }
        /**
         * <pre>
         *Remaining # of blocks until the commitment output can be swept.
         *Negative values indicate how many blocks have passed since becoming
         *mature.
         * </pre>
         *
         * <code>int32 blocks_til_maturity = 5;</code>
         * @param value The blocksTilMaturity to set.
         * @return This builder for chaining.
         */
        public Builder setBlocksTilMaturity(int value) {
          copyOnWrite();
          instance.setBlocksTilMaturity(value);
          return this;
        }
        /**
         * <pre>
         *Remaining # of blocks until the commitment output can be swept.
         *Negative values indicate how many blocks have passed since becoming
         *mature.
         * </pre>
         *
         * <code>int32 blocks_til_maturity = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearBlocksTilMaturity() {
          copyOnWrite();
          instance.clearBlocksTilMaturity();
          return this;
        }

        /**
         * <pre>
         * The total value of funds successfully recovered from this channel
         * </pre>
         *
         * <code>int64 recovered_balance = 6;</code>
         * @return The recoveredBalance.
         */
        @java.lang.Override
        public long getRecoveredBalance() {
          return instance.getRecoveredBalance();
        }
        /**
         * <pre>
         * The total value of funds successfully recovered from this channel
         * </pre>
         *
         * <code>int64 recovered_balance = 6;</code>
         * @param value The recoveredBalance to set.
         * @return This builder for chaining.
         */
        public Builder setRecoveredBalance(long value) {
          copyOnWrite();
          instance.setRecoveredBalance(value);
          return this;
        }
        /**
         * <pre>
         * The total value of funds successfully recovered from this channel
         * </pre>
         *
         * <code>int64 recovered_balance = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearRecoveredBalance() {
          copyOnWrite();
          instance.clearRecoveredBalance();
          return this;
        }

        /**
         * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
         */
        @java.lang.Override
        public java.util.List<co.anode.anodium.Rpc.PendingHTLC> getPendingHtlcsList() {
          return java.util.Collections.unmodifiableList(
              instance.getPendingHtlcsList());
        }
        /**
         * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
         */
        @java.lang.Override
        public int getPendingHtlcsCount() {
          return instance.getPendingHtlcsCount();
        }/**
         * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
         */
        @java.lang.Override
        public co.anode.anodium.Rpc.PendingHTLC getPendingHtlcs(int index) {
          return instance.getPendingHtlcs(index);
        }
        /**
         * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
         */
        public Builder setPendingHtlcs(
            int index, co.anode.anodium.Rpc.PendingHTLC value) {
          copyOnWrite();
          instance.setPendingHtlcs(index, value);
          return this;
        }
        /**
         * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
         */
        public Builder setPendingHtlcs(
            int index, co.anode.anodium.Rpc.PendingHTLC.Builder builderForValue) {
          copyOnWrite();
          instance.setPendingHtlcs(index,
              builderForValue.build());
          return this;
        }
        /**
         * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
         */
        public Builder addPendingHtlcs(co.anode.anodium.Rpc.PendingHTLC value) {
          copyOnWrite();
          instance.addPendingHtlcs(value);
          return this;
        }
        /**
         * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
         */
        public Builder addPendingHtlcs(
            int index, co.anode.anodium.Rpc.PendingHTLC value) {
          copyOnWrite();
          instance.addPendingHtlcs(index, value);
          return this;
        }
        /**
         * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
         */
        public Builder addPendingHtlcs(
            co.anode.anodium.Rpc.PendingHTLC.Builder builderForValue) {
          copyOnWrite();
          instance.addPendingHtlcs(builderForValue.build());
          return this;
        }
        /**
         * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
         */
        public Builder addPendingHtlcs(
            int index, co.anode.anodium.Rpc.PendingHTLC.Builder builderForValue) {
          copyOnWrite();
          instance.addPendingHtlcs(index,
              builderForValue.build());
          return this;
        }
        /**
         * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
         */
        public Builder addAllPendingHtlcs(
            java.lang.Iterable<? extends co.anode.anodium.Rpc.PendingHTLC> values) {
          copyOnWrite();
          instance.addAllPendingHtlcs(values);
          return this;
        }
        /**
         * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
         */
        public Builder clearPendingHtlcs() {
          copyOnWrite();
          instance.clearPendingHtlcs();
          return this;
        }
        /**
         * <code>repeated .co.anode.anodium.PendingHTLC pending_htlcs = 8;</code>
         */
        public Builder removePendingHtlcs(int index) {
          copyOnWrite();
          instance.removePendingHtlcs(index);
          return this;
        }

        /**
         * <code>.co.anode.anodium.PendingChannelsResponse.ForceClosedChannel.AnchorState anchor = 9;</code>
         * @return The enum numeric value on the wire for anchor.
         */
        @java.lang.Override
        public int getAnchorValue() {
          return instance.getAnchorValue();
        }
        /**
         * <code>.co.anode.anodium.PendingChannelsResponse.ForceClosedChannel.AnchorState anchor = 9;</code>
         * @param value The anchor to set.
         * @return This builder for chaining.
         */
        public Builder setAnchorValue(int value) {
          copyOnWrite();
          instance.setAnchorValue(value);
          return this;
        }
        /**
         * <code>.co.anode.anodium.PendingChannelsResponse.ForceClosedChannel.AnchorState anchor = 9;</code>
         * @return The anchor.
         */
        @java.lang.Override
        public co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel.AnchorState getAnchor() {
          return instance.getAnchor();
        }
        /**
         * <code>.co.anode.anodium.PendingChannelsResponse.ForceClosedChannel.AnchorState anchor = 9;</code>
         * @param value The enum numeric value on the wire for anchor to set.
         * @return This builder for chaining.
         */
        public Builder setAnchor(co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel.AnchorState value) {
          copyOnWrite();
          instance.setAnchor(value);
          return this;
        }
        /**
         * <code>.co.anode.anodium.PendingChannelsResponse.ForceClosedChannel.AnchorState anchor = 9;</code>
         * @return This builder for chaining.
         */
        public Builder clearAnchor() {
          copyOnWrite();
          instance.clearAnchor();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:co.anode.anodium.PendingChannelsResponse.ForceClosedChannel)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "channel_",
                "closingTxid_",
                "limboBalance_",
                "maturityHeight_",
                "blocksTilMaturity_",
                "recoveredBalance_",
                "pendingHtlcs_",
                co.anode.anodium.Rpc.PendingHTLC.class,
                "anchor_",
              };
              java.lang.String info =
                  "\u0000\b\u0000\u0000\u0001\t\b\u0000\u0001\u0000\u0001\t\u0002\u0208\u0003\u0002" +
                  "\u0004\u000b\u0005\u0004\u0006\u0002\b\u001b\t\f";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel> parser = PARSER;
            if (parser == null) {
              synchronized (co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:co.anode.anodium.PendingChannelsResponse.ForceClosedChannel)
      private static final co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel DEFAULT_INSTANCE;
      static {
        ForceClosedChannel defaultInstance = new ForceClosedChannel();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          ForceClosedChannel.class, defaultInstance);
      }

      public static co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<ForceClosedChannel> PARSER;

      public static com.google.protobuf.Parser<ForceClosedChannel> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public static final int TOTAL_LIMBO_BALANCE_FIELD_NUMBER = 1;
    private long totalLimboBalance_;
    /**
     * <pre>
     * The balance in satoshis encumbered in pending channels
     * </pre>
     *
     * <code>int64 total_limbo_balance = 1;</code>
     * @return The totalLimboBalance.
     */
    @java.lang.Override
    public long getTotalLimboBalance() {
      return totalLimboBalance_;
    }
    /**
     * <pre>
     * The balance in satoshis encumbered in pending channels
     * </pre>
     *
     * <code>int64 total_limbo_balance = 1;</code>
     * @param value The totalLimboBalance to set.
     */
    private void setTotalLimboBalance(long value) {
      
      totalLimboBalance_ = value;
    }
    /**
     * <pre>
     * The balance in satoshis encumbered in pending channels
     * </pre>
     *
     * <code>int64 total_limbo_balance = 1;</code>
     */
    private void clearTotalLimboBalance() {
      
      totalLimboBalance_ = 0L;
    }

    public static final int PENDING_OPEN_CHANNELS_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel> pendingOpenChannels_;
    /**
     * <pre>
     * Channels pending opening
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel> getPendingOpenChannelsList() {
      return pendingOpenChannels_;
    }
    /**
     * <pre>
     * Channels pending opening
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannelOrBuilder> 
        getPendingOpenChannelsOrBuilderList() {
      return pendingOpenChannels_;
    }
    /**
     * <pre>
     * Channels pending opening
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
     */
    @java.lang.Override
    public int getPendingOpenChannelsCount() {
      return pendingOpenChannels_.size();
    }
    /**
     * <pre>
     * Channels pending opening
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel getPendingOpenChannels(int index) {
      return pendingOpenChannels_.get(index);
    }
    /**
     * <pre>
     * Channels pending opening
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
     */
    public co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannelOrBuilder getPendingOpenChannelsOrBuilder(
        int index) {
      return pendingOpenChannels_.get(index);
    }
    private void ensurePendingOpenChannelsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel> tmp = pendingOpenChannels_;
      if (!tmp.isModifiable()) {
        pendingOpenChannels_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * Channels pending opening
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
     */
    private void setPendingOpenChannels(
        int index, co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel value) {
      value.getClass();
  ensurePendingOpenChannelsIsMutable();
      pendingOpenChannels_.set(index, value);
    }
    /**
     * <pre>
     * Channels pending opening
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
     */
    private void addPendingOpenChannels(co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel value) {
      value.getClass();
  ensurePendingOpenChannelsIsMutable();
      pendingOpenChannels_.add(value);
    }
    /**
     * <pre>
     * Channels pending opening
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
     */
    private void addPendingOpenChannels(
        int index, co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel value) {
      value.getClass();
  ensurePendingOpenChannelsIsMutable();
      pendingOpenChannels_.add(index, value);
    }
    /**
     * <pre>
     * Channels pending opening
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
     */
    private void addAllPendingOpenChannels(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel> values) {
      ensurePendingOpenChannelsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, pendingOpenChannels_);
    }
    /**
     * <pre>
     * Channels pending opening
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
     */
    private void clearPendingOpenChannels() {
      pendingOpenChannels_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Channels pending opening
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
     */
    private void removePendingOpenChannels(int index) {
      ensurePendingOpenChannelsIsMutable();
      pendingOpenChannels_.remove(index);
    }

    public static final int PENDING_CLOSING_CHANNELS_FIELD_NUMBER = 3;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel> pendingClosingChannels_;
    /**
     * <pre>
     *Deprecated: Channels pending closing previously contained cooperatively
     *closed channels with a single confirmation. These channels are now
     *considered closed from the time we see them on chain.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
     */
    @java.lang.Override
    @java.lang.Deprecated public java.util.List<co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel> getPendingClosingChannelsList() {
      return pendingClosingChannels_;
    }
    /**
     * <pre>
     *Deprecated: Channels pending closing previously contained cooperatively
     *closed channels with a single confirmation. These channels are now
     *considered closed from the time we see them on chain.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
     */
    @java.lang.Deprecated public java.util.List<? extends co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannelOrBuilder> 
        getPendingClosingChannelsOrBuilderList() {
      return pendingClosingChannels_;
    }
    /**
     * <pre>
     *Deprecated: Channels pending closing previously contained cooperatively
     *closed channels with a single confirmation. These channels are now
     *considered closed from the time we see them on chain.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
     */
    @java.lang.Override
    @java.lang.Deprecated public int getPendingClosingChannelsCount() {
      return pendingClosingChannels_.size();
    }
    /**
     * <pre>
     *Deprecated: Channels pending closing previously contained cooperatively
     *closed channels with a single confirmation. These channels are now
     *considered closed from the time we see them on chain.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
     */
    @java.lang.Override
    @java.lang.Deprecated public co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel getPendingClosingChannels(int index) {
      return pendingClosingChannels_.get(index);
    }
    /**
     * <pre>
     *Deprecated: Channels pending closing previously contained cooperatively
     *closed channels with a single confirmation. These channels are now
     *considered closed from the time we see them on chain.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
     */
    @java.lang.Deprecated public co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannelOrBuilder getPendingClosingChannelsOrBuilder(
        int index) {
      return pendingClosingChannels_.get(index);
    }
    private void ensurePendingClosingChannelsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel> tmp = pendingClosingChannels_;
      if (!tmp.isModifiable()) {
        pendingClosingChannels_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     *Deprecated: Channels pending closing previously contained cooperatively
     *closed channels with a single confirmation. These channels are now
     *considered closed from the time we see them on chain.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
     */
    private void setPendingClosingChannels(
        int index, co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel value) {
      value.getClass();
  ensurePendingClosingChannelsIsMutable();
      pendingClosingChannels_.set(index, value);
    }
    /**
     * <pre>
     *Deprecated: Channels pending closing previously contained cooperatively
     *closed channels with a single confirmation. These channels are now
     *considered closed from the time we see them on chain.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
     */
    private void addPendingClosingChannels(co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel value) {
      value.getClass();
  ensurePendingClosingChannelsIsMutable();
      pendingClosingChannels_.add(value);
    }
    /**
     * <pre>
     *Deprecated: Channels pending closing previously contained cooperatively
     *closed channels with a single confirmation. These channels are now
     *considered closed from the time we see them on chain.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
     */
    private void addPendingClosingChannels(
        int index, co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel value) {
      value.getClass();
  ensurePendingClosingChannelsIsMutable();
      pendingClosingChannels_.add(index, value);
    }
    /**
     * <pre>
     *Deprecated: Channels pending closing previously contained cooperatively
     *closed channels with a single confirmation. These channels are now
     *considered closed from the time we see them on chain.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
     */
    private void addAllPendingClosingChannels(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel> values) {
      ensurePendingClosingChannelsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, pendingClosingChannels_);
    }
    /**
     * <pre>
     *Deprecated: Channels pending closing previously contained cooperatively
     *closed channels with a single confirmation. These channels are now
     *considered closed from the time we see them on chain.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
     */
    private void clearPendingClosingChannels() {
      pendingClosingChannels_ = emptyProtobufList();
    }
    /**
     * <pre>
     *Deprecated: Channels pending closing previously contained cooperatively
     *closed channels with a single confirmation. These channels are now
     *considered closed from the time we see them on chain.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
     */
    private void removePendingClosingChannels(int index) {
      ensurePendingClosingChannelsIsMutable();
      pendingClosingChannels_.remove(index);
    }

    public static final int PENDING_FORCE_CLOSING_CHANNELS_FIELD_NUMBER = 4;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel> pendingForceClosingChannels_;
    /**
     * <pre>
     * Channels pending force closing
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel> getPendingForceClosingChannelsList() {
      return pendingForceClosingChannels_;
    }
    /**
     * <pre>
     * Channels pending force closing
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannelOrBuilder> 
        getPendingForceClosingChannelsOrBuilderList() {
      return pendingForceClosingChannels_;
    }
    /**
     * <pre>
     * Channels pending force closing
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
     */
    @java.lang.Override
    public int getPendingForceClosingChannelsCount() {
      return pendingForceClosingChannels_.size();
    }
    /**
     * <pre>
     * Channels pending force closing
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel getPendingForceClosingChannels(int index) {
      return pendingForceClosingChannels_.get(index);
    }
    /**
     * <pre>
     * Channels pending force closing
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
     */
    public co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannelOrBuilder getPendingForceClosingChannelsOrBuilder(
        int index) {
      return pendingForceClosingChannels_.get(index);
    }
    private void ensurePendingForceClosingChannelsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel> tmp = pendingForceClosingChannels_;
      if (!tmp.isModifiable()) {
        pendingForceClosingChannels_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * Channels pending force closing
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
     */
    private void setPendingForceClosingChannels(
        int index, co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel value) {
      value.getClass();
  ensurePendingForceClosingChannelsIsMutable();
      pendingForceClosingChannels_.set(index, value);
    }
    /**
     * <pre>
     * Channels pending force closing
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
     */
    private void addPendingForceClosingChannels(co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel value) {
      value.getClass();
  ensurePendingForceClosingChannelsIsMutable();
      pendingForceClosingChannels_.add(value);
    }
    /**
     * <pre>
     * Channels pending force closing
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
     */
    private void addPendingForceClosingChannels(
        int index, co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel value) {
      value.getClass();
  ensurePendingForceClosingChannelsIsMutable();
      pendingForceClosingChannels_.add(index, value);
    }
    /**
     * <pre>
     * Channels pending force closing
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
     */
    private void addAllPendingForceClosingChannels(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel> values) {
      ensurePendingForceClosingChannelsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, pendingForceClosingChannels_);
    }
    /**
     * <pre>
     * Channels pending force closing
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
     */
    private void clearPendingForceClosingChannels() {
      pendingForceClosingChannels_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Channels pending force closing
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
     */
    private void removePendingForceClosingChannels(int index) {
      ensurePendingForceClosingChannelsIsMutable();
      pendingForceClosingChannels_.remove(index);
    }

    public static final int WAITING_CLOSE_CHANNELS_FIELD_NUMBER = 5;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel> waitingCloseChannels_;
    /**
     * <pre>
     * Channels waiting for closing tx to confirm
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel> getWaitingCloseChannelsList() {
      return waitingCloseChannels_;
    }
    /**
     * <pre>
     * Channels waiting for closing tx to confirm
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannelOrBuilder> 
        getWaitingCloseChannelsOrBuilderList() {
      return waitingCloseChannels_;
    }
    /**
     * <pre>
     * Channels waiting for closing tx to confirm
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
     */
    @java.lang.Override
    public int getWaitingCloseChannelsCount() {
      return waitingCloseChannels_.size();
    }
    /**
     * <pre>
     * Channels waiting for closing tx to confirm
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel getWaitingCloseChannels(int index) {
      return waitingCloseChannels_.get(index);
    }
    /**
     * <pre>
     * Channels waiting for closing tx to confirm
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
     */
    public co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannelOrBuilder getWaitingCloseChannelsOrBuilder(
        int index) {
      return waitingCloseChannels_.get(index);
    }
    private void ensureWaitingCloseChannelsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel> tmp = waitingCloseChannels_;
      if (!tmp.isModifiable()) {
        waitingCloseChannels_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * Channels waiting for closing tx to confirm
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
     */
    private void setWaitingCloseChannels(
        int index, co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel value) {
      value.getClass();
  ensureWaitingCloseChannelsIsMutable();
      waitingCloseChannels_.set(index, value);
    }
    /**
     * <pre>
     * Channels waiting for closing tx to confirm
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
     */
    private void addWaitingCloseChannels(co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel value) {
      value.getClass();
  ensureWaitingCloseChannelsIsMutable();
      waitingCloseChannels_.add(value);
    }
    /**
     * <pre>
     * Channels waiting for closing tx to confirm
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
     */
    private void addWaitingCloseChannels(
        int index, co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel value) {
      value.getClass();
  ensureWaitingCloseChannelsIsMutable();
      waitingCloseChannels_.add(index, value);
    }
    /**
     * <pre>
     * Channels waiting for closing tx to confirm
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
     */
    private void addAllWaitingCloseChannels(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel> values) {
      ensureWaitingCloseChannelsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, waitingCloseChannels_);
    }
    /**
     * <pre>
     * Channels waiting for closing tx to confirm
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
     */
    private void clearWaitingCloseChannels() {
      waitingCloseChannels_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Channels waiting for closing tx to confirm
     * </pre>
     *
     * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
     */
    private void removeWaitingCloseChannels(int index) {
      ensureWaitingCloseChannelsIsMutable();
      waitingCloseChannels_.remove(index);
    }

    public static co.anode.anodium.Rpc.PendingChannelsResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PendingChannelsResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingChannelsResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PendingChannelsResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingChannelsResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PendingChannelsResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingChannelsResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PendingChannelsResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingChannelsResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PendingChannelsResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PendingChannelsResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PendingChannelsResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.PendingChannelsResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.PendingChannelsResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.PendingChannelsResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.PendingChannelsResponse)
        co.anode.anodium.Rpc.PendingChannelsResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.PendingChannelsResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The balance in satoshis encumbered in pending channels
       * </pre>
       *
       * <code>int64 total_limbo_balance = 1;</code>
       * @return The totalLimboBalance.
       */
      @java.lang.Override
      public long getTotalLimboBalance() {
        return instance.getTotalLimboBalance();
      }
      /**
       * <pre>
       * The balance in satoshis encumbered in pending channels
       * </pre>
       *
       * <code>int64 total_limbo_balance = 1;</code>
       * @param value The totalLimboBalance to set.
       * @return This builder for chaining.
       */
      public Builder setTotalLimboBalance(long value) {
        copyOnWrite();
        instance.setTotalLimboBalance(value);
        return this;
      }
      /**
       * <pre>
       * The balance in satoshis encumbered in pending channels
       * </pre>
       *
       * <code>int64 total_limbo_balance = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTotalLimboBalance() {
        copyOnWrite();
        instance.clearTotalLimboBalance();
        return this;
      }

      /**
       * <pre>
       * Channels pending opening
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel> getPendingOpenChannelsList() {
        return java.util.Collections.unmodifiableList(
            instance.getPendingOpenChannelsList());
      }
      /**
       * <pre>
       * Channels pending opening
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
       */
      @java.lang.Override
      public int getPendingOpenChannelsCount() {
        return instance.getPendingOpenChannelsCount();
      }/**
       * <pre>
       * Channels pending opening
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel getPendingOpenChannels(int index) {
        return instance.getPendingOpenChannels(index);
      }
      /**
       * <pre>
       * Channels pending opening
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
       */
      public Builder setPendingOpenChannels(
          int index, co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel value) {
        copyOnWrite();
        instance.setPendingOpenChannels(index, value);
        return this;
      }
      /**
       * <pre>
       * Channels pending opening
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
       */
      public Builder setPendingOpenChannels(
          int index, co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel.Builder builderForValue) {
        copyOnWrite();
        instance.setPendingOpenChannels(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Channels pending opening
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
       */
      public Builder addPendingOpenChannels(co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel value) {
        copyOnWrite();
        instance.addPendingOpenChannels(value);
        return this;
      }
      /**
       * <pre>
       * Channels pending opening
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
       */
      public Builder addPendingOpenChannels(
          int index, co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel value) {
        copyOnWrite();
        instance.addPendingOpenChannels(index, value);
        return this;
      }
      /**
       * <pre>
       * Channels pending opening
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
       */
      public Builder addPendingOpenChannels(
          co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel.Builder builderForValue) {
        copyOnWrite();
        instance.addPendingOpenChannels(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Channels pending opening
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
       */
      public Builder addPendingOpenChannels(
          int index, co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel.Builder builderForValue) {
        copyOnWrite();
        instance.addPendingOpenChannels(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Channels pending opening
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
       */
      public Builder addAllPendingOpenChannels(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel> values) {
        copyOnWrite();
        instance.addAllPendingOpenChannels(values);
        return this;
      }
      /**
       * <pre>
       * Channels pending opening
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
       */
      public Builder clearPendingOpenChannels() {
        copyOnWrite();
        instance.clearPendingOpenChannels();
        return this;
      }
      /**
       * <pre>
       * Channels pending opening
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;</code>
       */
      public Builder removePendingOpenChannels(int index) {
        copyOnWrite();
        instance.removePendingOpenChannels(index);
        return this;
      }

      /**
       * <pre>
       *Deprecated: Channels pending closing previously contained cooperatively
       *closed channels with a single confirmation. These channels are now
       *considered closed from the time we see them on chain.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
       */
      @java.lang.Override
      @java.lang.Deprecated public java.util.List<co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel> getPendingClosingChannelsList() {
        return java.util.Collections.unmodifiableList(
            instance.getPendingClosingChannelsList());
      }
      /**
       * <pre>
       *Deprecated: Channels pending closing previously contained cooperatively
       *closed channels with a single confirmation. These channels are now
       *considered closed from the time we see them on chain.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
       */
      @java.lang.Override
      @java.lang.Deprecated public int getPendingClosingChannelsCount() {
        return instance.getPendingClosingChannelsCount();
      }/**
       * <pre>
       *Deprecated: Channels pending closing previously contained cooperatively
       *closed channels with a single confirmation. These channels are now
       *considered closed from the time we see them on chain.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
       */
      @java.lang.Override
      @java.lang.Deprecated public co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel getPendingClosingChannels(int index) {
        return instance.getPendingClosingChannels(index);
      }
      /**
       * <pre>
       *Deprecated: Channels pending closing previously contained cooperatively
       *closed channels with a single confirmation. These channels are now
       *considered closed from the time we see them on chain.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder setPendingClosingChannels(
          int index, co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel value) {
        copyOnWrite();
        instance.setPendingClosingChannels(index, value);
        return this;
      }
      /**
       * <pre>
       *Deprecated: Channels pending closing previously contained cooperatively
       *closed channels with a single confirmation. These channels are now
       *considered closed from the time we see them on chain.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder setPendingClosingChannels(
          int index, co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel.Builder builderForValue) {
        copyOnWrite();
        instance.setPendingClosingChannels(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Deprecated: Channels pending closing previously contained cooperatively
       *closed channels with a single confirmation. These channels are now
       *considered closed from the time we see them on chain.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder addPendingClosingChannels(co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel value) {
        copyOnWrite();
        instance.addPendingClosingChannels(value);
        return this;
      }
      /**
       * <pre>
       *Deprecated: Channels pending closing previously contained cooperatively
       *closed channels with a single confirmation. These channels are now
       *considered closed from the time we see them on chain.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder addPendingClosingChannels(
          int index, co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel value) {
        copyOnWrite();
        instance.addPendingClosingChannels(index, value);
        return this;
      }
      /**
       * <pre>
       *Deprecated: Channels pending closing previously contained cooperatively
       *closed channels with a single confirmation. These channels are now
       *considered closed from the time we see them on chain.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder addPendingClosingChannels(
          co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel.Builder builderForValue) {
        copyOnWrite();
        instance.addPendingClosingChannels(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Deprecated: Channels pending closing previously contained cooperatively
       *closed channels with a single confirmation. These channels are now
       *considered closed from the time we see them on chain.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder addPendingClosingChannels(
          int index, co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel.Builder builderForValue) {
        copyOnWrite();
        instance.addPendingClosingChannels(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Deprecated: Channels pending closing previously contained cooperatively
       *closed channels with a single confirmation. These channels are now
       *considered closed from the time we see them on chain.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder addAllPendingClosingChannels(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel> values) {
        copyOnWrite();
        instance.addAllPendingClosingChannels(values);
        return this;
      }
      /**
       * <pre>
       *Deprecated: Channels pending closing previously contained cooperatively
       *closed channels with a single confirmation. These channels are now
       *considered closed from the time we see them on chain.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder clearPendingClosingChannels() {
        copyOnWrite();
        instance.clearPendingClosingChannels();
        return this;
      }
      /**
       * <pre>
       *Deprecated: Channels pending closing previously contained cooperatively
       *closed channels with a single confirmation. These channels are now
       *considered closed from the time we see them on chain.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder removePendingClosingChannels(int index) {
        copyOnWrite();
        instance.removePendingClosingChannels(index);
        return this;
      }

      /**
       * <pre>
       * Channels pending force closing
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel> getPendingForceClosingChannelsList() {
        return java.util.Collections.unmodifiableList(
            instance.getPendingForceClosingChannelsList());
      }
      /**
       * <pre>
       * Channels pending force closing
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
       */
      @java.lang.Override
      public int getPendingForceClosingChannelsCount() {
        return instance.getPendingForceClosingChannelsCount();
      }/**
       * <pre>
       * Channels pending force closing
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel getPendingForceClosingChannels(int index) {
        return instance.getPendingForceClosingChannels(index);
      }
      /**
       * <pre>
       * Channels pending force closing
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
       */
      public Builder setPendingForceClosingChannels(
          int index, co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel value) {
        copyOnWrite();
        instance.setPendingForceClosingChannels(index, value);
        return this;
      }
      /**
       * <pre>
       * Channels pending force closing
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
       */
      public Builder setPendingForceClosingChannels(
          int index, co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel.Builder builderForValue) {
        copyOnWrite();
        instance.setPendingForceClosingChannels(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Channels pending force closing
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
       */
      public Builder addPendingForceClosingChannels(co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel value) {
        copyOnWrite();
        instance.addPendingForceClosingChannels(value);
        return this;
      }
      /**
       * <pre>
       * Channels pending force closing
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
       */
      public Builder addPendingForceClosingChannels(
          int index, co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel value) {
        copyOnWrite();
        instance.addPendingForceClosingChannels(index, value);
        return this;
      }
      /**
       * <pre>
       * Channels pending force closing
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
       */
      public Builder addPendingForceClosingChannels(
          co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel.Builder builderForValue) {
        copyOnWrite();
        instance.addPendingForceClosingChannels(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Channels pending force closing
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
       */
      public Builder addPendingForceClosingChannels(
          int index, co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel.Builder builderForValue) {
        copyOnWrite();
        instance.addPendingForceClosingChannels(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Channels pending force closing
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
       */
      public Builder addAllPendingForceClosingChannels(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel> values) {
        copyOnWrite();
        instance.addAllPendingForceClosingChannels(values);
        return this;
      }
      /**
       * <pre>
       * Channels pending force closing
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
       */
      public Builder clearPendingForceClosingChannels() {
        copyOnWrite();
        instance.clearPendingForceClosingChannels();
        return this;
      }
      /**
       * <pre>
       * Channels pending force closing
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;</code>
       */
      public Builder removePendingForceClosingChannels(int index) {
        copyOnWrite();
        instance.removePendingForceClosingChannels(index);
        return this;
      }

      /**
       * <pre>
       * Channels waiting for closing tx to confirm
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel> getWaitingCloseChannelsList() {
        return java.util.Collections.unmodifiableList(
            instance.getWaitingCloseChannelsList());
      }
      /**
       * <pre>
       * Channels waiting for closing tx to confirm
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
       */
      @java.lang.Override
      public int getWaitingCloseChannelsCount() {
        return instance.getWaitingCloseChannelsCount();
      }/**
       * <pre>
       * Channels waiting for closing tx to confirm
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel getWaitingCloseChannels(int index) {
        return instance.getWaitingCloseChannels(index);
      }
      /**
       * <pre>
       * Channels waiting for closing tx to confirm
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
       */
      public Builder setWaitingCloseChannels(
          int index, co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel value) {
        copyOnWrite();
        instance.setWaitingCloseChannels(index, value);
        return this;
      }
      /**
       * <pre>
       * Channels waiting for closing tx to confirm
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
       */
      public Builder setWaitingCloseChannels(
          int index, co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel.Builder builderForValue) {
        copyOnWrite();
        instance.setWaitingCloseChannels(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Channels waiting for closing tx to confirm
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
       */
      public Builder addWaitingCloseChannels(co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel value) {
        copyOnWrite();
        instance.addWaitingCloseChannels(value);
        return this;
      }
      /**
       * <pre>
       * Channels waiting for closing tx to confirm
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
       */
      public Builder addWaitingCloseChannels(
          int index, co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel value) {
        copyOnWrite();
        instance.addWaitingCloseChannels(index, value);
        return this;
      }
      /**
       * <pre>
       * Channels waiting for closing tx to confirm
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
       */
      public Builder addWaitingCloseChannels(
          co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel.Builder builderForValue) {
        copyOnWrite();
        instance.addWaitingCloseChannels(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Channels waiting for closing tx to confirm
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
       */
      public Builder addWaitingCloseChannels(
          int index, co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel.Builder builderForValue) {
        copyOnWrite();
        instance.addWaitingCloseChannels(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Channels waiting for closing tx to confirm
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
       */
      public Builder addAllWaitingCloseChannels(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel> values) {
        copyOnWrite();
        instance.addAllWaitingCloseChannels(values);
        return this;
      }
      /**
       * <pre>
       * Channels waiting for closing tx to confirm
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
       */
      public Builder clearWaitingCloseChannels() {
        copyOnWrite();
        instance.clearWaitingCloseChannels();
        return this;
      }
      /**
       * <pre>
       * Channels waiting for closing tx to confirm
       * </pre>
       *
       * <code>repeated .co.anode.anodium.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;</code>
       */
      public Builder removeWaitingCloseChannels(int index) {
        copyOnWrite();
        instance.removeWaitingCloseChannels(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.PendingChannelsResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.PendingChannelsResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "totalLimboBalance_",
              "pendingOpenChannels_",
              co.anode.anodium.Rpc.PendingChannelsResponse.PendingOpenChannel.class,
              "pendingClosingChannels_",
              co.anode.anodium.Rpc.PendingChannelsResponse.ClosedChannel.class,
              "pendingForceClosingChannels_",
              co.anode.anodium.Rpc.PendingChannelsResponse.ForceClosedChannel.class,
              "waitingCloseChannels_",
              co.anode.anodium.Rpc.PendingChannelsResponse.WaitingCloseChannel.class,
            };
            java.lang.String info =
                "\u0000\u0005\u0000\u0000\u0001\u0005\u0005\u0000\u0004\u0000\u0001\u0002\u0002\u001b" +
                "\u0003\u001b\u0004\u001b\u0005\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.PendingChannelsResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.PendingChannelsResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.PendingChannelsResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.PendingChannelsResponse)
    private static final co.anode.anodium.Rpc.PendingChannelsResponse DEFAULT_INSTANCE;
    static {
      PendingChannelsResponse defaultInstance = new PendingChannelsResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        PendingChannelsResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.PendingChannelsResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<PendingChannelsResponse> PARSER;

    public static com.google.protobuf.Parser<PendingChannelsResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelEventSubscriptionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelEventSubscription)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChannelEventSubscription}
   */
  public  static final class ChannelEventSubscription extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelEventSubscription, ChannelEventSubscription.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelEventSubscription)
      ChannelEventSubscriptionOrBuilder {
    private ChannelEventSubscription() {
    }
    public static co.anode.anodium.Rpc.ChannelEventSubscription parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelEventSubscription parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEventSubscription parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelEventSubscription parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEventSubscription parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelEventSubscription parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEventSubscription parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelEventSubscription parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEventSubscription parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelEventSubscription parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEventSubscription parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelEventSubscription parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelEventSubscription prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChannelEventSubscription}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelEventSubscription, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelEventSubscription)
        co.anode.anodium.Rpc.ChannelEventSubscriptionOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelEventSubscription.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelEventSubscription)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelEventSubscription();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelEventSubscription> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelEventSubscription.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelEventSubscription>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelEventSubscription)
    private static final co.anode.anodium.Rpc.ChannelEventSubscription DEFAULT_INSTANCE;
    static {
      ChannelEventSubscription defaultInstance = new ChannelEventSubscription();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelEventSubscription.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelEventSubscription getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelEventSubscription> PARSER;

    public static com.google.protobuf.Parser<ChannelEventSubscription> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelEventUpdateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelEventUpdate)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>.co.anode.anodium.Channel open_channel = 1;</code>
     * @return Whether the openChannel field is set.
     */
    boolean hasOpenChannel();
    /**
     * <code>.co.anode.anodium.Channel open_channel = 1;</code>
     * @return The openChannel.
     */
    co.anode.anodium.Rpc.Channel getOpenChannel();

    /**
     * <code>.co.anode.anodium.ChannelCloseSummary closed_channel = 2;</code>
     * @return Whether the closedChannel field is set.
     */
    boolean hasClosedChannel();
    /**
     * <code>.co.anode.anodium.ChannelCloseSummary closed_channel = 2;</code>
     * @return The closedChannel.
     */
    co.anode.anodium.Rpc.ChannelCloseSummary getClosedChannel();

    /**
     * <code>.co.anode.anodium.ChannelPoint active_channel = 3;</code>
     * @return Whether the activeChannel field is set.
     */
    boolean hasActiveChannel();
    /**
     * <code>.co.anode.anodium.ChannelPoint active_channel = 3;</code>
     * @return The activeChannel.
     */
    co.anode.anodium.Rpc.ChannelPoint getActiveChannel();

    /**
     * <code>.co.anode.anodium.ChannelPoint inactive_channel = 4;</code>
     * @return Whether the inactiveChannel field is set.
     */
    boolean hasInactiveChannel();
    /**
     * <code>.co.anode.anodium.ChannelPoint inactive_channel = 4;</code>
     * @return The inactiveChannel.
     */
    co.anode.anodium.Rpc.ChannelPoint getInactiveChannel();

    /**
     * <code>.co.anode.anodium.PendingUpdate pending_open_channel = 6;</code>
     * @return Whether the pendingOpenChannel field is set.
     */
    boolean hasPendingOpenChannel();
    /**
     * <code>.co.anode.anodium.PendingUpdate pending_open_channel = 6;</code>
     * @return The pendingOpenChannel.
     */
    co.anode.anodium.Rpc.PendingUpdate getPendingOpenChannel();

    /**
     * <code>.co.anode.anodium.ChannelEventUpdate.UpdateType type = 5;</code>
     * @return The enum numeric value on the wire for type.
     */
    int getTypeValue();
    /**
     * <code>.co.anode.anodium.ChannelEventUpdate.UpdateType type = 5;</code>
     * @return The type.
     */
    co.anode.anodium.Rpc.ChannelEventUpdate.UpdateType getType();

    public co.anode.anodium.Rpc.ChannelEventUpdate.ChannelCase getChannelCase();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChannelEventUpdate}
   */
  public  static final class ChannelEventUpdate extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelEventUpdate, ChannelEventUpdate.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelEventUpdate)
      ChannelEventUpdateOrBuilder {
    private ChannelEventUpdate() {
    }
    /**
     * Protobuf enum {@code co.anode.anodium.ChannelEventUpdate.UpdateType}
     */
    public enum UpdateType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>OPEN_CHANNEL = 0;</code>
       */
      OPEN_CHANNEL(0),
      /**
       * <code>CLOSED_CHANNEL = 1;</code>
       */
      CLOSED_CHANNEL(1),
      /**
       * <code>ACTIVE_CHANNEL = 2;</code>
       */
      ACTIVE_CHANNEL(2),
      /**
       * <code>INACTIVE_CHANNEL = 3;</code>
       */
      INACTIVE_CHANNEL(3),
      /**
       * <code>PENDING_OPEN_CHANNEL = 4;</code>
       */
      PENDING_OPEN_CHANNEL(4),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>OPEN_CHANNEL = 0;</code>
       */
      public static final int OPEN_CHANNEL_VALUE = 0;
      /**
       * <code>CLOSED_CHANNEL = 1;</code>
       */
      public static final int CLOSED_CHANNEL_VALUE = 1;
      /**
       * <code>ACTIVE_CHANNEL = 2;</code>
       */
      public static final int ACTIVE_CHANNEL_VALUE = 2;
      /**
       * <code>INACTIVE_CHANNEL = 3;</code>
       */
      public static final int INACTIVE_CHANNEL_VALUE = 3;
      /**
       * <code>PENDING_OPEN_CHANNEL = 4;</code>
       */
      public static final int PENDING_OPEN_CHANNEL_VALUE = 4;


      @java.lang.Override
      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static UpdateType valueOf(int value) {
        return forNumber(value);
      }

      public static UpdateType forNumber(int value) {
        switch (value) {
          case 0: return OPEN_CHANNEL;
          case 1: return CLOSED_CHANNEL;
          case 2: return ACTIVE_CHANNEL;
          case 3: return INACTIVE_CHANNEL;
          case 4: return PENDING_OPEN_CHANNEL;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<UpdateType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          UpdateType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<UpdateType>() {
              @java.lang.Override
              public UpdateType findValueByNumber(int number) {
                return UpdateType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return UpdateTypeVerifier.INSTANCE;
      }

      private static final class UpdateTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new UpdateTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return UpdateType.forNumber(number) != null;
              }
            };

      private final int value;

      private UpdateType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:co.anode.anodium.ChannelEventUpdate.UpdateType)
    }

    private int channelCase_ = 0;
    private java.lang.Object channel_;
    public enum ChannelCase {
      OPEN_CHANNEL(1),
      CLOSED_CHANNEL(2),
      ACTIVE_CHANNEL(3),
      INACTIVE_CHANNEL(4),
      PENDING_OPEN_CHANNEL(6),
      CHANNEL_NOT_SET(0);
      private final int value;
      private ChannelCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ChannelCase valueOf(int value) {
        return forNumber(value);
      }

      public static ChannelCase forNumber(int value) {
        switch (value) {
          case 1: return OPEN_CHANNEL;
          case 2: return CLOSED_CHANNEL;
          case 3: return ACTIVE_CHANNEL;
          case 4: return INACTIVE_CHANNEL;
          case 6: return PENDING_OPEN_CHANNEL;
          case 0: return CHANNEL_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    @java.lang.Override
    public ChannelCase
    getChannelCase() {
      return ChannelCase.forNumber(
          channelCase_);
    }

    private void clearChannel() {
      channelCase_ = 0;
      channel_ = null;
    }

    public static final int OPEN_CHANNEL_FIELD_NUMBER = 1;
    /**
     * <code>.co.anode.anodium.Channel open_channel = 1;</code>
     */
    @java.lang.Override
    public boolean hasOpenChannel() {
      return channelCase_ == 1;
    }
    /**
     * <code>.co.anode.anodium.Channel open_channel = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Channel getOpenChannel() {
      if (channelCase_ == 1) {
         return (co.anode.anodium.Rpc.Channel) channel_;
      }
      return co.anode.anodium.Rpc.Channel.getDefaultInstance();
    }
    /**
     * <code>.co.anode.anodium.Channel open_channel = 1;</code>
     */
    private void setOpenChannel(co.anode.anodium.Rpc.Channel value) {
      value.getClass();
  channel_ = value;
      channelCase_ = 1;
    }
    /**
     * <code>.co.anode.anodium.Channel open_channel = 1;</code>
     */
    private void mergeOpenChannel(co.anode.anodium.Rpc.Channel value) {
      value.getClass();
  if (channelCase_ == 1 &&
          channel_ != co.anode.anodium.Rpc.Channel.getDefaultInstance()) {
        channel_ = co.anode.anodium.Rpc.Channel.newBuilder((co.anode.anodium.Rpc.Channel) channel_)
            .mergeFrom(value).buildPartial();
      } else {
        channel_ = value;
      }
      channelCase_ = 1;
    }
    /**
     * <code>.co.anode.anodium.Channel open_channel = 1;</code>
     */
    private void clearOpenChannel() {
      if (channelCase_ == 1) {
        channelCase_ = 0;
        channel_ = null;
      }
    }

    public static final int CLOSED_CHANNEL_FIELD_NUMBER = 2;
    /**
     * <code>.co.anode.anodium.ChannelCloseSummary closed_channel = 2;</code>
     */
    @java.lang.Override
    public boolean hasClosedChannel() {
      return channelCase_ == 2;
    }
    /**
     * <code>.co.anode.anodium.ChannelCloseSummary closed_channel = 2;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelCloseSummary getClosedChannel() {
      if (channelCase_ == 2) {
         return (co.anode.anodium.Rpc.ChannelCloseSummary) channel_;
      }
      return co.anode.anodium.Rpc.ChannelCloseSummary.getDefaultInstance();
    }
    /**
     * <code>.co.anode.anodium.ChannelCloseSummary closed_channel = 2;</code>
     */
    private void setClosedChannel(co.anode.anodium.Rpc.ChannelCloseSummary value) {
      value.getClass();
  channel_ = value;
      channelCase_ = 2;
    }
    /**
     * <code>.co.anode.anodium.ChannelCloseSummary closed_channel = 2;</code>
     */
    private void mergeClosedChannel(co.anode.anodium.Rpc.ChannelCloseSummary value) {
      value.getClass();
  if (channelCase_ == 2 &&
          channel_ != co.anode.anodium.Rpc.ChannelCloseSummary.getDefaultInstance()) {
        channel_ = co.anode.anodium.Rpc.ChannelCloseSummary.newBuilder((co.anode.anodium.Rpc.ChannelCloseSummary) channel_)
            .mergeFrom(value).buildPartial();
      } else {
        channel_ = value;
      }
      channelCase_ = 2;
    }
    /**
     * <code>.co.anode.anodium.ChannelCloseSummary closed_channel = 2;</code>
     */
    private void clearClosedChannel() {
      if (channelCase_ == 2) {
        channelCase_ = 0;
        channel_ = null;
      }
    }

    public static final int ACTIVE_CHANNEL_FIELD_NUMBER = 3;
    /**
     * <code>.co.anode.anodium.ChannelPoint active_channel = 3;</code>
     */
    @java.lang.Override
    public boolean hasActiveChannel() {
      return channelCase_ == 3;
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint active_channel = 3;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelPoint getActiveChannel() {
      if (channelCase_ == 3) {
         return (co.anode.anodium.Rpc.ChannelPoint) channel_;
      }
      return co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance();
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint active_channel = 3;</code>
     */
    private void setActiveChannel(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  channel_ = value;
      channelCase_ = 3;
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint active_channel = 3;</code>
     */
    private void mergeActiveChannel(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  if (channelCase_ == 3 &&
          channel_ != co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance()) {
        channel_ = co.anode.anodium.Rpc.ChannelPoint.newBuilder((co.anode.anodium.Rpc.ChannelPoint) channel_)
            .mergeFrom(value).buildPartial();
      } else {
        channel_ = value;
      }
      channelCase_ = 3;
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint active_channel = 3;</code>
     */
    private void clearActiveChannel() {
      if (channelCase_ == 3) {
        channelCase_ = 0;
        channel_ = null;
      }
    }

    public static final int INACTIVE_CHANNEL_FIELD_NUMBER = 4;
    /**
     * <code>.co.anode.anodium.ChannelPoint inactive_channel = 4;</code>
     */
    @java.lang.Override
    public boolean hasInactiveChannel() {
      return channelCase_ == 4;
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint inactive_channel = 4;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelPoint getInactiveChannel() {
      if (channelCase_ == 4) {
         return (co.anode.anodium.Rpc.ChannelPoint) channel_;
      }
      return co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance();
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint inactive_channel = 4;</code>
     */
    private void setInactiveChannel(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  channel_ = value;
      channelCase_ = 4;
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint inactive_channel = 4;</code>
     */
    private void mergeInactiveChannel(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  if (channelCase_ == 4 &&
          channel_ != co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance()) {
        channel_ = co.anode.anodium.Rpc.ChannelPoint.newBuilder((co.anode.anodium.Rpc.ChannelPoint) channel_)
            .mergeFrom(value).buildPartial();
      } else {
        channel_ = value;
      }
      channelCase_ = 4;
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint inactive_channel = 4;</code>
     */
    private void clearInactiveChannel() {
      if (channelCase_ == 4) {
        channelCase_ = 0;
        channel_ = null;
      }
    }

    public static final int PENDING_OPEN_CHANNEL_FIELD_NUMBER = 6;
    /**
     * <code>.co.anode.anodium.PendingUpdate pending_open_channel = 6;</code>
     */
    @java.lang.Override
    public boolean hasPendingOpenChannel() {
      return channelCase_ == 6;
    }
    /**
     * <code>.co.anode.anodium.PendingUpdate pending_open_channel = 6;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.PendingUpdate getPendingOpenChannel() {
      if (channelCase_ == 6) {
         return (co.anode.anodium.Rpc.PendingUpdate) channel_;
      }
      return co.anode.anodium.Rpc.PendingUpdate.getDefaultInstance();
    }
    /**
     * <code>.co.anode.anodium.PendingUpdate pending_open_channel = 6;</code>
     */
    private void setPendingOpenChannel(co.anode.anodium.Rpc.PendingUpdate value) {
      value.getClass();
  channel_ = value;
      channelCase_ = 6;
    }
    /**
     * <code>.co.anode.anodium.PendingUpdate pending_open_channel = 6;</code>
     */
    private void mergePendingOpenChannel(co.anode.anodium.Rpc.PendingUpdate value) {
      value.getClass();
  if (channelCase_ == 6 &&
          channel_ != co.anode.anodium.Rpc.PendingUpdate.getDefaultInstance()) {
        channel_ = co.anode.anodium.Rpc.PendingUpdate.newBuilder((co.anode.anodium.Rpc.PendingUpdate) channel_)
            .mergeFrom(value).buildPartial();
      } else {
        channel_ = value;
      }
      channelCase_ = 6;
    }
    /**
     * <code>.co.anode.anodium.PendingUpdate pending_open_channel = 6;</code>
     */
    private void clearPendingOpenChannel() {
      if (channelCase_ == 6) {
        channelCase_ = 0;
        channel_ = null;
      }
    }

    public static final int TYPE_FIELD_NUMBER = 5;
    private int type_;
    /**
     * <code>.co.anode.anodium.ChannelEventUpdate.UpdateType type = 5;</code>
     * @return The enum numeric value on the wire for type.
     */
    @java.lang.Override
    public int getTypeValue() {
      return type_;
    }
    /**
     * <code>.co.anode.anodium.ChannelEventUpdate.UpdateType type = 5;</code>
     * @return The type.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelEventUpdate.UpdateType getType() {
      co.anode.anodium.Rpc.ChannelEventUpdate.UpdateType result = co.anode.anodium.Rpc.ChannelEventUpdate.UpdateType.forNumber(type_);
      return result == null ? co.anode.anodium.Rpc.ChannelEventUpdate.UpdateType.UNRECOGNIZED : result;
    }
    /**
     * <code>.co.anode.anodium.ChannelEventUpdate.UpdateType type = 5;</code>
     * @param value The enum numeric value on the wire for type to set.
     */
    private void setTypeValue(int value) {
        type_ = value;
    }
    /**
     * <code>.co.anode.anodium.ChannelEventUpdate.UpdateType type = 5;</code>
     * @param value The type to set.
     */
    private void setType(co.anode.anodium.Rpc.ChannelEventUpdate.UpdateType value) {
      type_ = value.getNumber();
      
    }
    /**
     * <code>.co.anode.anodium.ChannelEventUpdate.UpdateType type = 5;</code>
     */
    private void clearType() {
      
      type_ = 0;
    }

    public static co.anode.anodium.Rpc.ChannelEventUpdate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelEventUpdate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEventUpdate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelEventUpdate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEventUpdate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelEventUpdate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEventUpdate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelEventUpdate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEventUpdate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelEventUpdate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEventUpdate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelEventUpdate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelEventUpdate prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChannelEventUpdate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelEventUpdate, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelEventUpdate)
        co.anode.anodium.Rpc.ChannelEventUpdateOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelEventUpdate.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }

      @java.lang.Override
      public ChannelCase
          getChannelCase() {
        return instance.getChannelCase();
      }

      public Builder clearChannel() {
        copyOnWrite();
        instance.clearChannel();
        return this;
      }


      /**
       * <code>.co.anode.anodium.Channel open_channel = 1;</code>
       */
      @java.lang.Override
      public boolean hasOpenChannel() {
        return instance.hasOpenChannel();
      }
      /**
       * <code>.co.anode.anodium.Channel open_channel = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Channel getOpenChannel() {
        return instance.getOpenChannel();
      }
      /**
       * <code>.co.anode.anodium.Channel open_channel = 1;</code>
       */
      public Builder setOpenChannel(co.anode.anodium.Rpc.Channel value) {
        copyOnWrite();
        instance.setOpenChannel(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.Channel open_channel = 1;</code>
       */
      public Builder setOpenChannel(
          co.anode.anodium.Rpc.Channel.Builder builderForValue) {
        copyOnWrite();
        instance.setOpenChannel(builderForValue.build());
        return this;
      }
      /**
       * <code>.co.anode.anodium.Channel open_channel = 1;</code>
       */
      public Builder mergeOpenChannel(co.anode.anodium.Rpc.Channel value) {
        copyOnWrite();
        instance.mergeOpenChannel(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.Channel open_channel = 1;</code>
       */
      public Builder clearOpenChannel() {
        copyOnWrite();
        instance.clearOpenChannel();
        return this;
      }

      /**
       * <code>.co.anode.anodium.ChannelCloseSummary closed_channel = 2;</code>
       */
      @java.lang.Override
      public boolean hasClosedChannel() {
        return instance.hasClosedChannel();
      }
      /**
       * <code>.co.anode.anodium.ChannelCloseSummary closed_channel = 2;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelCloseSummary getClosedChannel() {
        return instance.getClosedChannel();
      }
      /**
       * <code>.co.anode.anodium.ChannelCloseSummary closed_channel = 2;</code>
       */
      public Builder setClosedChannel(co.anode.anodium.Rpc.ChannelCloseSummary value) {
        copyOnWrite();
        instance.setClosedChannel(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelCloseSummary closed_channel = 2;</code>
       */
      public Builder setClosedChannel(
          co.anode.anodium.Rpc.ChannelCloseSummary.Builder builderForValue) {
        copyOnWrite();
        instance.setClosedChannel(builderForValue.build());
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelCloseSummary closed_channel = 2;</code>
       */
      public Builder mergeClosedChannel(co.anode.anodium.Rpc.ChannelCloseSummary value) {
        copyOnWrite();
        instance.mergeClosedChannel(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelCloseSummary closed_channel = 2;</code>
       */
      public Builder clearClosedChannel() {
        copyOnWrite();
        instance.clearClosedChannel();
        return this;
      }

      /**
       * <code>.co.anode.anodium.ChannelPoint active_channel = 3;</code>
       */
      @java.lang.Override
      public boolean hasActiveChannel() {
        return instance.hasActiveChannel();
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint active_channel = 3;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelPoint getActiveChannel() {
        return instance.getActiveChannel();
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint active_channel = 3;</code>
       */
      public Builder setActiveChannel(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.setActiveChannel(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint active_channel = 3;</code>
       */
      public Builder setActiveChannel(
          co.anode.anodium.Rpc.ChannelPoint.Builder builderForValue) {
        copyOnWrite();
        instance.setActiveChannel(builderForValue.build());
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint active_channel = 3;</code>
       */
      public Builder mergeActiveChannel(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.mergeActiveChannel(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint active_channel = 3;</code>
       */
      public Builder clearActiveChannel() {
        copyOnWrite();
        instance.clearActiveChannel();
        return this;
      }

      /**
       * <code>.co.anode.anodium.ChannelPoint inactive_channel = 4;</code>
       */
      @java.lang.Override
      public boolean hasInactiveChannel() {
        return instance.hasInactiveChannel();
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint inactive_channel = 4;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelPoint getInactiveChannel() {
        return instance.getInactiveChannel();
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint inactive_channel = 4;</code>
       */
      public Builder setInactiveChannel(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.setInactiveChannel(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint inactive_channel = 4;</code>
       */
      public Builder setInactiveChannel(
          co.anode.anodium.Rpc.ChannelPoint.Builder builderForValue) {
        copyOnWrite();
        instance.setInactiveChannel(builderForValue.build());
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint inactive_channel = 4;</code>
       */
      public Builder mergeInactiveChannel(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.mergeInactiveChannel(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint inactive_channel = 4;</code>
       */
      public Builder clearInactiveChannel() {
        copyOnWrite();
        instance.clearInactiveChannel();
        return this;
      }

      /**
       * <code>.co.anode.anodium.PendingUpdate pending_open_channel = 6;</code>
       */
      @java.lang.Override
      public boolean hasPendingOpenChannel() {
        return instance.hasPendingOpenChannel();
      }
      /**
       * <code>.co.anode.anodium.PendingUpdate pending_open_channel = 6;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.PendingUpdate getPendingOpenChannel() {
        return instance.getPendingOpenChannel();
      }
      /**
       * <code>.co.anode.anodium.PendingUpdate pending_open_channel = 6;</code>
       */
      public Builder setPendingOpenChannel(co.anode.anodium.Rpc.PendingUpdate value) {
        copyOnWrite();
        instance.setPendingOpenChannel(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.PendingUpdate pending_open_channel = 6;</code>
       */
      public Builder setPendingOpenChannel(
          co.anode.anodium.Rpc.PendingUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.setPendingOpenChannel(builderForValue.build());
        return this;
      }
      /**
       * <code>.co.anode.anodium.PendingUpdate pending_open_channel = 6;</code>
       */
      public Builder mergePendingOpenChannel(co.anode.anodium.Rpc.PendingUpdate value) {
        copyOnWrite();
        instance.mergePendingOpenChannel(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.PendingUpdate pending_open_channel = 6;</code>
       */
      public Builder clearPendingOpenChannel() {
        copyOnWrite();
        instance.clearPendingOpenChannel();
        return this;
      }

      /**
       * <code>.co.anode.anodium.ChannelEventUpdate.UpdateType type = 5;</code>
       * @return The enum numeric value on the wire for type.
       */
      @java.lang.Override
      public int getTypeValue() {
        return instance.getTypeValue();
      }
      /**
       * <code>.co.anode.anodium.ChannelEventUpdate.UpdateType type = 5;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeValue(int value) {
        copyOnWrite();
        instance.setTypeValue(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelEventUpdate.UpdateType type = 5;</code>
       * @return The type.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelEventUpdate.UpdateType getType() {
        return instance.getType();
      }
      /**
       * <code>.co.anode.anodium.ChannelEventUpdate.UpdateType type = 5;</code>
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setType(co.anode.anodium.Rpc.ChannelEventUpdate.UpdateType value) {
        copyOnWrite();
        instance.setType(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelEventUpdate.UpdateType type = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        copyOnWrite();
        instance.clearType();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelEventUpdate)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelEventUpdate();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "channel_",
              "channelCase_",
              co.anode.anodium.Rpc.Channel.class,
              co.anode.anodium.Rpc.ChannelCloseSummary.class,
              co.anode.anodium.Rpc.ChannelPoint.class,
              co.anode.anodium.Rpc.ChannelPoint.class,
              "type_",
              co.anode.anodium.Rpc.PendingUpdate.class,
            };
            java.lang.String info =
                "\u0000\u0006\u0001\u0000\u0001\u0006\u0006\u0000\u0000\u0000\u0001<\u0000\u0002<" +
                "\u0000\u0003<\u0000\u0004<\u0000\u0005\f\u0006<\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelEventUpdate> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelEventUpdate.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelEventUpdate>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelEventUpdate)
    private static final co.anode.anodium.Rpc.ChannelEventUpdate DEFAULT_INSTANCE;
    static {
      ChannelEventUpdate defaultInstance = new ChannelEventUpdate();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelEventUpdate.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelEventUpdate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelEventUpdate> PARSER;

    public static com.google.protobuf.Parser<ChannelEventUpdate> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface WalletBalanceRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.WalletBalanceRequest)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.WalletBalanceRequest}
   */
  public  static final class WalletBalanceRequest extends
      com.google.protobuf.GeneratedMessageLite<
          WalletBalanceRequest, WalletBalanceRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.WalletBalanceRequest)
      WalletBalanceRequestOrBuilder {
    private WalletBalanceRequest() {
    }
    public static co.anode.anodium.Rpc.WalletBalanceRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.WalletBalanceRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.WalletBalanceRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.WalletBalanceRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.WalletBalanceRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.WalletBalanceRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.WalletBalanceRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.WalletBalanceRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.WalletBalanceRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.WalletBalanceRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.WalletBalanceRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.WalletBalanceRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.WalletBalanceRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.WalletBalanceRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.WalletBalanceRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.WalletBalanceRequest)
        co.anode.anodium.Rpc.WalletBalanceRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.WalletBalanceRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.WalletBalanceRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.WalletBalanceRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.WalletBalanceRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.WalletBalanceRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.WalletBalanceRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.WalletBalanceRequest)
    private static final co.anode.anodium.Rpc.WalletBalanceRequest DEFAULT_INSTANCE;
    static {
      WalletBalanceRequest defaultInstance = new WalletBalanceRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        WalletBalanceRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.WalletBalanceRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<WalletBalanceRequest> PARSER;

    public static com.google.protobuf.Parser<WalletBalanceRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface WalletBalanceResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.WalletBalanceResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The balance of the wallet
     * </pre>
     *
     * <code>int64 total_balance = 1;</code>
     * @return The totalBalance.
     */
    long getTotalBalance();

    /**
     * <pre>
     * The confirmed balance of a wallet(with &gt;= 1 confirmations)
     * </pre>
     *
     * <code>int64 confirmed_balance = 2;</code>
     * @return The confirmedBalance.
     */
    long getConfirmedBalance();

    /**
     * <pre>
     * The unconfirmed balance of a wallet(with 0 confirmations)
     * </pre>
     *
     * <code>int64 unconfirmed_balance = 3;</code>
     * @return The unconfirmedBalance.
     */
    long getUnconfirmedBalance();
  }
  /**
   * Protobuf type {@code co.anode.anodium.WalletBalanceResponse}
   */
  public  static final class WalletBalanceResponse extends
      com.google.protobuf.GeneratedMessageLite<
          WalletBalanceResponse, WalletBalanceResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.WalletBalanceResponse)
      WalletBalanceResponseOrBuilder {
    private WalletBalanceResponse() {
    }
    public static final int TOTAL_BALANCE_FIELD_NUMBER = 1;
    private long totalBalance_;
    /**
     * <pre>
     * The balance of the wallet
     * </pre>
     *
     * <code>int64 total_balance = 1;</code>
     * @return The totalBalance.
     */
    @java.lang.Override
    public long getTotalBalance() {
      return totalBalance_;
    }
    /**
     * <pre>
     * The balance of the wallet
     * </pre>
     *
     * <code>int64 total_balance = 1;</code>
     * @param value The totalBalance to set.
     */
    private void setTotalBalance(long value) {
      
      totalBalance_ = value;
    }
    /**
     * <pre>
     * The balance of the wallet
     * </pre>
     *
     * <code>int64 total_balance = 1;</code>
     */
    private void clearTotalBalance() {
      
      totalBalance_ = 0L;
    }

    public static final int CONFIRMED_BALANCE_FIELD_NUMBER = 2;
    private long confirmedBalance_;
    /**
     * <pre>
     * The confirmed balance of a wallet(with &gt;= 1 confirmations)
     * </pre>
     *
     * <code>int64 confirmed_balance = 2;</code>
     * @return The confirmedBalance.
     */
    @java.lang.Override
    public long getConfirmedBalance() {
      return confirmedBalance_;
    }
    /**
     * <pre>
     * The confirmed balance of a wallet(with &gt;= 1 confirmations)
     * </pre>
     *
     * <code>int64 confirmed_balance = 2;</code>
     * @param value The confirmedBalance to set.
     */
    private void setConfirmedBalance(long value) {
      
      confirmedBalance_ = value;
    }
    /**
     * <pre>
     * The confirmed balance of a wallet(with &gt;= 1 confirmations)
     * </pre>
     *
     * <code>int64 confirmed_balance = 2;</code>
     */
    private void clearConfirmedBalance() {
      
      confirmedBalance_ = 0L;
    }

    public static final int UNCONFIRMED_BALANCE_FIELD_NUMBER = 3;
    private long unconfirmedBalance_;
    /**
     * <pre>
     * The unconfirmed balance of a wallet(with 0 confirmations)
     * </pre>
     *
     * <code>int64 unconfirmed_balance = 3;</code>
     * @return The unconfirmedBalance.
     */
    @java.lang.Override
    public long getUnconfirmedBalance() {
      return unconfirmedBalance_;
    }
    /**
     * <pre>
     * The unconfirmed balance of a wallet(with 0 confirmations)
     * </pre>
     *
     * <code>int64 unconfirmed_balance = 3;</code>
     * @param value The unconfirmedBalance to set.
     */
    private void setUnconfirmedBalance(long value) {
      
      unconfirmedBalance_ = value;
    }
    /**
     * <pre>
     * The unconfirmed balance of a wallet(with 0 confirmations)
     * </pre>
     *
     * <code>int64 unconfirmed_balance = 3;</code>
     */
    private void clearUnconfirmedBalance() {
      
      unconfirmedBalance_ = 0L;
    }

    public static co.anode.anodium.Rpc.WalletBalanceResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.WalletBalanceResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.WalletBalanceResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.WalletBalanceResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.WalletBalanceResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.WalletBalanceResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.WalletBalanceResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.WalletBalanceResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.WalletBalanceResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.WalletBalanceResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.WalletBalanceResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.WalletBalanceResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.WalletBalanceResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.WalletBalanceResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.WalletBalanceResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.WalletBalanceResponse)
        co.anode.anodium.Rpc.WalletBalanceResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.WalletBalanceResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The balance of the wallet
       * </pre>
       *
       * <code>int64 total_balance = 1;</code>
       * @return The totalBalance.
       */
      @java.lang.Override
      public long getTotalBalance() {
        return instance.getTotalBalance();
      }
      /**
       * <pre>
       * The balance of the wallet
       * </pre>
       *
       * <code>int64 total_balance = 1;</code>
       * @param value The totalBalance to set.
       * @return This builder for chaining.
       */
      public Builder setTotalBalance(long value) {
        copyOnWrite();
        instance.setTotalBalance(value);
        return this;
      }
      /**
       * <pre>
       * The balance of the wallet
       * </pre>
       *
       * <code>int64 total_balance = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTotalBalance() {
        copyOnWrite();
        instance.clearTotalBalance();
        return this;
      }

      /**
       * <pre>
       * The confirmed balance of a wallet(with &gt;= 1 confirmations)
       * </pre>
       *
       * <code>int64 confirmed_balance = 2;</code>
       * @return The confirmedBalance.
       */
      @java.lang.Override
      public long getConfirmedBalance() {
        return instance.getConfirmedBalance();
      }
      /**
       * <pre>
       * The confirmed balance of a wallet(with &gt;= 1 confirmations)
       * </pre>
       *
       * <code>int64 confirmed_balance = 2;</code>
       * @param value The confirmedBalance to set.
       * @return This builder for chaining.
       */
      public Builder setConfirmedBalance(long value) {
        copyOnWrite();
        instance.setConfirmedBalance(value);
        return this;
      }
      /**
       * <pre>
       * The confirmed balance of a wallet(with &gt;= 1 confirmations)
       * </pre>
       *
       * <code>int64 confirmed_balance = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearConfirmedBalance() {
        copyOnWrite();
        instance.clearConfirmedBalance();
        return this;
      }

      /**
       * <pre>
       * The unconfirmed balance of a wallet(with 0 confirmations)
       * </pre>
       *
       * <code>int64 unconfirmed_balance = 3;</code>
       * @return The unconfirmedBalance.
       */
      @java.lang.Override
      public long getUnconfirmedBalance() {
        return instance.getUnconfirmedBalance();
      }
      /**
       * <pre>
       * The unconfirmed balance of a wallet(with 0 confirmations)
       * </pre>
       *
       * <code>int64 unconfirmed_balance = 3;</code>
       * @param value The unconfirmedBalance to set.
       * @return This builder for chaining.
       */
      public Builder setUnconfirmedBalance(long value) {
        copyOnWrite();
        instance.setUnconfirmedBalance(value);
        return this;
      }
      /**
       * <pre>
       * The unconfirmed balance of a wallet(with 0 confirmations)
       * </pre>
       *
       * <code>int64 unconfirmed_balance = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearUnconfirmedBalance() {
        copyOnWrite();
        instance.clearUnconfirmedBalance();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.WalletBalanceResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.WalletBalanceResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "totalBalance_",
              "confirmedBalance_",
              "unconfirmedBalance_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0003\u0003\u0000\u0000\u0000\u0001\u0002\u0002\u0002" +
                "\u0003\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.WalletBalanceResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.WalletBalanceResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.WalletBalanceResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.WalletBalanceResponse)
    private static final co.anode.anodium.Rpc.WalletBalanceResponse DEFAULT_INSTANCE;
    static {
      WalletBalanceResponse defaultInstance = new WalletBalanceResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        WalletBalanceResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.WalletBalanceResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<WalletBalanceResponse> PARSER;

    public static com.google.protobuf.Parser<WalletBalanceResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface GetAddressBalancesRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.GetAddressBalancesRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Minimum number of confirmations for coins to be considered received                                                                                                                                 
     * </pre>
     *
     * <code>int32 minconf = 1;</code>
     * @return The minconf.
     */
    int getMinconf();

    /**
     * <pre>
     * If true then addresses which have been created but carry zero balance will be included
     * </pre>
     *
     * <code>bool showzerobalance = 2;</code>
     * @return The showzerobalance.
     */
    boolean getShowzerobalance();
  }
  /**
   * Protobuf type {@code co.anode.anodium.GetAddressBalancesRequest}
   */
  public  static final class GetAddressBalancesRequest extends
      com.google.protobuf.GeneratedMessageLite<
          GetAddressBalancesRequest, GetAddressBalancesRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.GetAddressBalancesRequest)
      GetAddressBalancesRequestOrBuilder {
    private GetAddressBalancesRequest() {
    }
    public static final int MINCONF_FIELD_NUMBER = 1;
    private int minconf_;
    /**
     * <pre>
     * Minimum number of confirmations for coins to be considered received                                                                                                                                 
     * </pre>
     *
     * <code>int32 minconf = 1;</code>
     * @return The minconf.
     */
    @java.lang.Override
    public int getMinconf() {
      return minconf_;
    }
    /**
     * <pre>
     * Minimum number of confirmations for coins to be considered received                                                                                                                                 
     * </pre>
     *
     * <code>int32 minconf = 1;</code>
     * @param value The minconf to set.
     */
    private void setMinconf(int value) {
      
      minconf_ = value;
    }
    /**
     * <pre>
     * Minimum number of confirmations for coins to be considered received                                                                                                                                 
     * </pre>
     *
     * <code>int32 minconf = 1;</code>
     */
    private void clearMinconf() {
      
      minconf_ = 0;
    }

    public static final int SHOWZEROBALANCE_FIELD_NUMBER = 2;
    private boolean showzerobalance_;
    /**
     * <pre>
     * If true then addresses which have been created but carry zero balance will be included
     * </pre>
     *
     * <code>bool showzerobalance = 2;</code>
     * @return The showzerobalance.
     */
    @java.lang.Override
    public boolean getShowzerobalance() {
      return showzerobalance_;
    }
    /**
     * <pre>
     * If true then addresses which have been created but carry zero balance will be included
     * </pre>
     *
     * <code>bool showzerobalance = 2;</code>
     * @param value The showzerobalance to set.
     */
    private void setShowzerobalance(boolean value) {
      
      showzerobalance_ = value;
    }
    /**
     * <pre>
     * If true then addresses which have been created but carry zero balance will be included
     * </pre>
     *
     * <code>bool showzerobalance = 2;</code>
     */
    private void clearShowzerobalance() {
      
      showzerobalance_ = false;
    }

    public static co.anode.anodium.Rpc.GetAddressBalancesRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.GetAddressBalancesRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.GetAddressBalancesRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.GetAddressBalancesRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.GetAddressBalancesRequest)
        co.anode.anodium.Rpc.GetAddressBalancesRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.GetAddressBalancesRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Minimum number of confirmations for coins to be considered received                                                                                                                                 
       * </pre>
       *
       * <code>int32 minconf = 1;</code>
       * @return The minconf.
       */
      @java.lang.Override
      public int getMinconf() {
        return instance.getMinconf();
      }
      /**
       * <pre>
       * Minimum number of confirmations for coins to be considered received                                                                                                                                 
       * </pre>
       *
       * <code>int32 minconf = 1;</code>
       * @param value The minconf to set.
       * @return This builder for chaining.
       */
      public Builder setMinconf(int value) {
        copyOnWrite();
        instance.setMinconf(value);
        return this;
      }
      /**
       * <pre>
       * Minimum number of confirmations for coins to be considered received                                                                                                                                 
       * </pre>
       *
       * <code>int32 minconf = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinconf() {
        copyOnWrite();
        instance.clearMinconf();
        return this;
      }

      /**
       * <pre>
       * If true then addresses which have been created but carry zero balance will be included
       * </pre>
       *
       * <code>bool showzerobalance = 2;</code>
       * @return The showzerobalance.
       */
      @java.lang.Override
      public boolean getShowzerobalance() {
        return instance.getShowzerobalance();
      }
      /**
       * <pre>
       * If true then addresses which have been created but carry zero balance will be included
       * </pre>
       *
       * <code>bool showzerobalance = 2;</code>
       * @param value The showzerobalance to set.
       * @return This builder for chaining.
       */
      public Builder setShowzerobalance(boolean value) {
        copyOnWrite();
        instance.setShowzerobalance(value);
        return this;
      }
      /**
       * <pre>
       * If true then addresses which have been created but carry zero balance will be included
       * </pre>
       *
       * <code>bool showzerobalance = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearShowzerobalance() {
        copyOnWrite();
        instance.clearShowzerobalance();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.GetAddressBalancesRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.GetAddressBalancesRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "minconf_",
              "showzerobalance_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0004\u0002\u0007" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.GetAddressBalancesRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.GetAddressBalancesRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.GetAddressBalancesRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.GetAddressBalancesRequest)
    private static final co.anode.anodium.Rpc.GetAddressBalancesRequest DEFAULT_INSTANCE;
    static {
      GetAddressBalancesRequest defaultInstance = new GetAddressBalancesRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        GetAddressBalancesRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.GetAddressBalancesRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<GetAddressBalancesRequest> PARSER;

    public static com.google.protobuf.Parser<GetAddressBalancesRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface GetAddressBalancesResponseAddrOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.GetAddressBalancesResponseAddr)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The address which has this balance
     * </pre>
     *
     * <code>string address = 1;</code>
     * @return The address.
     */
    java.lang.String getAddress();
    /**
     * <pre>
     * The address which has this balance
     * </pre>
     *
     * <code>string address = 1;</code>
     * @return The bytes for address.
     */
    com.google.protobuf.ByteString
        getAddressBytes();

    /**
     * <pre>
     * Total balance in coins
     * </pre>
     *
     * <code>double total = 2;</code>
     * @return The total.
     */
    double getTotal();

    /**
     * <pre>
     * Total balance (atomic units)
     * </pre>
     *
     * <code>int64 stotal = 3;</code>
     * @return The stotal.
     */
    long getStotal();

    /**
     * <pre>
     * Balance which is currently spendable (coins)
     * </pre>
     *
     * <code>double spendable = 4;</code>
     * @return The spendable.
     */
    double getSpendable();

    /**
     * <pre>
     * Balance which is currently spendable (atomic units)
     * </pre>
     *
     * <code>int64 sspendable = 5;</code>
     * @return The sspendable.
     */
    long getSspendable();

    /**
     * <pre>
     * Mined coins which have not yet matured (coins)
     * </pre>
     *
     * <code>double immaturereward = 6;</code>
     * @return The immaturereward.
     */
    double getImmaturereward();

    /**
     * <pre>
     * Mined coins which have not yet matured (atomic units)
     * </pre>
     *
     * <code>int64 simmaturereward = 7;</code>
     * @return The simmaturereward.
     */
    long getSimmaturereward();

    /**
     * <pre>
     * Unconfirmed balance in coins
     * </pre>
     *
     * <code>double unconfirmed = 8;</code>
     * @return The unconfirmed.
     */
    double getUnconfirmed();

    /**
     * <pre>
     * Unconfirmed balance in atomic units
     * </pre>
     *
     * <code>int64 sunconfirmed = 9;</code>
     * @return The sunconfirmed.
     */
    long getSunconfirmed();

    /**
     * <pre>
     * The number of transaction outputs which make up the balance
     * </pre>
     *
     * <code>int32 outputcount = 10;</code>
     * @return The outputcount.
     */
    int getOutputcount();
  }
  /**
   * Protobuf type {@code co.anode.anodium.GetAddressBalancesResponseAddr}
   */
  public  static final class GetAddressBalancesResponseAddr extends
      com.google.protobuf.GeneratedMessageLite<
          GetAddressBalancesResponseAddr, GetAddressBalancesResponseAddr.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.GetAddressBalancesResponseAddr)
      GetAddressBalancesResponseAddrOrBuilder {
    private GetAddressBalancesResponseAddr() {
      address_ = "";
    }
    public static final int ADDRESS_FIELD_NUMBER = 1;
    private java.lang.String address_;
    /**
     * <pre>
     * The address which has this balance
     * </pre>
     *
     * <code>string address = 1;</code>
     * @return The address.
     */
    @java.lang.Override
    public java.lang.String getAddress() {
      return address_;
    }
    /**
     * <pre>
     * The address which has this balance
     * </pre>
     *
     * <code>string address = 1;</code>
     * @return The bytes for address.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAddressBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(address_);
    }
    /**
     * <pre>
     * The address which has this balance
     * </pre>
     *
     * <code>string address = 1;</code>
     * @param value The address to set.
     */
    private void setAddress(
        java.lang.String value) {
      value.getClass();
  
      address_ = value;
    }
    /**
     * <pre>
     * The address which has this balance
     * </pre>
     *
     * <code>string address = 1;</code>
     */
    private void clearAddress() {
      
      address_ = getDefaultInstance().getAddress();
    }
    /**
     * <pre>
     * The address which has this balance
     * </pre>
     *
     * <code>string address = 1;</code>
     * @param value The bytes for address to set.
     */
    private void setAddressBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      address_ = value.toStringUtf8();
      
    }

    public static final int TOTAL_FIELD_NUMBER = 2;
    private double total_;
    /**
     * <pre>
     * Total balance in coins
     * </pre>
     *
     * <code>double total = 2;</code>
     * @return The total.
     */
    @java.lang.Override
    public double getTotal() {
      return total_;
    }
    /**
     * <pre>
     * Total balance in coins
     * </pre>
     *
     * <code>double total = 2;</code>
     * @param value The total to set.
     */
    private void setTotal(double value) {
      
      total_ = value;
    }
    /**
     * <pre>
     * Total balance in coins
     * </pre>
     *
     * <code>double total = 2;</code>
     */
    private void clearTotal() {
      
      total_ = 0D;
    }

    public static final int STOTAL_FIELD_NUMBER = 3;
    private long stotal_;
    /**
     * <pre>
     * Total balance (atomic units)
     * </pre>
     *
     * <code>int64 stotal = 3;</code>
     * @return The stotal.
     */
    @java.lang.Override
    public long getStotal() {
      return stotal_;
    }
    /**
     * <pre>
     * Total balance (atomic units)
     * </pre>
     *
     * <code>int64 stotal = 3;</code>
     * @param value The stotal to set.
     */
    private void setStotal(long value) {
      
      stotal_ = value;
    }
    /**
     * <pre>
     * Total balance (atomic units)
     * </pre>
     *
     * <code>int64 stotal = 3;</code>
     */
    private void clearStotal() {
      
      stotal_ = 0L;
    }

    public static final int SPENDABLE_FIELD_NUMBER = 4;
    private double spendable_;
    /**
     * <pre>
     * Balance which is currently spendable (coins)
     * </pre>
     *
     * <code>double spendable = 4;</code>
     * @return The spendable.
     */
    @java.lang.Override
    public double getSpendable() {
      return spendable_;
    }
    /**
     * <pre>
     * Balance which is currently spendable (coins)
     * </pre>
     *
     * <code>double spendable = 4;</code>
     * @param value The spendable to set.
     */
    private void setSpendable(double value) {
      
      spendable_ = value;
    }
    /**
     * <pre>
     * Balance which is currently spendable (coins)
     * </pre>
     *
     * <code>double spendable = 4;</code>
     */
    private void clearSpendable() {
      
      spendable_ = 0D;
    }

    public static final int SSPENDABLE_FIELD_NUMBER = 5;
    private long sspendable_;
    /**
     * <pre>
     * Balance which is currently spendable (atomic units)
     * </pre>
     *
     * <code>int64 sspendable = 5;</code>
     * @return The sspendable.
     */
    @java.lang.Override
    public long getSspendable() {
      return sspendable_;
    }
    /**
     * <pre>
     * Balance which is currently spendable (atomic units)
     * </pre>
     *
     * <code>int64 sspendable = 5;</code>
     * @param value The sspendable to set.
     */
    private void setSspendable(long value) {
      
      sspendable_ = value;
    }
    /**
     * <pre>
     * Balance which is currently spendable (atomic units)
     * </pre>
     *
     * <code>int64 sspendable = 5;</code>
     */
    private void clearSspendable() {
      
      sspendable_ = 0L;
    }

    public static final int IMMATUREREWARD_FIELD_NUMBER = 6;
    private double immaturereward_;
    /**
     * <pre>
     * Mined coins which have not yet matured (coins)
     * </pre>
     *
     * <code>double immaturereward = 6;</code>
     * @return The immaturereward.
     */
    @java.lang.Override
    public double getImmaturereward() {
      return immaturereward_;
    }
    /**
     * <pre>
     * Mined coins which have not yet matured (coins)
     * </pre>
     *
     * <code>double immaturereward = 6;</code>
     * @param value The immaturereward to set.
     */
    private void setImmaturereward(double value) {
      
      immaturereward_ = value;
    }
    /**
     * <pre>
     * Mined coins which have not yet matured (coins)
     * </pre>
     *
     * <code>double immaturereward = 6;</code>
     */
    private void clearImmaturereward() {
      
      immaturereward_ = 0D;
    }

    public static final int SIMMATUREREWARD_FIELD_NUMBER = 7;
    private long simmaturereward_;
    /**
     * <pre>
     * Mined coins which have not yet matured (atomic units)
     * </pre>
     *
     * <code>int64 simmaturereward = 7;</code>
     * @return The simmaturereward.
     */
    @java.lang.Override
    public long getSimmaturereward() {
      return simmaturereward_;
    }
    /**
     * <pre>
     * Mined coins which have not yet matured (atomic units)
     * </pre>
     *
     * <code>int64 simmaturereward = 7;</code>
     * @param value The simmaturereward to set.
     */
    private void setSimmaturereward(long value) {
      
      simmaturereward_ = value;
    }
    /**
     * <pre>
     * Mined coins which have not yet matured (atomic units)
     * </pre>
     *
     * <code>int64 simmaturereward = 7;</code>
     */
    private void clearSimmaturereward() {
      
      simmaturereward_ = 0L;
    }

    public static final int UNCONFIRMED_FIELD_NUMBER = 8;
    private double unconfirmed_;
    /**
     * <pre>
     * Unconfirmed balance in coins
     * </pre>
     *
     * <code>double unconfirmed = 8;</code>
     * @return The unconfirmed.
     */
    @java.lang.Override
    public double getUnconfirmed() {
      return unconfirmed_;
    }
    /**
     * <pre>
     * Unconfirmed balance in coins
     * </pre>
     *
     * <code>double unconfirmed = 8;</code>
     * @param value The unconfirmed to set.
     */
    private void setUnconfirmed(double value) {
      
      unconfirmed_ = value;
    }
    /**
     * <pre>
     * Unconfirmed balance in coins
     * </pre>
     *
     * <code>double unconfirmed = 8;</code>
     */
    private void clearUnconfirmed() {
      
      unconfirmed_ = 0D;
    }

    public static final int SUNCONFIRMED_FIELD_NUMBER = 9;
    private long sunconfirmed_;
    /**
     * <pre>
     * Unconfirmed balance in atomic units
     * </pre>
     *
     * <code>int64 sunconfirmed = 9;</code>
     * @return The sunconfirmed.
     */
    @java.lang.Override
    public long getSunconfirmed() {
      return sunconfirmed_;
    }
    /**
     * <pre>
     * Unconfirmed balance in atomic units
     * </pre>
     *
     * <code>int64 sunconfirmed = 9;</code>
     * @param value The sunconfirmed to set.
     */
    private void setSunconfirmed(long value) {
      
      sunconfirmed_ = value;
    }
    /**
     * <pre>
     * Unconfirmed balance in atomic units
     * </pre>
     *
     * <code>int64 sunconfirmed = 9;</code>
     */
    private void clearSunconfirmed() {
      
      sunconfirmed_ = 0L;
    }

    public static final int OUTPUTCOUNT_FIELD_NUMBER = 10;
    private int outputcount_;
    /**
     * <pre>
     * The number of transaction outputs which make up the balance
     * </pre>
     *
     * <code>int32 outputcount = 10;</code>
     * @return The outputcount.
     */
    @java.lang.Override
    public int getOutputcount() {
      return outputcount_;
    }
    /**
     * <pre>
     * The number of transaction outputs which make up the balance
     * </pre>
     *
     * <code>int32 outputcount = 10;</code>
     * @param value The outputcount to set.
     */
    private void setOutputcount(int value) {
      
      outputcount_ = value;
    }
    /**
     * <pre>
     * The number of transaction outputs which make up the balance
     * </pre>
     *
     * <code>int32 outputcount = 10;</code>
     */
    private void clearOutputcount() {
      
      outputcount_ = 0;
    }

    public static co.anode.anodium.Rpc.GetAddressBalancesResponseAddr parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponseAddr parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponseAddr parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponseAddr parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponseAddr parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponseAddr parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponseAddr parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponseAddr parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponseAddr parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponseAddr parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponseAddr parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponseAddr parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.GetAddressBalancesResponseAddr prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.GetAddressBalancesResponseAddr}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.GetAddressBalancesResponseAddr, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.GetAddressBalancesResponseAddr)
        co.anode.anodium.Rpc.GetAddressBalancesResponseAddrOrBuilder {
      // Construct using co.anode.anodium.Rpc.GetAddressBalancesResponseAddr.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The address which has this balance
       * </pre>
       *
       * <code>string address = 1;</code>
       * @return The address.
       */
      @java.lang.Override
      public java.lang.String getAddress() {
        return instance.getAddress();
      }
      /**
       * <pre>
       * The address which has this balance
       * </pre>
       *
       * <code>string address = 1;</code>
       * @return The bytes for address.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getAddressBytes() {
        return instance.getAddressBytes();
      }
      /**
       * <pre>
       * The address which has this balance
       * </pre>
       *
       * <code>string address = 1;</code>
       * @param value The address to set.
       * @return This builder for chaining.
       */
      public Builder setAddress(
          java.lang.String value) {
        copyOnWrite();
        instance.setAddress(value);
        return this;
      }
      /**
       * <pre>
       * The address which has this balance
       * </pre>
       *
       * <code>string address = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAddress() {
        copyOnWrite();
        instance.clearAddress();
        return this;
      }
      /**
       * <pre>
       * The address which has this balance
       * </pre>
       *
       * <code>string address = 1;</code>
       * @param value The bytes for address to set.
       * @return This builder for chaining.
       */
      public Builder setAddressBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setAddressBytes(value);
        return this;
      }

      /**
       * <pre>
       * Total balance in coins
       * </pre>
       *
       * <code>double total = 2;</code>
       * @return The total.
       */
      @java.lang.Override
      public double getTotal() {
        return instance.getTotal();
      }
      /**
       * <pre>
       * Total balance in coins
       * </pre>
       *
       * <code>double total = 2;</code>
       * @param value The total to set.
       * @return This builder for chaining.
       */
      public Builder setTotal(double value) {
        copyOnWrite();
        instance.setTotal(value);
        return this;
      }
      /**
       * <pre>
       * Total balance in coins
       * </pre>
       *
       * <code>double total = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearTotal() {
        copyOnWrite();
        instance.clearTotal();
        return this;
      }

      /**
       * <pre>
       * Total balance (atomic units)
       * </pre>
       *
       * <code>int64 stotal = 3;</code>
       * @return The stotal.
       */
      @java.lang.Override
      public long getStotal() {
        return instance.getStotal();
      }
      /**
       * <pre>
       * Total balance (atomic units)
       * </pre>
       *
       * <code>int64 stotal = 3;</code>
       * @param value The stotal to set.
       * @return This builder for chaining.
       */
      public Builder setStotal(long value) {
        copyOnWrite();
        instance.setStotal(value);
        return this;
      }
      /**
       * <pre>
       * Total balance (atomic units)
       * </pre>
       *
       * <code>int64 stotal = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearStotal() {
        copyOnWrite();
        instance.clearStotal();
        return this;
      }

      /**
       * <pre>
       * Balance which is currently spendable (coins)
       * </pre>
       *
       * <code>double spendable = 4;</code>
       * @return The spendable.
       */
      @java.lang.Override
      public double getSpendable() {
        return instance.getSpendable();
      }
      /**
       * <pre>
       * Balance which is currently spendable (coins)
       * </pre>
       *
       * <code>double spendable = 4;</code>
       * @param value The spendable to set.
       * @return This builder for chaining.
       */
      public Builder setSpendable(double value) {
        copyOnWrite();
        instance.setSpendable(value);
        return this;
      }
      /**
       * <pre>
       * Balance which is currently spendable (coins)
       * </pre>
       *
       * <code>double spendable = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearSpendable() {
        copyOnWrite();
        instance.clearSpendable();
        return this;
      }

      /**
       * <pre>
       * Balance which is currently spendable (atomic units)
       * </pre>
       *
       * <code>int64 sspendable = 5;</code>
       * @return The sspendable.
       */
      @java.lang.Override
      public long getSspendable() {
        return instance.getSspendable();
      }
      /**
       * <pre>
       * Balance which is currently spendable (atomic units)
       * </pre>
       *
       * <code>int64 sspendable = 5;</code>
       * @param value The sspendable to set.
       * @return This builder for chaining.
       */
      public Builder setSspendable(long value) {
        copyOnWrite();
        instance.setSspendable(value);
        return this;
      }
      /**
       * <pre>
       * Balance which is currently spendable (atomic units)
       * </pre>
       *
       * <code>int64 sspendable = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearSspendable() {
        copyOnWrite();
        instance.clearSspendable();
        return this;
      }

      /**
       * <pre>
       * Mined coins which have not yet matured (coins)
       * </pre>
       *
       * <code>double immaturereward = 6;</code>
       * @return The immaturereward.
       */
      @java.lang.Override
      public double getImmaturereward() {
        return instance.getImmaturereward();
      }
      /**
       * <pre>
       * Mined coins which have not yet matured (coins)
       * </pre>
       *
       * <code>double immaturereward = 6;</code>
       * @param value The immaturereward to set.
       * @return This builder for chaining.
       */
      public Builder setImmaturereward(double value) {
        copyOnWrite();
        instance.setImmaturereward(value);
        return this;
      }
      /**
       * <pre>
       * Mined coins which have not yet matured (coins)
       * </pre>
       *
       * <code>double immaturereward = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearImmaturereward() {
        copyOnWrite();
        instance.clearImmaturereward();
        return this;
      }

      /**
       * <pre>
       * Mined coins which have not yet matured (atomic units)
       * </pre>
       *
       * <code>int64 simmaturereward = 7;</code>
       * @return The simmaturereward.
       */
      @java.lang.Override
      public long getSimmaturereward() {
        return instance.getSimmaturereward();
      }
      /**
       * <pre>
       * Mined coins which have not yet matured (atomic units)
       * </pre>
       *
       * <code>int64 simmaturereward = 7;</code>
       * @param value The simmaturereward to set.
       * @return This builder for chaining.
       */
      public Builder setSimmaturereward(long value) {
        copyOnWrite();
        instance.setSimmaturereward(value);
        return this;
      }
      /**
       * <pre>
       * Mined coins which have not yet matured (atomic units)
       * </pre>
       *
       * <code>int64 simmaturereward = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearSimmaturereward() {
        copyOnWrite();
        instance.clearSimmaturereward();
        return this;
      }

      /**
       * <pre>
       * Unconfirmed balance in coins
       * </pre>
       *
       * <code>double unconfirmed = 8;</code>
       * @return The unconfirmed.
       */
      @java.lang.Override
      public double getUnconfirmed() {
        return instance.getUnconfirmed();
      }
      /**
       * <pre>
       * Unconfirmed balance in coins
       * </pre>
       *
       * <code>double unconfirmed = 8;</code>
       * @param value The unconfirmed to set.
       * @return This builder for chaining.
       */
      public Builder setUnconfirmed(double value) {
        copyOnWrite();
        instance.setUnconfirmed(value);
        return this;
      }
      /**
       * <pre>
       * Unconfirmed balance in coins
       * </pre>
       *
       * <code>double unconfirmed = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearUnconfirmed() {
        copyOnWrite();
        instance.clearUnconfirmed();
        return this;
      }

      /**
       * <pre>
       * Unconfirmed balance in atomic units
       * </pre>
       *
       * <code>int64 sunconfirmed = 9;</code>
       * @return The sunconfirmed.
       */
      @java.lang.Override
      public long getSunconfirmed() {
        return instance.getSunconfirmed();
      }
      /**
       * <pre>
       * Unconfirmed balance in atomic units
       * </pre>
       *
       * <code>int64 sunconfirmed = 9;</code>
       * @param value The sunconfirmed to set.
       * @return This builder for chaining.
       */
      public Builder setSunconfirmed(long value) {
        copyOnWrite();
        instance.setSunconfirmed(value);
        return this;
      }
      /**
       * <pre>
       * Unconfirmed balance in atomic units
       * </pre>
       *
       * <code>int64 sunconfirmed = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearSunconfirmed() {
        copyOnWrite();
        instance.clearSunconfirmed();
        return this;
      }

      /**
       * <pre>
       * The number of transaction outputs which make up the balance
       * </pre>
       *
       * <code>int32 outputcount = 10;</code>
       * @return The outputcount.
       */
      @java.lang.Override
      public int getOutputcount() {
        return instance.getOutputcount();
      }
      /**
       * <pre>
       * The number of transaction outputs which make up the balance
       * </pre>
       *
       * <code>int32 outputcount = 10;</code>
       * @param value The outputcount to set.
       * @return This builder for chaining.
       */
      public Builder setOutputcount(int value) {
        copyOnWrite();
        instance.setOutputcount(value);
        return this;
      }
      /**
       * <pre>
       * The number of transaction outputs which make up the balance
       * </pre>
       *
       * <code>int32 outputcount = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearOutputcount() {
        copyOnWrite();
        instance.clearOutputcount();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.GetAddressBalancesResponseAddr)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.GetAddressBalancesResponseAddr();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "address_",
              "total_",
              "stotal_",
              "spendable_",
              "sspendable_",
              "immaturereward_",
              "simmaturereward_",
              "unconfirmed_",
              "sunconfirmed_",
              "outputcount_",
            };
            java.lang.String info =
                "\u0000\n\u0000\u0000\u0001\n\n\u0000\u0000\u0000\u0001\u0208\u0002\u0000\u0003\u0002" +
                "\u0004\u0000\u0005\u0002\u0006\u0000\u0007\u0002\b\u0000\t\u0002\n\u0004";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.GetAddressBalancesResponseAddr> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.GetAddressBalancesResponseAddr.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.GetAddressBalancesResponseAddr>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.GetAddressBalancesResponseAddr)
    private static final co.anode.anodium.Rpc.GetAddressBalancesResponseAddr DEFAULT_INSTANCE;
    static {
      GetAddressBalancesResponseAddr defaultInstance = new GetAddressBalancesResponseAddr();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        GetAddressBalancesResponseAddr.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.GetAddressBalancesResponseAddr getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<GetAddressBalancesResponseAddr> PARSER;

    public static com.google.protobuf.Parser<GetAddressBalancesResponseAddr> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface GetAddressBalancesResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.GetAddressBalancesResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
     */
    java.util.List<co.anode.anodium.Rpc.GetAddressBalancesResponseAddr> 
        getAddrsList();
    /**
     * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
     */
    co.anode.anodium.Rpc.GetAddressBalancesResponseAddr getAddrs(int index);
    /**
     * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
     */
    int getAddrsCount();
  }
  /**
   * Protobuf type {@code co.anode.anodium.GetAddressBalancesResponse}
   */
  public  static final class GetAddressBalancesResponse extends
      com.google.protobuf.GeneratedMessageLite<
          GetAddressBalancesResponse, GetAddressBalancesResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.GetAddressBalancesResponse)
      GetAddressBalancesResponseOrBuilder {
    private GetAddressBalancesResponse() {
      addrs_ = emptyProtobufList();
    }
    public static final int ADDRS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.GetAddressBalancesResponseAddr> addrs_;
    /**
     * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.GetAddressBalancesResponseAddr> getAddrsList() {
      return addrs_;
    }
    /**
     * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.GetAddressBalancesResponseAddrOrBuilder> 
        getAddrsOrBuilderList() {
      return addrs_;
    }
    /**
     * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
     */
    @java.lang.Override
    public int getAddrsCount() {
      return addrs_.size();
    }
    /**
     * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.GetAddressBalancesResponseAddr getAddrs(int index) {
      return addrs_.get(index);
    }
    /**
     * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
     */
    public co.anode.anodium.Rpc.GetAddressBalancesResponseAddrOrBuilder getAddrsOrBuilder(
        int index) {
      return addrs_.get(index);
    }
    private void ensureAddrsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.GetAddressBalancesResponseAddr> tmp = addrs_;
      if (!tmp.isModifiable()) {
        addrs_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
     */
    private void setAddrs(
        int index, co.anode.anodium.Rpc.GetAddressBalancesResponseAddr value) {
      value.getClass();
  ensureAddrsIsMutable();
      addrs_.set(index, value);
    }
    /**
     * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
     */
    private void addAddrs(co.anode.anodium.Rpc.GetAddressBalancesResponseAddr value) {
      value.getClass();
  ensureAddrsIsMutable();
      addrs_.add(value);
    }
    /**
     * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
     */
    private void addAddrs(
        int index, co.anode.anodium.Rpc.GetAddressBalancesResponseAddr value) {
      value.getClass();
  ensureAddrsIsMutable();
      addrs_.add(index, value);
    }
    /**
     * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
     */
    private void addAllAddrs(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.GetAddressBalancesResponseAddr> values) {
      ensureAddrsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, addrs_);
    }
    /**
     * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
     */
    private void clearAddrs() {
      addrs_ = emptyProtobufList();
    }
    /**
     * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
     */
    private void removeAddrs(int index) {
      ensureAddrsIsMutable();
      addrs_.remove(index);
    }

    public static co.anode.anodium.Rpc.GetAddressBalancesResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GetAddressBalancesResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.GetAddressBalancesResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.GetAddressBalancesResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.GetAddressBalancesResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.GetAddressBalancesResponse)
        co.anode.anodium.Rpc.GetAddressBalancesResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.GetAddressBalancesResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.GetAddressBalancesResponseAddr> getAddrsList() {
        return java.util.Collections.unmodifiableList(
            instance.getAddrsList());
      }
      /**
       * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
       */
      @java.lang.Override
      public int getAddrsCount() {
        return instance.getAddrsCount();
      }/**
       * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.GetAddressBalancesResponseAddr getAddrs(int index) {
        return instance.getAddrs(index);
      }
      /**
       * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
       */
      public Builder setAddrs(
          int index, co.anode.anodium.Rpc.GetAddressBalancesResponseAddr value) {
        copyOnWrite();
        instance.setAddrs(index, value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
       */
      public Builder setAddrs(
          int index, co.anode.anodium.Rpc.GetAddressBalancesResponseAddr.Builder builderForValue) {
        copyOnWrite();
        instance.setAddrs(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
       */
      public Builder addAddrs(co.anode.anodium.Rpc.GetAddressBalancesResponseAddr value) {
        copyOnWrite();
        instance.addAddrs(value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
       */
      public Builder addAddrs(
          int index, co.anode.anodium.Rpc.GetAddressBalancesResponseAddr value) {
        copyOnWrite();
        instance.addAddrs(index, value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
       */
      public Builder addAddrs(
          co.anode.anodium.Rpc.GetAddressBalancesResponseAddr.Builder builderForValue) {
        copyOnWrite();
        instance.addAddrs(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
       */
      public Builder addAddrs(
          int index, co.anode.anodium.Rpc.GetAddressBalancesResponseAddr.Builder builderForValue) {
        copyOnWrite();
        instance.addAddrs(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
       */
      public Builder addAllAddrs(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.GetAddressBalancesResponseAddr> values) {
        copyOnWrite();
        instance.addAllAddrs(values);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
       */
      public Builder clearAddrs() {
        copyOnWrite();
        instance.clearAddrs();
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.GetAddressBalancesResponseAddr addrs = 1;</code>
       */
      public Builder removeAddrs(int index) {
        copyOnWrite();
        instance.removeAddrs(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.GetAddressBalancesResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.GetAddressBalancesResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "addrs_",
              co.anode.anodium.Rpc.GetAddressBalancesResponseAddr.class,
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0000\u0001\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.GetAddressBalancesResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.GetAddressBalancesResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.GetAddressBalancesResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.GetAddressBalancesResponse)
    private static final co.anode.anodium.Rpc.GetAddressBalancesResponse DEFAULT_INSTANCE;
    static {
      GetAddressBalancesResponse defaultInstance = new GetAddressBalancesResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        GetAddressBalancesResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.GetAddressBalancesResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<GetAddressBalancesResponse> PARSER;

    public static com.google.protobuf.Parser<GetAddressBalancesResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface AmountOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.Amount)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Value denominated in satoshis.
     * </pre>
     *
     * <code>uint64 sat = 1;</code>
     * @return The sat.
     */
    long getSat();

    /**
     * <pre>
     * Value denominated in milli-satoshis.
     * </pre>
     *
     * <code>uint64 msat = 2;</code>
     * @return The msat.
     */
    long getMsat();
  }
  /**
   * Protobuf type {@code co.anode.anodium.Amount}
   */
  public  static final class Amount extends
      com.google.protobuf.GeneratedMessageLite<
          Amount, Amount.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.Amount)
      AmountOrBuilder {
    private Amount() {
    }
    public static final int SAT_FIELD_NUMBER = 1;
    private long sat_;
    /**
     * <pre>
     * Value denominated in satoshis.
     * </pre>
     *
     * <code>uint64 sat = 1;</code>
     * @return The sat.
     */
    @java.lang.Override
    public long getSat() {
      return sat_;
    }
    /**
     * <pre>
     * Value denominated in satoshis.
     * </pre>
     *
     * <code>uint64 sat = 1;</code>
     * @param value The sat to set.
     */
    private void setSat(long value) {
      
      sat_ = value;
    }
    /**
     * <pre>
     * Value denominated in satoshis.
     * </pre>
     *
     * <code>uint64 sat = 1;</code>
     */
    private void clearSat() {
      
      sat_ = 0L;
    }

    public static final int MSAT_FIELD_NUMBER = 2;
    private long msat_;
    /**
     * <pre>
     * Value denominated in milli-satoshis.
     * </pre>
     *
     * <code>uint64 msat = 2;</code>
     * @return The msat.
     */
    @java.lang.Override
    public long getMsat() {
      return msat_;
    }
    /**
     * <pre>
     * Value denominated in milli-satoshis.
     * </pre>
     *
     * <code>uint64 msat = 2;</code>
     * @param value The msat to set.
     */
    private void setMsat(long value) {
      
      msat_ = value;
    }
    /**
     * <pre>
     * Value denominated in milli-satoshis.
     * </pre>
     *
     * <code>uint64 msat = 2;</code>
     */
    private void clearMsat() {
      
      msat_ = 0L;
    }

    public static co.anode.anodium.Rpc.Amount parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Amount parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Amount parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Amount parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Amount parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Amount parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Amount parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Amount parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Amount parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Amount parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Amount parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Amount parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.Amount prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.Amount}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.Amount, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.Amount)
        co.anode.anodium.Rpc.AmountOrBuilder {
      // Construct using co.anode.anodium.Rpc.Amount.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Value denominated in satoshis.
       * </pre>
       *
       * <code>uint64 sat = 1;</code>
       * @return The sat.
       */
      @java.lang.Override
      public long getSat() {
        return instance.getSat();
      }
      /**
       * <pre>
       * Value denominated in satoshis.
       * </pre>
       *
       * <code>uint64 sat = 1;</code>
       * @param value The sat to set.
       * @return This builder for chaining.
       */
      public Builder setSat(long value) {
        copyOnWrite();
        instance.setSat(value);
        return this;
      }
      /**
       * <pre>
       * Value denominated in satoshis.
       * </pre>
       *
       * <code>uint64 sat = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSat() {
        copyOnWrite();
        instance.clearSat();
        return this;
      }

      /**
       * <pre>
       * Value denominated in milli-satoshis.
       * </pre>
       *
       * <code>uint64 msat = 2;</code>
       * @return The msat.
       */
      @java.lang.Override
      public long getMsat() {
        return instance.getMsat();
      }
      /**
       * <pre>
       * Value denominated in milli-satoshis.
       * </pre>
       *
       * <code>uint64 msat = 2;</code>
       * @param value The msat to set.
       * @return This builder for chaining.
       */
      public Builder setMsat(long value) {
        copyOnWrite();
        instance.setMsat(value);
        return this;
      }
      /**
       * <pre>
       * Value denominated in milli-satoshis.
       * </pre>
       *
       * <code>uint64 msat = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearMsat() {
        copyOnWrite();
        instance.clearMsat();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.Amount)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.Amount();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "sat_",
              "msat_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0003\u0002\u0003" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.Amount> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.Amount.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.Amount>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.Amount)
    private static final co.anode.anodium.Rpc.Amount DEFAULT_INSTANCE;
    static {
      Amount defaultInstance = new Amount();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Amount.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.Amount getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Amount> PARSER;

    public static com.google.protobuf.Parser<Amount> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelBalanceRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelBalanceRequest)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChannelBalanceRequest}
   */
  public  static final class ChannelBalanceRequest extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelBalanceRequest, ChannelBalanceRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelBalanceRequest)
      ChannelBalanceRequestOrBuilder {
    private ChannelBalanceRequest() {
    }
    public static co.anode.anodium.Rpc.ChannelBalanceRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelBalanceRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChannelBalanceRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelBalanceRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelBalanceRequest)
        co.anode.anodium.Rpc.ChannelBalanceRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelBalanceRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelBalanceRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelBalanceRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelBalanceRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelBalanceRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelBalanceRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelBalanceRequest)
    private static final co.anode.anodium.Rpc.ChannelBalanceRequest DEFAULT_INSTANCE;
    static {
      ChannelBalanceRequest defaultInstance = new ChannelBalanceRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelBalanceRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelBalanceRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelBalanceRequest> PARSER;

    public static com.google.protobuf.Parser<ChannelBalanceRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelBalanceResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelBalanceResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Deprecated. Sum of channels balances denominated in satoshis
     * </pre>
     *
     * <code>int64 balance = 1 [deprecated = true];</code>
     * @return The balance.
     */
    @java.lang.Deprecated long getBalance();

    /**
     * <pre>
     * Deprecated. Sum of channels pending balances denominated in satoshis
     * </pre>
     *
     * <code>int64 pending_open_balance = 2 [deprecated = true];</code>
     * @return The pendingOpenBalance.
     */
    @java.lang.Deprecated long getPendingOpenBalance();

    /**
     * <pre>
     * Sum of channels local balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount local_balance = 3;</code>
     * @return Whether the localBalance field is set.
     */
    boolean hasLocalBalance();
    /**
     * <pre>
     * Sum of channels local balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount local_balance = 3;</code>
     * @return The localBalance.
     */
    co.anode.anodium.Rpc.Amount getLocalBalance();

    /**
     * <pre>
     * Sum of channels remote balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount remote_balance = 4;</code>
     * @return Whether the remoteBalance field is set.
     */
    boolean hasRemoteBalance();
    /**
     * <pre>
     * Sum of channels remote balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount remote_balance = 4;</code>
     * @return The remoteBalance.
     */
    co.anode.anodium.Rpc.Amount getRemoteBalance();

    /**
     * <pre>
     * Sum of channels local unsettled balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount unsettled_local_balance = 5;</code>
     * @return Whether the unsettledLocalBalance field is set.
     */
    boolean hasUnsettledLocalBalance();
    /**
     * <pre>
     * Sum of channels local unsettled balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount unsettled_local_balance = 5;</code>
     * @return The unsettledLocalBalance.
     */
    co.anode.anodium.Rpc.Amount getUnsettledLocalBalance();

    /**
     * <pre>
     * Sum of channels remote unsettled balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount unsettled_remote_balance = 6;</code>
     * @return Whether the unsettledRemoteBalance field is set.
     */
    boolean hasUnsettledRemoteBalance();
    /**
     * <pre>
     * Sum of channels remote unsettled balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount unsettled_remote_balance = 6;</code>
     * @return The unsettledRemoteBalance.
     */
    co.anode.anodium.Rpc.Amount getUnsettledRemoteBalance();

    /**
     * <pre>
     * Sum of channels pending local balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount pending_open_local_balance = 7;</code>
     * @return Whether the pendingOpenLocalBalance field is set.
     */
    boolean hasPendingOpenLocalBalance();
    /**
     * <pre>
     * Sum of channels pending local balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount pending_open_local_balance = 7;</code>
     * @return The pendingOpenLocalBalance.
     */
    co.anode.anodium.Rpc.Amount getPendingOpenLocalBalance();

    /**
     * <pre>
     * Sum of channels pending remote balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount pending_open_remote_balance = 8;</code>
     * @return Whether the pendingOpenRemoteBalance field is set.
     */
    boolean hasPendingOpenRemoteBalance();
    /**
     * <pre>
     * Sum of channels pending remote balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount pending_open_remote_balance = 8;</code>
     * @return The pendingOpenRemoteBalance.
     */
    co.anode.anodium.Rpc.Amount getPendingOpenRemoteBalance();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChannelBalanceResponse}
   */
  public  static final class ChannelBalanceResponse extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelBalanceResponse, ChannelBalanceResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelBalanceResponse)
      ChannelBalanceResponseOrBuilder {
    private ChannelBalanceResponse() {
    }
    public static final int BALANCE_FIELD_NUMBER = 1;
    private long balance_;
    /**
     * <pre>
     * Deprecated. Sum of channels balances denominated in satoshis
     * </pre>
     *
     * <code>int64 balance = 1 [deprecated = true];</code>
     * @return The balance.
     */
    @java.lang.Override
    @java.lang.Deprecated public long getBalance() {
      return balance_;
    }
    /**
     * <pre>
     * Deprecated. Sum of channels balances denominated in satoshis
     * </pre>
     *
     * <code>int64 balance = 1 [deprecated = true];</code>
     * @param value The balance to set.
     */
    private void setBalance(long value) {
      
      balance_ = value;
    }
    /**
     * <pre>
     * Deprecated. Sum of channels balances denominated in satoshis
     * </pre>
     *
     * <code>int64 balance = 1 [deprecated = true];</code>
     */
    private void clearBalance() {
      
      balance_ = 0L;
    }

    public static final int PENDING_OPEN_BALANCE_FIELD_NUMBER = 2;
    private long pendingOpenBalance_;
    /**
     * <pre>
     * Deprecated. Sum of channels pending balances denominated in satoshis
     * </pre>
     *
     * <code>int64 pending_open_balance = 2 [deprecated = true];</code>
     * @return The pendingOpenBalance.
     */
    @java.lang.Override
    @java.lang.Deprecated public long getPendingOpenBalance() {
      return pendingOpenBalance_;
    }
    /**
     * <pre>
     * Deprecated. Sum of channels pending balances denominated in satoshis
     * </pre>
     *
     * <code>int64 pending_open_balance = 2 [deprecated = true];</code>
     * @param value The pendingOpenBalance to set.
     */
    private void setPendingOpenBalance(long value) {
      
      pendingOpenBalance_ = value;
    }
    /**
     * <pre>
     * Deprecated. Sum of channels pending balances denominated in satoshis
     * </pre>
     *
     * <code>int64 pending_open_balance = 2 [deprecated = true];</code>
     */
    private void clearPendingOpenBalance() {
      
      pendingOpenBalance_ = 0L;
    }

    public static final int LOCAL_BALANCE_FIELD_NUMBER = 3;
    private co.anode.anodium.Rpc.Amount localBalance_;
    /**
     * <pre>
     * Sum of channels local balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount local_balance = 3;</code>
     */
    @java.lang.Override
    public boolean hasLocalBalance() {
      return localBalance_ != null;
    }
    /**
     * <pre>
     * Sum of channels local balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount local_balance = 3;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Amount getLocalBalance() {
      return localBalance_ == null ? co.anode.anodium.Rpc.Amount.getDefaultInstance() : localBalance_;
    }
    /**
     * <pre>
     * Sum of channels local balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount local_balance = 3;</code>
     */
    private void setLocalBalance(co.anode.anodium.Rpc.Amount value) {
      value.getClass();
  localBalance_ = value;
      
      }
    /**
     * <pre>
     * Sum of channels local balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount local_balance = 3;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeLocalBalance(co.anode.anodium.Rpc.Amount value) {
      value.getClass();
  if (localBalance_ != null &&
          localBalance_ != co.anode.anodium.Rpc.Amount.getDefaultInstance()) {
        localBalance_ =
          co.anode.anodium.Rpc.Amount.newBuilder(localBalance_).mergeFrom(value).buildPartial();
      } else {
        localBalance_ = value;
      }
      
    }
    /**
     * <pre>
     * Sum of channels local balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount local_balance = 3;</code>
     */
    private void clearLocalBalance() {  localBalance_ = null;
      
    }

    public static final int REMOTE_BALANCE_FIELD_NUMBER = 4;
    private co.anode.anodium.Rpc.Amount remoteBalance_;
    /**
     * <pre>
     * Sum of channels remote balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount remote_balance = 4;</code>
     */
    @java.lang.Override
    public boolean hasRemoteBalance() {
      return remoteBalance_ != null;
    }
    /**
     * <pre>
     * Sum of channels remote balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount remote_balance = 4;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Amount getRemoteBalance() {
      return remoteBalance_ == null ? co.anode.anodium.Rpc.Amount.getDefaultInstance() : remoteBalance_;
    }
    /**
     * <pre>
     * Sum of channels remote balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount remote_balance = 4;</code>
     */
    private void setRemoteBalance(co.anode.anodium.Rpc.Amount value) {
      value.getClass();
  remoteBalance_ = value;
      
      }
    /**
     * <pre>
     * Sum of channels remote balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount remote_balance = 4;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeRemoteBalance(co.anode.anodium.Rpc.Amount value) {
      value.getClass();
  if (remoteBalance_ != null &&
          remoteBalance_ != co.anode.anodium.Rpc.Amount.getDefaultInstance()) {
        remoteBalance_ =
          co.anode.anodium.Rpc.Amount.newBuilder(remoteBalance_).mergeFrom(value).buildPartial();
      } else {
        remoteBalance_ = value;
      }
      
    }
    /**
     * <pre>
     * Sum of channels remote balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount remote_balance = 4;</code>
     */
    private void clearRemoteBalance() {  remoteBalance_ = null;
      
    }

    public static final int UNSETTLED_LOCAL_BALANCE_FIELD_NUMBER = 5;
    private co.anode.anodium.Rpc.Amount unsettledLocalBalance_;
    /**
     * <pre>
     * Sum of channels local unsettled balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount unsettled_local_balance = 5;</code>
     */
    @java.lang.Override
    public boolean hasUnsettledLocalBalance() {
      return unsettledLocalBalance_ != null;
    }
    /**
     * <pre>
     * Sum of channels local unsettled balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount unsettled_local_balance = 5;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Amount getUnsettledLocalBalance() {
      return unsettledLocalBalance_ == null ? co.anode.anodium.Rpc.Amount.getDefaultInstance() : unsettledLocalBalance_;
    }
    /**
     * <pre>
     * Sum of channels local unsettled balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount unsettled_local_balance = 5;</code>
     */
    private void setUnsettledLocalBalance(co.anode.anodium.Rpc.Amount value) {
      value.getClass();
  unsettledLocalBalance_ = value;
      
      }
    /**
     * <pre>
     * Sum of channels local unsettled balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount unsettled_local_balance = 5;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeUnsettledLocalBalance(co.anode.anodium.Rpc.Amount value) {
      value.getClass();
  if (unsettledLocalBalance_ != null &&
          unsettledLocalBalance_ != co.anode.anodium.Rpc.Amount.getDefaultInstance()) {
        unsettledLocalBalance_ =
          co.anode.anodium.Rpc.Amount.newBuilder(unsettledLocalBalance_).mergeFrom(value).buildPartial();
      } else {
        unsettledLocalBalance_ = value;
      }
      
    }
    /**
     * <pre>
     * Sum of channels local unsettled balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount unsettled_local_balance = 5;</code>
     */
    private void clearUnsettledLocalBalance() {  unsettledLocalBalance_ = null;
      
    }

    public static final int UNSETTLED_REMOTE_BALANCE_FIELD_NUMBER = 6;
    private co.anode.anodium.Rpc.Amount unsettledRemoteBalance_;
    /**
     * <pre>
     * Sum of channels remote unsettled balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount unsettled_remote_balance = 6;</code>
     */
    @java.lang.Override
    public boolean hasUnsettledRemoteBalance() {
      return unsettledRemoteBalance_ != null;
    }
    /**
     * <pre>
     * Sum of channels remote unsettled balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount unsettled_remote_balance = 6;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Amount getUnsettledRemoteBalance() {
      return unsettledRemoteBalance_ == null ? co.anode.anodium.Rpc.Amount.getDefaultInstance() : unsettledRemoteBalance_;
    }
    /**
     * <pre>
     * Sum of channels remote unsettled balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount unsettled_remote_balance = 6;</code>
     */
    private void setUnsettledRemoteBalance(co.anode.anodium.Rpc.Amount value) {
      value.getClass();
  unsettledRemoteBalance_ = value;
      
      }
    /**
     * <pre>
     * Sum of channels remote unsettled balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount unsettled_remote_balance = 6;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeUnsettledRemoteBalance(co.anode.anodium.Rpc.Amount value) {
      value.getClass();
  if (unsettledRemoteBalance_ != null &&
          unsettledRemoteBalance_ != co.anode.anodium.Rpc.Amount.getDefaultInstance()) {
        unsettledRemoteBalance_ =
          co.anode.anodium.Rpc.Amount.newBuilder(unsettledRemoteBalance_).mergeFrom(value).buildPartial();
      } else {
        unsettledRemoteBalance_ = value;
      }
      
    }
    /**
     * <pre>
     * Sum of channels remote unsettled balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount unsettled_remote_balance = 6;</code>
     */
    private void clearUnsettledRemoteBalance() {  unsettledRemoteBalance_ = null;
      
    }

    public static final int PENDING_OPEN_LOCAL_BALANCE_FIELD_NUMBER = 7;
    private co.anode.anodium.Rpc.Amount pendingOpenLocalBalance_;
    /**
     * <pre>
     * Sum of channels pending local balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount pending_open_local_balance = 7;</code>
     */
    @java.lang.Override
    public boolean hasPendingOpenLocalBalance() {
      return pendingOpenLocalBalance_ != null;
    }
    /**
     * <pre>
     * Sum of channels pending local balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount pending_open_local_balance = 7;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Amount getPendingOpenLocalBalance() {
      return pendingOpenLocalBalance_ == null ? co.anode.anodium.Rpc.Amount.getDefaultInstance() : pendingOpenLocalBalance_;
    }
    /**
     * <pre>
     * Sum of channels pending local balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount pending_open_local_balance = 7;</code>
     */
    private void setPendingOpenLocalBalance(co.anode.anodium.Rpc.Amount value) {
      value.getClass();
  pendingOpenLocalBalance_ = value;
      
      }
    /**
     * <pre>
     * Sum of channels pending local balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount pending_open_local_balance = 7;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergePendingOpenLocalBalance(co.anode.anodium.Rpc.Amount value) {
      value.getClass();
  if (pendingOpenLocalBalance_ != null &&
          pendingOpenLocalBalance_ != co.anode.anodium.Rpc.Amount.getDefaultInstance()) {
        pendingOpenLocalBalance_ =
          co.anode.anodium.Rpc.Amount.newBuilder(pendingOpenLocalBalance_).mergeFrom(value).buildPartial();
      } else {
        pendingOpenLocalBalance_ = value;
      }
      
    }
    /**
     * <pre>
     * Sum of channels pending local balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount pending_open_local_balance = 7;</code>
     */
    private void clearPendingOpenLocalBalance() {  pendingOpenLocalBalance_ = null;
      
    }

    public static final int PENDING_OPEN_REMOTE_BALANCE_FIELD_NUMBER = 8;
    private co.anode.anodium.Rpc.Amount pendingOpenRemoteBalance_;
    /**
     * <pre>
     * Sum of channels pending remote balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount pending_open_remote_balance = 8;</code>
     */
    @java.lang.Override
    public boolean hasPendingOpenRemoteBalance() {
      return pendingOpenRemoteBalance_ != null;
    }
    /**
     * <pre>
     * Sum of channels pending remote balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount pending_open_remote_balance = 8;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Amount getPendingOpenRemoteBalance() {
      return pendingOpenRemoteBalance_ == null ? co.anode.anodium.Rpc.Amount.getDefaultInstance() : pendingOpenRemoteBalance_;
    }
    /**
     * <pre>
     * Sum of channels pending remote balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount pending_open_remote_balance = 8;</code>
     */
    private void setPendingOpenRemoteBalance(co.anode.anodium.Rpc.Amount value) {
      value.getClass();
  pendingOpenRemoteBalance_ = value;
      
      }
    /**
     * <pre>
     * Sum of channels pending remote balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount pending_open_remote_balance = 8;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergePendingOpenRemoteBalance(co.anode.anodium.Rpc.Amount value) {
      value.getClass();
  if (pendingOpenRemoteBalance_ != null &&
          pendingOpenRemoteBalance_ != co.anode.anodium.Rpc.Amount.getDefaultInstance()) {
        pendingOpenRemoteBalance_ =
          co.anode.anodium.Rpc.Amount.newBuilder(pendingOpenRemoteBalance_).mergeFrom(value).buildPartial();
      } else {
        pendingOpenRemoteBalance_ = value;
      }
      
    }
    /**
     * <pre>
     * Sum of channels pending remote balances.
     * </pre>
     *
     * <code>.co.anode.anodium.Amount pending_open_remote_balance = 8;</code>
     */
    private void clearPendingOpenRemoteBalance() {  pendingOpenRemoteBalance_ = null;
      
    }

    public static co.anode.anodium.Rpc.ChannelBalanceResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelBalanceResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelBalanceResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChannelBalanceResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelBalanceResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelBalanceResponse)
        co.anode.anodium.Rpc.ChannelBalanceResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelBalanceResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Deprecated. Sum of channels balances denominated in satoshis
       * </pre>
       *
       * <code>int64 balance = 1 [deprecated = true];</code>
       * @return The balance.
       */
      @java.lang.Override
      @java.lang.Deprecated public long getBalance() {
        return instance.getBalance();
      }
      /**
       * <pre>
       * Deprecated. Sum of channels balances denominated in satoshis
       * </pre>
       *
       * <code>int64 balance = 1 [deprecated = true];</code>
       * @param value The balance to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setBalance(long value) {
        copyOnWrite();
        instance.setBalance(value);
        return this;
      }
      /**
       * <pre>
       * Deprecated. Sum of channels balances denominated in satoshis
       * </pre>
       *
       * <code>int64 balance = 1 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearBalance() {
        copyOnWrite();
        instance.clearBalance();
        return this;
      }

      /**
       * <pre>
       * Deprecated. Sum of channels pending balances denominated in satoshis
       * </pre>
       *
       * <code>int64 pending_open_balance = 2 [deprecated = true];</code>
       * @return The pendingOpenBalance.
       */
      @java.lang.Override
      @java.lang.Deprecated public long getPendingOpenBalance() {
        return instance.getPendingOpenBalance();
      }
      /**
       * <pre>
       * Deprecated. Sum of channels pending balances denominated in satoshis
       * </pre>
       *
       * <code>int64 pending_open_balance = 2 [deprecated = true];</code>
       * @param value The pendingOpenBalance to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setPendingOpenBalance(long value) {
        copyOnWrite();
        instance.setPendingOpenBalance(value);
        return this;
      }
      /**
       * <pre>
       * Deprecated. Sum of channels pending balances denominated in satoshis
       * </pre>
       *
       * <code>int64 pending_open_balance = 2 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearPendingOpenBalance() {
        copyOnWrite();
        instance.clearPendingOpenBalance();
        return this;
      }

      /**
       * <pre>
       * Sum of channels local balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount local_balance = 3;</code>
       */
      @java.lang.Override
      public boolean hasLocalBalance() {
        return instance.hasLocalBalance();
      }
      /**
       * <pre>
       * Sum of channels local balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount local_balance = 3;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Amount getLocalBalance() {
        return instance.getLocalBalance();
      }
      /**
       * <pre>
       * Sum of channels local balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount local_balance = 3;</code>
       */
      public Builder setLocalBalance(co.anode.anodium.Rpc.Amount value) {
        copyOnWrite();
        instance.setLocalBalance(value);
        return this;
        }
      /**
       * <pre>
       * Sum of channels local balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount local_balance = 3;</code>
       */
      public Builder setLocalBalance(
          co.anode.anodium.Rpc.Amount.Builder builderForValue) {
        copyOnWrite();
        instance.setLocalBalance(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Sum of channels local balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount local_balance = 3;</code>
       */
      public Builder mergeLocalBalance(co.anode.anodium.Rpc.Amount value) {
        copyOnWrite();
        instance.mergeLocalBalance(value);
        return this;
      }
      /**
       * <pre>
       * Sum of channels local balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount local_balance = 3;</code>
       */
      public Builder clearLocalBalance() {  copyOnWrite();
        instance.clearLocalBalance();
        return this;
      }

      /**
       * <pre>
       * Sum of channels remote balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount remote_balance = 4;</code>
       */
      @java.lang.Override
      public boolean hasRemoteBalance() {
        return instance.hasRemoteBalance();
      }
      /**
       * <pre>
       * Sum of channels remote balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount remote_balance = 4;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Amount getRemoteBalance() {
        return instance.getRemoteBalance();
      }
      /**
       * <pre>
       * Sum of channels remote balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount remote_balance = 4;</code>
       */
      public Builder setRemoteBalance(co.anode.anodium.Rpc.Amount value) {
        copyOnWrite();
        instance.setRemoteBalance(value);
        return this;
        }
      /**
       * <pre>
       * Sum of channels remote balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount remote_balance = 4;</code>
       */
      public Builder setRemoteBalance(
          co.anode.anodium.Rpc.Amount.Builder builderForValue) {
        copyOnWrite();
        instance.setRemoteBalance(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Sum of channels remote balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount remote_balance = 4;</code>
       */
      public Builder mergeRemoteBalance(co.anode.anodium.Rpc.Amount value) {
        copyOnWrite();
        instance.mergeRemoteBalance(value);
        return this;
      }
      /**
       * <pre>
       * Sum of channels remote balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount remote_balance = 4;</code>
       */
      public Builder clearRemoteBalance() {  copyOnWrite();
        instance.clearRemoteBalance();
        return this;
      }

      /**
       * <pre>
       * Sum of channels local unsettled balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount unsettled_local_balance = 5;</code>
       */
      @java.lang.Override
      public boolean hasUnsettledLocalBalance() {
        return instance.hasUnsettledLocalBalance();
      }
      /**
       * <pre>
       * Sum of channels local unsettled balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount unsettled_local_balance = 5;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Amount getUnsettledLocalBalance() {
        return instance.getUnsettledLocalBalance();
      }
      /**
       * <pre>
       * Sum of channels local unsettled balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount unsettled_local_balance = 5;</code>
       */
      public Builder setUnsettledLocalBalance(co.anode.anodium.Rpc.Amount value) {
        copyOnWrite();
        instance.setUnsettledLocalBalance(value);
        return this;
        }
      /**
       * <pre>
       * Sum of channels local unsettled balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount unsettled_local_balance = 5;</code>
       */
      public Builder setUnsettledLocalBalance(
          co.anode.anodium.Rpc.Amount.Builder builderForValue) {
        copyOnWrite();
        instance.setUnsettledLocalBalance(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Sum of channels local unsettled balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount unsettled_local_balance = 5;</code>
       */
      public Builder mergeUnsettledLocalBalance(co.anode.anodium.Rpc.Amount value) {
        copyOnWrite();
        instance.mergeUnsettledLocalBalance(value);
        return this;
      }
      /**
       * <pre>
       * Sum of channels local unsettled balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount unsettled_local_balance = 5;</code>
       */
      public Builder clearUnsettledLocalBalance() {  copyOnWrite();
        instance.clearUnsettledLocalBalance();
        return this;
      }

      /**
       * <pre>
       * Sum of channels remote unsettled balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount unsettled_remote_balance = 6;</code>
       */
      @java.lang.Override
      public boolean hasUnsettledRemoteBalance() {
        return instance.hasUnsettledRemoteBalance();
      }
      /**
       * <pre>
       * Sum of channels remote unsettled balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount unsettled_remote_balance = 6;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Amount getUnsettledRemoteBalance() {
        return instance.getUnsettledRemoteBalance();
      }
      /**
       * <pre>
       * Sum of channels remote unsettled balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount unsettled_remote_balance = 6;</code>
       */
      public Builder setUnsettledRemoteBalance(co.anode.anodium.Rpc.Amount value) {
        copyOnWrite();
        instance.setUnsettledRemoteBalance(value);
        return this;
        }
      /**
       * <pre>
       * Sum of channels remote unsettled balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount unsettled_remote_balance = 6;</code>
       */
      public Builder setUnsettledRemoteBalance(
          co.anode.anodium.Rpc.Amount.Builder builderForValue) {
        copyOnWrite();
        instance.setUnsettledRemoteBalance(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Sum of channels remote unsettled balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount unsettled_remote_balance = 6;</code>
       */
      public Builder mergeUnsettledRemoteBalance(co.anode.anodium.Rpc.Amount value) {
        copyOnWrite();
        instance.mergeUnsettledRemoteBalance(value);
        return this;
      }
      /**
       * <pre>
       * Sum of channels remote unsettled balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount unsettled_remote_balance = 6;</code>
       */
      public Builder clearUnsettledRemoteBalance() {  copyOnWrite();
        instance.clearUnsettledRemoteBalance();
        return this;
      }

      /**
       * <pre>
       * Sum of channels pending local balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount pending_open_local_balance = 7;</code>
       */
      @java.lang.Override
      public boolean hasPendingOpenLocalBalance() {
        return instance.hasPendingOpenLocalBalance();
      }
      /**
       * <pre>
       * Sum of channels pending local balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount pending_open_local_balance = 7;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Amount getPendingOpenLocalBalance() {
        return instance.getPendingOpenLocalBalance();
      }
      /**
       * <pre>
       * Sum of channels pending local balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount pending_open_local_balance = 7;</code>
       */
      public Builder setPendingOpenLocalBalance(co.anode.anodium.Rpc.Amount value) {
        copyOnWrite();
        instance.setPendingOpenLocalBalance(value);
        return this;
        }
      /**
       * <pre>
       * Sum of channels pending local balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount pending_open_local_balance = 7;</code>
       */
      public Builder setPendingOpenLocalBalance(
          co.anode.anodium.Rpc.Amount.Builder builderForValue) {
        copyOnWrite();
        instance.setPendingOpenLocalBalance(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Sum of channels pending local balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount pending_open_local_balance = 7;</code>
       */
      public Builder mergePendingOpenLocalBalance(co.anode.anodium.Rpc.Amount value) {
        copyOnWrite();
        instance.mergePendingOpenLocalBalance(value);
        return this;
      }
      /**
       * <pre>
       * Sum of channels pending local balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount pending_open_local_balance = 7;</code>
       */
      public Builder clearPendingOpenLocalBalance() {  copyOnWrite();
        instance.clearPendingOpenLocalBalance();
        return this;
      }

      /**
       * <pre>
       * Sum of channels pending remote balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount pending_open_remote_balance = 8;</code>
       */
      @java.lang.Override
      public boolean hasPendingOpenRemoteBalance() {
        return instance.hasPendingOpenRemoteBalance();
      }
      /**
       * <pre>
       * Sum of channels pending remote balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount pending_open_remote_balance = 8;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Amount getPendingOpenRemoteBalance() {
        return instance.getPendingOpenRemoteBalance();
      }
      /**
       * <pre>
       * Sum of channels pending remote balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount pending_open_remote_balance = 8;</code>
       */
      public Builder setPendingOpenRemoteBalance(co.anode.anodium.Rpc.Amount value) {
        copyOnWrite();
        instance.setPendingOpenRemoteBalance(value);
        return this;
        }
      /**
       * <pre>
       * Sum of channels pending remote balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount pending_open_remote_balance = 8;</code>
       */
      public Builder setPendingOpenRemoteBalance(
          co.anode.anodium.Rpc.Amount.Builder builderForValue) {
        copyOnWrite();
        instance.setPendingOpenRemoteBalance(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Sum of channels pending remote balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount pending_open_remote_balance = 8;</code>
       */
      public Builder mergePendingOpenRemoteBalance(co.anode.anodium.Rpc.Amount value) {
        copyOnWrite();
        instance.mergePendingOpenRemoteBalance(value);
        return this;
      }
      /**
       * <pre>
       * Sum of channels pending remote balances.
       * </pre>
       *
       * <code>.co.anode.anodium.Amount pending_open_remote_balance = 8;</code>
       */
      public Builder clearPendingOpenRemoteBalance() {  copyOnWrite();
        instance.clearPendingOpenRemoteBalance();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelBalanceResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelBalanceResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "balance_",
              "pendingOpenBalance_",
              "localBalance_",
              "remoteBalance_",
              "unsettledLocalBalance_",
              "unsettledRemoteBalance_",
              "pendingOpenLocalBalance_",
              "pendingOpenRemoteBalance_",
            };
            java.lang.String info =
                "\u0000\b\u0000\u0000\u0001\b\b\u0000\u0000\u0000\u0001\u0002\u0002\u0002\u0003\t" +
                "\u0004\t\u0005\t\u0006\t\u0007\t\b\t";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelBalanceResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelBalanceResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelBalanceResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelBalanceResponse)
    private static final co.anode.anodium.Rpc.ChannelBalanceResponse DEFAULT_INSTANCE;
    static {
      ChannelBalanceResponse defaultInstance = new ChannelBalanceResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelBalanceResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelBalanceResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelBalanceResponse> PARSER;

    public static com.google.protobuf.Parser<ChannelBalanceResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface QueryRoutesRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.QueryRoutesRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The 33-byte hex-encoded public key for the payment destination
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The pubKey.
     */
    java.lang.String getPubKey();
    /**
     * <pre>
     * The 33-byte hex-encoded public key for the payment destination
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The bytes for pubKey.
     */
    com.google.protobuf.ByteString
        getPubKeyBytes();

    /**
     * <pre>
     *The amount to send expressed in satoshis.
     *The fields amt and amt_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 amt = 2;</code>
     * @return The amt.
     */
    long getAmt();

    /**
     * <pre>
     *The amount to send expressed in millisatoshis.
     *The fields amt and amt_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 amt_msat = 12;</code>
     * @return The amtMsat.
     */
    long getAmtMsat();

    /**
     * <pre>
     *An optional CLTV delta from the current height that should be used for the
     *timelock of the final hop. Note that unlike SendPayment, QueryRoutes does
     *not add any additional block padding on top of final_ctlv_delta. This
     *padding of a few blocks needs to be added manually or otherwise failures may
     *happen when a block comes in while the payment is in flight.
     * </pre>
     *
     * <code>int32 final_cltv_delta = 4;</code>
     * @return The finalCltvDelta.
     */
    int getFinalCltvDelta();

    /**
     * <pre>
     *The maximum number of satoshis that will be paid as a fee of the payment.
     *This value can be represented either as a percentage of the amount being
     *sent, or as a fixed amount of the maximum fee the user is willing the pay to
     *send the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.FeeLimit fee_limit = 5;</code>
     * @return Whether the feeLimit field is set.
     */
    boolean hasFeeLimit();
    /**
     * <pre>
     *The maximum number of satoshis that will be paid as a fee of the payment.
     *This value can be represented either as a percentage of the amount being
     *sent, or as a fixed amount of the maximum fee the user is willing the pay to
     *send the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.FeeLimit fee_limit = 5;</code>
     * @return The feeLimit.
     */
    co.anode.anodium.Rpc.FeeLimit getFeeLimit();

    /**
     * <pre>
     *A list of nodes to ignore during path finding. When using REST, these fields
     *must be encoded as base64.
     * </pre>
     *
     * <code>repeated bytes ignored_nodes = 6;</code>
     * @return A list containing the ignoredNodes.
     */
    java.util.List<com.google.protobuf.ByteString> getIgnoredNodesList();
    /**
     * <pre>
     *A list of nodes to ignore during path finding. When using REST, these fields
     *must be encoded as base64.
     * </pre>
     *
     * <code>repeated bytes ignored_nodes = 6;</code>
     * @return The count of ignoredNodes.
     */
    int getIgnoredNodesCount();
    /**
     * <pre>
     *A list of nodes to ignore during path finding. When using REST, these fields
     *must be encoded as base64.
     * </pre>
     *
     * <code>repeated bytes ignored_nodes = 6;</code>
     * @param index The index of the element to return.
     * @return The ignoredNodes at the given index.
     */
    com.google.protobuf.ByteString getIgnoredNodes(int index);

    /**
     * <pre>
     *Deprecated. A list of edges to ignore during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated java.util.List<co.anode.anodium.Rpc.EdgeLocator> 
        getIgnoredEdgesList();
    /**
     * <pre>
     *Deprecated. A list of edges to ignore during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated co.anode.anodium.Rpc.EdgeLocator getIgnoredEdges(int index);
    /**
     * <pre>
     *Deprecated. A list of edges to ignore during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated int getIgnoredEdgesCount();

    /**
     * <pre>
     *The source node where the request route should originated from. If empty,
     *self is assumed.
     * </pre>
     *
     * <code>string source_pub_key = 8;</code>
     * @return The sourcePubKey.
     */
    java.lang.String getSourcePubKey();
    /**
     * <pre>
     *The source node where the request route should originated from. If empty,
     *self is assumed.
     * </pre>
     *
     * <code>string source_pub_key = 8;</code>
     * @return The bytes for sourcePubKey.
     */
    com.google.protobuf.ByteString
        getSourcePubKeyBytes();

    /**
     * <pre>
     *If set to true, edge probabilities from mission control will be used to get
     *the optimal route.
     * </pre>
     *
     * <code>bool use_mission_control = 9;</code>
     * @return The useMissionControl.
     */
    boolean getUseMissionControl();

    /**
     * <pre>
     *A list of directed node pairs that will be ignored during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
     */
    java.util.List<co.anode.anodium.Rpc.NodePair> 
        getIgnoredPairsList();
    /**
     * <pre>
     *A list of directed node pairs that will be ignored during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
     */
    co.anode.anodium.Rpc.NodePair getIgnoredPairs(int index);
    /**
     * <pre>
     *A list of directed node pairs that will be ignored during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
     */
    int getIgnoredPairsCount();

    /**
     * <pre>
     *An optional maximum total time lock for the route. If the source is empty or
     *ourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If
     *zero, then the value of `--max-cltv-expiry` is used as the limit.
     * </pre>
     *
     * <code>uint32 cltv_limit = 11;</code>
     * @return The cltvLimit.
     */
    int getCltvLimit();

    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. If the destination
     *does not support the specified recrods, and error will be returned.
     *Record types are required to be in the custom range &gt;= 65536. When using
     *REST, the values must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 13;</code>
     */
    int getDestCustomRecordsCount();
    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. If the destination
     *does not support the specified recrods, and error will be returned.
     *Record types are required to be in the custom range &gt;= 65536. When using
     *REST, the values must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 13;</code>
     */
    boolean containsDestCustomRecords(
        long key);
    /**
     * Use {@link #getDestCustomRecordsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Long, com.google.protobuf.ByteString>
    getDestCustomRecords();
    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. If the destination
     *does not support the specified recrods, and error will be returned.
     *Record types are required to be in the custom range &gt;= 65536. When using
     *REST, the values must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 13;</code>
     */
    java.util.Map<java.lang.Long, com.google.protobuf.ByteString>
    getDestCustomRecordsMap();
    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. If the destination
     *does not support the specified recrods, and error will be returned.
     *Record types are required to be in the custom range &gt;= 65536. When using
     *REST, the values must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 13;</code>
     */

    com.google.protobuf.ByteString getDestCustomRecordsOrDefault(
        long key,
        com.google.protobuf.ByteString defaultValue);
    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. If the destination
     *does not support the specified recrods, and error will be returned.
     *Record types are required to be in the custom range &gt;= 65536. When using
     *REST, the values must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 13;</code>
     */

    com.google.protobuf.ByteString getDestCustomRecordsOrThrow(
        long key);

    /**
     * <pre>
     *The channel id of the channel that must be taken to the first hop. If zero,
     *any channel may be used.
     * </pre>
     *
     * <code>uint64 outgoing_chan_id = 14 [jstype = JS_STRING];</code>
     * @return The outgoingChanId.
     */
    long getOutgoingChanId();

    /**
     * <pre>
     *The pubkey of the last hop of the route. If empty, any hop may be used.
     * </pre>
     *
     * <code>bytes last_hop_pubkey = 15;</code>
     * @return The lastHopPubkey.
     */
    com.google.protobuf.ByteString getLastHopPubkey();

    /**
     * <pre>
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
     */
    java.util.List<co.anode.anodium.Rpc.RouteHint> 
        getRouteHintsList();
    /**
     * <pre>
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
     */
    co.anode.anodium.Rpc.RouteHint getRouteHints(int index);
    /**
     * <pre>
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
     */
    int getRouteHintsCount();

    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
     * @return A list containing the destFeatures.
     */
    java.util.List<co.anode.anodium.Rpc.FeatureBit> getDestFeaturesList();
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
     * @return The count of destFeatures.
     */
    int getDestFeaturesCount();
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
     * @param index The index of the element to return.
     * @return The destFeatures at the given index.
     */
    co.anode.anodium.Rpc.FeatureBit getDestFeatures(int index);
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
     * @return A list containing the enum numeric values on the wire for destFeatures.
     */
    java.util.List<java.lang.Integer>
    getDestFeaturesValueList();
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
     * @param index The index of the value to return.
     * @return The enum numeric value on the wire of destFeatures at the given index.
     */
    int getDestFeaturesValue(int index);
  }
  /**
   * Protobuf type {@code co.anode.anodium.QueryRoutesRequest}
   */
  public  static final class QueryRoutesRequest extends
      com.google.protobuf.GeneratedMessageLite<
          QueryRoutesRequest, QueryRoutesRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.QueryRoutesRequest)
      QueryRoutesRequestOrBuilder {
    private QueryRoutesRequest() {
      pubKey_ = "";
      ignoredNodes_ = emptyProtobufList();
      ignoredEdges_ = emptyProtobufList();
      sourcePubKey_ = "";
      ignoredPairs_ = emptyProtobufList();
      lastHopPubkey_ = com.google.protobuf.ByteString.EMPTY;
      routeHints_ = emptyProtobufList();
      destFeatures_ = emptyIntList();
    }
    public static final int PUB_KEY_FIELD_NUMBER = 1;
    private java.lang.String pubKey_;
    /**
     * <pre>
     * The 33-byte hex-encoded public key for the payment destination
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The pubKey.
     */
    @java.lang.Override
    public java.lang.String getPubKey() {
      return pubKey_;
    }
    /**
     * <pre>
     * The 33-byte hex-encoded public key for the payment destination
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The bytes for pubKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPubKeyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(pubKey_);
    }
    /**
     * <pre>
     * The 33-byte hex-encoded public key for the payment destination
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @param value The pubKey to set.
     */
    private void setPubKey(
        java.lang.String value) {
      value.getClass();
  
      pubKey_ = value;
    }
    /**
     * <pre>
     * The 33-byte hex-encoded public key for the payment destination
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     */
    private void clearPubKey() {
      
      pubKey_ = getDefaultInstance().getPubKey();
    }
    /**
     * <pre>
     * The 33-byte hex-encoded public key for the payment destination
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @param value The bytes for pubKey to set.
     */
    private void setPubKeyBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      pubKey_ = value.toStringUtf8();
      
    }

    public static final int AMT_FIELD_NUMBER = 2;
    private long amt_;
    /**
     * <pre>
     *The amount to send expressed in satoshis.
     *The fields amt and amt_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 amt = 2;</code>
     * @return The amt.
     */
    @java.lang.Override
    public long getAmt() {
      return amt_;
    }
    /**
     * <pre>
     *The amount to send expressed in satoshis.
     *The fields amt and amt_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 amt = 2;</code>
     * @param value The amt to set.
     */
    private void setAmt(long value) {
      
      amt_ = value;
    }
    /**
     * <pre>
     *The amount to send expressed in satoshis.
     *The fields amt and amt_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 amt = 2;</code>
     */
    private void clearAmt() {
      
      amt_ = 0L;
    }

    public static final int AMT_MSAT_FIELD_NUMBER = 12;
    private long amtMsat_;
    /**
     * <pre>
     *The amount to send expressed in millisatoshis.
     *The fields amt and amt_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 amt_msat = 12;</code>
     * @return The amtMsat.
     */
    @java.lang.Override
    public long getAmtMsat() {
      return amtMsat_;
    }
    /**
     * <pre>
     *The amount to send expressed in millisatoshis.
     *The fields amt and amt_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 amt_msat = 12;</code>
     * @param value The amtMsat to set.
     */
    private void setAmtMsat(long value) {
      
      amtMsat_ = value;
    }
    /**
     * <pre>
     *The amount to send expressed in millisatoshis.
     *The fields amt and amt_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 amt_msat = 12;</code>
     */
    private void clearAmtMsat() {
      
      amtMsat_ = 0L;
    }

    public static final int FINAL_CLTV_DELTA_FIELD_NUMBER = 4;
    private int finalCltvDelta_;
    /**
     * <pre>
     *An optional CLTV delta from the current height that should be used for the
     *timelock of the final hop. Note that unlike SendPayment, QueryRoutes does
     *not add any additional block padding on top of final_ctlv_delta. This
     *padding of a few blocks needs to be added manually or otherwise failures may
     *happen when a block comes in while the payment is in flight.
     * </pre>
     *
     * <code>int32 final_cltv_delta = 4;</code>
     * @return The finalCltvDelta.
     */
    @java.lang.Override
    public int getFinalCltvDelta() {
      return finalCltvDelta_;
    }
    /**
     * <pre>
     *An optional CLTV delta from the current height that should be used for the
     *timelock of the final hop. Note that unlike SendPayment, QueryRoutes does
     *not add any additional block padding on top of final_ctlv_delta. This
     *padding of a few blocks needs to be added manually or otherwise failures may
     *happen when a block comes in while the payment is in flight.
     * </pre>
     *
     * <code>int32 final_cltv_delta = 4;</code>
     * @param value The finalCltvDelta to set.
     */
    private void setFinalCltvDelta(int value) {
      
      finalCltvDelta_ = value;
    }
    /**
     * <pre>
     *An optional CLTV delta from the current height that should be used for the
     *timelock of the final hop. Note that unlike SendPayment, QueryRoutes does
     *not add any additional block padding on top of final_ctlv_delta. This
     *padding of a few blocks needs to be added manually or otherwise failures may
     *happen when a block comes in while the payment is in flight.
     * </pre>
     *
     * <code>int32 final_cltv_delta = 4;</code>
     */
    private void clearFinalCltvDelta() {
      
      finalCltvDelta_ = 0;
    }

    public static final int FEE_LIMIT_FIELD_NUMBER = 5;
    private co.anode.anodium.Rpc.FeeLimit feeLimit_;
    /**
     * <pre>
     *The maximum number of satoshis that will be paid as a fee of the payment.
     *This value can be represented either as a percentage of the amount being
     *sent, or as a fixed amount of the maximum fee the user is willing the pay to
     *send the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.FeeLimit fee_limit = 5;</code>
     */
    @java.lang.Override
    public boolean hasFeeLimit() {
      return feeLimit_ != null;
    }
    /**
     * <pre>
     *The maximum number of satoshis that will be paid as a fee of the payment.
     *This value can be represented either as a percentage of the amount being
     *sent, or as a fixed amount of the maximum fee the user is willing the pay to
     *send the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.FeeLimit fee_limit = 5;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.FeeLimit getFeeLimit() {
      return feeLimit_ == null ? co.anode.anodium.Rpc.FeeLimit.getDefaultInstance() : feeLimit_;
    }
    /**
     * <pre>
     *The maximum number of satoshis that will be paid as a fee of the payment.
     *This value can be represented either as a percentage of the amount being
     *sent, or as a fixed amount of the maximum fee the user is willing the pay to
     *send the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.FeeLimit fee_limit = 5;</code>
     */
    private void setFeeLimit(co.anode.anodium.Rpc.FeeLimit value) {
      value.getClass();
  feeLimit_ = value;
      
      }
    /**
     * <pre>
     *The maximum number of satoshis that will be paid as a fee of the payment.
     *This value can be represented either as a percentage of the amount being
     *sent, or as a fixed amount of the maximum fee the user is willing the pay to
     *send the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.FeeLimit fee_limit = 5;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeFeeLimit(co.anode.anodium.Rpc.FeeLimit value) {
      value.getClass();
  if (feeLimit_ != null &&
          feeLimit_ != co.anode.anodium.Rpc.FeeLimit.getDefaultInstance()) {
        feeLimit_ =
          co.anode.anodium.Rpc.FeeLimit.newBuilder(feeLimit_).mergeFrom(value).buildPartial();
      } else {
        feeLimit_ = value;
      }
      
    }
    /**
     * <pre>
     *The maximum number of satoshis that will be paid as a fee of the payment.
     *This value can be represented either as a percentage of the amount being
     *sent, or as a fixed amount of the maximum fee the user is willing the pay to
     *send the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.FeeLimit fee_limit = 5;</code>
     */
    private void clearFeeLimit() {  feeLimit_ = null;
      
    }

    public static final int IGNORED_NODES_FIELD_NUMBER = 6;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> ignoredNodes_;
    /**
     * <pre>
     *A list of nodes to ignore during path finding. When using REST, these fields
     *must be encoded as base64.
     * </pre>
     *
     * <code>repeated bytes ignored_nodes = 6;</code>
     * @return A list containing the ignoredNodes.
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.ByteString>
        getIgnoredNodesList() {
      return ignoredNodes_;
    }
    /**
     * <pre>
     *A list of nodes to ignore during path finding. When using REST, these fields
     *must be encoded as base64.
     * </pre>
     *
     * <code>repeated bytes ignored_nodes = 6;</code>
     * @return The count of ignoredNodes.
     */
    @java.lang.Override
    public int getIgnoredNodesCount() {
      return ignoredNodes_.size();
    }
    /**
     * <pre>
     *A list of nodes to ignore during path finding. When using REST, these fields
     *must be encoded as base64.
     * </pre>
     *
     * <code>repeated bytes ignored_nodes = 6;</code>
     * @param index The index of the element to return.
     * @return The ignoredNodes at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getIgnoredNodes(int index) {
      return ignoredNodes_.get(index);
    }
    private void ensureIgnoredNodesIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> tmp = ignoredNodes_;
      if (!tmp.isModifiable()) {
        ignoredNodes_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     *A list of nodes to ignore during path finding. When using REST, these fields
     *must be encoded as base64.
     * </pre>
     *
     * <code>repeated bytes ignored_nodes = 6;</code>
     * @param index The index to set the value at.
     * @param value The ignoredNodes to set.
     */
    private void setIgnoredNodes(
        int index, com.google.protobuf.ByteString value) {
      value.getClass();
  ensureIgnoredNodesIsMutable();
      ignoredNodes_.set(index, value);
    }
    /**
     * <pre>
     *A list of nodes to ignore during path finding. When using REST, these fields
     *must be encoded as base64.
     * </pre>
     *
     * <code>repeated bytes ignored_nodes = 6;</code>
     * @param value The ignoredNodes to add.
     */
    private void addIgnoredNodes(com.google.protobuf.ByteString value) {
      value.getClass();
  ensureIgnoredNodesIsMutable();
      ignoredNodes_.add(value);
    }
    /**
     * <pre>
     *A list of nodes to ignore during path finding. When using REST, these fields
     *must be encoded as base64.
     * </pre>
     *
     * <code>repeated bytes ignored_nodes = 6;</code>
     * @param values The ignoredNodes to add.
     */
    private void addAllIgnoredNodes(
        java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
      ensureIgnoredNodesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, ignoredNodes_);
    }
    /**
     * <pre>
     *A list of nodes to ignore during path finding. When using REST, these fields
     *must be encoded as base64.
     * </pre>
     *
     * <code>repeated bytes ignored_nodes = 6;</code>
     */
    private void clearIgnoredNodes() {
      ignoredNodes_ = emptyProtobufList();
    }

    public static final int IGNORED_EDGES_FIELD_NUMBER = 7;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.EdgeLocator> ignoredEdges_;
    /**
     * <pre>
     *Deprecated. A list of edges to ignore during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
     */
    @java.lang.Override
    @java.lang.Deprecated public java.util.List<co.anode.anodium.Rpc.EdgeLocator> getIgnoredEdgesList() {
      return ignoredEdges_;
    }
    /**
     * <pre>
     *Deprecated. A list of edges to ignore during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public java.util.List<? extends co.anode.anodium.Rpc.EdgeLocatorOrBuilder> 
        getIgnoredEdgesOrBuilderList() {
      return ignoredEdges_;
    }
    /**
     * <pre>
     *Deprecated. A list of edges to ignore during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
     */
    @java.lang.Override
    @java.lang.Deprecated public int getIgnoredEdgesCount() {
      return ignoredEdges_.size();
    }
    /**
     * <pre>
     *Deprecated. A list of edges to ignore during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
     */
    @java.lang.Override
    @java.lang.Deprecated public co.anode.anodium.Rpc.EdgeLocator getIgnoredEdges(int index) {
      return ignoredEdges_.get(index);
    }
    /**
     * <pre>
     *Deprecated. A list of edges to ignore during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public co.anode.anodium.Rpc.EdgeLocatorOrBuilder getIgnoredEdgesOrBuilder(
        int index) {
      return ignoredEdges_.get(index);
    }
    private void ensureIgnoredEdgesIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.EdgeLocator> tmp = ignoredEdges_;
      if (!tmp.isModifiable()) {
        ignoredEdges_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     *Deprecated. A list of edges to ignore during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
     */
    private void setIgnoredEdges(
        int index, co.anode.anodium.Rpc.EdgeLocator value) {
      value.getClass();
  ensureIgnoredEdgesIsMutable();
      ignoredEdges_.set(index, value);
    }
    /**
     * <pre>
     *Deprecated. A list of edges to ignore during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
     */
    private void addIgnoredEdges(co.anode.anodium.Rpc.EdgeLocator value) {
      value.getClass();
  ensureIgnoredEdgesIsMutable();
      ignoredEdges_.add(value);
    }
    /**
     * <pre>
     *Deprecated. A list of edges to ignore during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
     */
    private void addIgnoredEdges(
        int index, co.anode.anodium.Rpc.EdgeLocator value) {
      value.getClass();
  ensureIgnoredEdgesIsMutable();
      ignoredEdges_.add(index, value);
    }
    /**
     * <pre>
     *Deprecated. A list of edges to ignore during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
     */
    private void addAllIgnoredEdges(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.EdgeLocator> values) {
      ensureIgnoredEdgesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, ignoredEdges_);
    }
    /**
     * <pre>
     *Deprecated. A list of edges to ignore during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
     */
    private void clearIgnoredEdges() {
      ignoredEdges_ = emptyProtobufList();
    }
    /**
     * <pre>
     *Deprecated. A list of edges to ignore during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
     */
    private void removeIgnoredEdges(int index) {
      ensureIgnoredEdgesIsMutable();
      ignoredEdges_.remove(index);
    }

    public static final int SOURCE_PUB_KEY_FIELD_NUMBER = 8;
    private java.lang.String sourcePubKey_;
    /**
     * <pre>
     *The source node where the request route should originated from. If empty,
     *self is assumed.
     * </pre>
     *
     * <code>string source_pub_key = 8;</code>
     * @return The sourcePubKey.
     */
    @java.lang.Override
    public java.lang.String getSourcePubKey() {
      return sourcePubKey_;
    }
    /**
     * <pre>
     *The source node where the request route should originated from. If empty,
     *self is assumed.
     * </pre>
     *
     * <code>string source_pub_key = 8;</code>
     * @return The bytes for sourcePubKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSourcePubKeyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(sourcePubKey_);
    }
    /**
     * <pre>
     *The source node where the request route should originated from. If empty,
     *self is assumed.
     * </pre>
     *
     * <code>string source_pub_key = 8;</code>
     * @param value The sourcePubKey to set.
     */
    private void setSourcePubKey(
        java.lang.String value) {
      value.getClass();
  
      sourcePubKey_ = value;
    }
    /**
     * <pre>
     *The source node where the request route should originated from. If empty,
     *self is assumed.
     * </pre>
     *
     * <code>string source_pub_key = 8;</code>
     */
    private void clearSourcePubKey() {
      
      sourcePubKey_ = getDefaultInstance().getSourcePubKey();
    }
    /**
     * <pre>
     *The source node where the request route should originated from. If empty,
     *self is assumed.
     * </pre>
     *
     * <code>string source_pub_key = 8;</code>
     * @param value The bytes for sourcePubKey to set.
     */
    private void setSourcePubKeyBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      sourcePubKey_ = value.toStringUtf8();
      
    }

    public static final int USE_MISSION_CONTROL_FIELD_NUMBER = 9;
    private boolean useMissionControl_;
    /**
     * <pre>
     *If set to true, edge probabilities from mission control will be used to get
     *the optimal route.
     * </pre>
     *
     * <code>bool use_mission_control = 9;</code>
     * @return The useMissionControl.
     */
    @java.lang.Override
    public boolean getUseMissionControl() {
      return useMissionControl_;
    }
    /**
     * <pre>
     *If set to true, edge probabilities from mission control will be used to get
     *the optimal route.
     * </pre>
     *
     * <code>bool use_mission_control = 9;</code>
     * @param value The useMissionControl to set.
     */
    private void setUseMissionControl(boolean value) {
      
      useMissionControl_ = value;
    }
    /**
     * <pre>
     *If set to true, edge probabilities from mission control will be used to get
     *the optimal route.
     * </pre>
     *
     * <code>bool use_mission_control = 9;</code>
     */
    private void clearUseMissionControl() {
      
      useMissionControl_ = false;
    }

    public static final int IGNORED_PAIRS_FIELD_NUMBER = 10;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.NodePair> ignoredPairs_;
    /**
     * <pre>
     *A list of directed node pairs that will be ignored during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.NodePair> getIgnoredPairsList() {
      return ignoredPairs_;
    }
    /**
     * <pre>
     *A list of directed node pairs that will be ignored during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.NodePairOrBuilder> 
        getIgnoredPairsOrBuilderList() {
      return ignoredPairs_;
    }
    /**
     * <pre>
     *A list of directed node pairs that will be ignored during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
     */
    @java.lang.Override
    public int getIgnoredPairsCount() {
      return ignoredPairs_.size();
    }
    /**
     * <pre>
     *A list of directed node pairs that will be ignored during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.NodePair getIgnoredPairs(int index) {
      return ignoredPairs_.get(index);
    }
    /**
     * <pre>
     *A list of directed node pairs that will be ignored during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
     */
    public co.anode.anodium.Rpc.NodePairOrBuilder getIgnoredPairsOrBuilder(
        int index) {
      return ignoredPairs_.get(index);
    }
    private void ensureIgnoredPairsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.NodePair> tmp = ignoredPairs_;
      if (!tmp.isModifiable()) {
        ignoredPairs_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     *A list of directed node pairs that will be ignored during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
     */
    private void setIgnoredPairs(
        int index, co.anode.anodium.Rpc.NodePair value) {
      value.getClass();
  ensureIgnoredPairsIsMutable();
      ignoredPairs_.set(index, value);
    }
    /**
     * <pre>
     *A list of directed node pairs that will be ignored during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
     */
    private void addIgnoredPairs(co.anode.anodium.Rpc.NodePair value) {
      value.getClass();
  ensureIgnoredPairsIsMutable();
      ignoredPairs_.add(value);
    }
    /**
     * <pre>
     *A list of directed node pairs that will be ignored during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
     */
    private void addIgnoredPairs(
        int index, co.anode.anodium.Rpc.NodePair value) {
      value.getClass();
  ensureIgnoredPairsIsMutable();
      ignoredPairs_.add(index, value);
    }
    /**
     * <pre>
     *A list of directed node pairs that will be ignored during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
     */
    private void addAllIgnoredPairs(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.NodePair> values) {
      ensureIgnoredPairsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, ignoredPairs_);
    }
    /**
     * <pre>
     *A list of directed node pairs that will be ignored during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
     */
    private void clearIgnoredPairs() {
      ignoredPairs_ = emptyProtobufList();
    }
    /**
     * <pre>
     *A list of directed node pairs that will be ignored during path finding.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
     */
    private void removeIgnoredPairs(int index) {
      ensureIgnoredPairsIsMutable();
      ignoredPairs_.remove(index);
    }

    public static final int CLTV_LIMIT_FIELD_NUMBER = 11;
    private int cltvLimit_;
    /**
     * <pre>
     *An optional maximum total time lock for the route. If the source is empty or
     *ourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If
     *zero, then the value of `--max-cltv-expiry` is used as the limit.
     * </pre>
     *
     * <code>uint32 cltv_limit = 11;</code>
     * @return The cltvLimit.
     */
    @java.lang.Override
    public int getCltvLimit() {
      return cltvLimit_;
    }
    /**
     * <pre>
     *An optional maximum total time lock for the route. If the source is empty or
     *ourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If
     *zero, then the value of `--max-cltv-expiry` is used as the limit.
     * </pre>
     *
     * <code>uint32 cltv_limit = 11;</code>
     * @param value The cltvLimit to set.
     */
    private void setCltvLimit(int value) {
      
      cltvLimit_ = value;
    }
    /**
     * <pre>
     *An optional maximum total time lock for the route. If the source is empty or
     *ourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If
     *zero, then the value of `--max-cltv-expiry` is used as the limit.
     * </pre>
     *
     * <code>uint32 cltv_limit = 11;</code>
     */
    private void clearCltvLimit() {
      
      cltvLimit_ = 0;
    }

    public static final int DEST_CUSTOM_RECORDS_FIELD_NUMBER = 13;
    private static final class DestCustomRecordsDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Long, com.google.protobuf.ByteString> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Long, com.google.protobuf.ByteString>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.UINT64,
                  0L,
                  com.google.protobuf.WireFormat.FieldType.BYTES,
                  com.google.protobuf.ByteString.EMPTY);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Long, com.google.protobuf.ByteString> destCustomRecords_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Long, com.google.protobuf.ByteString>
    internalGetDestCustomRecords() {
      return destCustomRecords_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Long, com.google.protobuf.ByteString>
    internalGetMutableDestCustomRecords() {
      if (!destCustomRecords_.isMutable()) {
        destCustomRecords_ = destCustomRecords_.mutableCopy();
      }
      return destCustomRecords_;
    }
    @java.lang.Override

    public int getDestCustomRecordsCount() {
      return internalGetDestCustomRecords().size();
    }
    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. If the destination
     *does not support the specified recrods, and error will be returned.
     *Record types are required to be in the custom range &gt;= 65536. When using
     *REST, the values must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 13;</code>
     */
    @java.lang.Override

    public boolean containsDestCustomRecords(
        long key) {
      
      return internalGetDestCustomRecords().containsKey(key);
    }
    /**
     * Use {@link #getDestCustomRecordsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getDestCustomRecords() {
      return getDestCustomRecordsMap();
    }
    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. If the destination
     *does not support the specified recrods, and error will be returned.
     *Record types are required to be in the custom range &gt;= 65536. When using
     *REST, the values must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 13;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getDestCustomRecordsMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetDestCustomRecords());
    }
    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. If the destination
     *does not support the specified recrods, and error will be returned.
     *Record types are required to be in the custom range &gt;= 65536. When using
     *REST, the values must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 13;</code>
     */
    @java.lang.Override

    public com.google.protobuf.ByteString getDestCustomRecordsOrDefault(
        long key,
        com.google.protobuf.ByteString defaultValue) {
      
      java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
          internalGetDestCustomRecords();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. If the destination
     *does not support the specified recrods, and error will be returned.
     *Record types are required to be in the custom range &gt;= 65536. When using
     *REST, the values must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 13;</code>
     */
    @java.lang.Override

    public com.google.protobuf.ByteString getDestCustomRecordsOrThrow(
        long key) {
      
      java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
          internalGetDestCustomRecords();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     *An optional field that can be used to pass an arbitrary set of TLV records
     *to a peer which understands the new records. This can be used to pass
     *application specific data during the payment attempt. If the destination
     *does not support the specified recrods, and error will be returned.
     *Record types are required to be in the custom range &gt;= 65536. When using
     *REST, the values must be encoded as base64.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; dest_custom_records = 13;</code>
     */
    private java.util.Map<java.lang.Long, com.google.protobuf.ByteString>
    getMutableDestCustomRecordsMap() {
      return internalGetMutableDestCustomRecords();
    }

    public static final int OUTGOING_CHAN_ID_FIELD_NUMBER = 14;
    private long outgoingChanId_;
    /**
     * <pre>
     *The channel id of the channel that must be taken to the first hop. If zero,
     *any channel may be used.
     * </pre>
     *
     * <code>uint64 outgoing_chan_id = 14 [jstype = JS_STRING];</code>
     * @return The outgoingChanId.
     */
    @java.lang.Override
    public long getOutgoingChanId() {
      return outgoingChanId_;
    }
    /**
     * <pre>
     *The channel id of the channel that must be taken to the first hop. If zero,
     *any channel may be used.
     * </pre>
     *
     * <code>uint64 outgoing_chan_id = 14 [jstype = JS_STRING];</code>
     * @param value The outgoingChanId to set.
     */
    private void setOutgoingChanId(long value) {
      
      outgoingChanId_ = value;
    }
    /**
     * <pre>
     *The channel id of the channel that must be taken to the first hop. If zero,
     *any channel may be used.
     * </pre>
     *
     * <code>uint64 outgoing_chan_id = 14 [jstype = JS_STRING];</code>
     */
    private void clearOutgoingChanId() {
      
      outgoingChanId_ = 0L;
    }

    public static final int LAST_HOP_PUBKEY_FIELD_NUMBER = 15;
    private com.google.protobuf.ByteString lastHopPubkey_;
    /**
     * <pre>
     *The pubkey of the last hop of the route. If empty, any hop may be used.
     * </pre>
     *
     * <code>bytes last_hop_pubkey = 15;</code>
     * @return The lastHopPubkey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getLastHopPubkey() {
      return lastHopPubkey_;
    }
    /**
     * <pre>
     *The pubkey of the last hop of the route. If empty, any hop may be used.
     * </pre>
     *
     * <code>bytes last_hop_pubkey = 15;</code>
     * @param value The lastHopPubkey to set.
     */
    private void setLastHopPubkey(com.google.protobuf.ByteString value) {
      value.getClass();
  
      lastHopPubkey_ = value;
    }
    /**
     * <pre>
     *The pubkey of the last hop of the route. If empty, any hop may be used.
     * </pre>
     *
     * <code>bytes last_hop_pubkey = 15;</code>
     */
    private void clearLastHopPubkey() {
      
      lastHopPubkey_ = getDefaultInstance().getLastHopPubkey();
    }

    public static final int ROUTE_HINTS_FIELD_NUMBER = 16;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.RouteHint> routeHints_;
    /**
     * <pre>
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.RouteHint> getRouteHintsList() {
      return routeHints_;
    }
    /**
     * <pre>
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.RouteHintOrBuilder> 
        getRouteHintsOrBuilderList() {
      return routeHints_;
    }
    /**
     * <pre>
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
     */
    @java.lang.Override
    public int getRouteHintsCount() {
      return routeHints_.size();
    }
    /**
     * <pre>
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.RouteHint getRouteHints(int index) {
      return routeHints_.get(index);
    }
    /**
     * <pre>
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
     */
    public co.anode.anodium.Rpc.RouteHintOrBuilder getRouteHintsOrBuilder(
        int index) {
      return routeHints_.get(index);
    }
    private void ensureRouteHintsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.RouteHint> tmp = routeHints_;
      if (!tmp.isModifiable()) {
        routeHints_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
     */
    private void setRouteHints(
        int index, co.anode.anodium.Rpc.RouteHint value) {
      value.getClass();
  ensureRouteHintsIsMutable();
      routeHints_.set(index, value);
    }
    /**
     * <pre>
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
     */
    private void addRouteHints(co.anode.anodium.Rpc.RouteHint value) {
      value.getClass();
  ensureRouteHintsIsMutable();
      routeHints_.add(value);
    }
    /**
     * <pre>
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
     */
    private void addRouteHints(
        int index, co.anode.anodium.Rpc.RouteHint value) {
      value.getClass();
  ensureRouteHintsIsMutable();
      routeHints_.add(index, value);
    }
    /**
     * <pre>
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
     */
    private void addAllRouteHints(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.RouteHint> values) {
      ensureRouteHintsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, routeHints_);
    }
    /**
     * <pre>
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
     */
    private void clearRouteHints() {
      routeHints_ = emptyProtobufList();
    }
    /**
     * <pre>
     *Optional route hints to reach the destination through private channels.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
     */
    private void removeRouteHints(int index) {
      ensureRouteHintsIsMutable();
      routeHints_.remove(index);
    }

    public static final int DEST_FEATURES_FIELD_NUMBER = 17;
    private com.google.protobuf.Internal.IntList destFeatures_;
    private static final com.google.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, co.anode.anodium.Rpc.FeatureBit> destFeatures_converter_ =
            new com.google.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, co.anode.anodium.Rpc.FeatureBit>() {
              @java.lang.Override
              public co.anode.anodium.Rpc.FeatureBit convert(java.lang.Integer from) {
                co.anode.anodium.Rpc.FeatureBit result = co.anode.anodium.Rpc.FeatureBit.forNumber(from);
                return result == null ? co.anode.anodium.Rpc.FeatureBit.UNRECOGNIZED : result;
              }
            };
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
     * @return A list containing the destFeatures.
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.FeatureBit> getDestFeaturesList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, co.anode.anodium.Rpc.FeatureBit>(destFeatures_, destFeatures_converter_);
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
     * @return The count of destFeatures.
     */
    @java.lang.Override
    public int getDestFeaturesCount() {
      return destFeatures_.size();
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
     * @param index The index of the element to return.
     * @return The destFeatures at the given index.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.FeatureBit getDestFeatures(int index) {
      return destFeatures_converter_.convert(destFeatures_.getInt(index));
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
     * @return A list containing the enum numeric values on the wire for destFeatures.
     */
    @java.lang.Override
    public java.util.List<java.lang.Integer>
    getDestFeaturesValueList() {
      return destFeatures_;
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
     * @param index The index of the value to return.
     * @return The enum numeric value on the wire of destFeatures at the given index.
     */
    @java.lang.Override
    public int getDestFeaturesValue(int index) {
      return destFeatures_.getInt(index);
    }
    private int destFeaturesMemoizedSerializedSize;
    private void ensureDestFeaturesIsMutable() {
      com.google.protobuf.Internal.IntList tmp = destFeatures_;
      if (!tmp.isModifiable()) {
        destFeatures_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
      }
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
     * @param index The index to set the value at.
     * @param value The destFeatures to set.
     */
    private void setDestFeatures(
        int index, co.anode.anodium.Rpc.FeatureBit value) {
      value.getClass();
  ensureDestFeaturesIsMutable();
      destFeatures_.setInt(index, value.getNumber());
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
     * @param value The destFeatures to add.
     */
    private void addDestFeatures(co.anode.anodium.Rpc.FeatureBit value) {
      value.getClass();
  ensureDestFeaturesIsMutable();
      destFeatures_.addInt(value.getNumber());
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
     * @param values The destFeatures to add.
     */
    private void addAllDestFeatures(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.FeatureBit> values) {
      ensureDestFeaturesIsMutable();
      for (co.anode.anodium.Rpc.FeatureBit value : values) {
        destFeatures_.addInt(value.getNumber());
      }
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
     */
    private void clearDestFeatures() {
      destFeatures_ = emptyIntList();
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
     * @param value The enum numeric value on the wire for destFeatures to set.
     */
    private void setDestFeaturesValue(
        int index, int value) {
      ensureDestFeaturesIsMutable();
      destFeatures_.setInt(index, value);
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
     * @param value The enum numeric value on the wire for destFeatures to add.
     */
    private void addDestFeaturesValue(int value) {
      ensureDestFeaturesIsMutable();
      destFeatures_.addInt(value);
    }
    /**
     * <pre>
     *Features assumed to be supported by the final node. All transitive feature
     *dependencies must also be set properly. For a given feature bit pair, either
     *optional or remote may be set, but not both. If this field is nil or empty,
     *the router will try to load destination features from the graph as a
     *fallback.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
     * @param values The enum numeric values on the wire for destFeatures to add.
     */
    private void addAllDestFeaturesValue(
        java.lang.Iterable<java.lang.Integer> values) {
      ensureDestFeaturesIsMutable();
      for (int value : values) {
        destFeatures_.addInt(value);
      }
    }

    public static co.anode.anodium.Rpc.QueryRoutesRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.QueryRoutesRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.QueryRoutesRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.QueryRoutesRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.QueryRoutesRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.QueryRoutesRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.QueryRoutesRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.QueryRoutesRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.QueryRoutesRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.QueryRoutesRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.QueryRoutesRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.QueryRoutesRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.QueryRoutesRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.QueryRoutesRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.QueryRoutesRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.QueryRoutesRequest)
        co.anode.anodium.Rpc.QueryRoutesRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.QueryRoutesRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The 33-byte hex-encoded public key for the payment destination
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @return The pubKey.
       */
      @java.lang.Override
      public java.lang.String getPubKey() {
        return instance.getPubKey();
      }
      /**
       * <pre>
       * The 33-byte hex-encoded public key for the payment destination
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @return The bytes for pubKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPubKeyBytes() {
        return instance.getPubKeyBytes();
      }
      /**
       * <pre>
       * The 33-byte hex-encoded public key for the payment destination
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @param value The pubKey to set.
       * @return This builder for chaining.
       */
      public Builder setPubKey(
          java.lang.String value) {
        copyOnWrite();
        instance.setPubKey(value);
        return this;
      }
      /**
       * <pre>
       * The 33-byte hex-encoded public key for the payment destination
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPubKey() {
        copyOnWrite();
        instance.clearPubKey();
        return this;
      }
      /**
       * <pre>
       * The 33-byte hex-encoded public key for the payment destination
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @param value The bytes for pubKey to set.
       * @return This builder for chaining.
       */
      public Builder setPubKeyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPubKeyBytes(value);
        return this;
      }

      /**
       * <pre>
       *The amount to send expressed in satoshis.
       *The fields amt and amt_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 amt = 2;</code>
       * @return The amt.
       */
      @java.lang.Override
      public long getAmt() {
        return instance.getAmt();
      }
      /**
       * <pre>
       *The amount to send expressed in satoshis.
       *The fields amt and amt_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 amt = 2;</code>
       * @param value The amt to set.
       * @return This builder for chaining.
       */
      public Builder setAmt(long value) {
        copyOnWrite();
        instance.setAmt(value);
        return this;
      }
      /**
       * <pre>
       *The amount to send expressed in satoshis.
       *The fields amt and amt_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 amt = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmt() {
        copyOnWrite();
        instance.clearAmt();
        return this;
      }

      /**
       * <pre>
       *The amount to send expressed in millisatoshis.
       *The fields amt and amt_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 amt_msat = 12;</code>
       * @return The amtMsat.
       */
      @java.lang.Override
      public long getAmtMsat() {
        return instance.getAmtMsat();
      }
      /**
       * <pre>
       *The amount to send expressed in millisatoshis.
       *The fields amt and amt_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 amt_msat = 12;</code>
       * @param value The amtMsat to set.
       * @return This builder for chaining.
       */
      public Builder setAmtMsat(long value) {
        copyOnWrite();
        instance.setAmtMsat(value);
        return this;
      }
      /**
       * <pre>
       *The amount to send expressed in millisatoshis.
       *The fields amt and amt_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 amt_msat = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmtMsat() {
        copyOnWrite();
        instance.clearAmtMsat();
        return this;
      }

      /**
       * <pre>
       *An optional CLTV delta from the current height that should be used for the
       *timelock of the final hop. Note that unlike SendPayment, QueryRoutes does
       *not add any additional block padding on top of final_ctlv_delta. This
       *padding of a few blocks needs to be added manually or otherwise failures may
       *happen when a block comes in while the payment is in flight.
       * </pre>
       *
       * <code>int32 final_cltv_delta = 4;</code>
       * @return The finalCltvDelta.
       */
      @java.lang.Override
      public int getFinalCltvDelta() {
        return instance.getFinalCltvDelta();
      }
      /**
       * <pre>
       *An optional CLTV delta from the current height that should be used for the
       *timelock of the final hop. Note that unlike SendPayment, QueryRoutes does
       *not add any additional block padding on top of final_ctlv_delta. This
       *padding of a few blocks needs to be added manually or otherwise failures may
       *happen when a block comes in while the payment is in flight.
       * </pre>
       *
       * <code>int32 final_cltv_delta = 4;</code>
       * @param value The finalCltvDelta to set.
       * @return This builder for chaining.
       */
      public Builder setFinalCltvDelta(int value) {
        copyOnWrite();
        instance.setFinalCltvDelta(value);
        return this;
      }
      /**
       * <pre>
       *An optional CLTV delta from the current height that should be used for the
       *timelock of the final hop. Note that unlike SendPayment, QueryRoutes does
       *not add any additional block padding on top of final_ctlv_delta. This
       *padding of a few blocks needs to be added manually or otherwise failures may
       *happen when a block comes in while the payment is in flight.
       * </pre>
       *
       * <code>int32 final_cltv_delta = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearFinalCltvDelta() {
        copyOnWrite();
        instance.clearFinalCltvDelta();
        return this;
      }

      /**
       * <pre>
       *The maximum number of satoshis that will be paid as a fee of the payment.
       *This value can be represented either as a percentage of the amount being
       *sent, or as a fixed amount of the maximum fee the user is willing the pay to
       *send the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.FeeLimit fee_limit = 5;</code>
       */
      @java.lang.Override
      public boolean hasFeeLimit() {
        return instance.hasFeeLimit();
      }
      /**
       * <pre>
       *The maximum number of satoshis that will be paid as a fee of the payment.
       *This value can be represented either as a percentage of the amount being
       *sent, or as a fixed amount of the maximum fee the user is willing the pay to
       *send the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.FeeLimit fee_limit = 5;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.FeeLimit getFeeLimit() {
        return instance.getFeeLimit();
      }
      /**
       * <pre>
       *The maximum number of satoshis that will be paid as a fee of the payment.
       *This value can be represented either as a percentage of the amount being
       *sent, or as a fixed amount of the maximum fee the user is willing the pay to
       *send the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.FeeLimit fee_limit = 5;</code>
       */
      public Builder setFeeLimit(co.anode.anodium.Rpc.FeeLimit value) {
        copyOnWrite();
        instance.setFeeLimit(value);
        return this;
        }
      /**
       * <pre>
       *The maximum number of satoshis that will be paid as a fee of the payment.
       *This value can be represented either as a percentage of the amount being
       *sent, or as a fixed amount of the maximum fee the user is willing the pay to
       *send the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.FeeLimit fee_limit = 5;</code>
       */
      public Builder setFeeLimit(
          co.anode.anodium.Rpc.FeeLimit.Builder builderForValue) {
        copyOnWrite();
        instance.setFeeLimit(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *The maximum number of satoshis that will be paid as a fee of the payment.
       *This value can be represented either as a percentage of the amount being
       *sent, or as a fixed amount of the maximum fee the user is willing the pay to
       *send the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.FeeLimit fee_limit = 5;</code>
       */
      public Builder mergeFeeLimit(co.anode.anodium.Rpc.FeeLimit value) {
        copyOnWrite();
        instance.mergeFeeLimit(value);
        return this;
      }
      /**
       * <pre>
       *The maximum number of satoshis that will be paid as a fee of the payment.
       *This value can be represented either as a percentage of the amount being
       *sent, or as a fixed amount of the maximum fee the user is willing the pay to
       *send the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.FeeLimit fee_limit = 5;</code>
       */
      public Builder clearFeeLimit() {  copyOnWrite();
        instance.clearFeeLimit();
        return this;
      }

      /**
       * <pre>
       *A list of nodes to ignore during path finding. When using REST, these fields
       *must be encoded as base64.
       * </pre>
       *
       * <code>repeated bytes ignored_nodes = 6;</code>
       * @return A list containing the ignoredNodes.
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.ByteString>
          getIgnoredNodesList() {
        return java.util.Collections.unmodifiableList(
            instance.getIgnoredNodesList());
      }
      /**
       * <pre>
       *A list of nodes to ignore during path finding. When using REST, these fields
       *must be encoded as base64.
       * </pre>
       *
       * <code>repeated bytes ignored_nodes = 6;</code>
       * @return The count of ignoredNodes.
       */
      @java.lang.Override
      public int getIgnoredNodesCount() {
        return instance.getIgnoredNodesCount();
      }
      /**
       * <pre>
       *A list of nodes to ignore during path finding. When using REST, these fields
       *must be encoded as base64.
       * </pre>
       *
       * <code>repeated bytes ignored_nodes = 6;</code>
       * @param index The index of the element to return.
       * @return The ignoredNodes at the given index.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getIgnoredNodes(int index) {
        return instance.getIgnoredNodes(index);
      }
      /**
       * <pre>
       *A list of nodes to ignore during path finding. When using REST, these fields
       *must be encoded as base64.
       * </pre>
       *
       * <code>repeated bytes ignored_nodes = 6;</code>
       * @param value The ignoredNodes to set.
       * @return This builder for chaining.
       */
      public Builder setIgnoredNodes(
          int index, com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setIgnoredNodes(index, value);
        return this;
      }
      /**
       * <pre>
       *A list of nodes to ignore during path finding. When using REST, these fields
       *must be encoded as base64.
       * </pre>
       *
       * <code>repeated bytes ignored_nodes = 6;</code>
       * @param value The ignoredNodes to add.
       * @return This builder for chaining.
       */
      public Builder addIgnoredNodes(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addIgnoredNodes(value);
        return this;
      }
      /**
       * <pre>
       *A list of nodes to ignore during path finding. When using REST, these fields
       *must be encoded as base64.
       * </pre>
       *
       * <code>repeated bytes ignored_nodes = 6;</code>
       * @param values The ignoredNodes to add.
       * @return This builder for chaining.
       */
      public Builder addAllIgnoredNodes(
          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
        copyOnWrite();
        instance.addAllIgnoredNodes(values);
        return this;
      }
      /**
       * <pre>
       *A list of nodes to ignore during path finding. When using REST, these fields
       *must be encoded as base64.
       * </pre>
       *
       * <code>repeated bytes ignored_nodes = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearIgnoredNodes() {
        copyOnWrite();
        instance.clearIgnoredNodes();
        return this;
      }

      /**
       * <pre>
       *Deprecated. A list of edges to ignore during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
       */
      @java.lang.Override
      @java.lang.Deprecated public java.util.List<co.anode.anodium.Rpc.EdgeLocator> getIgnoredEdgesList() {
        return java.util.Collections.unmodifiableList(
            instance.getIgnoredEdgesList());
      }
      /**
       * <pre>
       *Deprecated. A list of edges to ignore during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
       */
      @java.lang.Override
      @java.lang.Deprecated public int getIgnoredEdgesCount() {
        return instance.getIgnoredEdgesCount();
      }/**
       * <pre>
       *Deprecated. A list of edges to ignore during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
       */
      @java.lang.Override
      @java.lang.Deprecated public co.anode.anodium.Rpc.EdgeLocator getIgnoredEdges(int index) {
        return instance.getIgnoredEdges(index);
      }
      /**
       * <pre>
       *Deprecated. A list of edges to ignore during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder setIgnoredEdges(
          int index, co.anode.anodium.Rpc.EdgeLocator value) {
        copyOnWrite();
        instance.setIgnoredEdges(index, value);
        return this;
      }
      /**
       * <pre>
       *Deprecated. A list of edges to ignore during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder setIgnoredEdges(
          int index, co.anode.anodium.Rpc.EdgeLocator.Builder builderForValue) {
        copyOnWrite();
        instance.setIgnoredEdges(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Deprecated. A list of edges to ignore during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder addIgnoredEdges(co.anode.anodium.Rpc.EdgeLocator value) {
        copyOnWrite();
        instance.addIgnoredEdges(value);
        return this;
      }
      /**
       * <pre>
       *Deprecated. A list of edges to ignore during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder addIgnoredEdges(
          int index, co.anode.anodium.Rpc.EdgeLocator value) {
        copyOnWrite();
        instance.addIgnoredEdges(index, value);
        return this;
      }
      /**
       * <pre>
       *Deprecated. A list of edges to ignore during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder addIgnoredEdges(
          co.anode.anodium.Rpc.EdgeLocator.Builder builderForValue) {
        copyOnWrite();
        instance.addIgnoredEdges(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Deprecated. A list of edges to ignore during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder addIgnoredEdges(
          int index, co.anode.anodium.Rpc.EdgeLocator.Builder builderForValue) {
        copyOnWrite();
        instance.addIgnoredEdges(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Deprecated. A list of edges to ignore during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder addAllIgnoredEdges(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.EdgeLocator> values) {
        copyOnWrite();
        instance.addAllIgnoredEdges(values);
        return this;
      }
      /**
       * <pre>
       *Deprecated. A list of edges to ignore during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder clearIgnoredEdges() {
        copyOnWrite();
        instance.clearIgnoredEdges();
        return this;
      }
      /**
       * <pre>
       *Deprecated. A list of edges to ignore during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.EdgeLocator ignored_edges = 7 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder removeIgnoredEdges(int index) {
        copyOnWrite();
        instance.removeIgnoredEdges(index);
        return this;
      }

      /**
       * <pre>
       *The source node where the request route should originated from. If empty,
       *self is assumed.
       * </pre>
       *
       * <code>string source_pub_key = 8;</code>
       * @return The sourcePubKey.
       */
      @java.lang.Override
      public java.lang.String getSourcePubKey() {
        return instance.getSourcePubKey();
      }
      /**
       * <pre>
       *The source node where the request route should originated from. If empty,
       *self is assumed.
       * </pre>
       *
       * <code>string source_pub_key = 8;</code>
       * @return The bytes for sourcePubKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getSourcePubKeyBytes() {
        return instance.getSourcePubKeyBytes();
      }
      /**
       * <pre>
       *The source node where the request route should originated from. If empty,
       *self is assumed.
       * </pre>
       *
       * <code>string source_pub_key = 8;</code>
       * @param value The sourcePubKey to set.
       * @return This builder for chaining.
       */
      public Builder setSourcePubKey(
          java.lang.String value) {
        copyOnWrite();
        instance.setSourcePubKey(value);
        return this;
      }
      /**
       * <pre>
       *The source node where the request route should originated from. If empty,
       *self is assumed.
       * </pre>
       *
       * <code>string source_pub_key = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearSourcePubKey() {
        copyOnWrite();
        instance.clearSourcePubKey();
        return this;
      }
      /**
       * <pre>
       *The source node where the request route should originated from. If empty,
       *self is assumed.
       * </pre>
       *
       * <code>string source_pub_key = 8;</code>
       * @param value The bytes for sourcePubKey to set.
       * @return This builder for chaining.
       */
      public Builder setSourcePubKeyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSourcePubKeyBytes(value);
        return this;
      }

      /**
       * <pre>
       *If set to true, edge probabilities from mission control will be used to get
       *the optimal route.
       * </pre>
       *
       * <code>bool use_mission_control = 9;</code>
       * @return The useMissionControl.
       */
      @java.lang.Override
      public boolean getUseMissionControl() {
        return instance.getUseMissionControl();
      }
      /**
       * <pre>
       *If set to true, edge probabilities from mission control will be used to get
       *the optimal route.
       * </pre>
       *
       * <code>bool use_mission_control = 9;</code>
       * @param value The useMissionControl to set.
       * @return This builder for chaining.
       */
      public Builder setUseMissionControl(boolean value) {
        copyOnWrite();
        instance.setUseMissionControl(value);
        return this;
      }
      /**
       * <pre>
       *If set to true, edge probabilities from mission control will be used to get
       *the optimal route.
       * </pre>
       *
       * <code>bool use_mission_control = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearUseMissionControl() {
        copyOnWrite();
        instance.clearUseMissionControl();
        return this;
      }

      /**
       * <pre>
       *A list of directed node pairs that will be ignored during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.NodePair> getIgnoredPairsList() {
        return java.util.Collections.unmodifiableList(
            instance.getIgnoredPairsList());
      }
      /**
       * <pre>
       *A list of directed node pairs that will be ignored during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
       */
      @java.lang.Override
      public int getIgnoredPairsCount() {
        return instance.getIgnoredPairsCount();
      }/**
       * <pre>
       *A list of directed node pairs that will be ignored during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.NodePair getIgnoredPairs(int index) {
        return instance.getIgnoredPairs(index);
      }
      /**
       * <pre>
       *A list of directed node pairs that will be ignored during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
       */
      public Builder setIgnoredPairs(
          int index, co.anode.anodium.Rpc.NodePair value) {
        copyOnWrite();
        instance.setIgnoredPairs(index, value);
        return this;
      }
      /**
       * <pre>
       *A list of directed node pairs that will be ignored during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
       */
      public Builder setIgnoredPairs(
          int index, co.anode.anodium.Rpc.NodePair.Builder builderForValue) {
        copyOnWrite();
        instance.setIgnoredPairs(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *A list of directed node pairs that will be ignored during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
       */
      public Builder addIgnoredPairs(co.anode.anodium.Rpc.NodePair value) {
        copyOnWrite();
        instance.addIgnoredPairs(value);
        return this;
      }
      /**
       * <pre>
       *A list of directed node pairs that will be ignored during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
       */
      public Builder addIgnoredPairs(
          int index, co.anode.anodium.Rpc.NodePair value) {
        copyOnWrite();
        instance.addIgnoredPairs(index, value);
        return this;
      }
      /**
       * <pre>
       *A list of directed node pairs that will be ignored during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
       */
      public Builder addIgnoredPairs(
          co.anode.anodium.Rpc.NodePair.Builder builderForValue) {
        copyOnWrite();
        instance.addIgnoredPairs(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *A list of directed node pairs that will be ignored during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
       */
      public Builder addIgnoredPairs(
          int index, co.anode.anodium.Rpc.NodePair.Builder builderForValue) {
        copyOnWrite();
        instance.addIgnoredPairs(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *A list of directed node pairs that will be ignored during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
       */
      public Builder addAllIgnoredPairs(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.NodePair> values) {
        copyOnWrite();
        instance.addAllIgnoredPairs(values);
        return this;
      }
      /**
       * <pre>
       *A list of directed node pairs that will be ignored during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
       */
      public Builder clearIgnoredPairs() {
        copyOnWrite();
        instance.clearIgnoredPairs();
        return this;
      }
      /**
       * <pre>
       *A list of directed node pairs that will be ignored during path finding.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodePair ignored_pairs = 10;</code>
       */
      public Builder removeIgnoredPairs(int index) {
        copyOnWrite();
        instance.removeIgnoredPairs(index);
        return this;
      }

      /**
       * <pre>
       *An optional maximum total time lock for the route. If the source is empty or
       *ourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If
       *zero, then the value of `--max-cltv-expiry` is used as the limit.
       * </pre>
       *
       * <code>uint32 cltv_limit = 11;</code>
       * @return The cltvLimit.
       */
      @java.lang.Override
      public int getCltvLimit() {
        return instance.getCltvLimit();
      }
      /**
       * <pre>
       *An optional maximum total time lock for the route. If the source is empty or
       *ourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If
       *zero, then the value of `--max-cltv-expiry` is used as the limit.
       * </pre>
       *
       * <code>uint32 cltv_limit = 11;</code>
       * @param value The cltvLimit to set.
       * @return This builder for chaining.
       */
      public Builder setCltvLimit(int value) {
        copyOnWrite();
        instance.setCltvLimit(value);
        return this;
      }
      /**
       * <pre>
       *An optional maximum total time lock for the route. If the source is empty or
       *ourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If
       *zero, then the value of `--max-cltv-expiry` is used as the limit.
       * </pre>
       *
       * <code>uint32 cltv_limit = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearCltvLimit() {
        copyOnWrite();
        instance.clearCltvLimit();
        return this;
      }

      @java.lang.Override

      public int getDestCustomRecordsCount() {
        return instance.getDestCustomRecordsMap().size();
      }
      /**
       * <pre>
       *An optional field that can be used to pass an arbitrary set of TLV records
       *to a peer which understands the new records. This can be used to pass
       *application specific data during the payment attempt. If the destination
       *does not support the specified recrods, and error will be returned.
       *Record types are required to be in the custom range &gt;= 65536. When using
       *REST, the values must be encoded as base64.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; dest_custom_records = 13;</code>
       */
      @java.lang.Override

      public boolean containsDestCustomRecords(
          long key) {
        
        return instance.getDestCustomRecordsMap().containsKey(key);
      }

      public Builder clearDestCustomRecords() {
        copyOnWrite();
        instance.getMutableDestCustomRecordsMap().clear();
        return this;
      }
      /**
       * <pre>
       *An optional field that can be used to pass an arbitrary set of TLV records
       *to a peer which understands the new records. This can be used to pass
       *application specific data during the payment attempt. If the destination
       *does not support the specified recrods, and error will be returned.
       *Record types are required to be in the custom range &gt;= 65536. When using
       *REST, the values must be encoded as base64.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; dest_custom_records = 13;</code>
       */

      public Builder removeDestCustomRecords(
          long key) {
        
        copyOnWrite();
        instance.getMutableDestCustomRecordsMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getDestCustomRecordsMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getDestCustomRecords() {
        return getDestCustomRecordsMap();
      }
      /**
       * <pre>
       *An optional field that can be used to pass an arbitrary set of TLV records
       *to a peer which understands the new records. This can be used to pass
       *application specific data during the payment attempt. If the destination
       *does not support the specified recrods, and error will be returned.
       *Record types are required to be in the custom range &gt;= 65536. When using
       *REST, the values must be encoded as base64.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; dest_custom_records = 13;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getDestCustomRecordsMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getDestCustomRecordsMap());
      }
      /**
       * <pre>
       *An optional field that can be used to pass an arbitrary set of TLV records
       *to a peer which understands the new records. This can be used to pass
       *application specific data during the payment attempt. If the destination
       *does not support the specified recrods, and error will be returned.
       *Record types are required to be in the custom range &gt;= 65536. When using
       *REST, the values must be encoded as base64.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; dest_custom_records = 13;</code>
       */
      @java.lang.Override

      public com.google.protobuf.ByteString getDestCustomRecordsOrDefault(
          long key,
          com.google.protobuf.ByteString defaultValue) {
        
        java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
            instance.getDestCustomRecordsMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       *An optional field that can be used to pass an arbitrary set of TLV records
       *to a peer which understands the new records. This can be used to pass
       *application specific data during the payment attempt. If the destination
       *does not support the specified recrods, and error will be returned.
       *Record types are required to be in the custom range &gt;= 65536. When using
       *REST, the values must be encoded as base64.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; dest_custom_records = 13;</code>
       */
      @java.lang.Override

      public com.google.protobuf.ByteString getDestCustomRecordsOrThrow(
          long key) {
        
        java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
            instance.getDestCustomRecordsMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       *An optional field that can be used to pass an arbitrary set of TLV records
       *to a peer which understands the new records. This can be used to pass
       *application specific data during the payment attempt. If the destination
       *does not support the specified recrods, and error will be returned.
       *Record types are required to be in the custom range &gt;= 65536. When using
       *REST, the values must be encoded as base64.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; dest_custom_records = 13;</code>
       */
      public Builder putDestCustomRecords(
          long key,
          com.google.protobuf.ByteString value) {
        
        value.getClass();
        copyOnWrite();
        instance.getMutableDestCustomRecordsMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       *An optional field that can be used to pass an arbitrary set of TLV records
       *to a peer which understands the new records. This can be used to pass
       *application specific data during the payment attempt. If the destination
       *does not support the specified recrods, and error will be returned.
       *Record types are required to be in the custom range &gt;= 65536. When using
       *REST, the values must be encoded as base64.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; dest_custom_records = 13;</code>
       */
      public Builder putAllDestCustomRecords(
          java.util.Map<java.lang.Long, com.google.protobuf.ByteString> values) {
        copyOnWrite();
        instance.getMutableDestCustomRecordsMap().putAll(values);
        return this;
      }

      /**
       * <pre>
       *The channel id of the channel that must be taken to the first hop. If zero,
       *any channel may be used.
       * </pre>
       *
       * <code>uint64 outgoing_chan_id = 14 [jstype = JS_STRING];</code>
       * @return The outgoingChanId.
       */
      @java.lang.Override
      public long getOutgoingChanId() {
        return instance.getOutgoingChanId();
      }
      /**
       * <pre>
       *The channel id of the channel that must be taken to the first hop. If zero,
       *any channel may be used.
       * </pre>
       *
       * <code>uint64 outgoing_chan_id = 14 [jstype = JS_STRING];</code>
       * @param value The outgoingChanId to set.
       * @return This builder for chaining.
       */
      public Builder setOutgoingChanId(long value) {
        copyOnWrite();
        instance.setOutgoingChanId(value);
        return this;
      }
      /**
       * <pre>
       *The channel id of the channel that must be taken to the first hop. If zero,
       *any channel may be used.
       * </pre>
       *
       * <code>uint64 outgoing_chan_id = 14 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearOutgoingChanId() {
        copyOnWrite();
        instance.clearOutgoingChanId();
        return this;
      }

      /**
       * <pre>
       *The pubkey of the last hop of the route. If empty, any hop may be used.
       * </pre>
       *
       * <code>bytes last_hop_pubkey = 15;</code>
       * @return The lastHopPubkey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getLastHopPubkey() {
        return instance.getLastHopPubkey();
      }
      /**
       * <pre>
       *The pubkey of the last hop of the route. If empty, any hop may be used.
       * </pre>
       *
       * <code>bytes last_hop_pubkey = 15;</code>
       * @param value The lastHopPubkey to set.
       * @return This builder for chaining.
       */
      public Builder setLastHopPubkey(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLastHopPubkey(value);
        return this;
      }
      /**
       * <pre>
       *The pubkey of the last hop of the route. If empty, any hop may be used.
       * </pre>
       *
       * <code>bytes last_hop_pubkey = 15;</code>
       * @return This builder for chaining.
       */
      public Builder clearLastHopPubkey() {
        copyOnWrite();
        instance.clearLastHopPubkey();
        return this;
      }

      /**
       * <pre>
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.RouteHint> getRouteHintsList() {
        return java.util.Collections.unmodifiableList(
            instance.getRouteHintsList());
      }
      /**
       * <pre>
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
       */
      @java.lang.Override
      public int getRouteHintsCount() {
        return instance.getRouteHintsCount();
      }/**
       * <pre>
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.RouteHint getRouteHints(int index) {
        return instance.getRouteHints(index);
      }
      /**
       * <pre>
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
       */
      public Builder setRouteHints(
          int index, co.anode.anodium.Rpc.RouteHint value) {
        copyOnWrite();
        instance.setRouteHints(index, value);
        return this;
      }
      /**
       * <pre>
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
       */
      public Builder setRouteHints(
          int index, co.anode.anodium.Rpc.RouteHint.Builder builderForValue) {
        copyOnWrite();
        instance.setRouteHints(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
       */
      public Builder addRouteHints(co.anode.anodium.Rpc.RouteHint value) {
        copyOnWrite();
        instance.addRouteHints(value);
        return this;
      }
      /**
       * <pre>
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
       */
      public Builder addRouteHints(
          int index, co.anode.anodium.Rpc.RouteHint value) {
        copyOnWrite();
        instance.addRouteHints(index, value);
        return this;
      }
      /**
       * <pre>
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
       */
      public Builder addRouteHints(
          co.anode.anodium.Rpc.RouteHint.Builder builderForValue) {
        copyOnWrite();
        instance.addRouteHints(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
       */
      public Builder addRouteHints(
          int index, co.anode.anodium.Rpc.RouteHint.Builder builderForValue) {
        copyOnWrite();
        instance.addRouteHints(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
       */
      public Builder addAllRouteHints(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.RouteHint> values) {
        copyOnWrite();
        instance.addAllRouteHints(values);
        return this;
      }
      /**
       * <pre>
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
       */
      public Builder clearRouteHints() {
        copyOnWrite();
        instance.clearRouteHints();
        return this;
      }
      /**
       * <pre>
       *Optional route hints to reach the destination through private channels.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 16;</code>
       */
      public Builder removeRouteHints(int index) {
        copyOnWrite();
        instance.removeRouteHints(index);
        return this;
      }

      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
       * @return A list containing the destFeatures.
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.FeatureBit> getDestFeaturesList() {
        return instance.getDestFeaturesList();
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
       * @return The count of destFeatures.
       */
      @java.lang.Override
      public int getDestFeaturesCount() {
        return instance.getDestFeaturesCount();
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
       * @param index The index of the element to return.
       * @return The destFeatures at the given index.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.FeatureBit getDestFeatures(int index) {
        return instance.getDestFeatures(index);
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
       * @param index The index to set the value at.
       * @param value The destFeatures to set.
       * @return This builder for chaining.
       */
      public Builder setDestFeatures(
          int index, co.anode.anodium.Rpc.FeatureBit value) {
        copyOnWrite();
        instance.setDestFeatures(index, value);
        return this;
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
       * @param value The destFeatures to add.
       * @return This builder for chaining.
       */
      public Builder addDestFeatures(co.anode.anodium.Rpc.FeatureBit value) {
        copyOnWrite();
        instance.addDestFeatures(value);
        return this;
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
       * @param values The destFeatures to add.
       * @return This builder for chaining.
       */
      public Builder addAllDestFeatures(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.FeatureBit> values) {
        copyOnWrite();
        instance.addAllDestFeatures(values);  return this;
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
       * @return This builder for chaining.
       */
      public Builder clearDestFeatures() {
        copyOnWrite();
        instance.clearDestFeatures();
        return this;
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
       * @return A list containing the enum numeric values on the wire for destFeatures.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
      getDestFeaturesValueList() {
        return java.util.Collections.unmodifiableList(
            instance.getDestFeaturesValueList());
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
       * @param index The index of the value to return.
       * @return The enum numeric value on the wire of destFeatures at the given index.
       */
      @java.lang.Override
      public int getDestFeaturesValue(int index) {
        return instance.getDestFeaturesValue(index);
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
       * @param index The index to set the value at.
       * @param value The enum numeric value on the wire for destFeatures to set.
       * @return This builder for chaining.
       */
      public Builder setDestFeaturesValue(
          int index, int value) {
        copyOnWrite();
        instance.setDestFeaturesValue(index, value);
        return this;
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
       * @param value The enum numeric value on the wire for destFeatures to add.
       * @return This builder for chaining.
       */
      public Builder addDestFeaturesValue(int value) {
        instance.addDestFeaturesValue(value);
        return this;
      }
      /**
       * <pre>
       *Features assumed to be supported by the final node. All transitive feature
       *dependencies must also be set properly. For a given feature bit pair, either
       *optional or remote may be set, but not both. If this field is nil or empty,
       *the router will try to load destination features from the graph as a
       *fallback.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.FeatureBit dest_features = 17;</code>
       * @param values The enum numeric values on the wire for destFeatures to add.
       * @return This builder for chaining.
       */
      public Builder addAllDestFeaturesValue(
          java.lang.Iterable<java.lang.Integer> values) {
        copyOnWrite();
        instance.addAllDestFeaturesValue(values);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.QueryRoutesRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.QueryRoutesRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "pubKey_",
              "amt_",
              "finalCltvDelta_",
              "feeLimit_",
              "ignoredNodes_",
              "ignoredEdges_",
              co.anode.anodium.Rpc.EdgeLocator.class,
              "sourcePubKey_",
              "useMissionControl_",
              "ignoredPairs_",
              co.anode.anodium.Rpc.NodePair.class,
              "cltvLimit_",
              "amtMsat_",
              "destCustomRecords_",
              DestCustomRecordsDefaultEntryHolder.defaultEntry,
              "outgoingChanId_",
              "lastHopPubkey_",
              "routeHints_",
              co.anode.anodium.Rpc.RouteHint.class,
              "destFeatures_",
            };
            java.lang.String info =
                "\u0000\u0010\u0000\u0000\u0001\u0011\u0010\u0001\u0005\u0000\u0001\u0208\u0002\u0002" +
                "\u0004\u0004\u0005\t\u0006\u001c\u0007\u001b\b\u0208\t\u0007\n\u001b\u000b\u000b" +
                "\f\u0002\r2\u000e\u0003\u000f\n\u0010\u001b\u0011,";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.QueryRoutesRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.QueryRoutesRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.QueryRoutesRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.QueryRoutesRequest)
    private static final co.anode.anodium.Rpc.QueryRoutesRequest DEFAULT_INSTANCE;
    static {
      QueryRoutesRequest defaultInstance = new QueryRoutesRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        QueryRoutesRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.QueryRoutesRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<QueryRoutesRequest> PARSER;

    public static com.google.protobuf.Parser<QueryRoutesRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface NodePairOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.NodePair)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The sending node of the pair. When using REST, this field must be encoded as
     *base64.
     * </pre>
     *
     * <code>bytes from = 1;</code>
     * @return The from.
     */
    com.google.protobuf.ByteString getFrom();

    /**
     * <pre>
     *The receiving node of the pair. When using REST, this field must be encoded
     *as base64.
     * </pre>
     *
     * <code>bytes to = 2;</code>
     * @return The to.
     */
    com.google.protobuf.ByteString getTo();
  }
  /**
   * Protobuf type {@code co.anode.anodium.NodePair}
   */
  public  static final class NodePair extends
      com.google.protobuf.GeneratedMessageLite<
          NodePair, NodePair.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.NodePair)
      NodePairOrBuilder {
    private NodePair() {
      from_ = com.google.protobuf.ByteString.EMPTY;
      to_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int FROM_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString from_;
    /**
     * <pre>
     *The sending node of the pair. When using REST, this field must be encoded as
     *base64.
     * </pre>
     *
     * <code>bytes from = 1;</code>
     * @return The from.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getFrom() {
      return from_;
    }
    /**
     * <pre>
     *The sending node of the pair. When using REST, this field must be encoded as
     *base64.
     * </pre>
     *
     * <code>bytes from = 1;</code>
     * @param value The from to set.
     */
    private void setFrom(com.google.protobuf.ByteString value) {
      value.getClass();
  
      from_ = value;
    }
    /**
     * <pre>
     *The sending node of the pair. When using REST, this field must be encoded as
     *base64.
     * </pre>
     *
     * <code>bytes from = 1;</code>
     */
    private void clearFrom() {
      
      from_ = getDefaultInstance().getFrom();
    }

    public static final int TO_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString to_;
    /**
     * <pre>
     *The receiving node of the pair. When using REST, this field must be encoded
     *as base64.
     * </pre>
     *
     * <code>bytes to = 2;</code>
     * @return The to.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getTo() {
      return to_;
    }
    /**
     * <pre>
     *The receiving node of the pair. When using REST, this field must be encoded
     *as base64.
     * </pre>
     *
     * <code>bytes to = 2;</code>
     * @param value The to to set.
     */
    private void setTo(com.google.protobuf.ByteString value) {
      value.getClass();
  
      to_ = value;
    }
    /**
     * <pre>
     *The receiving node of the pair. When using REST, this field must be encoded
     *as base64.
     * </pre>
     *
     * <code>bytes to = 2;</code>
     */
    private void clearTo() {
      
      to_ = getDefaultInstance().getTo();
    }

    public static co.anode.anodium.Rpc.NodePair parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodePair parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodePair parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodePair parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodePair parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodePair parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodePair parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodePair parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodePair parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodePair parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodePair parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodePair parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.NodePair prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.NodePair}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.NodePair, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.NodePair)
        co.anode.anodium.Rpc.NodePairOrBuilder {
      // Construct using co.anode.anodium.Rpc.NodePair.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The sending node of the pair. When using REST, this field must be encoded as
       *base64.
       * </pre>
       *
       * <code>bytes from = 1;</code>
       * @return The from.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getFrom() {
        return instance.getFrom();
      }
      /**
       * <pre>
       *The sending node of the pair. When using REST, this field must be encoded as
       *base64.
       * </pre>
       *
       * <code>bytes from = 1;</code>
       * @param value The from to set.
       * @return This builder for chaining.
       */
      public Builder setFrom(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setFrom(value);
        return this;
      }
      /**
       * <pre>
       *The sending node of the pair. When using REST, this field must be encoded as
       *base64.
       * </pre>
       *
       * <code>bytes from = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearFrom() {
        copyOnWrite();
        instance.clearFrom();
        return this;
      }

      /**
       * <pre>
       *The receiving node of the pair. When using REST, this field must be encoded
       *as base64.
       * </pre>
       *
       * <code>bytes to = 2;</code>
       * @return The to.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getTo() {
        return instance.getTo();
      }
      /**
       * <pre>
       *The receiving node of the pair. When using REST, this field must be encoded
       *as base64.
       * </pre>
       *
       * <code>bytes to = 2;</code>
       * @param value The to to set.
       * @return This builder for chaining.
       */
      public Builder setTo(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTo(value);
        return this;
      }
      /**
       * <pre>
       *The receiving node of the pair. When using REST, this field must be encoded
       *as base64.
       * </pre>
       *
       * <code>bytes to = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearTo() {
        copyOnWrite();
        instance.clearTo();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.NodePair)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.NodePair();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "from_",
              "to_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\n\u0002\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.NodePair> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.NodePair.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.NodePair>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.NodePair)
    private static final co.anode.anodium.Rpc.NodePair DEFAULT_INSTANCE;
    static {
      NodePair defaultInstance = new NodePair();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        NodePair.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.NodePair getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<NodePair> PARSER;

    public static com.google.protobuf.Parser<NodePair> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface EdgeLocatorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.EdgeLocator)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The short channel id of this edge.
     * </pre>
     *
     * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
     * @return The channelId.
     */
    long getChannelId();

    /**
     * <pre>
     *The direction of this edge. If direction_reverse is false, the direction
     *of this edge is from the channel endpoint with the lexicographically smaller
     *pub key to the endpoint with the larger pub key. If direction_reverse is
     *is true, the edge goes the other way.
     * </pre>
     *
     * <code>bool direction_reverse = 2;</code>
     * @return The directionReverse.
     */
    boolean getDirectionReverse();
  }
  /**
   * Protobuf type {@code co.anode.anodium.EdgeLocator}
   */
  public  static final class EdgeLocator extends
      com.google.protobuf.GeneratedMessageLite<
          EdgeLocator, EdgeLocator.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.EdgeLocator)
      EdgeLocatorOrBuilder {
    private EdgeLocator() {
    }
    public static final int CHANNEL_ID_FIELD_NUMBER = 1;
    private long channelId_;
    /**
     * <pre>
     * The short channel id of this edge.
     * </pre>
     *
     * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
     * @return The channelId.
     */
    @java.lang.Override
    public long getChannelId() {
      return channelId_;
    }
    /**
     * <pre>
     * The short channel id of this edge.
     * </pre>
     *
     * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
     * @param value The channelId to set.
     */
    private void setChannelId(long value) {
      
      channelId_ = value;
    }
    /**
     * <pre>
     * The short channel id of this edge.
     * </pre>
     *
     * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
     */
    private void clearChannelId() {
      
      channelId_ = 0L;
    }

    public static final int DIRECTION_REVERSE_FIELD_NUMBER = 2;
    private boolean directionReverse_;
    /**
     * <pre>
     *The direction of this edge. If direction_reverse is false, the direction
     *of this edge is from the channel endpoint with the lexicographically smaller
     *pub key to the endpoint with the larger pub key. If direction_reverse is
     *is true, the edge goes the other way.
     * </pre>
     *
     * <code>bool direction_reverse = 2;</code>
     * @return The directionReverse.
     */
    @java.lang.Override
    public boolean getDirectionReverse() {
      return directionReverse_;
    }
    /**
     * <pre>
     *The direction of this edge. If direction_reverse is false, the direction
     *of this edge is from the channel endpoint with the lexicographically smaller
     *pub key to the endpoint with the larger pub key. If direction_reverse is
     *is true, the edge goes the other way.
     * </pre>
     *
     * <code>bool direction_reverse = 2;</code>
     * @param value The directionReverse to set.
     */
    private void setDirectionReverse(boolean value) {
      
      directionReverse_ = value;
    }
    /**
     * <pre>
     *The direction of this edge. If direction_reverse is false, the direction
     *of this edge is from the channel endpoint with the lexicographically smaller
     *pub key to the endpoint with the larger pub key. If direction_reverse is
     *is true, the edge goes the other way.
     * </pre>
     *
     * <code>bool direction_reverse = 2;</code>
     */
    private void clearDirectionReverse() {
      
      directionReverse_ = false;
    }

    public static co.anode.anodium.Rpc.EdgeLocator parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.EdgeLocator parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.EdgeLocator parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.EdgeLocator parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.EdgeLocator parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.EdgeLocator parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.EdgeLocator parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.EdgeLocator parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.EdgeLocator parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.EdgeLocator parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.EdgeLocator parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.EdgeLocator parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.EdgeLocator prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.EdgeLocator}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.EdgeLocator, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.EdgeLocator)
        co.anode.anodium.Rpc.EdgeLocatorOrBuilder {
      // Construct using co.anode.anodium.Rpc.EdgeLocator.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The short channel id of this edge.
       * </pre>
       *
       * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
       * @return The channelId.
       */
      @java.lang.Override
      public long getChannelId() {
        return instance.getChannelId();
      }
      /**
       * <pre>
       * The short channel id of this edge.
       * </pre>
       *
       * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
       * @param value The channelId to set.
       * @return This builder for chaining.
       */
      public Builder setChannelId(long value) {
        copyOnWrite();
        instance.setChannelId(value);
        return this;
      }
      /**
       * <pre>
       * The short channel id of this edge.
       * </pre>
       *
       * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearChannelId() {
        copyOnWrite();
        instance.clearChannelId();
        return this;
      }

      /**
       * <pre>
       *The direction of this edge. If direction_reverse is false, the direction
       *of this edge is from the channel endpoint with the lexicographically smaller
       *pub key to the endpoint with the larger pub key. If direction_reverse is
       *is true, the edge goes the other way.
       * </pre>
       *
       * <code>bool direction_reverse = 2;</code>
       * @return The directionReverse.
       */
      @java.lang.Override
      public boolean getDirectionReverse() {
        return instance.getDirectionReverse();
      }
      /**
       * <pre>
       *The direction of this edge. If direction_reverse is false, the direction
       *of this edge is from the channel endpoint with the lexicographically smaller
       *pub key to the endpoint with the larger pub key. If direction_reverse is
       *is true, the edge goes the other way.
       * </pre>
       *
       * <code>bool direction_reverse = 2;</code>
       * @param value The directionReverse to set.
       * @return This builder for chaining.
       */
      public Builder setDirectionReverse(boolean value) {
        copyOnWrite();
        instance.setDirectionReverse(value);
        return this;
      }
      /**
       * <pre>
       *The direction of this edge. If direction_reverse is false, the direction
       *of this edge is from the channel endpoint with the lexicographically smaller
       *pub key to the endpoint with the larger pub key. If direction_reverse is
       *is true, the edge goes the other way.
       * </pre>
       *
       * <code>bool direction_reverse = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearDirectionReverse() {
        copyOnWrite();
        instance.clearDirectionReverse();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.EdgeLocator)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.EdgeLocator();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "channelId_",
              "directionReverse_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0003\u0002\u0007" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.EdgeLocator> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.EdgeLocator.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.EdgeLocator>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.EdgeLocator)
    private static final co.anode.anodium.Rpc.EdgeLocator DEFAULT_INSTANCE;
    static {
      EdgeLocator defaultInstance = new EdgeLocator();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        EdgeLocator.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.EdgeLocator getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<EdgeLocator> PARSER;

    public static com.google.protobuf.Parser<EdgeLocator> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface QueryRoutesResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.QueryRoutesResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The route that results from the path finding operation. This is still a
     *repeated field to retain backwards compatibility.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Route routes = 1;</code>
     */
    java.util.List<co.anode.anodium.Rpc.Route> 
        getRoutesList();
    /**
     * <pre>
     *The route that results from the path finding operation. This is still a
     *repeated field to retain backwards compatibility.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Route routes = 1;</code>
     */
    co.anode.anodium.Rpc.Route getRoutes(int index);
    /**
     * <pre>
     *The route that results from the path finding operation. This is still a
     *repeated field to retain backwards compatibility.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Route routes = 1;</code>
     */
    int getRoutesCount();

    /**
     * <pre>
     *The success probability of the returned route based on the current mission
     *control state. [EXPERIMENTAL]
     * </pre>
     *
     * <code>double success_prob = 2;</code>
     * @return The successProb.
     */
    double getSuccessProb();
  }
  /**
   * Protobuf type {@code co.anode.anodium.QueryRoutesResponse}
   */
  public  static final class QueryRoutesResponse extends
      com.google.protobuf.GeneratedMessageLite<
          QueryRoutesResponse, QueryRoutesResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.QueryRoutesResponse)
      QueryRoutesResponseOrBuilder {
    private QueryRoutesResponse() {
      routes_ = emptyProtobufList();
    }
    public static final int ROUTES_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Route> routes_;
    /**
     * <pre>
     *The route that results from the path finding operation. This is still a
     *repeated field to retain backwards compatibility.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Route routes = 1;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.Route> getRoutesList() {
      return routes_;
    }
    /**
     * <pre>
     *The route that results from the path finding operation. This is still a
     *repeated field to retain backwards compatibility.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Route routes = 1;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.RouteOrBuilder> 
        getRoutesOrBuilderList() {
      return routes_;
    }
    /**
     * <pre>
     *The route that results from the path finding operation. This is still a
     *repeated field to retain backwards compatibility.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Route routes = 1;</code>
     */
    @java.lang.Override
    public int getRoutesCount() {
      return routes_.size();
    }
    /**
     * <pre>
     *The route that results from the path finding operation. This is still a
     *repeated field to retain backwards compatibility.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Route routes = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Route getRoutes(int index) {
      return routes_.get(index);
    }
    /**
     * <pre>
     *The route that results from the path finding operation. This is still a
     *repeated field to retain backwards compatibility.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Route routes = 1;</code>
     */
    public co.anode.anodium.Rpc.RouteOrBuilder getRoutesOrBuilder(
        int index) {
      return routes_.get(index);
    }
    private void ensureRoutesIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Route> tmp = routes_;
      if (!tmp.isModifiable()) {
        routes_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     *The route that results from the path finding operation. This is still a
     *repeated field to retain backwards compatibility.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Route routes = 1;</code>
     */
    private void setRoutes(
        int index, co.anode.anodium.Rpc.Route value) {
      value.getClass();
  ensureRoutesIsMutable();
      routes_.set(index, value);
    }
    /**
     * <pre>
     *The route that results from the path finding operation. This is still a
     *repeated field to retain backwards compatibility.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Route routes = 1;</code>
     */
    private void addRoutes(co.anode.anodium.Rpc.Route value) {
      value.getClass();
  ensureRoutesIsMutable();
      routes_.add(value);
    }
    /**
     * <pre>
     *The route that results from the path finding operation. This is still a
     *repeated field to retain backwards compatibility.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Route routes = 1;</code>
     */
    private void addRoutes(
        int index, co.anode.anodium.Rpc.Route value) {
      value.getClass();
  ensureRoutesIsMutable();
      routes_.add(index, value);
    }
    /**
     * <pre>
     *The route that results from the path finding operation. This is still a
     *repeated field to retain backwards compatibility.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Route routes = 1;</code>
     */
    private void addAllRoutes(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.Route> values) {
      ensureRoutesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, routes_);
    }
    /**
     * <pre>
     *The route that results from the path finding operation. This is still a
     *repeated field to retain backwards compatibility.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Route routes = 1;</code>
     */
    private void clearRoutes() {
      routes_ = emptyProtobufList();
    }
    /**
     * <pre>
     *The route that results from the path finding operation. This is still a
     *repeated field to retain backwards compatibility.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Route routes = 1;</code>
     */
    private void removeRoutes(int index) {
      ensureRoutesIsMutable();
      routes_.remove(index);
    }

    public static final int SUCCESS_PROB_FIELD_NUMBER = 2;
    private double successProb_;
    /**
     * <pre>
     *The success probability of the returned route based on the current mission
     *control state. [EXPERIMENTAL]
     * </pre>
     *
     * <code>double success_prob = 2;</code>
     * @return The successProb.
     */
    @java.lang.Override
    public double getSuccessProb() {
      return successProb_;
    }
    /**
     * <pre>
     *The success probability of the returned route based on the current mission
     *control state. [EXPERIMENTAL]
     * </pre>
     *
     * <code>double success_prob = 2;</code>
     * @param value The successProb to set.
     */
    private void setSuccessProb(double value) {
      
      successProb_ = value;
    }
    /**
     * <pre>
     *The success probability of the returned route based on the current mission
     *control state. [EXPERIMENTAL]
     * </pre>
     *
     * <code>double success_prob = 2;</code>
     */
    private void clearSuccessProb() {
      
      successProb_ = 0D;
    }

    public static co.anode.anodium.Rpc.QueryRoutesResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.QueryRoutesResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.QueryRoutesResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.QueryRoutesResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.QueryRoutesResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.QueryRoutesResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.QueryRoutesResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.QueryRoutesResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.QueryRoutesResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.QueryRoutesResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.QueryRoutesResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.QueryRoutesResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.QueryRoutesResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.QueryRoutesResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.QueryRoutesResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.QueryRoutesResponse)
        co.anode.anodium.Rpc.QueryRoutesResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.QueryRoutesResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The route that results from the path finding operation. This is still a
       *repeated field to retain backwards compatibility.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Route routes = 1;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.Route> getRoutesList() {
        return java.util.Collections.unmodifiableList(
            instance.getRoutesList());
      }
      /**
       * <pre>
       *The route that results from the path finding operation. This is still a
       *repeated field to retain backwards compatibility.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Route routes = 1;</code>
       */
      @java.lang.Override
      public int getRoutesCount() {
        return instance.getRoutesCount();
      }/**
       * <pre>
       *The route that results from the path finding operation. This is still a
       *repeated field to retain backwards compatibility.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Route routes = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Route getRoutes(int index) {
        return instance.getRoutes(index);
      }
      /**
       * <pre>
       *The route that results from the path finding operation. This is still a
       *repeated field to retain backwards compatibility.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Route routes = 1;</code>
       */
      public Builder setRoutes(
          int index, co.anode.anodium.Rpc.Route value) {
        copyOnWrite();
        instance.setRoutes(index, value);
        return this;
      }
      /**
       * <pre>
       *The route that results from the path finding operation. This is still a
       *repeated field to retain backwards compatibility.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Route routes = 1;</code>
       */
      public Builder setRoutes(
          int index, co.anode.anodium.Rpc.Route.Builder builderForValue) {
        copyOnWrite();
        instance.setRoutes(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *The route that results from the path finding operation. This is still a
       *repeated field to retain backwards compatibility.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Route routes = 1;</code>
       */
      public Builder addRoutes(co.anode.anodium.Rpc.Route value) {
        copyOnWrite();
        instance.addRoutes(value);
        return this;
      }
      /**
       * <pre>
       *The route that results from the path finding operation. This is still a
       *repeated field to retain backwards compatibility.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Route routes = 1;</code>
       */
      public Builder addRoutes(
          int index, co.anode.anodium.Rpc.Route value) {
        copyOnWrite();
        instance.addRoutes(index, value);
        return this;
      }
      /**
       * <pre>
       *The route that results from the path finding operation. This is still a
       *repeated field to retain backwards compatibility.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Route routes = 1;</code>
       */
      public Builder addRoutes(
          co.anode.anodium.Rpc.Route.Builder builderForValue) {
        copyOnWrite();
        instance.addRoutes(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *The route that results from the path finding operation. This is still a
       *repeated field to retain backwards compatibility.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Route routes = 1;</code>
       */
      public Builder addRoutes(
          int index, co.anode.anodium.Rpc.Route.Builder builderForValue) {
        copyOnWrite();
        instance.addRoutes(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *The route that results from the path finding operation. This is still a
       *repeated field to retain backwards compatibility.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Route routes = 1;</code>
       */
      public Builder addAllRoutes(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.Route> values) {
        copyOnWrite();
        instance.addAllRoutes(values);
        return this;
      }
      /**
       * <pre>
       *The route that results from the path finding operation. This is still a
       *repeated field to retain backwards compatibility.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Route routes = 1;</code>
       */
      public Builder clearRoutes() {
        copyOnWrite();
        instance.clearRoutes();
        return this;
      }
      /**
       * <pre>
       *The route that results from the path finding operation. This is still a
       *repeated field to retain backwards compatibility.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Route routes = 1;</code>
       */
      public Builder removeRoutes(int index) {
        copyOnWrite();
        instance.removeRoutes(index);
        return this;
      }

      /**
       * <pre>
       *The success probability of the returned route based on the current mission
       *control state. [EXPERIMENTAL]
       * </pre>
       *
       * <code>double success_prob = 2;</code>
       * @return The successProb.
       */
      @java.lang.Override
      public double getSuccessProb() {
        return instance.getSuccessProb();
      }
      /**
       * <pre>
       *The success probability of the returned route based on the current mission
       *control state. [EXPERIMENTAL]
       * </pre>
       *
       * <code>double success_prob = 2;</code>
       * @param value The successProb to set.
       * @return This builder for chaining.
       */
      public Builder setSuccessProb(double value) {
        copyOnWrite();
        instance.setSuccessProb(value);
        return this;
      }
      /**
       * <pre>
       *The success probability of the returned route based on the current mission
       *control state. [EXPERIMENTAL]
       * </pre>
       *
       * <code>double success_prob = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSuccessProb() {
        copyOnWrite();
        instance.clearSuccessProb();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.QueryRoutesResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.QueryRoutesResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "routes_",
              co.anode.anodium.Rpc.Route.class,
              "successProb_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0001\u0000\u0001\u001b\u0002\u0000" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.QueryRoutesResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.QueryRoutesResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.QueryRoutesResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.QueryRoutesResponse)
    private static final co.anode.anodium.Rpc.QueryRoutesResponse DEFAULT_INSTANCE;
    static {
      QueryRoutesResponse defaultInstance = new QueryRoutesResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        QueryRoutesResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.QueryRoutesResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<QueryRoutesResponse> PARSER;

    public static com.google.protobuf.Parser<QueryRoutesResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface HopOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.Hop)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    long getChanId();

    /**
     * <code>int64 chan_capacity = 2;</code>
     * @return The chanCapacity.
     */
    long getChanCapacity();

    /**
     * <code>int64 amt_to_forward = 3 [deprecated = true];</code>
     * @return The amtToForward.
     */
    @java.lang.Deprecated long getAmtToForward();

    /**
     * <code>int64 fee = 4 [deprecated = true];</code>
     * @return The fee.
     */
    @java.lang.Deprecated long getFee();

    /**
     * <code>uint32 expiry = 5;</code>
     * @return The expiry.
     */
    int getExpiry();

    /**
     * <code>int64 amt_to_forward_msat = 6;</code>
     * @return The amtToForwardMsat.
     */
    long getAmtToForwardMsat();

    /**
     * <code>int64 fee_msat = 7;</code>
     * @return The feeMsat.
     */
    long getFeeMsat();

    /**
     * <pre>
     *An optional public key of the hop. If the public key is given, the payment
     *can be executed without relying on a copy of the channel graph.
     * </pre>
     *
     * <code>string pub_key = 8;</code>
     * @return The pubKey.
     */
    java.lang.String getPubKey();
    /**
     * <pre>
     *An optional public key of the hop. If the public key is given, the payment
     *can be executed without relying on a copy of the channel graph.
     * </pre>
     *
     * <code>string pub_key = 8;</code>
     * @return The bytes for pubKey.
     */
    com.google.protobuf.ByteString
        getPubKeyBytes();

    /**
     * <pre>
     *If set to true, then this hop will be encoded using the new variable length
     *TLV format. Note that if any custom tlv_records below are specified, then
     *this field MUST be set to true for them to be encoded properly.
     * </pre>
     *
     * <code>bool tlv_payload = 9;</code>
     * @return The tlvPayload.
     */
    boolean getTlvPayload();

    /**
     * <pre>
     *An optional TLV record that signals the use of an MPP payment. If present,
     *the receiver will enforce that that the same mpp_record is included in the
     *final hop payload of all non-zero payments in the HTLC set. If empty, a
     *regular single-shot payment is or was attempted.
     * </pre>
     *
     * <code>.co.anode.anodium.MPPRecord mpp_record = 10;</code>
     * @return Whether the mppRecord field is set.
     */
    boolean hasMppRecord();
    /**
     * <pre>
     *An optional TLV record that signals the use of an MPP payment. If present,
     *the receiver will enforce that that the same mpp_record is included in the
     *final hop payload of all non-zero payments in the HTLC set. If empty, a
     *regular single-shot payment is or was attempted.
     * </pre>
     *
     * <code>.co.anode.anodium.MPPRecord mpp_record = 10;</code>
     * @return The mppRecord.
     */
    co.anode.anodium.Rpc.MPPRecord getMppRecord();

    /**
     * <pre>
     *An optional set of key-value TLV records. This is useful within the context
     *of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
     *to drop off at each hop within the onion.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 11;</code>
     */
    int getCustomRecordsCount();
    /**
     * <pre>
     *An optional set of key-value TLV records. This is useful within the context
     *of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
     *to drop off at each hop within the onion.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 11;</code>
     */
    boolean containsCustomRecords(
        long key);
    /**
     * Use {@link #getCustomRecordsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Long, com.google.protobuf.ByteString>
    getCustomRecords();
    /**
     * <pre>
     *An optional set of key-value TLV records. This is useful within the context
     *of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
     *to drop off at each hop within the onion.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 11;</code>
     */
    java.util.Map<java.lang.Long, com.google.protobuf.ByteString>
    getCustomRecordsMap();
    /**
     * <pre>
     *An optional set of key-value TLV records. This is useful within the context
     *of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
     *to drop off at each hop within the onion.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 11;</code>
     */

    com.google.protobuf.ByteString getCustomRecordsOrDefault(
        long key,
        com.google.protobuf.ByteString defaultValue);
    /**
     * <pre>
     *An optional set of key-value TLV records. This is useful within the context
     *of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
     *to drop off at each hop within the onion.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 11;</code>
     */

    com.google.protobuf.ByteString getCustomRecordsOrThrow(
        long key);
  }
  /**
   * Protobuf type {@code co.anode.anodium.Hop}
   */
  public  static final class Hop extends
      com.google.protobuf.GeneratedMessageLite<
          Hop, Hop.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.Hop)
      HopOrBuilder {
    private Hop() {
      pubKey_ = "";
    }
    public static final int CHAN_ID_FIELD_NUMBER = 1;
    private long chanId_;
    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    @java.lang.Override
    public long getChanId() {
      return chanId_;
    }
    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     * @param value The chanId to set.
     */
    private void setChanId(long value) {
      
      chanId_ = value;
    }
    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     */
    private void clearChanId() {
      
      chanId_ = 0L;
    }

    public static final int CHAN_CAPACITY_FIELD_NUMBER = 2;
    private long chanCapacity_;
    /**
     * <code>int64 chan_capacity = 2;</code>
     * @return The chanCapacity.
     */
    @java.lang.Override
    public long getChanCapacity() {
      return chanCapacity_;
    }
    /**
     * <code>int64 chan_capacity = 2;</code>
     * @param value The chanCapacity to set.
     */
    private void setChanCapacity(long value) {
      
      chanCapacity_ = value;
    }
    /**
     * <code>int64 chan_capacity = 2;</code>
     */
    private void clearChanCapacity() {
      
      chanCapacity_ = 0L;
    }

    public static final int AMT_TO_FORWARD_FIELD_NUMBER = 3;
    private long amtToForward_;
    /**
     * <code>int64 amt_to_forward = 3 [deprecated = true];</code>
     * @return The amtToForward.
     */
    @java.lang.Override
    @java.lang.Deprecated public long getAmtToForward() {
      return amtToForward_;
    }
    /**
     * <code>int64 amt_to_forward = 3 [deprecated = true];</code>
     * @param value The amtToForward to set.
     */
    private void setAmtToForward(long value) {
      
      amtToForward_ = value;
    }
    /**
     * <code>int64 amt_to_forward = 3 [deprecated = true];</code>
     */
    private void clearAmtToForward() {
      
      amtToForward_ = 0L;
    }

    public static final int FEE_FIELD_NUMBER = 4;
    private long fee_;
    /**
     * <code>int64 fee = 4 [deprecated = true];</code>
     * @return The fee.
     */
    @java.lang.Override
    @java.lang.Deprecated public long getFee() {
      return fee_;
    }
    /**
     * <code>int64 fee = 4 [deprecated = true];</code>
     * @param value The fee to set.
     */
    private void setFee(long value) {
      
      fee_ = value;
    }
    /**
     * <code>int64 fee = 4 [deprecated = true];</code>
     */
    private void clearFee() {
      
      fee_ = 0L;
    }

    public static final int EXPIRY_FIELD_NUMBER = 5;
    private int expiry_;
    /**
     * <code>uint32 expiry = 5;</code>
     * @return The expiry.
     */
    @java.lang.Override
    public int getExpiry() {
      return expiry_;
    }
    /**
     * <code>uint32 expiry = 5;</code>
     * @param value The expiry to set.
     */
    private void setExpiry(int value) {
      
      expiry_ = value;
    }
    /**
     * <code>uint32 expiry = 5;</code>
     */
    private void clearExpiry() {
      
      expiry_ = 0;
    }

    public static final int AMT_TO_FORWARD_MSAT_FIELD_NUMBER = 6;
    private long amtToForwardMsat_;
    /**
     * <code>int64 amt_to_forward_msat = 6;</code>
     * @return The amtToForwardMsat.
     */
    @java.lang.Override
    public long getAmtToForwardMsat() {
      return amtToForwardMsat_;
    }
    /**
     * <code>int64 amt_to_forward_msat = 6;</code>
     * @param value The amtToForwardMsat to set.
     */
    private void setAmtToForwardMsat(long value) {
      
      amtToForwardMsat_ = value;
    }
    /**
     * <code>int64 amt_to_forward_msat = 6;</code>
     */
    private void clearAmtToForwardMsat() {
      
      amtToForwardMsat_ = 0L;
    }

    public static final int FEE_MSAT_FIELD_NUMBER = 7;
    private long feeMsat_;
    /**
     * <code>int64 fee_msat = 7;</code>
     * @return The feeMsat.
     */
    @java.lang.Override
    public long getFeeMsat() {
      return feeMsat_;
    }
    /**
     * <code>int64 fee_msat = 7;</code>
     * @param value The feeMsat to set.
     */
    private void setFeeMsat(long value) {
      
      feeMsat_ = value;
    }
    /**
     * <code>int64 fee_msat = 7;</code>
     */
    private void clearFeeMsat() {
      
      feeMsat_ = 0L;
    }

    public static final int PUB_KEY_FIELD_NUMBER = 8;
    private java.lang.String pubKey_;
    /**
     * <pre>
     *An optional public key of the hop. If the public key is given, the payment
     *can be executed without relying on a copy of the channel graph.
     * </pre>
     *
     * <code>string pub_key = 8;</code>
     * @return The pubKey.
     */
    @java.lang.Override
    public java.lang.String getPubKey() {
      return pubKey_;
    }
    /**
     * <pre>
     *An optional public key of the hop. If the public key is given, the payment
     *can be executed without relying on a copy of the channel graph.
     * </pre>
     *
     * <code>string pub_key = 8;</code>
     * @return The bytes for pubKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPubKeyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(pubKey_);
    }
    /**
     * <pre>
     *An optional public key of the hop. If the public key is given, the payment
     *can be executed without relying on a copy of the channel graph.
     * </pre>
     *
     * <code>string pub_key = 8;</code>
     * @param value The pubKey to set.
     */
    private void setPubKey(
        java.lang.String value) {
      value.getClass();
  
      pubKey_ = value;
    }
    /**
     * <pre>
     *An optional public key of the hop. If the public key is given, the payment
     *can be executed without relying on a copy of the channel graph.
     * </pre>
     *
     * <code>string pub_key = 8;</code>
     */
    private void clearPubKey() {
      
      pubKey_ = getDefaultInstance().getPubKey();
    }
    /**
     * <pre>
     *An optional public key of the hop. If the public key is given, the payment
     *can be executed without relying on a copy of the channel graph.
     * </pre>
     *
     * <code>string pub_key = 8;</code>
     * @param value The bytes for pubKey to set.
     */
    private void setPubKeyBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      pubKey_ = value.toStringUtf8();
      
    }

    public static final int TLV_PAYLOAD_FIELD_NUMBER = 9;
    private boolean tlvPayload_;
    /**
     * <pre>
     *If set to true, then this hop will be encoded using the new variable length
     *TLV format. Note that if any custom tlv_records below are specified, then
     *this field MUST be set to true for them to be encoded properly.
     * </pre>
     *
     * <code>bool tlv_payload = 9;</code>
     * @return The tlvPayload.
     */
    @java.lang.Override
    public boolean getTlvPayload() {
      return tlvPayload_;
    }
    /**
     * <pre>
     *If set to true, then this hop will be encoded using the new variable length
     *TLV format. Note that if any custom tlv_records below are specified, then
     *this field MUST be set to true for them to be encoded properly.
     * </pre>
     *
     * <code>bool tlv_payload = 9;</code>
     * @param value The tlvPayload to set.
     */
    private void setTlvPayload(boolean value) {
      
      tlvPayload_ = value;
    }
    /**
     * <pre>
     *If set to true, then this hop will be encoded using the new variable length
     *TLV format. Note that if any custom tlv_records below are specified, then
     *this field MUST be set to true for them to be encoded properly.
     * </pre>
     *
     * <code>bool tlv_payload = 9;</code>
     */
    private void clearTlvPayload() {
      
      tlvPayload_ = false;
    }

    public static final int MPP_RECORD_FIELD_NUMBER = 10;
    private co.anode.anodium.Rpc.MPPRecord mppRecord_;
    /**
     * <pre>
     *An optional TLV record that signals the use of an MPP payment. If present,
     *the receiver will enforce that that the same mpp_record is included in the
     *final hop payload of all non-zero payments in the HTLC set. If empty, a
     *regular single-shot payment is or was attempted.
     * </pre>
     *
     * <code>.co.anode.anodium.MPPRecord mpp_record = 10;</code>
     */
    @java.lang.Override
    public boolean hasMppRecord() {
      return mppRecord_ != null;
    }
    /**
     * <pre>
     *An optional TLV record that signals the use of an MPP payment. If present,
     *the receiver will enforce that that the same mpp_record is included in the
     *final hop payload of all non-zero payments in the HTLC set. If empty, a
     *regular single-shot payment is or was attempted.
     * </pre>
     *
     * <code>.co.anode.anodium.MPPRecord mpp_record = 10;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.MPPRecord getMppRecord() {
      return mppRecord_ == null ? co.anode.anodium.Rpc.MPPRecord.getDefaultInstance() : mppRecord_;
    }
    /**
     * <pre>
     *An optional TLV record that signals the use of an MPP payment. If present,
     *the receiver will enforce that that the same mpp_record is included in the
     *final hop payload of all non-zero payments in the HTLC set. If empty, a
     *regular single-shot payment is or was attempted.
     * </pre>
     *
     * <code>.co.anode.anodium.MPPRecord mpp_record = 10;</code>
     */
    private void setMppRecord(co.anode.anodium.Rpc.MPPRecord value) {
      value.getClass();
  mppRecord_ = value;
      
      }
    /**
     * <pre>
     *An optional TLV record that signals the use of an MPP payment. If present,
     *the receiver will enforce that that the same mpp_record is included in the
     *final hop payload of all non-zero payments in the HTLC set. If empty, a
     *regular single-shot payment is or was attempted.
     * </pre>
     *
     * <code>.co.anode.anodium.MPPRecord mpp_record = 10;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeMppRecord(co.anode.anodium.Rpc.MPPRecord value) {
      value.getClass();
  if (mppRecord_ != null &&
          mppRecord_ != co.anode.anodium.Rpc.MPPRecord.getDefaultInstance()) {
        mppRecord_ =
          co.anode.anodium.Rpc.MPPRecord.newBuilder(mppRecord_).mergeFrom(value).buildPartial();
      } else {
        mppRecord_ = value;
      }
      
    }
    /**
     * <pre>
     *An optional TLV record that signals the use of an MPP payment. If present,
     *the receiver will enforce that that the same mpp_record is included in the
     *final hop payload of all non-zero payments in the HTLC set. If empty, a
     *regular single-shot payment is or was attempted.
     * </pre>
     *
     * <code>.co.anode.anodium.MPPRecord mpp_record = 10;</code>
     */
    private void clearMppRecord() {  mppRecord_ = null;
      
    }

    public static final int CUSTOM_RECORDS_FIELD_NUMBER = 11;
    private static final class CustomRecordsDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Long, com.google.protobuf.ByteString> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Long, com.google.protobuf.ByteString>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.UINT64,
                  0L,
                  com.google.protobuf.WireFormat.FieldType.BYTES,
                  com.google.protobuf.ByteString.EMPTY);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Long, com.google.protobuf.ByteString> customRecords_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Long, com.google.protobuf.ByteString>
    internalGetCustomRecords() {
      return customRecords_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Long, com.google.protobuf.ByteString>
    internalGetMutableCustomRecords() {
      if (!customRecords_.isMutable()) {
        customRecords_ = customRecords_.mutableCopy();
      }
      return customRecords_;
    }
    @java.lang.Override

    public int getCustomRecordsCount() {
      return internalGetCustomRecords().size();
    }
    /**
     * <pre>
     *An optional set of key-value TLV records. This is useful within the context
     *of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
     *to drop off at each hop within the onion.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 11;</code>
     */
    @java.lang.Override

    public boolean containsCustomRecords(
        long key) {
      
      return internalGetCustomRecords().containsKey(key);
    }
    /**
     * Use {@link #getCustomRecordsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getCustomRecords() {
      return getCustomRecordsMap();
    }
    /**
     * <pre>
     *An optional set of key-value TLV records. This is useful within the context
     *of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
     *to drop off at each hop within the onion.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 11;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getCustomRecordsMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetCustomRecords());
    }
    /**
     * <pre>
     *An optional set of key-value TLV records. This is useful within the context
     *of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
     *to drop off at each hop within the onion.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 11;</code>
     */
    @java.lang.Override

    public com.google.protobuf.ByteString getCustomRecordsOrDefault(
        long key,
        com.google.protobuf.ByteString defaultValue) {
      
      java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
          internalGetCustomRecords();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     *An optional set of key-value TLV records. This is useful within the context
     *of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
     *to drop off at each hop within the onion.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 11;</code>
     */
    @java.lang.Override

    public com.google.protobuf.ByteString getCustomRecordsOrThrow(
        long key) {
      
      java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
          internalGetCustomRecords();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     *An optional set of key-value TLV records. This is useful within the context
     *of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
     *to drop off at each hop within the onion.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 11;</code>
     */
    private java.util.Map<java.lang.Long, com.google.protobuf.ByteString>
    getMutableCustomRecordsMap() {
      return internalGetMutableCustomRecords();
    }

    public static co.anode.anodium.Rpc.Hop parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Hop parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Hop parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Hop parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Hop parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Hop parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Hop parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Hop parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Hop parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Hop parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Hop parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Hop parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.Hop prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.Hop}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.Hop, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.Hop)
        co.anode.anodium.Rpc.HopOrBuilder {
      // Construct using co.anode.anodium.Rpc.Hop.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The unique channel ID for the channel. The first 3 bytes are the block
       *height, the next 3 the index within the block, and the last 2 bytes are the
       *output index for the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
       * @return The chanId.
       */
      @java.lang.Override
      public long getChanId() {
        return instance.getChanId();
      }
      /**
       * <pre>
       *The unique channel ID for the channel. The first 3 bytes are the block
       *height, the next 3 the index within the block, and the last 2 bytes are the
       *output index for the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
       * @param value The chanId to set.
       * @return This builder for chaining.
       */
      public Builder setChanId(long value) {
        copyOnWrite();
        instance.setChanId(value);
        return this;
      }
      /**
       * <pre>
       *The unique channel ID for the channel. The first 3 bytes are the block
       *height, the next 3 the index within the block, and the last 2 bytes are the
       *output index for the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearChanId() {
        copyOnWrite();
        instance.clearChanId();
        return this;
      }

      /**
       * <code>int64 chan_capacity = 2;</code>
       * @return The chanCapacity.
       */
      @java.lang.Override
      public long getChanCapacity() {
        return instance.getChanCapacity();
      }
      /**
       * <code>int64 chan_capacity = 2;</code>
       * @param value The chanCapacity to set.
       * @return This builder for chaining.
       */
      public Builder setChanCapacity(long value) {
        copyOnWrite();
        instance.setChanCapacity(value);
        return this;
      }
      /**
       * <code>int64 chan_capacity = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearChanCapacity() {
        copyOnWrite();
        instance.clearChanCapacity();
        return this;
      }

      /**
       * <code>int64 amt_to_forward = 3 [deprecated = true];</code>
       * @return The amtToForward.
       */
      @java.lang.Override
      @java.lang.Deprecated public long getAmtToForward() {
        return instance.getAmtToForward();
      }
      /**
       * <code>int64 amt_to_forward = 3 [deprecated = true];</code>
       * @param value The amtToForward to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setAmtToForward(long value) {
        copyOnWrite();
        instance.setAmtToForward(value);
        return this;
      }
      /**
       * <code>int64 amt_to_forward = 3 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearAmtToForward() {
        copyOnWrite();
        instance.clearAmtToForward();
        return this;
      }

      /**
       * <code>int64 fee = 4 [deprecated = true];</code>
       * @return The fee.
       */
      @java.lang.Override
      @java.lang.Deprecated public long getFee() {
        return instance.getFee();
      }
      /**
       * <code>int64 fee = 4 [deprecated = true];</code>
       * @param value The fee to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setFee(long value) {
        copyOnWrite();
        instance.setFee(value);
        return this;
      }
      /**
       * <code>int64 fee = 4 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearFee() {
        copyOnWrite();
        instance.clearFee();
        return this;
      }

      /**
       * <code>uint32 expiry = 5;</code>
       * @return The expiry.
       */
      @java.lang.Override
      public int getExpiry() {
        return instance.getExpiry();
      }
      /**
       * <code>uint32 expiry = 5;</code>
       * @param value The expiry to set.
       * @return This builder for chaining.
       */
      public Builder setExpiry(int value) {
        copyOnWrite();
        instance.setExpiry(value);
        return this;
      }
      /**
       * <code>uint32 expiry = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearExpiry() {
        copyOnWrite();
        instance.clearExpiry();
        return this;
      }

      /**
       * <code>int64 amt_to_forward_msat = 6;</code>
       * @return The amtToForwardMsat.
       */
      @java.lang.Override
      public long getAmtToForwardMsat() {
        return instance.getAmtToForwardMsat();
      }
      /**
       * <code>int64 amt_to_forward_msat = 6;</code>
       * @param value The amtToForwardMsat to set.
       * @return This builder for chaining.
       */
      public Builder setAmtToForwardMsat(long value) {
        copyOnWrite();
        instance.setAmtToForwardMsat(value);
        return this;
      }
      /**
       * <code>int64 amt_to_forward_msat = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmtToForwardMsat() {
        copyOnWrite();
        instance.clearAmtToForwardMsat();
        return this;
      }

      /**
       * <code>int64 fee_msat = 7;</code>
       * @return The feeMsat.
       */
      @java.lang.Override
      public long getFeeMsat() {
        return instance.getFeeMsat();
      }
      /**
       * <code>int64 fee_msat = 7;</code>
       * @param value The feeMsat to set.
       * @return This builder for chaining.
       */
      public Builder setFeeMsat(long value) {
        copyOnWrite();
        instance.setFeeMsat(value);
        return this;
      }
      /**
       * <code>int64 fee_msat = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearFeeMsat() {
        copyOnWrite();
        instance.clearFeeMsat();
        return this;
      }

      /**
       * <pre>
       *An optional public key of the hop. If the public key is given, the payment
       *can be executed without relying on a copy of the channel graph.
       * </pre>
       *
       * <code>string pub_key = 8;</code>
       * @return The pubKey.
       */
      @java.lang.Override
      public java.lang.String getPubKey() {
        return instance.getPubKey();
      }
      /**
       * <pre>
       *An optional public key of the hop. If the public key is given, the payment
       *can be executed without relying on a copy of the channel graph.
       * </pre>
       *
       * <code>string pub_key = 8;</code>
       * @return The bytes for pubKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPubKeyBytes() {
        return instance.getPubKeyBytes();
      }
      /**
       * <pre>
       *An optional public key of the hop. If the public key is given, the payment
       *can be executed without relying on a copy of the channel graph.
       * </pre>
       *
       * <code>string pub_key = 8;</code>
       * @param value The pubKey to set.
       * @return This builder for chaining.
       */
      public Builder setPubKey(
          java.lang.String value) {
        copyOnWrite();
        instance.setPubKey(value);
        return this;
      }
      /**
       * <pre>
       *An optional public key of the hop. If the public key is given, the payment
       *can be executed without relying on a copy of the channel graph.
       * </pre>
       *
       * <code>string pub_key = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearPubKey() {
        copyOnWrite();
        instance.clearPubKey();
        return this;
      }
      /**
       * <pre>
       *An optional public key of the hop. If the public key is given, the payment
       *can be executed without relying on a copy of the channel graph.
       * </pre>
       *
       * <code>string pub_key = 8;</code>
       * @param value The bytes for pubKey to set.
       * @return This builder for chaining.
       */
      public Builder setPubKeyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPubKeyBytes(value);
        return this;
      }

      /**
       * <pre>
       *If set to true, then this hop will be encoded using the new variable length
       *TLV format. Note that if any custom tlv_records below are specified, then
       *this field MUST be set to true for them to be encoded properly.
       * </pre>
       *
       * <code>bool tlv_payload = 9;</code>
       * @return The tlvPayload.
       */
      @java.lang.Override
      public boolean getTlvPayload() {
        return instance.getTlvPayload();
      }
      /**
       * <pre>
       *If set to true, then this hop will be encoded using the new variable length
       *TLV format. Note that if any custom tlv_records below are specified, then
       *this field MUST be set to true for them to be encoded properly.
       * </pre>
       *
       * <code>bool tlv_payload = 9;</code>
       * @param value The tlvPayload to set.
       * @return This builder for chaining.
       */
      public Builder setTlvPayload(boolean value) {
        copyOnWrite();
        instance.setTlvPayload(value);
        return this;
      }
      /**
       * <pre>
       *If set to true, then this hop will be encoded using the new variable length
       *TLV format. Note that if any custom tlv_records below are specified, then
       *this field MUST be set to true for them to be encoded properly.
       * </pre>
       *
       * <code>bool tlv_payload = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearTlvPayload() {
        copyOnWrite();
        instance.clearTlvPayload();
        return this;
      }

      /**
       * <pre>
       *An optional TLV record that signals the use of an MPP payment. If present,
       *the receiver will enforce that that the same mpp_record is included in the
       *final hop payload of all non-zero payments in the HTLC set. If empty, a
       *regular single-shot payment is or was attempted.
       * </pre>
       *
       * <code>.co.anode.anodium.MPPRecord mpp_record = 10;</code>
       */
      @java.lang.Override
      public boolean hasMppRecord() {
        return instance.hasMppRecord();
      }
      /**
       * <pre>
       *An optional TLV record that signals the use of an MPP payment. If present,
       *the receiver will enforce that that the same mpp_record is included in the
       *final hop payload of all non-zero payments in the HTLC set. If empty, a
       *regular single-shot payment is or was attempted.
       * </pre>
       *
       * <code>.co.anode.anodium.MPPRecord mpp_record = 10;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.MPPRecord getMppRecord() {
        return instance.getMppRecord();
      }
      /**
       * <pre>
       *An optional TLV record that signals the use of an MPP payment. If present,
       *the receiver will enforce that that the same mpp_record is included in the
       *final hop payload of all non-zero payments in the HTLC set. If empty, a
       *regular single-shot payment is or was attempted.
       * </pre>
       *
       * <code>.co.anode.anodium.MPPRecord mpp_record = 10;</code>
       */
      public Builder setMppRecord(co.anode.anodium.Rpc.MPPRecord value) {
        copyOnWrite();
        instance.setMppRecord(value);
        return this;
        }
      /**
       * <pre>
       *An optional TLV record that signals the use of an MPP payment. If present,
       *the receiver will enforce that that the same mpp_record is included in the
       *final hop payload of all non-zero payments in the HTLC set. If empty, a
       *regular single-shot payment is or was attempted.
       * </pre>
       *
       * <code>.co.anode.anodium.MPPRecord mpp_record = 10;</code>
       */
      public Builder setMppRecord(
          co.anode.anodium.Rpc.MPPRecord.Builder builderForValue) {
        copyOnWrite();
        instance.setMppRecord(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *An optional TLV record that signals the use of an MPP payment. If present,
       *the receiver will enforce that that the same mpp_record is included in the
       *final hop payload of all non-zero payments in the HTLC set. If empty, a
       *regular single-shot payment is or was attempted.
       * </pre>
       *
       * <code>.co.anode.anodium.MPPRecord mpp_record = 10;</code>
       */
      public Builder mergeMppRecord(co.anode.anodium.Rpc.MPPRecord value) {
        copyOnWrite();
        instance.mergeMppRecord(value);
        return this;
      }
      /**
       * <pre>
       *An optional TLV record that signals the use of an MPP payment. If present,
       *the receiver will enforce that that the same mpp_record is included in the
       *final hop payload of all non-zero payments in the HTLC set. If empty, a
       *regular single-shot payment is or was attempted.
       * </pre>
       *
       * <code>.co.anode.anodium.MPPRecord mpp_record = 10;</code>
       */
      public Builder clearMppRecord() {  copyOnWrite();
        instance.clearMppRecord();
        return this;
      }

      @java.lang.Override

      public int getCustomRecordsCount() {
        return instance.getCustomRecordsMap().size();
      }
      /**
       * <pre>
       *An optional set of key-value TLV records. This is useful within the context
       *of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
       *to drop off at each hop within the onion.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; custom_records = 11;</code>
       */
      @java.lang.Override

      public boolean containsCustomRecords(
          long key) {
        
        return instance.getCustomRecordsMap().containsKey(key);
      }

      public Builder clearCustomRecords() {
        copyOnWrite();
        instance.getMutableCustomRecordsMap().clear();
        return this;
      }
      /**
       * <pre>
       *An optional set of key-value TLV records. This is useful within the context
       *of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
       *to drop off at each hop within the onion.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; custom_records = 11;</code>
       */

      public Builder removeCustomRecords(
          long key) {
        
        copyOnWrite();
        instance.getMutableCustomRecordsMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getCustomRecordsMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getCustomRecords() {
        return getCustomRecordsMap();
      }
      /**
       * <pre>
       *An optional set of key-value TLV records. This is useful within the context
       *of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
       *to drop off at each hop within the onion.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; custom_records = 11;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getCustomRecordsMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getCustomRecordsMap());
      }
      /**
       * <pre>
       *An optional set of key-value TLV records. This is useful within the context
       *of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
       *to drop off at each hop within the onion.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; custom_records = 11;</code>
       */
      @java.lang.Override

      public com.google.protobuf.ByteString getCustomRecordsOrDefault(
          long key,
          com.google.protobuf.ByteString defaultValue) {
        
        java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
            instance.getCustomRecordsMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       *An optional set of key-value TLV records. This is useful within the context
       *of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
       *to drop off at each hop within the onion.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; custom_records = 11;</code>
       */
      @java.lang.Override

      public com.google.protobuf.ByteString getCustomRecordsOrThrow(
          long key) {
        
        java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
            instance.getCustomRecordsMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       *An optional set of key-value TLV records. This is useful within the context
       *of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
       *to drop off at each hop within the onion.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; custom_records = 11;</code>
       */
      public Builder putCustomRecords(
          long key,
          com.google.protobuf.ByteString value) {
        
        value.getClass();
        copyOnWrite();
        instance.getMutableCustomRecordsMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       *An optional set of key-value TLV records. This is useful within the context
       *of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
       *to drop off at each hop within the onion.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; custom_records = 11;</code>
       */
      public Builder putAllCustomRecords(
          java.util.Map<java.lang.Long, com.google.protobuf.ByteString> values) {
        copyOnWrite();
        instance.getMutableCustomRecordsMap().putAll(values);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.Hop)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.Hop();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "chanId_",
              "chanCapacity_",
              "amtToForward_",
              "fee_",
              "expiry_",
              "amtToForwardMsat_",
              "feeMsat_",
              "pubKey_",
              "tlvPayload_",
              "mppRecord_",
              "customRecords_",
              CustomRecordsDefaultEntryHolder.defaultEntry,
            };
            java.lang.String info =
                "\u0000\u000b\u0000\u0000\u0001\u000b\u000b\u0001\u0000\u0000\u0001\u0003\u0002\u0002" +
                "\u0003\u0002\u0004\u0002\u0005\u000b\u0006\u0002\u0007\u0002\b\u0208\t\u0007\n\t" +
                "\u000b2";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.Hop> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.Hop.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.Hop>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.Hop)
    private static final co.anode.anodium.Rpc.Hop DEFAULT_INSTANCE;
    static {
      Hop defaultInstance = new Hop();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Hop.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.Hop getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Hop> PARSER;

    public static com.google.protobuf.Parser<Hop> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface MPPRecordOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.MPPRecord)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *A unique, random identifier used to authenticate the sender as the intended
     *payer of a multi-path payment. The payment_addr must be the same for all
     *subpayments, and match the payment_addr provided in the receiver's invoice.
     *The same payment_addr must be used on all subpayments.
     * </pre>
     *
     * <code>bytes payment_addr = 11;</code>
     * @return The paymentAddr.
     */
    com.google.protobuf.ByteString getPaymentAddr();

    /**
     * <pre>
     *The total amount in milli-satoshis being sent as part of a larger multi-path
     *payment. The caller is responsible for ensuring subpayments to the same node
     *and payment_hash sum exactly to total_amt_msat. The same
     *total_amt_msat must be used on all subpayments.
     * </pre>
     *
     * <code>int64 total_amt_msat = 10;</code>
     * @return The totalAmtMsat.
     */
    long getTotalAmtMsat();
  }
  /**
   * Protobuf type {@code co.anode.anodium.MPPRecord}
   */
  public  static final class MPPRecord extends
      com.google.protobuf.GeneratedMessageLite<
          MPPRecord, MPPRecord.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.MPPRecord)
      MPPRecordOrBuilder {
    private MPPRecord() {
      paymentAddr_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int PAYMENT_ADDR_FIELD_NUMBER = 11;
    private com.google.protobuf.ByteString paymentAddr_;
    /**
     * <pre>
     *A unique, random identifier used to authenticate the sender as the intended
     *payer of a multi-path payment. The payment_addr must be the same for all
     *subpayments, and match the payment_addr provided in the receiver's invoice.
     *The same payment_addr must be used on all subpayments.
     * </pre>
     *
     * <code>bytes payment_addr = 11;</code>
     * @return The paymentAddr.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPaymentAddr() {
      return paymentAddr_;
    }
    /**
     * <pre>
     *A unique, random identifier used to authenticate the sender as the intended
     *payer of a multi-path payment. The payment_addr must be the same for all
     *subpayments, and match the payment_addr provided in the receiver's invoice.
     *The same payment_addr must be used on all subpayments.
     * </pre>
     *
     * <code>bytes payment_addr = 11;</code>
     * @param value The paymentAddr to set.
     */
    private void setPaymentAddr(com.google.protobuf.ByteString value) {
      value.getClass();
  
      paymentAddr_ = value;
    }
    /**
     * <pre>
     *A unique, random identifier used to authenticate the sender as the intended
     *payer of a multi-path payment. The payment_addr must be the same for all
     *subpayments, and match the payment_addr provided in the receiver's invoice.
     *The same payment_addr must be used on all subpayments.
     * </pre>
     *
     * <code>bytes payment_addr = 11;</code>
     */
    private void clearPaymentAddr() {
      
      paymentAddr_ = getDefaultInstance().getPaymentAddr();
    }

    public static final int TOTAL_AMT_MSAT_FIELD_NUMBER = 10;
    private long totalAmtMsat_;
    /**
     * <pre>
     *The total amount in milli-satoshis being sent as part of a larger multi-path
     *payment. The caller is responsible for ensuring subpayments to the same node
     *and payment_hash sum exactly to total_amt_msat. The same
     *total_amt_msat must be used on all subpayments.
     * </pre>
     *
     * <code>int64 total_amt_msat = 10;</code>
     * @return The totalAmtMsat.
     */
    @java.lang.Override
    public long getTotalAmtMsat() {
      return totalAmtMsat_;
    }
    /**
     * <pre>
     *The total amount in milli-satoshis being sent as part of a larger multi-path
     *payment. The caller is responsible for ensuring subpayments to the same node
     *and payment_hash sum exactly to total_amt_msat. The same
     *total_amt_msat must be used on all subpayments.
     * </pre>
     *
     * <code>int64 total_amt_msat = 10;</code>
     * @param value The totalAmtMsat to set.
     */
    private void setTotalAmtMsat(long value) {
      
      totalAmtMsat_ = value;
    }
    /**
     * <pre>
     *The total amount in milli-satoshis being sent as part of a larger multi-path
     *payment. The caller is responsible for ensuring subpayments to the same node
     *and payment_hash sum exactly to total_amt_msat. The same
     *total_amt_msat must be used on all subpayments.
     * </pre>
     *
     * <code>int64 total_amt_msat = 10;</code>
     */
    private void clearTotalAmtMsat() {
      
      totalAmtMsat_ = 0L;
    }

    public static co.anode.anodium.Rpc.MPPRecord parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.MPPRecord parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MPPRecord parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.MPPRecord parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MPPRecord parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.MPPRecord parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MPPRecord parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.MPPRecord parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MPPRecord parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.MPPRecord parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MPPRecord parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.MPPRecord parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.MPPRecord prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.MPPRecord}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.MPPRecord, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.MPPRecord)
        co.anode.anodium.Rpc.MPPRecordOrBuilder {
      // Construct using co.anode.anodium.Rpc.MPPRecord.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *A unique, random identifier used to authenticate the sender as the intended
       *payer of a multi-path payment. The payment_addr must be the same for all
       *subpayments, and match the payment_addr provided in the receiver's invoice.
       *The same payment_addr must be used on all subpayments.
       * </pre>
       *
       * <code>bytes payment_addr = 11;</code>
       * @return The paymentAddr.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPaymentAddr() {
        return instance.getPaymentAddr();
      }
      /**
       * <pre>
       *A unique, random identifier used to authenticate the sender as the intended
       *payer of a multi-path payment. The payment_addr must be the same for all
       *subpayments, and match the payment_addr provided in the receiver's invoice.
       *The same payment_addr must be used on all subpayments.
       * </pre>
       *
       * <code>bytes payment_addr = 11;</code>
       * @param value The paymentAddr to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentAddr(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPaymentAddr(value);
        return this;
      }
      /**
       * <pre>
       *A unique, random identifier used to authenticate the sender as the intended
       *payer of a multi-path payment. The payment_addr must be the same for all
       *subpayments, and match the payment_addr provided in the receiver's invoice.
       *The same payment_addr must be used on all subpayments.
       * </pre>
       *
       * <code>bytes payment_addr = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaymentAddr() {
        copyOnWrite();
        instance.clearPaymentAddr();
        return this;
      }

      /**
       * <pre>
       *The total amount in milli-satoshis being sent as part of a larger multi-path
       *payment. The caller is responsible for ensuring subpayments to the same node
       *and payment_hash sum exactly to total_amt_msat. The same
       *total_amt_msat must be used on all subpayments.
       * </pre>
       *
       * <code>int64 total_amt_msat = 10;</code>
       * @return The totalAmtMsat.
       */
      @java.lang.Override
      public long getTotalAmtMsat() {
        return instance.getTotalAmtMsat();
      }
      /**
       * <pre>
       *The total amount in milli-satoshis being sent as part of a larger multi-path
       *payment. The caller is responsible for ensuring subpayments to the same node
       *and payment_hash sum exactly to total_amt_msat. The same
       *total_amt_msat must be used on all subpayments.
       * </pre>
       *
       * <code>int64 total_amt_msat = 10;</code>
       * @param value The totalAmtMsat to set.
       * @return This builder for chaining.
       */
      public Builder setTotalAmtMsat(long value) {
        copyOnWrite();
        instance.setTotalAmtMsat(value);
        return this;
      }
      /**
       * <pre>
       *The total amount in milli-satoshis being sent as part of a larger multi-path
       *payment. The caller is responsible for ensuring subpayments to the same node
       *and payment_hash sum exactly to total_amt_msat. The same
       *total_amt_msat must be used on all subpayments.
       * </pre>
       *
       * <code>int64 total_amt_msat = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearTotalAmtMsat() {
        copyOnWrite();
        instance.clearTotalAmtMsat();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.MPPRecord)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.MPPRecord();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "totalAmtMsat_",
              "paymentAddr_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\n\u000b\u0002\u0000\u0000\u0000\n\u0002\u000b\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.MPPRecord> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.MPPRecord.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.MPPRecord>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.MPPRecord)
    private static final co.anode.anodium.Rpc.MPPRecord DEFAULT_INSTANCE;
    static {
      MPPRecord defaultInstance = new MPPRecord();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        MPPRecord.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.MPPRecord getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<MPPRecord> PARSER;

    public static com.google.protobuf.Parser<MPPRecord> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface RouteOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.Route)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The cumulative (final) time lock across the entire route. This is the CLTV
     *value that should be extended to the first hop in the route. All other hops
     *will decrement the time-lock as advertised, leaving enough time for all
     *hops to wait for or present the payment preimage to complete the payment.
     * </pre>
     *
     * <code>uint32 total_time_lock = 1;</code>
     * @return The totalTimeLock.
     */
    int getTotalTimeLock();

    /**
     * <pre>
     *The sum of the fees paid at each hop within the final route. In the case
     *of a one-hop payment, this value will be zero as we don't need to pay a fee
     *to ourselves.
     * </pre>
     *
     * <code>int64 total_fees = 2 [deprecated = true];</code>
     * @return The totalFees.
     */
    @java.lang.Deprecated long getTotalFees();

    /**
     * <pre>
     *The total amount of funds required to complete a payment over this route.
     *This value includes the cumulative fees at each hop. As a result, the HTLC
     *extended to the first-hop in the route will need to have at least this many
     *satoshis, otherwise the route will fail at an intermediate node due to an
     *insufficient amount of fees.
     * </pre>
     *
     * <code>int64 total_amt = 3 [deprecated = true];</code>
     * @return The totalAmt.
     */
    @java.lang.Deprecated long getTotalAmt();

    /**
     * <pre>
     *Contains details concerning the specific forwarding details at each hop.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
     */
    java.util.List<co.anode.anodium.Rpc.Hop> 
        getHopsList();
    /**
     * <pre>
     *Contains details concerning the specific forwarding details at each hop.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
     */
    co.anode.anodium.Rpc.Hop getHops(int index);
    /**
     * <pre>
     *Contains details concerning the specific forwarding details at each hop.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
     */
    int getHopsCount();

    /**
     * <pre>
     *The total fees in millisatoshis.
     * </pre>
     *
     * <code>int64 total_fees_msat = 5;</code>
     * @return The totalFeesMsat.
     */
    long getTotalFeesMsat();

    /**
     * <pre>
     *The total amount in millisatoshis.
     * </pre>
     *
     * <code>int64 total_amt_msat = 6;</code>
     * @return The totalAmtMsat.
     */
    long getTotalAmtMsat();
  }
  /**
   * <pre>
   *A path through the channel graph which runs over one or more channels in
   *succession. This struct carries all the information required to craft the
   *Sphinx onion packet, and send the payment along the first hop in the path. A
   *route is only selected as valid if all the channels have sufficient capacity to
   *carry the initial payment amount after fees are accounted for.
   * </pre>
   *
   * Protobuf type {@code co.anode.anodium.Route}
   */
  public  static final class Route extends
      com.google.protobuf.GeneratedMessageLite<
          Route, Route.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.Route)
      RouteOrBuilder {
    private Route() {
      hops_ = emptyProtobufList();
    }
    public static final int TOTAL_TIME_LOCK_FIELD_NUMBER = 1;
    private int totalTimeLock_;
    /**
     * <pre>
     *The cumulative (final) time lock across the entire route. This is the CLTV
     *value that should be extended to the first hop in the route. All other hops
     *will decrement the time-lock as advertised, leaving enough time for all
     *hops to wait for or present the payment preimage to complete the payment.
     * </pre>
     *
     * <code>uint32 total_time_lock = 1;</code>
     * @return The totalTimeLock.
     */
    @java.lang.Override
    public int getTotalTimeLock() {
      return totalTimeLock_;
    }
    /**
     * <pre>
     *The cumulative (final) time lock across the entire route. This is the CLTV
     *value that should be extended to the first hop in the route. All other hops
     *will decrement the time-lock as advertised, leaving enough time for all
     *hops to wait for or present the payment preimage to complete the payment.
     * </pre>
     *
     * <code>uint32 total_time_lock = 1;</code>
     * @param value The totalTimeLock to set.
     */
    private void setTotalTimeLock(int value) {
      
      totalTimeLock_ = value;
    }
    /**
     * <pre>
     *The cumulative (final) time lock across the entire route. This is the CLTV
     *value that should be extended to the first hop in the route. All other hops
     *will decrement the time-lock as advertised, leaving enough time for all
     *hops to wait for or present the payment preimage to complete the payment.
     * </pre>
     *
     * <code>uint32 total_time_lock = 1;</code>
     */
    private void clearTotalTimeLock() {
      
      totalTimeLock_ = 0;
    }

    public static final int TOTAL_FEES_FIELD_NUMBER = 2;
    private long totalFees_;
    /**
     * <pre>
     *The sum of the fees paid at each hop within the final route. In the case
     *of a one-hop payment, this value will be zero as we don't need to pay a fee
     *to ourselves.
     * </pre>
     *
     * <code>int64 total_fees = 2 [deprecated = true];</code>
     * @return The totalFees.
     */
    @java.lang.Override
    @java.lang.Deprecated public long getTotalFees() {
      return totalFees_;
    }
    /**
     * <pre>
     *The sum of the fees paid at each hop within the final route. In the case
     *of a one-hop payment, this value will be zero as we don't need to pay a fee
     *to ourselves.
     * </pre>
     *
     * <code>int64 total_fees = 2 [deprecated = true];</code>
     * @param value The totalFees to set.
     */
    private void setTotalFees(long value) {
      
      totalFees_ = value;
    }
    /**
     * <pre>
     *The sum of the fees paid at each hop within the final route. In the case
     *of a one-hop payment, this value will be zero as we don't need to pay a fee
     *to ourselves.
     * </pre>
     *
     * <code>int64 total_fees = 2 [deprecated = true];</code>
     */
    private void clearTotalFees() {
      
      totalFees_ = 0L;
    }

    public static final int TOTAL_AMT_FIELD_NUMBER = 3;
    private long totalAmt_;
    /**
     * <pre>
     *The total amount of funds required to complete a payment over this route.
     *This value includes the cumulative fees at each hop. As a result, the HTLC
     *extended to the first-hop in the route will need to have at least this many
     *satoshis, otherwise the route will fail at an intermediate node due to an
     *insufficient amount of fees.
     * </pre>
     *
     * <code>int64 total_amt = 3 [deprecated = true];</code>
     * @return The totalAmt.
     */
    @java.lang.Override
    @java.lang.Deprecated public long getTotalAmt() {
      return totalAmt_;
    }
    /**
     * <pre>
     *The total amount of funds required to complete a payment over this route.
     *This value includes the cumulative fees at each hop. As a result, the HTLC
     *extended to the first-hop in the route will need to have at least this many
     *satoshis, otherwise the route will fail at an intermediate node due to an
     *insufficient amount of fees.
     * </pre>
     *
     * <code>int64 total_amt = 3 [deprecated = true];</code>
     * @param value The totalAmt to set.
     */
    private void setTotalAmt(long value) {
      
      totalAmt_ = value;
    }
    /**
     * <pre>
     *The total amount of funds required to complete a payment over this route.
     *This value includes the cumulative fees at each hop. As a result, the HTLC
     *extended to the first-hop in the route will need to have at least this many
     *satoshis, otherwise the route will fail at an intermediate node due to an
     *insufficient amount of fees.
     * </pre>
     *
     * <code>int64 total_amt = 3 [deprecated = true];</code>
     */
    private void clearTotalAmt() {
      
      totalAmt_ = 0L;
    }

    public static final int HOPS_FIELD_NUMBER = 4;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Hop> hops_;
    /**
     * <pre>
     *Contains details concerning the specific forwarding details at each hop.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.Hop> getHopsList() {
      return hops_;
    }
    /**
     * <pre>
     *Contains details concerning the specific forwarding details at each hop.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.HopOrBuilder> 
        getHopsOrBuilderList() {
      return hops_;
    }
    /**
     * <pre>
     *Contains details concerning the specific forwarding details at each hop.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
     */
    @java.lang.Override
    public int getHopsCount() {
      return hops_.size();
    }
    /**
     * <pre>
     *Contains details concerning the specific forwarding details at each hop.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Hop getHops(int index) {
      return hops_.get(index);
    }
    /**
     * <pre>
     *Contains details concerning the specific forwarding details at each hop.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
     */
    public co.anode.anodium.Rpc.HopOrBuilder getHopsOrBuilder(
        int index) {
      return hops_.get(index);
    }
    private void ensureHopsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Hop> tmp = hops_;
      if (!tmp.isModifiable()) {
        hops_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     *Contains details concerning the specific forwarding details at each hop.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
     */
    private void setHops(
        int index, co.anode.anodium.Rpc.Hop value) {
      value.getClass();
  ensureHopsIsMutable();
      hops_.set(index, value);
    }
    /**
     * <pre>
     *Contains details concerning the specific forwarding details at each hop.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
     */
    private void addHops(co.anode.anodium.Rpc.Hop value) {
      value.getClass();
  ensureHopsIsMutable();
      hops_.add(value);
    }
    /**
     * <pre>
     *Contains details concerning the specific forwarding details at each hop.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
     */
    private void addHops(
        int index, co.anode.anodium.Rpc.Hop value) {
      value.getClass();
  ensureHopsIsMutable();
      hops_.add(index, value);
    }
    /**
     * <pre>
     *Contains details concerning the specific forwarding details at each hop.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
     */
    private void addAllHops(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.Hop> values) {
      ensureHopsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, hops_);
    }
    /**
     * <pre>
     *Contains details concerning the specific forwarding details at each hop.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
     */
    private void clearHops() {
      hops_ = emptyProtobufList();
    }
    /**
     * <pre>
     *Contains details concerning the specific forwarding details at each hop.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
     */
    private void removeHops(int index) {
      ensureHopsIsMutable();
      hops_.remove(index);
    }

    public static final int TOTAL_FEES_MSAT_FIELD_NUMBER = 5;
    private long totalFeesMsat_;
    /**
     * <pre>
     *The total fees in millisatoshis.
     * </pre>
     *
     * <code>int64 total_fees_msat = 5;</code>
     * @return The totalFeesMsat.
     */
    @java.lang.Override
    public long getTotalFeesMsat() {
      return totalFeesMsat_;
    }
    /**
     * <pre>
     *The total fees in millisatoshis.
     * </pre>
     *
     * <code>int64 total_fees_msat = 5;</code>
     * @param value The totalFeesMsat to set.
     */
    private void setTotalFeesMsat(long value) {
      
      totalFeesMsat_ = value;
    }
    /**
     * <pre>
     *The total fees in millisatoshis.
     * </pre>
     *
     * <code>int64 total_fees_msat = 5;</code>
     */
    private void clearTotalFeesMsat() {
      
      totalFeesMsat_ = 0L;
    }

    public static final int TOTAL_AMT_MSAT_FIELD_NUMBER = 6;
    private long totalAmtMsat_;
    /**
     * <pre>
     *The total amount in millisatoshis.
     * </pre>
     *
     * <code>int64 total_amt_msat = 6;</code>
     * @return The totalAmtMsat.
     */
    @java.lang.Override
    public long getTotalAmtMsat() {
      return totalAmtMsat_;
    }
    /**
     * <pre>
     *The total amount in millisatoshis.
     * </pre>
     *
     * <code>int64 total_amt_msat = 6;</code>
     * @param value The totalAmtMsat to set.
     */
    private void setTotalAmtMsat(long value) {
      
      totalAmtMsat_ = value;
    }
    /**
     * <pre>
     *The total amount in millisatoshis.
     * </pre>
     *
     * <code>int64 total_amt_msat = 6;</code>
     */
    private void clearTotalAmtMsat() {
      
      totalAmtMsat_ = 0L;
    }

    public static co.anode.anodium.Rpc.Route parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Route parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Route parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Route parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Route parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Route parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Route parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Route parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Route parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Route parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Route parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Route parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.Route prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     *A path through the channel graph which runs over one or more channels in
     *succession. This struct carries all the information required to craft the
     *Sphinx onion packet, and send the payment along the first hop in the path. A
     *route is only selected as valid if all the channels have sufficient capacity to
     *carry the initial payment amount after fees are accounted for.
     * </pre>
     *
     * Protobuf type {@code co.anode.anodium.Route}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.Route, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.Route)
        co.anode.anodium.Rpc.RouteOrBuilder {
      // Construct using co.anode.anodium.Rpc.Route.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The cumulative (final) time lock across the entire route. This is the CLTV
       *value that should be extended to the first hop in the route. All other hops
       *will decrement the time-lock as advertised, leaving enough time for all
       *hops to wait for or present the payment preimage to complete the payment.
       * </pre>
       *
       * <code>uint32 total_time_lock = 1;</code>
       * @return The totalTimeLock.
       */
      @java.lang.Override
      public int getTotalTimeLock() {
        return instance.getTotalTimeLock();
      }
      /**
       * <pre>
       *The cumulative (final) time lock across the entire route. This is the CLTV
       *value that should be extended to the first hop in the route. All other hops
       *will decrement the time-lock as advertised, leaving enough time for all
       *hops to wait for or present the payment preimage to complete the payment.
       * </pre>
       *
       * <code>uint32 total_time_lock = 1;</code>
       * @param value The totalTimeLock to set.
       * @return This builder for chaining.
       */
      public Builder setTotalTimeLock(int value) {
        copyOnWrite();
        instance.setTotalTimeLock(value);
        return this;
      }
      /**
       * <pre>
       *The cumulative (final) time lock across the entire route. This is the CLTV
       *value that should be extended to the first hop in the route. All other hops
       *will decrement the time-lock as advertised, leaving enough time for all
       *hops to wait for or present the payment preimage to complete the payment.
       * </pre>
       *
       * <code>uint32 total_time_lock = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTotalTimeLock() {
        copyOnWrite();
        instance.clearTotalTimeLock();
        return this;
      }

      /**
       * <pre>
       *The sum of the fees paid at each hop within the final route. In the case
       *of a one-hop payment, this value will be zero as we don't need to pay a fee
       *to ourselves.
       * </pre>
       *
       * <code>int64 total_fees = 2 [deprecated = true];</code>
       * @return The totalFees.
       */
      @java.lang.Override
      @java.lang.Deprecated public long getTotalFees() {
        return instance.getTotalFees();
      }
      /**
       * <pre>
       *The sum of the fees paid at each hop within the final route. In the case
       *of a one-hop payment, this value will be zero as we don't need to pay a fee
       *to ourselves.
       * </pre>
       *
       * <code>int64 total_fees = 2 [deprecated = true];</code>
       * @param value The totalFees to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setTotalFees(long value) {
        copyOnWrite();
        instance.setTotalFees(value);
        return this;
      }
      /**
       * <pre>
       *The sum of the fees paid at each hop within the final route. In the case
       *of a one-hop payment, this value will be zero as we don't need to pay a fee
       *to ourselves.
       * </pre>
       *
       * <code>int64 total_fees = 2 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearTotalFees() {
        copyOnWrite();
        instance.clearTotalFees();
        return this;
      }

      /**
       * <pre>
       *The total amount of funds required to complete a payment over this route.
       *This value includes the cumulative fees at each hop. As a result, the HTLC
       *extended to the first-hop in the route will need to have at least this many
       *satoshis, otherwise the route will fail at an intermediate node due to an
       *insufficient amount of fees.
       * </pre>
       *
       * <code>int64 total_amt = 3 [deprecated = true];</code>
       * @return The totalAmt.
       */
      @java.lang.Override
      @java.lang.Deprecated public long getTotalAmt() {
        return instance.getTotalAmt();
      }
      /**
       * <pre>
       *The total amount of funds required to complete a payment over this route.
       *This value includes the cumulative fees at each hop. As a result, the HTLC
       *extended to the first-hop in the route will need to have at least this many
       *satoshis, otherwise the route will fail at an intermediate node due to an
       *insufficient amount of fees.
       * </pre>
       *
       * <code>int64 total_amt = 3 [deprecated = true];</code>
       * @param value The totalAmt to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setTotalAmt(long value) {
        copyOnWrite();
        instance.setTotalAmt(value);
        return this;
      }
      /**
       * <pre>
       *The total amount of funds required to complete a payment over this route.
       *This value includes the cumulative fees at each hop. As a result, the HTLC
       *extended to the first-hop in the route will need to have at least this many
       *satoshis, otherwise the route will fail at an intermediate node due to an
       *insufficient amount of fees.
       * </pre>
       *
       * <code>int64 total_amt = 3 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearTotalAmt() {
        copyOnWrite();
        instance.clearTotalAmt();
        return this;
      }

      /**
       * <pre>
       *Contains details concerning the specific forwarding details at each hop.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.Hop> getHopsList() {
        return java.util.Collections.unmodifiableList(
            instance.getHopsList());
      }
      /**
       * <pre>
       *Contains details concerning the specific forwarding details at each hop.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
       */
      @java.lang.Override
      public int getHopsCount() {
        return instance.getHopsCount();
      }/**
       * <pre>
       *Contains details concerning the specific forwarding details at each hop.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Hop getHops(int index) {
        return instance.getHops(index);
      }
      /**
       * <pre>
       *Contains details concerning the specific forwarding details at each hop.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
       */
      public Builder setHops(
          int index, co.anode.anodium.Rpc.Hop value) {
        copyOnWrite();
        instance.setHops(index, value);
        return this;
      }
      /**
       * <pre>
       *Contains details concerning the specific forwarding details at each hop.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
       */
      public Builder setHops(
          int index, co.anode.anodium.Rpc.Hop.Builder builderForValue) {
        copyOnWrite();
        instance.setHops(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Contains details concerning the specific forwarding details at each hop.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
       */
      public Builder addHops(co.anode.anodium.Rpc.Hop value) {
        copyOnWrite();
        instance.addHops(value);
        return this;
      }
      /**
       * <pre>
       *Contains details concerning the specific forwarding details at each hop.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
       */
      public Builder addHops(
          int index, co.anode.anodium.Rpc.Hop value) {
        copyOnWrite();
        instance.addHops(index, value);
        return this;
      }
      /**
       * <pre>
       *Contains details concerning the specific forwarding details at each hop.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
       */
      public Builder addHops(
          co.anode.anodium.Rpc.Hop.Builder builderForValue) {
        copyOnWrite();
        instance.addHops(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Contains details concerning the specific forwarding details at each hop.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
       */
      public Builder addHops(
          int index, co.anode.anodium.Rpc.Hop.Builder builderForValue) {
        copyOnWrite();
        instance.addHops(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Contains details concerning the specific forwarding details at each hop.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
       */
      public Builder addAllHops(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.Hop> values) {
        copyOnWrite();
        instance.addAllHops(values);
        return this;
      }
      /**
       * <pre>
       *Contains details concerning the specific forwarding details at each hop.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
       */
      public Builder clearHops() {
        copyOnWrite();
        instance.clearHops();
        return this;
      }
      /**
       * <pre>
       *Contains details concerning the specific forwarding details at each hop.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Hop hops = 4;</code>
       */
      public Builder removeHops(int index) {
        copyOnWrite();
        instance.removeHops(index);
        return this;
      }

      /**
       * <pre>
       *The total fees in millisatoshis.
       * </pre>
       *
       * <code>int64 total_fees_msat = 5;</code>
       * @return The totalFeesMsat.
       */
      @java.lang.Override
      public long getTotalFeesMsat() {
        return instance.getTotalFeesMsat();
      }
      /**
       * <pre>
       *The total fees in millisatoshis.
       * </pre>
       *
       * <code>int64 total_fees_msat = 5;</code>
       * @param value The totalFeesMsat to set.
       * @return This builder for chaining.
       */
      public Builder setTotalFeesMsat(long value) {
        copyOnWrite();
        instance.setTotalFeesMsat(value);
        return this;
      }
      /**
       * <pre>
       *The total fees in millisatoshis.
       * </pre>
       *
       * <code>int64 total_fees_msat = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearTotalFeesMsat() {
        copyOnWrite();
        instance.clearTotalFeesMsat();
        return this;
      }

      /**
       * <pre>
       *The total amount in millisatoshis.
       * </pre>
       *
       * <code>int64 total_amt_msat = 6;</code>
       * @return The totalAmtMsat.
       */
      @java.lang.Override
      public long getTotalAmtMsat() {
        return instance.getTotalAmtMsat();
      }
      /**
       * <pre>
       *The total amount in millisatoshis.
       * </pre>
       *
       * <code>int64 total_amt_msat = 6;</code>
       * @param value The totalAmtMsat to set.
       * @return This builder for chaining.
       */
      public Builder setTotalAmtMsat(long value) {
        copyOnWrite();
        instance.setTotalAmtMsat(value);
        return this;
      }
      /**
       * <pre>
       *The total amount in millisatoshis.
       * </pre>
       *
       * <code>int64 total_amt_msat = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearTotalAmtMsat() {
        copyOnWrite();
        instance.clearTotalAmtMsat();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.Route)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.Route();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "totalTimeLock_",
              "totalFees_",
              "totalAmt_",
              "hops_",
              co.anode.anodium.Rpc.Hop.class,
              "totalFeesMsat_",
              "totalAmtMsat_",
            };
            java.lang.String info =
                "\u0000\u0006\u0000\u0000\u0001\u0006\u0006\u0000\u0001\u0000\u0001\u000b\u0002\u0002" +
                "\u0003\u0002\u0004\u001b\u0005\u0002\u0006\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.Route> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.Route.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.Route>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.Route)
    private static final co.anode.anodium.Rpc.Route DEFAULT_INSTANCE;
    static {
      Route defaultInstance = new Route();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Route.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.Route getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Route> PARSER;

    public static com.google.protobuf.Parser<Route> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface NodeInfoRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.NodeInfoRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The 33-byte hex-encoded compressed public of the target node
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The pubKey.
     */
    java.lang.String getPubKey();
    /**
     * <pre>
     * The 33-byte hex-encoded compressed public of the target node
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The bytes for pubKey.
     */
    com.google.protobuf.ByteString
        getPubKeyBytes();

    /**
     * <pre>
     * If true, will include all known channels associated with the node.
     * </pre>
     *
     * <code>bool include_channels = 2;</code>
     * @return The includeChannels.
     */
    boolean getIncludeChannels();
  }
  /**
   * Protobuf type {@code co.anode.anodium.NodeInfoRequest}
   */
  public  static final class NodeInfoRequest extends
      com.google.protobuf.GeneratedMessageLite<
          NodeInfoRequest, NodeInfoRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.NodeInfoRequest)
      NodeInfoRequestOrBuilder {
    private NodeInfoRequest() {
      pubKey_ = "";
    }
    public static final int PUB_KEY_FIELD_NUMBER = 1;
    private java.lang.String pubKey_;
    /**
     * <pre>
     * The 33-byte hex-encoded compressed public of the target node
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The pubKey.
     */
    @java.lang.Override
    public java.lang.String getPubKey() {
      return pubKey_;
    }
    /**
     * <pre>
     * The 33-byte hex-encoded compressed public of the target node
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @return The bytes for pubKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPubKeyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(pubKey_);
    }
    /**
     * <pre>
     * The 33-byte hex-encoded compressed public of the target node
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @param value The pubKey to set.
     */
    private void setPubKey(
        java.lang.String value) {
      value.getClass();
  
      pubKey_ = value;
    }
    /**
     * <pre>
     * The 33-byte hex-encoded compressed public of the target node
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     */
    private void clearPubKey() {
      
      pubKey_ = getDefaultInstance().getPubKey();
    }
    /**
     * <pre>
     * The 33-byte hex-encoded compressed public of the target node
     * </pre>
     *
     * <code>string pub_key = 1;</code>
     * @param value The bytes for pubKey to set.
     */
    private void setPubKeyBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      pubKey_ = value.toStringUtf8();
      
    }

    public static final int INCLUDE_CHANNELS_FIELD_NUMBER = 2;
    private boolean includeChannels_;
    /**
     * <pre>
     * If true, will include all known channels associated with the node.
     * </pre>
     *
     * <code>bool include_channels = 2;</code>
     * @return The includeChannels.
     */
    @java.lang.Override
    public boolean getIncludeChannels() {
      return includeChannels_;
    }
    /**
     * <pre>
     * If true, will include all known channels associated with the node.
     * </pre>
     *
     * <code>bool include_channels = 2;</code>
     * @param value The includeChannels to set.
     */
    private void setIncludeChannels(boolean value) {
      
      includeChannels_ = value;
    }
    /**
     * <pre>
     * If true, will include all known channels associated with the node.
     * </pre>
     *
     * <code>bool include_channels = 2;</code>
     */
    private void clearIncludeChannels() {
      
      includeChannels_ = false;
    }

    public static co.anode.anodium.Rpc.NodeInfoRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodeInfoRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeInfoRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodeInfoRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeInfoRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodeInfoRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeInfoRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodeInfoRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeInfoRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodeInfoRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodeInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.NodeInfoRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.NodeInfoRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.NodeInfoRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.NodeInfoRequest)
        co.anode.anodium.Rpc.NodeInfoRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.NodeInfoRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The 33-byte hex-encoded compressed public of the target node
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @return The pubKey.
       */
      @java.lang.Override
      public java.lang.String getPubKey() {
        return instance.getPubKey();
      }
      /**
       * <pre>
       * The 33-byte hex-encoded compressed public of the target node
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @return The bytes for pubKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPubKeyBytes() {
        return instance.getPubKeyBytes();
      }
      /**
       * <pre>
       * The 33-byte hex-encoded compressed public of the target node
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @param value The pubKey to set.
       * @return This builder for chaining.
       */
      public Builder setPubKey(
          java.lang.String value) {
        copyOnWrite();
        instance.setPubKey(value);
        return this;
      }
      /**
       * <pre>
       * The 33-byte hex-encoded compressed public of the target node
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPubKey() {
        copyOnWrite();
        instance.clearPubKey();
        return this;
      }
      /**
       * <pre>
       * The 33-byte hex-encoded compressed public of the target node
       * </pre>
       *
       * <code>string pub_key = 1;</code>
       * @param value The bytes for pubKey to set.
       * @return This builder for chaining.
       */
      public Builder setPubKeyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPubKeyBytes(value);
        return this;
      }

      /**
       * <pre>
       * If true, will include all known channels associated with the node.
       * </pre>
       *
       * <code>bool include_channels = 2;</code>
       * @return The includeChannels.
       */
      @java.lang.Override
      public boolean getIncludeChannels() {
        return instance.getIncludeChannels();
      }
      /**
       * <pre>
       * If true, will include all known channels associated with the node.
       * </pre>
       *
       * <code>bool include_channels = 2;</code>
       * @param value The includeChannels to set.
       * @return This builder for chaining.
       */
      public Builder setIncludeChannels(boolean value) {
        copyOnWrite();
        instance.setIncludeChannels(value);
        return this;
      }
      /**
       * <pre>
       * If true, will include all known channels associated with the node.
       * </pre>
       *
       * <code>bool include_channels = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearIncludeChannels() {
        copyOnWrite();
        instance.clearIncludeChannels();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.NodeInfoRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.NodeInfoRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "pubKey_",
              "includeChannels_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0208\u0002\u0007" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.NodeInfoRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.NodeInfoRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.NodeInfoRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.NodeInfoRequest)
    private static final co.anode.anodium.Rpc.NodeInfoRequest DEFAULT_INSTANCE;
    static {
      NodeInfoRequest defaultInstance = new NodeInfoRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        NodeInfoRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.NodeInfoRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<NodeInfoRequest> PARSER;

    public static com.google.protobuf.Parser<NodeInfoRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface NodeInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.NodeInfo)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *An individual vertex/node within the channel graph. A node is
     *connected to other nodes by one or more channel edges emanating from it. As
     *the graph is directed, a node will also have an incoming edge attached to
     *it for each outgoing edge.
     * </pre>
     *
     * <code>.co.anode.anodium.LightningNode node = 1;</code>
     * @return Whether the node field is set.
     */
    boolean hasNode();
    /**
     * <pre>
     *An individual vertex/node within the channel graph. A node is
     *connected to other nodes by one or more channel edges emanating from it. As
     *the graph is directed, a node will also have an incoming edge attached to
     *it for each outgoing edge.
     * </pre>
     *
     * <code>.co.anode.anodium.LightningNode node = 1;</code>
     * @return The node.
     */
    co.anode.anodium.Rpc.LightningNode getNode();

    /**
     * <pre>
     * The total number of channels for the node.
     * </pre>
     *
     * <code>uint32 num_channels = 2;</code>
     * @return The numChannels.
     */
    int getNumChannels();

    /**
     * <pre>
     * The sum of all channels capacity for the node, denominated in satoshis.
     * </pre>
     *
     * <code>int64 total_capacity = 3;</code>
     * @return The totalCapacity.
     */
    long getTotalCapacity();

    /**
     * <pre>
     * A list of all public channels for the node.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
     */
    java.util.List<co.anode.anodium.Rpc.ChannelEdge> 
        getChannelsList();
    /**
     * <pre>
     * A list of all public channels for the node.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
     */
    co.anode.anodium.Rpc.ChannelEdge getChannels(int index);
    /**
     * <pre>
     * A list of all public channels for the node.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
     */
    int getChannelsCount();
  }
  /**
   * Protobuf type {@code co.anode.anodium.NodeInfo}
   */
  public  static final class NodeInfo extends
      com.google.protobuf.GeneratedMessageLite<
          NodeInfo, NodeInfo.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.NodeInfo)
      NodeInfoOrBuilder {
    private NodeInfo() {
      channels_ = emptyProtobufList();
    }
    public static final int NODE_FIELD_NUMBER = 1;
    private co.anode.anodium.Rpc.LightningNode node_;
    /**
     * <pre>
     *An individual vertex/node within the channel graph. A node is
     *connected to other nodes by one or more channel edges emanating from it. As
     *the graph is directed, a node will also have an incoming edge attached to
     *it for each outgoing edge.
     * </pre>
     *
     * <code>.co.anode.anodium.LightningNode node = 1;</code>
     */
    @java.lang.Override
    public boolean hasNode() {
      return node_ != null;
    }
    /**
     * <pre>
     *An individual vertex/node within the channel graph. A node is
     *connected to other nodes by one or more channel edges emanating from it. As
     *the graph is directed, a node will also have an incoming edge attached to
     *it for each outgoing edge.
     * </pre>
     *
     * <code>.co.anode.anodium.LightningNode node = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.LightningNode getNode() {
      return node_ == null ? co.anode.anodium.Rpc.LightningNode.getDefaultInstance() : node_;
    }
    /**
     * <pre>
     *An individual vertex/node within the channel graph. A node is
     *connected to other nodes by one or more channel edges emanating from it. As
     *the graph is directed, a node will also have an incoming edge attached to
     *it for each outgoing edge.
     * </pre>
     *
     * <code>.co.anode.anodium.LightningNode node = 1;</code>
     */
    private void setNode(co.anode.anodium.Rpc.LightningNode value) {
      value.getClass();
  node_ = value;
      
      }
    /**
     * <pre>
     *An individual vertex/node within the channel graph. A node is
     *connected to other nodes by one or more channel edges emanating from it. As
     *the graph is directed, a node will also have an incoming edge attached to
     *it for each outgoing edge.
     * </pre>
     *
     * <code>.co.anode.anodium.LightningNode node = 1;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeNode(co.anode.anodium.Rpc.LightningNode value) {
      value.getClass();
  if (node_ != null &&
          node_ != co.anode.anodium.Rpc.LightningNode.getDefaultInstance()) {
        node_ =
          co.anode.anodium.Rpc.LightningNode.newBuilder(node_).mergeFrom(value).buildPartial();
      } else {
        node_ = value;
      }
      
    }
    /**
     * <pre>
     *An individual vertex/node within the channel graph. A node is
     *connected to other nodes by one or more channel edges emanating from it. As
     *the graph is directed, a node will also have an incoming edge attached to
     *it for each outgoing edge.
     * </pre>
     *
     * <code>.co.anode.anodium.LightningNode node = 1;</code>
     */
    private void clearNode() {  node_ = null;
      
    }

    public static final int NUM_CHANNELS_FIELD_NUMBER = 2;
    private int numChannels_;
    /**
     * <pre>
     * The total number of channels for the node.
     * </pre>
     *
     * <code>uint32 num_channels = 2;</code>
     * @return The numChannels.
     */
    @java.lang.Override
    public int getNumChannels() {
      return numChannels_;
    }
    /**
     * <pre>
     * The total number of channels for the node.
     * </pre>
     *
     * <code>uint32 num_channels = 2;</code>
     * @param value The numChannels to set.
     */
    private void setNumChannels(int value) {
      
      numChannels_ = value;
    }
    /**
     * <pre>
     * The total number of channels for the node.
     * </pre>
     *
     * <code>uint32 num_channels = 2;</code>
     */
    private void clearNumChannels() {
      
      numChannels_ = 0;
    }

    public static final int TOTAL_CAPACITY_FIELD_NUMBER = 3;
    private long totalCapacity_;
    /**
     * <pre>
     * The sum of all channels capacity for the node, denominated in satoshis.
     * </pre>
     *
     * <code>int64 total_capacity = 3;</code>
     * @return The totalCapacity.
     */
    @java.lang.Override
    public long getTotalCapacity() {
      return totalCapacity_;
    }
    /**
     * <pre>
     * The sum of all channels capacity for the node, denominated in satoshis.
     * </pre>
     *
     * <code>int64 total_capacity = 3;</code>
     * @param value The totalCapacity to set.
     */
    private void setTotalCapacity(long value) {
      
      totalCapacity_ = value;
    }
    /**
     * <pre>
     * The sum of all channels capacity for the node, denominated in satoshis.
     * </pre>
     *
     * <code>int64 total_capacity = 3;</code>
     */
    private void clearTotalCapacity() {
      
      totalCapacity_ = 0L;
    }

    public static final int CHANNELS_FIELD_NUMBER = 4;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.ChannelEdge> channels_;
    /**
     * <pre>
     * A list of all public channels for the node.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.ChannelEdge> getChannelsList() {
      return channels_;
    }
    /**
     * <pre>
     * A list of all public channels for the node.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.ChannelEdgeOrBuilder> 
        getChannelsOrBuilderList() {
      return channels_;
    }
    /**
     * <pre>
     * A list of all public channels for the node.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
     */
    @java.lang.Override
    public int getChannelsCount() {
      return channels_.size();
    }
    /**
     * <pre>
     * A list of all public channels for the node.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelEdge getChannels(int index) {
      return channels_.get(index);
    }
    /**
     * <pre>
     * A list of all public channels for the node.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
     */
    public co.anode.anodium.Rpc.ChannelEdgeOrBuilder getChannelsOrBuilder(
        int index) {
      return channels_.get(index);
    }
    private void ensureChannelsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.ChannelEdge> tmp = channels_;
      if (!tmp.isModifiable()) {
        channels_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * A list of all public channels for the node.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
     */
    private void setChannels(
        int index, co.anode.anodium.Rpc.ChannelEdge value) {
      value.getClass();
  ensureChannelsIsMutable();
      channels_.set(index, value);
    }
    /**
     * <pre>
     * A list of all public channels for the node.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
     */
    private void addChannels(co.anode.anodium.Rpc.ChannelEdge value) {
      value.getClass();
  ensureChannelsIsMutable();
      channels_.add(value);
    }
    /**
     * <pre>
     * A list of all public channels for the node.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
     */
    private void addChannels(
        int index, co.anode.anodium.Rpc.ChannelEdge value) {
      value.getClass();
  ensureChannelsIsMutable();
      channels_.add(index, value);
    }
    /**
     * <pre>
     * A list of all public channels for the node.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
     */
    private void addAllChannels(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.ChannelEdge> values) {
      ensureChannelsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, channels_);
    }
    /**
     * <pre>
     * A list of all public channels for the node.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
     */
    private void clearChannels() {
      channels_ = emptyProtobufList();
    }
    /**
     * <pre>
     * A list of all public channels for the node.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
     */
    private void removeChannels(int index) {
      ensureChannelsIsMutable();
      channels_.remove(index);
    }

    public static co.anode.anodium.Rpc.NodeInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodeInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodeInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodeInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodeInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodeInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodeInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.NodeInfo prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.NodeInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.NodeInfo, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.NodeInfo)
        co.anode.anodium.Rpc.NodeInfoOrBuilder {
      // Construct using co.anode.anodium.Rpc.NodeInfo.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *An individual vertex/node within the channel graph. A node is
       *connected to other nodes by one or more channel edges emanating from it. As
       *the graph is directed, a node will also have an incoming edge attached to
       *it for each outgoing edge.
       * </pre>
       *
       * <code>.co.anode.anodium.LightningNode node = 1;</code>
       */
      @java.lang.Override
      public boolean hasNode() {
        return instance.hasNode();
      }
      /**
       * <pre>
       *An individual vertex/node within the channel graph. A node is
       *connected to other nodes by one or more channel edges emanating from it. As
       *the graph is directed, a node will also have an incoming edge attached to
       *it for each outgoing edge.
       * </pre>
       *
       * <code>.co.anode.anodium.LightningNode node = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.LightningNode getNode() {
        return instance.getNode();
      }
      /**
       * <pre>
       *An individual vertex/node within the channel graph. A node is
       *connected to other nodes by one or more channel edges emanating from it. As
       *the graph is directed, a node will also have an incoming edge attached to
       *it for each outgoing edge.
       * </pre>
       *
       * <code>.co.anode.anodium.LightningNode node = 1;</code>
       */
      public Builder setNode(co.anode.anodium.Rpc.LightningNode value) {
        copyOnWrite();
        instance.setNode(value);
        return this;
        }
      /**
       * <pre>
       *An individual vertex/node within the channel graph. A node is
       *connected to other nodes by one or more channel edges emanating from it. As
       *the graph is directed, a node will also have an incoming edge attached to
       *it for each outgoing edge.
       * </pre>
       *
       * <code>.co.anode.anodium.LightningNode node = 1;</code>
       */
      public Builder setNode(
          co.anode.anodium.Rpc.LightningNode.Builder builderForValue) {
        copyOnWrite();
        instance.setNode(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *An individual vertex/node within the channel graph. A node is
       *connected to other nodes by one or more channel edges emanating from it. As
       *the graph is directed, a node will also have an incoming edge attached to
       *it for each outgoing edge.
       * </pre>
       *
       * <code>.co.anode.anodium.LightningNode node = 1;</code>
       */
      public Builder mergeNode(co.anode.anodium.Rpc.LightningNode value) {
        copyOnWrite();
        instance.mergeNode(value);
        return this;
      }
      /**
       * <pre>
       *An individual vertex/node within the channel graph. A node is
       *connected to other nodes by one or more channel edges emanating from it. As
       *the graph is directed, a node will also have an incoming edge attached to
       *it for each outgoing edge.
       * </pre>
       *
       * <code>.co.anode.anodium.LightningNode node = 1;</code>
       */
      public Builder clearNode() {  copyOnWrite();
        instance.clearNode();
        return this;
      }

      /**
       * <pre>
       * The total number of channels for the node.
       * </pre>
       *
       * <code>uint32 num_channels = 2;</code>
       * @return The numChannels.
       */
      @java.lang.Override
      public int getNumChannels() {
        return instance.getNumChannels();
      }
      /**
       * <pre>
       * The total number of channels for the node.
       * </pre>
       *
       * <code>uint32 num_channels = 2;</code>
       * @param value The numChannels to set.
       * @return This builder for chaining.
       */
      public Builder setNumChannels(int value) {
        copyOnWrite();
        instance.setNumChannels(value);
        return this;
      }
      /**
       * <pre>
       * The total number of channels for the node.
       * </pre>
       *
       * <code>uint32 num_channels = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumChannels() {
        copyOnWrite();
        instance.clearNumChannels();
        return this;
      }

      /**
       * <pre>
       * The sum of all channels capacity for the node, denominated in satoshis.
       * </pre>
       *
       * <code>int64 total_capacity = 3;</code>
       * @return The totalCapacity.
       */
      @java.lang.Override
      public long getTotalCapacity() {
        return instance.getTotalCapacity();
      }
      /**
       * <pre>
       * The sum of all channels capacity for the node, denominated in satoshis.
       * </pre>
       *
       * <code>int64 total_capacity = 3;</code>
       * @param value The totalCapacity to set.
       * @return This builder for chaining.
       */
      public Builder setTotalCapacity(long value) {
        copyOnWrite();
        instance.setTotalCapacity(value);
        return this;
      }
      /**
       * <pre>
       * The sum of all channels capacity for the node, denominated in satoshis.
       * </pre>
       *
       * <code>int64 total_capacity = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearTotalCapacity() {
        copyOnWrite();
        instance.clearTotalCapacity();
        return this;
      }

      /**
       * <pre>
       * A list of all public channels for the node.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.ChannelEdge> getChannelsList() {
        return java.util.Collections.unmodifiableList(
            instance.getChannelsList());
      }
      /**
       * <pre>
       * A list of all public channels for the node.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
       */
      @java.lang.Override
      public int getChannelsCount() {
        return instance.getChannelsCount();
      }/**
       * <pre>
       * A list of all public channels for the node.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelEdge getChannels(int index) {
        return instance.getChannels(index);
      }
      /**
       * <pre>
       * A list of all public channels for the node.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
       */
      public Builder setChannels(
          int index, co.anode.anodium.Rpc.ChannelEdge value) {
        copyOnWrite();
        instance.setChannels(index, value);
        return this;
      }
      /**
       * <pre>
       * A list of all public channels for the node.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
       */
      public Builder setChannels(
          int index, co.anode.anodium.Rpc.ChannelEdge.Builder builderForValue) {
        copyOnWrite();
        instance.setChannels(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A list of all public channels for the node.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
       */
      public Builder addChannels(co.anode.anodium.Rpc.ChannelEdge value) {
        copyOnWrite();
        instance.addChannels(value);
        return this;
      }
      /**
       * <pre>
       * A list of all public channels for the node.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
       */
      public Builder addChannels(
          int index, co.anode.anodium.Rpc.ChannelEdge value) {
        copyOnWrite();
        instance.addChannels(index, value);
        return this;
      }
      /**
       * <pre>
       * A list of all public channels for the node.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
       */
      public Builder addChannels(
          co.anode.anodium.Rpc.ChannelEdge.Builder builderForValue) {
        copyOnWrite();
        instance.addChannels(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A list of all public channels for the node.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
       */
      public Builder addChannels(
          int index, co.anode.anodium.Rpc.ChannelEdge.Builder builderForValue) {
        copyOnWrite();
        instance.addChannels(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A list of all public channels for the node.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
       */
      public Builder addAllChannels(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.ChannelEdge> values) {
        copyOnWrite();
        instance.addAllChannels(values);
        return this;
      }
      /**
       * <pre>
       * A list of all public channels for the node.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
       */
      public Builder clearChannels() {
        copyOnWrite();
        instance.clearChannels();
        return this;
      }
      /**
       * <pre>
       * A list of all public channels for the node.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge channels = 4;</code>
       */
      public Builder removeChannels(int index) {
        copyOnWrite();
        instance.removeChannels(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.NodeInfo)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.NodeInfo();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "node_",
              "numChannels_",
              "totalCapacity_",
              "channels_",
              co.anode.anodium.Rpc.ChannelEdge.class,
            };
            java.lang.String info =
                "\u0000\u0004\u0000\u0000\u0001\u0004\u0004\u0000\u0001\u0000\u0001\t\u0002\u000b" +
                "\u0003\u0002\u0004\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.NodeInfo> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.NodeInfo.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.NodeInfo>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.NodeInfo)
    private static final co.anode.anodium.Rpc.NodeInfo DEFAULT_INSTANCE;
    static {
      NodeInfo defaultInstance = new NodeInfo();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        NodeInfo.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.NodeInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<NodeInfo> PARSER;

    public static com.google.protobuf.Parser<NodeInfo> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface LightningNodeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.LightningNode)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>uint32 last_update = 1;</code>
     * @return The lastUpdate.
     */
    int getLastUpdate();

    /**
     * <code>string pub_key = 2;</code>
     * @return The pubKey.
     */
    java.lang.String getPubKey();
    /**
     * <code>string pub_key = 2;</code>
     * @return The bytes for pubKey.
     */
    com.google.protobuf.ByteString
        getPubKeyBytes();

    /**
     * <code>string alias = 3;</code>
     * @return The alias.
     */
    java.lang.String getAlias();
    /**
     * <code>string alias = 3;</code>
     * @return The bytes for alias.
     */
    com.google.protobuf.ByteString
        getAliasBytes();

    /**
     * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
     */
    java.util.List<co.anode.anodium.Rpc.NodeAddress> 
        getAddressesList();
    /**
     * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
     */
    co.anode.anodium.Rpc.NodeAddress getAddresses(int index);
    /**
     * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
     */
    int getAddressesCount();

    /**
     * <code>string color = 5;</code>
     * @return The color.
     */
    java.lang.String getColor();
    /**
     * <code>string color = 5;</code>
     * @return The bytes for color.
     */
    com.google.protobuf.ByteString
        getColorBytes();

    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 6;</code>
     */
    int getFeaturesCount();
    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 6;</code>
     */
    boolean containsFeatures(
        int key);
    /**
     * Use {@link #getFeaturesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    getFeatures();
    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 6;</code>
     */
    java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    getFeaturesMap();
    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 6;</code>
     */

    co.anode.anodium.Rpc.Feature getFeaturesOrDefault(
        int key,
        co.anode.anodium.Rpc.Feature defaultValue);
    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 6;</code>
     */

    co.anode.anodium.Rpc.Feature getFeaturesOrThrow(
        int key);
  }
  /**
   * <pre>
   *An individual vertex/node within the channel graph. A node is
   *connected to other nodes by one or more channel edges emanating from it. As the
   *graph is directed, a node will also have an incoming edge attached to it for
   *each outgoing edge.
   * </pre>
   *
   * Protobuf type {@code co.anode.anodium.LightningNode}
   */
  public  static final class LightningNode extends
      com.google.protobuf.GeneratedMessageLite<
          LightningNode, LightningNode.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.LightningNode)
      LightningNodeOrBuilder {
    private LightningNode() {
      pubKey_ = "";
      alias_ = "";
      addresses_ = emptyProtobufList();
      color_ = "";
    }
    public static final int LAST_UPDATE_FIELD_NUMBER = 1;
    private int lastUpdate_;
    /**
     * <code>uint32 last_update = 1;</code>
     * @return The lastUpdate.
     */
    @java.lang.Override
    public int getLastUpdate() {
      return lastUpdate_;
    }
    /**
     * <code>uint32 last_update = 1;</code>
     * @param value The lastUpdate to set.
     */
    private void setLastUpdate(int value) {
      
      lastUpdate_ = value;
    }
    /**
     * <code>uint32 last_update = 1;</code>
     */
    private void clearLastUpdate() {
      
      lastUpdate_ = 0;
    }

    public static final int PUB_KEY_FIELD_NUMBER = 2;
    private java.lang.String pubKey_;
    /**
     * <code>string pub_key = 2;</code>
     * @return The pubKey.
     */
    @java.lang.Override
    public java.lang.String getPubKey() {
      return pubKey_;
    }
    /**
     * <code>string pub_key = 2;</code>
     * @return The bytes for pubKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPubKeyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(pubKey_);
    }
    /**
     * <code>string pub_key = 2;</code>
     * @param value The pubKey to set.
     */
    private void setPubKey(
        java.lang.String value) {
      value.getClass();
  
      pubKey_ = value;
    }
    /**
     * <code>string pub_key = 2;</code>
     */
    private void clearPubKey() {
      
      pubKey_ = getDefaultInstance().getPubKey();
    }
    /**
     * <code>string pub_key = 2;</code>
     * @param value The bytes for pubKey to set.
     */
    private void setPubKeyBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      pubKey_ = value.toStringUtf8();
      
    }

    public static final int ALIAS_FIELD_NUMBER = 3;
    private java.lang.String alias_;
    /**
     * <code>string alias = 3;</code>
     * @return The alias.
     */
    @java.lang.Override
    public java.lang.String getAlias() {
      return alias_;
    }
    /**
     * <code>string alias = 3;</code>
     * @return The bytes for alias.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAliasBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(alias_);
    }
    /**
     * <code>string alias = 3;</code>
     * @param value The alias to set.
     */
    private void setAlias(
        java.lang.String value) {
      value.getClass();
  
      alias_ = value;
    }
    /**
     * <code>string alias = 3;</code>
     */
    private void clearAlias() {
      
      alias_ = getDefaultInstance().getAlias();
    }
    /**
     * <code>string alias = 3;</code>
     * @param value The bytes for alias to set.
     */
    private void setAliasBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      alias_ = value.toStringUtf8();
      
    }

    public static final int ADDRESSES_FIELD_NUMBER = 4;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.NodeAddress> addresses_;
    /**
     * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.NodeAddress> getAddressesList() {
      return addresses_;
    }
    /**
     * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.NodeAddressOrBuilder> 
        getAddressesOrBuilderList() {
      return addresses_;
    }
    /**
     * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
     */
    @java.lang.Override
    public int getAddressesCount() {
      return addresses_.size();
    }
    /**
     * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.NodeAddress getAddresses(int index) {
      return addresses_.get(index);
    }
    /**
     * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
     */
    public co.anode.anodium.Rpc.NodeAddressOrBuilder getAddressesOrBuilder(
        int index) {
      return addresses_.get(index);
    }
    private void ensureAddressesIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.NodeAddress> tmp = addresses_;
      if (!tmp.isModifiable()) {
        addresses_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
     */
    private void setAddresses(
        int index, co.anode.anodium.Rpc.NodeAddress value) {
      value.getClass();
  ensureAddressesIsMutable();
      addresses_.set(index, value);
    }
    /**
     * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
     */
    private void addAddresses(co.anode.anodium.Rpc.NodeAddress value) {
      value.getClass();
  ensureAddressesIsMutable();
      addresses_.add(value);
    }
    /**
     * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
     */
    private void addAddresses(
        int index, co.anode.anodium.Rpc.NodeAddress value) {
      value.getClass();
  ensureAddressesIsMutable();
      addresses_.add(index, value);
    }
    /**
     * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
     */
    private void addAllAddresses(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.NodeAddress> values) {
      ensureAddressesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, addresses_);
    }
    /**
     * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
     */
    private void clearAddresses() {
      addresses_ = emptyProtobufList();
    }
    /**
     * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
     */
    private void removeAddresses(int index) {
      ensureAddressesIsMutable();
      addresses_.remove(index);
    }

    public static final int COLOR_FIELD_NUMBER = 5;
    private java.lang.String color_;
    /**
     * <code>string color = 5;</code>
     * @return The color.
     */
    @java.lang.Override
    public java.lang.String getColor() {
      return color_;
    }
    /**
     * <code>string color = 5;</code>
     * @return The bytes for color.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getColorBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(color_);
    }
    /**
     * <code>string color = 5;</code>
     * @param value The color to set.
     */
    private void setColor(
        java.lang.String value) {
      value.getClass();
  
      color_ = value;
    }
    /**
     * <code>string color = 5;</code>
     */
    private void clearColor() {
      
      color_ = getDefaultInstance().getColor();
    }
    /**
     * <code>string color = 5;</code>
     * @param value The bytes for color to set.
     */
    private void setColorBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      color_ = value.toStringUtf8();
      
    }

    public static final int FEATURES_FIELD_NUMBER = 6;
    private static final class FeaturesDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Integer, co.anode.anodium.Rpc.Feature> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Integer, co.anode.anodium.Rpc.Feature>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.UINT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  co.anode.anodium.Rpc.Feature.getDefaultInstance());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Integer, co.anode.anodium.Rpc.Feature> features_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    internalGetFeatures() {
      return features_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    internalGetMutableFeatures() {
      if (!features_.isMutable()) {
        features_ = features_.mutableCopy();
      }
      return features_;
    }
    @java.lang.Override

    public int getFeaturesCount() {
      return internalGetFeatures().size();
    }
    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 6;</code>
     */
    @java.lang.Override

    public boolean containsFeatures(
        int key) {
      
      return internalGetFeatures().containsKey(key);
    }
    /**
     * Use {@link #getFeaturesMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeatures() {
      return getFeaturesMap();
    }
    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 6;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeaturesMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetFeatures());
    }
    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 6;</code>
     */
    @java.lang.Override

    public co.anode.anodium.Rpc.Feature getFeaturesOrDefault(
        int key,
        co.anode.anodium.Rpc.Feature defaultValue) {
      
      java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
          internalGetFeatures();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 6;</code>
     */
    @java.lang.Override

    public co.anode.anodium.Rpc.Feature getFeaturesOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
          internalGetFeatures();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 6;</code>
     */
    private java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    getMutableFeaturesMap() {
      return internalGetMutableFeatures();
    }

    public static co.anode.anodium.Rpc.LightningNode parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.LightningNode parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.LightningNode parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.LightningNode parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.LightningNode parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.LightningNode parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.LightningNode parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.LightningNode parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.LightningNode parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.LightningNode parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.LightningNode parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.LightningNode parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.LightningNode prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     *An individual vertex/node within the channel graph. A node is
     *connected to other nodes by one or more channel edges emanating from it. As the
     *graph is directed, a node will also have an incoming edge attached to it for
     *each outgoing edge.
     * </pre>
     *
     * Protobuf type {@code co.anode.anodium.LightningNode}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.LightningNode, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.LightningNode)
        co.anode.anodium.Rpc.LightningNodeOrBuilder {
      // Construct using co.anode.anodium.Rpc.LightningNode.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>uint32 last_update = 1;</code>
       * @return The lastUpdate.
       */
      @java.lang.Override
      public int getLastUpdate() {
        return instance.getLastUpdate();
      }
      /**
       * <code>uint32 last_update = 1;</code>
       * @param value The lastUpdate to set.
       * @return This builder for chaining.
       */
      public Builder setLastUpdate(int value) {
        copyOnWrite();
        instance.setLastUpdate(value);
        return this;
      }
      /**
       * <code>uint32 last_update = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearLastUpdate() {
        copyOnWrite();
        instance.clearLastUpdate();
        return this;
      }

      /**
       * <code>string pub_key = 2;</code>
       * @return The pubKey.
       */
      @java.lang.Override
      public java.lang.String getPubKey() {
        return instance.getPubKey();
      }
      /**
       * <code>string pub_key = 2;</code>
       * @return The bytes for pubKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPubKeyBytes() {
        return instance.getPubKeyBytes();
      }
      /**
       * <code>string pub_key = 2;</code>
       * @param value The pubKey to set.
       * @return This builder for chaining.
       */
      public Builder setPubKey(
          java.lang.String value) {
        copyOnWrite();
        instance.setPubKey(value);
        return this;
      }
      /**
       * <code>string pub_key = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPubKey() {
        copyOnWrite();
        instance.clearPubKey();
        return this;
      }
      /**
       * <code>string pub_key = 2;</code>
       * @param value The bytes for pubKey to set.
       * @return This builder for chaining.
       */
      public Builder setPubKeyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPubKeyBytes(value);
        return this;
      }

      /**
       * <code>string alias = 3;</code>
       * @return The alias.
       */
      @java.lang.Override
      public java.lang.String getAlias() {
        return instance.getAlias();
      }
      /**
       * <code>string alias = 3;</code>
       * @return The bytes for alias.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getAliasBytes() {
        return instance.getAliasBytes();
      }
      /**
       * <code>string alias = 3;</code>
       * @param value The alias to set.
       * @return This builder for chaining.
       */
      public Builder setAlias(
          java.lang.String value) {
        copyOnWrite();
        instance.setAlias(value);
        return this;
      }
      /**
       * <code>string alias = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearAlias() {
        copyOnWrite();
        instance.clearAlias();
        return this;
      }
      /**
       * <code>string alias = 3;</code>
       * @param value The bytes for alias to set.
       * @return This builder for chaining.
       */
      public Builder setAliasBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setAliasBytes(value);
        return this;
      }

      /**
       * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.NodeAddress> getAddressesList() {
        return java.util.Collections.unmodifiableList(
            instance.getAddressesList());
      }
      /**
       * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
       */
      @java.lang.Override
      public int getAddressesCount() {
        return instance.getAddressesCount();
      }/**
       * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.NodeAddress getAddresses(int index) {
        return instance.getAddresses(index);
      }
      /**
       * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
       */
      public Builder setAddresses(
          int index, co.anode.anodium.Rpc.NodeAddress value) {
        copyOnWrite();
        instance.setAddresses(index, value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
       */
      public Builder setAddresses(
          int index, co.anode.anodium.Rpc.NodeAddress.Builder builderForValue) {
        copyOnWrite();
        instance.setAddresses(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
       */
      public Builder addAddresses(co.anode.anodium.Rpc.NodeAddress value) {
        copyOnWrite();
        instance.addAddresses(value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
       */
      public Builder addAddresses(
          int index, co.anode.anodium.Rpc.NodeAddress value) {
        copyOnWrite();
        instance.addAddresses(index, value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
       */
      public Builder addAddresses(
          co.anode.anodium.Rpc.NodeAddress.Builder builderForValue) {
        copyOnWrite();
        instance.addAddresses(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
       */
      public Builder addAddresses(
          int index, co.anode.anodium.Rpc.NodeAddress.Builder builderForValue) {
        copyOnWrite();
        instance.addAddresses(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
       */
      public Builder addAllAddresses(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.NodeAddress> values) {
        copyOnWrite();
        instance.addAllAddresses(values);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
       */
      public Builder clearAddresses() {
        copyOnWrite();
        instance.clearAddresses();
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.NodeAddress addresses = 4;</code>
       */
      public Builder removeAddresses(int index) {
        copyOnWrite();
        instance.removeAddresses(index);
        return this;
      }

      /**
       * <code>string color = 5;</code>
       * @return The color.
       */
      @java.lang.Override
      public java.lang.String getColor() {
        return instance.getColor();
      }
      /**
       * <code>string color = 5;</code>
       * @return The bytes for color.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getColorBytes() {
        return instance.getColorBytes();
      }
      /**
       * <code>string color = 5;</code>
       * @param value The color to set.
       * @return This builder for chaining.
       */
      public Builder setColor(
          java.lang.String value) {
        copyOnWrite();
        instance.setColor(value);
        return this;
      }
      /**
       * <code>string color = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearColor() {
        copyOnWrite();
        instance.clearColor();
        return this;
      }
      /**
       * <code>string color = 5;</code>
       * @param value The bytes for color to set.
       * @return This builder for chaining.
       */
      public Builder setColorBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setColorBytes(value);
        return this;
      }

      @java.lang.Override

      public int getFeaturesCount() {
        return instance.getFeaturesMap().size();
      }
      /**
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 6;</code>
       */
      @java.lang.Override

      public boolean containsFeatures(
          int key) {
        
        return instance.getFeaturesMap().containsKey(key);
      }

      public Builder clearFeatures() {
        copyOnWrite();
        instance.getMutableFeaturesMap().clear();
        return this;
      }
      /**
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 6;</code>
       */

      public Builder removeFeatures(
          int key) {
        
        copyOnWrite();
        instance.getMutableFeaturesMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getFeaturesMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeatures() {
        return getFeaturesMap();
      }
      /**
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 6;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeaturesMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getFeaturesMap());
      }
      /**
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 6;</code>
       */
      @java.lang.Override

      public co.anode.anodium.Rpc.Feature getFeaturesOrDefault(
          int key,
          co.anode.anodium.Rpc.Feature defaultValue) {
        
        java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
            instance.getFeaturesMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 6;</code>
       */
      @java.lang.Override

      public co.anode.anodium.Rpc.Feature getFeaturesOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
            instance.getFeaturesMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 6;</code>
       */
      public Builder putFeatures(
          int key,
          co.anode.anodium.Rpc.Feature value) {
        
        value.getClass();
        copyOnWrite();
        instance.getMutableFeaturesMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 6;</code>
       */
      public Builder putAllFeatures(
          java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> values) {
        copyOnWrite();
        instance.getMutableFeaturesMap().putAll(values);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.LightningNode)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.LightningNode();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "lastUpdate_",
              "pubKey_",
              "alias_",
              "addresses_",
              co.anode.anodium.Rpc.NodeAddress.class,
              "color_",
              "features_",
              FeaturesDefaultEntryHolder.defaultEntry,
            };
            java.lang.String info =
                "\u0000\u0006\u0000\u0000\u0001\u0006\u0006\u0001\u0001\u0000\u0001\u000b\u0002\u0208" +
                "\u0003\u0208\u0004\u001b\u0005\u0208\u00062";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.LightningNode> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.LightningNode.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.LightningNode>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.LightningNode)
    private static final co.anode.anodium.Rpc.LightningNode DEFAULT_INSTANCE;
    static {
      LightningNode defaultInstance = new LightningNode();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        LightningNode.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.LightningNode getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<LightningNode> PARSER;

    public static com.google.protobuf.Parser<LightningNode> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface NodeAddressOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.NodeAddress)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>string network = 1;</code>
     * @return The network.
     */
    java.lang.String getNetwork();
    /**
     * <code>string network = 1;</code>
     * @return The bytes for network.
     */
    com.google.protobuf.ByteString
        getNetworkBytes();

    /**
     * <code>string addr = 2;</code>
     * @return The addr.
     */
    java.lang.String getAddr();
    /**
     * <code>string addr = 2;</code>
     * @return The bytes for addr.
     */
    com.google.protobuf.ByteString
        getAddrBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.NodeAddress}
   */
  public  static final class NodeAddress extends
      com.google.protobuf.GeneratedMessageLite<
          NodeAddress, NodeAddress.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.NodeAddress)
      NodeAddressOrBuilder {
    private NodeAddress() {
      network_ = "";
      addr_ = "";
    }
    public static final int NETWORK_FIELD_NUMBER = 1;
    private java.lang.String network_;
    /**
     * <code>string network = 1;</code>
     * @return The network.
     */
    @java.lang.Override
    public java.lang.String getNetwork() {
      return network_;
    }
    /**
     * <code>string network = 1;</code>
     * @return The bytes for network.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNetworkBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(network_);
    }
    /**
     * <code>string network = 1;</code>
     * @param value The network to set.
     */
    private void setNetwork(
        java.lang.String value) {
      value.getClass();
  
      network_ = value;
    }
    /**
     * <code>string network = 1;</code>
     */
    private void clearNetwork() {
      
      network_ = getDefaultInstance().getNetwork();
    }
    /**
     * <code>string network = 1;</code>
     * @param value The bytes for network to set.
     */
    private void setNetworkBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      network_ = value.toStringUtf8();
      
    }

    public static final int ADDR_FIELD_NUMBER = 2;
    private java.lang.String addr_;
    /**
     * <code>string addr = 2;</code>
     * @return The addr.
     */
    @java.lang.Override
    public java.lang.String getAddr() {
      return addr_;
    }
    /**
     * <code>string addr = 2;</code>
     * @return The bytes for addr.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAddrBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(addr_);
    }
    /**
     * <code>string addr = 2;</code>
     * @param value The addr to set.
     */
    private void setAddr(
        java.lang.String value) {
      value.getClass();
  
      addr_ = value;
    }
    /**
     * <code>string addr = 2;</code>
     */
    private void clearAddr() {
      
      addr_ = getDefaultInstance().getAddr();
    }
    /**
     * <code>string addr = 2;</code>
     * @param value The bytes for addr to set.
     */
    private void setAddrBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      addr_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.NodeAddress parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodeAddress parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeAddress parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodeAddress parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeAddress parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodeAddress parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeAddress parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodeAddress parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeAddress parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodeAddress parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeAddress parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodeAddress parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.NodeAddress prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.NodeAddress}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.NodeAddress, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.NodeAddress)
        co.anode.anodium.Rpc.NodeAddressOrBuilder {
      // Construct using co.anode.anodium.Rpc.NodeAddress.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>string network = 1;</code>
       * @return The network.
       */
      @java.lang.Override
      public java.lang.String getNetwork() {
        return instance.getNetwork();
      }
      /**
       * <code>string network = 1;</code>
       * @return The bytes for network.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNetworkBytes() {
        return instance.getNetworkBytes();
      }
      /**
       * <code>string network = 1;</code>
       * @param value The network to set.
       * @return This builder for chaining.
       */
      public Builder setNetwork(
          java.lang.String value) {
        copyOnWrite();
        instance.setNetwork(value);
        return this;
      }
      /**
       * <code>string network = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearNetwork() {
        copyOnWrite();
        instance.clearNetwork();
        return this;
      }
      /**
       * <code>string network = 1;</code>
       * @param value The bytes for network to set.
       * @return This builder for chaining.
       */
      public Builder setNetworkBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNetworkBytes(value);
        return this;
      }

      /**
       * <code>string addr = 2;</code>
       * @return The addr.
       */
      @java.lang.Override
      public java.lang.String getAddr() {
        return instance.getAddr();
      }
      /**
       * <code>string addr = 2;</code>
       * @return The bytes for addr.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getAddrBytes() {
        return instance.getAddrBytes();
      }
      /**
       * <code>string addr = 2;</code>
       * @param value The addr to set.
       * @return This builder for chaining.
       */
      public Builder setAddr(
          java.lang.String value) {
        copyOnWrite();
        instance.setAddr(value);
        return this;
      }
      /**
       * <code>string addr = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAddr() {
        copyOnWrite();
        instance.clearAddr();
        return this;
      }
      /**
       * <code>string addr = 2;</code>
       * @param value The bytes for addr to set.
       * @return This builder for chaining.
       */
      public Builder setAddrBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setAddrBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.NodeAddress)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.NodeAddress();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "network_",
              "addr_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0208\u0002\u0208" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.NodeAddress> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.NodeAddress.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.NodeAddress>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.NodeAddress)
    private static final co.anode.anodium.Rpc.NodeAddress DEFAULT_INSTANCE;
    static {
      NodeAddress defaultInstance = new NodeAddress();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        NodeAddress.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.NodeAddress getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<NodeAddress> PARSER;

    public static com.google.protobuf.Parser<NodeAddress> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface RoutingPolicyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.RoutingPolicy)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>uint32 time_lock_delta = 1;</code>
     * @return The timeLockDelta.
     */
    int getTimeLockDelta();

    /**
     * <code>int64 min_htlc = 2;</code>
     * @return The minHtlc.
     */
    long getMinHtlc();

    /**
     * <code>int64 fee_base_msat = 3;</code>
     * @return The feeBaseMsat.
     */
    long getFeeBaseMsat();

    /**
     * <code>int64 fee_rate_milli_msat = 4;</code>
     * @return The feeRateMilliMsat.
     */
    long getFeeRateMilliMsat();

    /**
     * <code>bool disabled = 5;</code>
     * @return The disabled.
     */
    boolean getDisabled();

    /**
     * <code>uint64 max_htlc_msat = 6;</code>
     * @return The maxHtlcMsat.
     */
    long getMaxHtlcMsat();

    /**
     * <code>uint32 last_update = 7;</code>
     * @return The lastUpdate.
     */
    int getLastUpdate();
  }
  /**
   * Protobuf type {@code co.anode.anodium.RoutingPolicy}
   */
  public  static final class RoutingPolicy extends
      com.google.protobuf.GeneratedMessageLite<
          RoutingPolicy, RoutingPolicy.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.RoutingPolicy)
      RoutingPolicyOrBuilder {
    private RoutingPolicy() {
    }
    public static final int TIME_LOCK_DELTA_FIELD_NUMBER = 1;
    private int timeLockDelta_;
    /**
     * <code>uint32 time_lock_delta = 1;</code>
     * @return The timeLockDelta.
     */
    @java.lang.Override
    public int getTimeLockDelta() {
      return timeLockDelta_;
    }
    /**
     * <code>uint32 time_lock_delta = 1;</code>
     * @param value The timeLockDelta to set.
     */
    private void setTimeLockDelta(int value) {
      
      timeLockDelta_ = value;
    }
    /**
     * <code>uint32 time_lock_delta = 1;</code>
     */
    private void clearTimeLockDelta() {
      
      timeLockDelta_ = 0;
    }

    public static final int MIN_HTLC_FIELD_NUMBER = 2;
    private long minHtlc_;
    /**
     * <code>int64 min_htlc = 2;</code>
     * @return The minHtlc.
     */
    @java.lang.Override
    public long getMinHtlc() {
      return minHtlc_;
    }
    /**
     * <code>int64 min_htlc = 2;</code>
     * @param value The minHtlc to set.
     */
    private void setMinHtlc(long value) {
      
      minHtlc_ = value;
    }
    /**
     * <code>int64 min_htlc = 2;</code>
     */
    private void clearMinHtlc() {
      
      minHtlc_ = 0L;
    }

    public static final int FEE_BASE_MSAT_FIELD_NUMBER = 3;
    private long feeBaseMsat_;
    /**
     * <code>int64 fee_base_msat = 3;</code>
     * @return The feeBaseMsat.
     */
    @java.lang.Override
    public long getFeeBaseMsat() {
      return feeBaseMsat_;
    }
    /**
     * <code>int64 fee_base_msat = 3;</code>
     * @param value The feeBaseMsat to set.
     */
    private void setFeeBaseMsat(long value) {
      
      feeBaseMsat_ = value;
    }
    /**
     * <code>int64 fee_base_msat = 3;</code>
     */
    private void clearFeeBaseMsat() {
      
      feeBaseMsat_ = 0L;
    }

    public static final int FEE_RATE_MILLI_MSAT_FIELD_NUMBER = 4;
    private long feeRateMilliMsat_;
    /**
     * <code>int64 fee_rate_milli_msat = 4;</code>
     * @return The feeRateMilliMsat.
     */
    @java.lang.Override
    public long getFeeRateMilliMsat() {
      return feeRateMilliMsat_;
    }
    /**
     * <code>int64 fee_rate_milli_msat = 4;</code>
     * @param value The feeRateMilliMsat to set.
     */
    private void setFeeRateMilliMsat(long value) {
      
      feeRateMilliMsat_ = value;
    }
    /**
     * <code>int64 fee_rate_milli_msat = 4;</code>
     */
    private void clearFeeRateMilliMsat() {
      
      feeRateMilliMsat_ = 0L;
    }

    public static final int DISABLED_FIELD_NUMBER = 5;
    private boolean disabled_;
    /**
     * <code>bool disabled = 5;</code>
     * @return The disabled.
     */
    @java.lang.Override
    public boolean getDisabled() {
      return disabled_;
    }
    /**
     * <code>bool disabled = 5;</code>
     * @param value The disabled to set.
     */
    private void setDisabled(boolean value) {
      
      disabled_ = value;
    }
    /**
     * <code>bool disabled = 5;</code>
     */
    private void clearDisabled() {
      
      disabled_ = false;
    }

    public static final int MAX_HTLC_MSAT_FIELD_NUMBER = 6;
    private long maxHtlcMsat_;
    /**
     * <code>uint64 max_htlc_msat = 6;</code>
     * @return The maxHtlcMsat.
     */
    @java.lang.Override
    public long getMaxHtlcMsat() {
      return maxHtlcMsat_;
    }
    /**
     * <code>uint64 max_htlc_msat = 6;</code>
     * @param value The maxHtlcMsat to set.
     */
    private void setMaxHtlcMsat(long value) {
      
      maxHtlcMsat_ = value;
    }
    /**
     * <code>uint64 max_htlc_msat = 6;</code>
     */
    private void clearMaxHtlcMsat() {
      
      maxHtlcMsat_ = 0L;
    }

    public static final int LAST_UPDATE_FIELD_NUMBER = 7;
    private int lastUpdate_;
    /**
     * <code>uint32 last_update = 7;</code>
     * @return The lastUpdate.
     */
    @java.lang.Override
    public int getLastUpdate() {
      return lastUpdate_;
    }
    /**
     * <code>uint32 last_update = 7;</code>
     * @param value The lastUpdate to set.
     */
    private void setLastUpdate(int value) {
      
      lastUpdate_ = value;
    }
    /**
     * <code>uint32 last_update = 7;</code>
     */
    private void clearLastUpdate() {
      
      lastUpdate_ = 0;
    }

    public static co.anode.anodium.Rpc.RoutingPolicy parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.RoutingPolicy parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RoutingPolicy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.RoutingPolicy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RoutingPolicy parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.RoutingPolicy parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RoutingPolicy parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.RoutingPolicy parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RoutingPolicy parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.RoutingPolicy parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RoutingPolicy parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.RoutingPolicy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.RoutingPolicy prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.RoutingPolicy}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.RoutingPolicy, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.RoutingPolicy)
        co.anode.anodium.Rpc.RoutingPolicyOrBuilder {
      // Construct using co.anode.anodium.Rpc.RoutingPolicy.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>uint32 time_lock_delta = 1;</code>
       * @return The timeLockDelta.
       */
      @java.lang.Override
      public int getTimeLockDelta() {
        return instance.getTimeLockDelta();
      }
      /**
       * <code>uint32 time_lock_delta = 1;</code>
       * @param value The timeLockDelta to set.
       * @return This builder for chaining.
       */
      public Builder setTimeLockDelta(int value) {
        copyOnWrite();
        instance.setTimeLockDelta(value);
        return this;
      }
      /**
       * <code>uint32 time_lock_delta = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimeLockDelta() {
        copyOnWrite();
        instance.clearTimeLockDelta();
        return this;
      }

      /**
       * <code>int64 min_htlc = 2;</code>
       * @return The minHtlc.
       */
      @java.lang.Override
      public long getMinHtlc() {
        return instance.getMinHtlc();
      }
      /**
       * <code>int64 min_htlc = 2;</code>
       * @param value The minHtlc to set.
       * @return This builder for chaining.
       */
      public Builder setMinHtlc(long value) {
        copyOnWrite();
        instance.setMinHtlc(value);
        return this;
      }
      /**
       * <code>int64 min_htlc = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinHtlc() {
        copyOnWrite();
        instance.clearMinHtlc();
        return this;
      }

      /**
       * <code>int64 fee_base_msat = 3;</code>
       * @return The feeBaseMsat.
       */
      @java.lang.Override
      public long getFeeBaseMsat() {
        return instance.getFeeBaseMsat();
      }
      /**
       * <code>int64 fee_base_msat = 3;</code>
       * @param value The feeBaseMsat to set.
       * @return This builder for chaining.
       */
      public Builder setFeeBaseMsat(long value) {
        copyOnWrite();
        instance.setFeeBaseMsat(value);
        return this;
      }
      /**
       * <code>int64 fee_base_msat = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearFeeBaseMsat() {
        copyOnWrite();
        instance.clearFeeBaseMsat();
        return this;
      }

      /**
       * <code>int64 fee_rate_milli_msat = 4;</code>
       * @return The feeRateMilliMsat.
       */
      @java.lang.Override
      public long getFeeRateMilliMsat() {
        return instance.getFeeRateMilliMsat();
      }
      /**
       * <code>int64 fee_rate_milli_msat = 4;</code>
       * @param value The feeRateMilliMsat to set.
       * @return This builder for chaining.
       */
      public Builder setFeeRateMilliMsat(long value) {
        copyOnWrite();
        instance.setFeeRateMilliMsat(value);
        return this;
      }
      /**
       * <code>int64 fee_rate_milli_msat = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearFeeRateMilliMsat() {
        copyOnWrite();
        instance.clearFeeRateMilliMsat();
        return this;
      }

      /**
       * <code>bool disabled = 5;</code>
       * @return The disabled.
       */
      @java.lang.Override
      public boolean getDisabled() {
        return instance.getDisabled();
      }
      /**
       * <code>bool disabled = 5;</code>
       * @param value The disabled to set.
       * @return This builder for chaining.
       */
      public Builder setDisabled(boolean value) {
        copyOnWrite();
        instance.setDisabled(value);
        return this;
      }
      /**
       * <code>bool disabled = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearDisabled() {
        copyOnWrite();
        instance.clearDisabled();
        return this;
      }

      /**
       * <code>uint64 max_htlc_msat = 6;</code>
       * @return The maxHtlcMsat.
       */
      @java.lang.Override
      public long getMaxHtlcMsat() {
        return instance.getMaxHtlcMsat();
      }
      /**
       * <code>uint64 max_htlc_msat = 6;</code>
       * @param value The maxHtlcMsat to set.
       * @return This builder for chaining.
       */
      public Builder setMaxHtlcMsat(long value) {
        copyOnWrite();
        instance.setMaxHtlcMsat(value);
        return this;
      }
      /**
       * <code>uint64 max_htlc_msat = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxHtlcMsat() {
        copyOnWrite();
        instance.clearMaxHtlcMsat();
        return this;
      }

      /**
       * <code>uint32 last_update = 7;</code>
       * @return The lastUpdate.
       */
      @java.lang.Override
      public int getLastUpdate() {
        return instance.getLastUpdate();
      }
      /**
       * <code>uint32 last_update = 7;</code>
       * @param value The lastUpdate to set.
       * @return This builder for chaining.
       */
      public Builder setLastUpdate(int value) {
        copyOnWrite();
        instance.setLastUpdate(value);
        return this;
      }
      /**
       * <code>uint32 last_update = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearLastUpdate() {
        copyOnWrite();
        instance.clearLastUpdate();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.RoutingPolicy)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.RoutingPolicy();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "timeLockDelta_",
              "minHtlc_",
              "feeBaseMsat_",
              "feeRateMilliMsat_",
              "disabled_",
              "maxHtlcMsat_",
              "lastUpdate_",
            };
            java.lang.String info =
                "\u0000\u0007\u0000\u0000\u0001\u0007\u0007\u0000\u0000\u0000\u0001\u000b\u0002\u0002" +
                "\u0003\u0002\u0004\u0002\u0005\u0007\u0006\u0003\u0007\u000b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.RoutingPolicy> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.RoutingPolicy.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.RoutingPolicy>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.RoutingPolicy)
    private static final co.anode.anodium.Rpc.RoutingPolicy DEFAULT_INSTANCE;
    static {
      RoutingPolicy defaultInstance = new RoutingPolicy();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        RoutingPolicy.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.RoutingPolicy getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<RoutingPolicy> PARSER;

    public static com.google.protobuf.Parser<RoutingPolicy> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelEdgeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelEdge)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
     * @return The channelId.
     */
    long getChannelId();

    /**
     * <code>string chan_point = 2;</code>
     * @return The chanPoint.
     */
    java.lang.String getChanPoint();
    /**
     * <code>string chan_point = 2;</code>
     * @return The bytes for chanPoint.
     */
    com.google.protobuf.ByteString
        getChanPointBytes();

    /**
     * <code>uint32 last_update = 3 [deprecated = true];</code>
     * @return The lastUpdate.
     */
    @java.lang.Deprecated int getLastUpdate();

    /**
     * <code>string node1_pub = 4;</code>
     * @return The node1Pub.
     */
    java.lang.String getNode1Pub();
    /**
     * <code>string node1_pub = 4;</code>
     * @return The bytes for node1Pub.
     */
    com.google.protobuf.ByteString
        getNode1PubBytes();

    /**
     * <code>string node2_pub = 5;</code>
     * @return The node2Pub.
     */
    java.lang.String getNode2Pub();
    /**
     * <code>string node2_pub = 5;</code>
     * @return The bytes for node2Pub.
     */
    com.google.protobuf.ByteString
        getNode2PubBytes();

    /**
     * <code>int64 capacity = 6;</code>
     * @return The capacity.
     */
    long getCapacity();

    /**
     * <code>.co.anode.anodium.RoutingPolicy node1_policy = 7;</code>
     * @return Whether the node1Policy field is set.
     */
    boolean hasNode1Policy();
    /**
     * <code>.co.anode.anodium.RoutingPolicy node1_policy = 7;</code>
     * @return The node1Policy.
     */
    co.anode.anodium.Rpc.RoutingPolicy getNode1Policy();

    /**
     * <code>.co.anode.anodium.RoutingPolicy node2_policy = 8;</code>
     * @return Whether the node2Policy field is set.
     */
    boolean hasNode2Policy();
    /**
     * <code>.co.anode.anodium.RoutingPolicy node2_policy = 8;</code>
     * @return The node2Policy.
     */
    co.anode.anodium.Rpc.RoutingPolicy getNode2Policy();
  }
  /**
   * <pre>
   *A fully authenticated channel along with all its unique attributes.
   *Once an authenticated channel announcement has been processed on the network,
   *then an instance of ChannelEdgeInfo encapsulating the channels attributes is
   *stored. The other portions relevant to routing policy of a channel are stored
   *within a ChannelEdgePolicy for each direction of the channel.
   * </pre>
   *
   * Protobuf type {@code co.anode.anodium.ChannelEdge}
   */
  public  static final class ChannelEdge extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelEdge, ChannelEdge.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelEdge)
      ChannelEdgeOrBuilder {
    private ChannelEdge() {
      chanPoint_ = "";
      node1Pub_ = "";
      node2Pub_ = "";
    }
    public static final int CHANNEL_ID_FIELD_NUMBER = 1;
    private long channelId_;
    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
     * @return The channelId.
     */
    @java.lang.Override
    public long getChannelId() {
      return channelId_;
    }
    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
     * @param value The channelId to set.
     */
    private void setChannelId(long value) {
      
      channelId_ = value;
    }
    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
     */
    private void clearChannelId() {
      
      channelId_ = 0L;
    }

    public static final int CHAN_POINT_FIELD_NUMBER = 2;
    private java.lang.String chanPoint_;
    /**
     * <code>string chan_point = 2;</code>
     * @return The chanPoint.
     */
    @java.lang.Override
    public java.lang.String getChanPoint() {
      return chanPoint_;
    }
    /**
     * <code>string chan_point = 2;</code>
     * @return The bytes for chanPoint.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getChanPointBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(chanPoint_);
    }
    /**
     * <code>string chan_point = 2;</code>
     * @param value The chanPoint to set.
     */
    private void setChanPoint(
        java.lang.String value) {
      value.getClass();
  
      chanPoint_ = value;
    }
    /**
     * <code>string chan_point = 2;</code>
     */
    private void clearChanPoint() {
      
      chanPoint_ = getDefaultInstance().getChanPoint();
    }
    /**
     * <code>string chan_point = 2;</code>
     * @param value The bytes for chanPoint to set.
     */
    private void setChanPointBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      chanPoint_ = value.toStringUtf8();
      
    }

    public static final int LAST_UPDATE_FIELD_NUMBER = 3;
    private int lastUpdate_;
    /**
     * <code>uint32 last_update = 3 [deprecated = true];</code>
     * @return The lastUpdate.
     */
    @java.lang.Override
    @java.lang.Deprecated public int getLastUpdate() {
      return lastUpdate_;
    }
    /**
     * <code>uint32 last_update = 3 [deprecated = true];</code>
     * @param value The lastUpdate to set.
     */
    private void setLastUpdate(int value) {
      
      lastUpdate_ = value;
    }
    /**
     * <code>uint32 last_update = 3 [deprecated = true];</code>
     */
    private void clearLastUpdate() {
      
      lastUpdate_ = 0;
    }

    public static final int NODE1_PUB_FIELD_NUMBER = 4;
    private java.lang.String node1Pub_;
    /**
     * <code>string node1_pub = 4;</code>
     * @return The node1Pub.
     */
    @java.lang.Override
    public java.lang.String getNode1Pub() {
      return node1Pub_;
    }
    /**
     * <code>string node1_pub = 4;</code>
     * @return The bytes for node1Pub.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNode1PubBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(node1Pub_);
    }
    /**
     * <code>string node1_pub = 4;</code>
     * @param value The node1Pub to set.
     */
    private void setNode1Pub(
        java.lang.String value) {
      value.getClass();
  
      node1Pub_ = value;
    }
    /**
     * <code>string node1_pub = 4;</code>
     */
    private void clearNode1Pub() {
      
      node1Pub_ = getDefaultInstance().getNode1Pub();
    }
    /**
     * <code>string node1_pub = 4;</code>
     * @param value The bytes for node1Pub to set.
     */
    private void setNode1PubBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      node1Pub_ = value.toStringUtf8();
      
    }

    public static final int NODE2_PUB_FIELD_NUMBER = 5;
    private java.lang.String node2Pub_;
    /**
     * <code>string node2_pub = 5;</code>
     * @return The node2Pub.
     */
    @java.lang.Override
    public java.lang.String getNode2Pub() {
      return node2Pub_;
    }
    /**
     * <code>string node2_pub = 5;</code>
     * @return The bytes for node2Pub.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNode2PubBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(node2Pub_);
    }
    /**
     * <code>string node2_pub = 5;</code>
     * @param value The node2Pub to set.
     */
    private void setNode2Pub(
        java.lang.String value) {
      value.getClass();
  
      node2Pub_ = value;
    }
    /**
     * <code>string node2_pub = 5;</code>
     */
    private void clearNode2Pub() {
      
      node2Pub_ = getDefaultInstance().getNode2Pub();
    }
    /**
     * <code>string node2_pub = 5;</code>
     * @param value The bytes for node2Pub to set.
     */
    private void setNode2PubBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      node2Pub_ = value.toStringUtf8();
      
    }

    public static final int CAPACITY_FIELD_NUMBER = 6;
    private long capacity_;
    /**
     * <code>int64 capacity = 6;</code>
     * @return The capacity.
     */
    @java.lang.Override
    public long getCapacity() {
      return capacity_;
    }
    /**
     * <code>int64 capacity = 6;</code>
     * @param value The capacity to set.
     */
    private void setCapacity(long value) {
      
      capacity_ = value;
    }
    /**
     * <code>int64 capacity = 6;</code>
     */
    private void clearCapacity() {
      
      capacity_ = 0L;
    }

    public static final int NODE1_POLICY_FIELD_NUMBER = 7;
    private co.anode.anodium.Rpc.RoutingPolicy node1Policy_;
    /**
     * <code>.co.anode.anodium.RoutingPolicy node1_policy = 7;</code>
     */
    @java.lang.Override
    public boolean hasNode1Policy() {
      return node1Policy_ != null;
    }
    /**
     * <code>.co.anode.anodium.RoutingPolicy node1_policy = 7;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.RoutingPolicy getNode1Policy() {
      return node1Policy_ == null ? co.anode.anodium.Rpc.RoutingPolicy.getDefaultInstance() : node1Policy_;
    }
    /**
     * <code>.co.anode.anodium.RoutingPolicy node1_policy = 7;</code>
     */
    private void setNode1Policy(co.anode.anodium.Rpc.RoutingPolicy value) {
      value.getClass();
  node1Policy_ = value;
      
      }
    /**
     * <code>.co.anode.anodium.RoutingPolicy node1_policy = 7;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeNode1Policy(co.anode.anodium.Rpc.RoutingPolicy value) {
      value.getClass();
  if (node1Policy_ != null &&
          node1Policy_ != co.anode.anodium.Rpc.RoutingPolicy.getDefaultInstance()) {
        node1Policy_ =
          co.anode.anodium.Rpc.RoutingPolicy.newBuilder(node1Policy_).mergeFrom(value).buildPartial();
      } else {
        node1Policy_ = value;
      }
      
    }
    /**
     * <code>.co.anode.anodium.RoutingPolicy node1_policy = 7;</code>
     */
    private void clearNode1Policy() {  node1Policy_ = null;
      
    }

    public static final int NODE2_POLICY_FIELD_NUMBER = 8;
    private co.anode.anodium.Rpc.RoutingPolicy node2Policy_;
    /**
     * <code>.co.anode.anodium.RoutingPolicy node2_policy = 8;</code>
     */
    @java.lang.Override
    public boolean hasNode2Policy() {
      return node2Policy_ != null;
    }
    /**
     * <code>.co.anode.anodium.RoutingPolicy node2_policy = 8;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.RoutingPolicy getNode2Policy() {
      return node2Policy_ == null ? co.anode.anodium.Rpc.RoutingPolicy.getDefaultInstance() : node2Policy_;
    }
    /**
     * <code>.co.anode.anodium.RoutingPolicy node2_policy = 8;</code>
     */
    private void setNode2Policy(co.anode.anodium.Rpc.RoutingPolicy value) {
      value.getClass();
  node2Policy_ = value;
      
      }
    /**
     * <code>.co.anode.anodium.RoutingPolicy node2_policy = 8;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeNode2Policy(co.anode.anodium.Rpc.RoutingPolicy value) {
      value.getClass();
  if (node2Policy_ != null &&
          node2Policy_ != co.anode.anodium.Rpc.RoutingPolicy.getDefaultInstance()) {
        node2Policy_ =
          co.anode.anodium.Rpc.RoutingPolicy.newBuilder(node2Policy_).mergeFrom(value).buildPartial();
      } else {
        node2Policy_ = value;
      }
      
    }
    /**
     * <code>.co.anode.anodium.RoutingPolicy node2_policy = 8;</code>
     */
    private void clearNode2Policy() {  node2Policy_ = null;
      
    }

    public static co.anode.anodium.Rpc.ChannelEdge parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelEdge parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEdge parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelEdge parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEdge parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelEdge parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEdge parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelEdge parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEdge parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelEdge parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEdge parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelEdge parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelEdge prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     *A fully authenticated channel along with all its unique attributes.
     *Once an authenticated channel announcement has been processed on the network,
     *then an instance of ChannelEdgeInfo encapsulating the channels attributes is
     *stored. The other portions relevant to routing policy of a channel are stored
     *within a ChannelEdgePolicy for each direction of the channel.
     * </pre>
     *
     * Protobuf type {@code co.anode.anodium.ChannelEdge}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelEdge, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelEdge)
        co.anode.anodium.Rpc.ChannelEdgeOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelEdge.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The unique channel ID for the channel. The first 3 bytes are the block
       *height, the next 3 the index within the block, and the last 2 bytes are the
       *output index for the channel.
       * </pre>
       *
       * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
       * @return The channelId.
       */
      @java.lang.Override
      public long getChannelId() {
        return instance.getChannelId();
      }
      /**
       * <pre>
       *The unique channel ID for the channel. The first 3 bytes are the block
       *height, the next 3 the index within the block, and the last 2 bytes are the
       *output index for the channel.
       * </pre>
       *
       * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
       * @param value The channelId to set.
       * @return This builder for chaining.
       */
      public Builder setChannelId(long value) {
        copyOnWrite();
        instance.setChannelId(value);
        return this;
      }
      /**
       * <pre>
       *The unique channel ID for the channel. The first 3 bytes are the block
       *height, the next 3 the index within the block, and the last 2 bytes are the
       *output index for the channel.
       * </pre>
       *
       * <code>uint64 channel_id = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearChannelId() {
        copyOnWrite();
        instance.clearChannelId();
        return this;
      }

      /**
       * <code>string chan_point = 2;</code>
       * @return The chanPoint.
       */
      @java.lang.Override
      public java.lang.String getChanPoint() {
        return instance.getChanPoint();
      }
      /**
       * <code>string chan_point = 2;</code>
       * @return The bytes for chanPoint.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getChanPointBytes() {
        return instance.getChanPointBytes();
      }
      /**
       * <code>string chan_point = 2;</code>
       * @param value The chanPoint to set.
       * @return This builder for chaining.
       */
      public Builder setChanPoint(
          java.lang.String value) {
        copyOnWrite();
        instance.setChanPoint(value);
        return this;
      }
      /**
       * <code>string chan_point = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearChanPoint() {
        copyOnWrite();
        instance.clearChanPoint();
        return this;
      }
      /**
       * <code>string chan_point = 2;</code>
       * @param value The bytes for chanPoint to set.
       * @return This builder for chaining.
       */
      public Builder setChanPointBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setChanPointBytes(value);
        return this;
      }

      /**
       * <code>uint32 last_update = 3 [deprecated = true];</code>
       * @return The lastUpdate.
       */
      @java.lang.Override
      @java.lang.Deprecated public int getLastUpdate() {
        return instance.getLastUpdate();
      }
      /**
       * <code>uint32 last_update = 3 [deprecated = true];</code>
       * @param value The lastUpdate to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setLastUpdate(int value) {
        copyOnWrite();
        instance.setLastUpdate(value);
        return this;
      }
      /**
       * <code>uint32 last_update = 3 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearLastUpdate() {
        copyOnWrite();
        instance.clearLastUpdate();
        return this;
      }

      /**
       * <code>string node1_pub = 4;</code>
       * @return The node1Pub.
       */
      @java.lang.Override
      public java.lang.String getNode1Pub() {
        return instance.getNode1Pub();
      }
      /**
       * <code>string node1_pub = 4;</code>
       * @return The bytes for node1Pub.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNode1PubBytes() {
        return instance.getNode1PubBytes();
      }
      /**
       * <code>string node1_pub = 4;</code>
       * @param value The node1Pub to set.
       * @return This builder for chaining.
       */
      public Builder setNode1Pub(
          java.lang.String value) {
        copyOnWrite();
        instance.setNode1Pub(value);
        return this;
      }
      /**
       * <code>string node1_pub = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearNode1Pub() {
        copyOnWrite();
        instance.clearNode1Pub();
        return this;
      }
      /**
       * <code>string node1_pub = 4;</code>
       * @param value The bytes for node1Pub to set.
       * @return This builder for chaining.
       */
      public Builder setNode1PubBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNode1PubBytes(value);
        return this;
      }

      /**
       * <code>string node2_pub = 5;</code>
       * @return The node2Pub.
       */
      @java.lang.Override
      public java.lang.String getNode2Pub() {
        return instance.getNode2Pub();
      }
      /**
       * <code>string node2_pub = 5;</code>
       * @return The bytes for node2Pub.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNode2PubBytes() {
        return instance.getNode2PubBytes();
      }
      /**
       * <code>string node2_pub = 5;</code>
       * @param value The node2Pub to set.
       * @return This builder for chaining.
       */
      public Builder setNode2Pub(
          java.lang.String value) {
        copyOnWrite();
        instance.setNode2Pub(value);
        return this;
      }
      /**
       * <code>string node2_pub = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearNode2Pub() {
        copyOnWrite();
        instance.clearNode2Pub();
        return this;
      }
      /**
       * <code>string node2_pub = 5;</code>
       * @param value The bytes for node2Pub to set.
       * @return This builder for chaining.
       */
      public Builder setNode2PubBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNode2PubBytes(value);
        return this;
      }

      /**
       * <code>int64 capacity = 6;</code>
       * @return The capacity.
       */
      @java.lang.Override
      public long getCapacity() {
        return instance.getCapacity();
      }
      /**
       * <code>int64 capacity = 6;</code>
       * @param value The capacity to set.
       * @return This builder for chaining.
       */
      public Builder setCapacity(long value) {
        copyOnWrite();
        instance.setCapacity(value);
        return this;
      }
      /**
       * <code>int64 capacity = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearCapacity() {
        copyOnWrite();
        instance.clearCapacity();
        return this;
      }

      /**
       * <code>.co.anode.anodium.RoutingPolicy node1_policy = 7;</code>
       */
      @java.lang.Override
      public boolean hasNode1Policy() {
        return instance.hasNode1Policy();
      }
      /**
       * <code>.co.anode.anodium.RoutingPolicy node1_policy = 7;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.RoutingPolicy getNode1Policy() {
        return instance.getNode1Policy();
      }
      /**
       * <code>.co.anode.anodium.RoutingPolicy node1_policy = 7;</code>
       */
      public Builder setNode1Policy(co.anode.anodium.Rpc.RoutingPolicy value) {
        copyOnWrite();
        instance.setNode1Policy(value);
        return this;
        }
      /**
       * <code>.co.anode.anodium.RoutingPolicy node1_policy = 7;</code>
       */
      public Builder setNode1Policy(
          co.anode.anodium.Rpc.RoutingPolicy.Builder builderForValue) {
        copyOnWrite();
        instance.setNode1Policy(builderForValue.build());
        return this;
      }
      /**
       * <code>.co.anode.anodium.RoutingPolicy node1_policy = 7;</code>
       */
      public Builder mergeNode1Policy(co.anode.anodium.Rpc.RoutingPolicy value) {
        copyOnWrite();
        instance.mergeNode1Policy(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.RoutingPolicy node1_policy = 7;</code>
       */
      public Builder clearNode1Policy() {  copyOnWrite();
        instance.clearNode1Policy();
        return this;
      }

      /**
       * <code>.co.anode.anodium.RoutingPolicy node2_policy = 8;</code>
       */
      @java.lang.Override
      public boolean hasNode2Policy() {
        return instance.hasNode2Policy();
      }
      /**
       * <code>.co.anode.anodium.RoutingPolicy node2_policy = 8;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.RoutingPolicy getNode2Policy() {
        return instance.getNode2Policy();
      }
      /**
       * <code>.co.anode.anodium.RoutingPolicy node2_policy = 8;</code>
       */
      public Builder setNode2Policy(co.anode.anodium.Rpc.RoutingPolicy value) {
        copyOnWrite();
        instance.setNode2Policy(value);
        return this;
        }
      /**
       * <code>.co.anode.anodium.RoutingPolicy node2_policy = 8;</code>
       */
      public Builder setNode2Policy(
          co.anode.anodium.Rpc.RoutingPolicy.Builder builderForValue) {
        copyOnWrite();
        instance.setNode2Policy(builderForValue.build());
        return this;
      }
      /**
       * <code>.co.anode.anodium.RoutingPolicy node2_policy = 8;</code>
       */
      public Builder mergeNode2Policy(co.anode.anodium.Rpc.RoutingPolicy value) {
        copyOnWrite();
        instance.mergeNode2Policy(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.RoutingPolicy node2_policy = 8;</code>
       */
      public Builder clearNode2Policy() {  copyOnWrite();
        instance.clearNode2Policy();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelEdge)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelEdge();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "channelId_",
              "chanPoint_",
              "lastUpdate_",
              "node1Pub_",
              "node2Pub_",
              "capacity_",
              "node1Policy_",
              "node2Policy_",
            };
            java.lang.String info =
                "\u0000\b\u0000\u0000\u0001\b\b\u0000\u0000\u0000\u0001\u0003\u0002\u0208\u0003\u000b" +
                "\u0004\u0208\u0005\u0208\u0006\u0002\u0007\t\b\t";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelEdge> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelEdge.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelEdge>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelEdge)
    private static final co.anode.anodium.Rpc.ChannelEdge DEFAULT_INSTANCE;
    static {
      ChannelEdge defaultInstance = new ChannelEdge();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelEdge.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelEdge getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelEdge> PARSER;

    public static com.google.protobuf.Parser<ChannelEdge> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelGraphRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelGraphRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *Whether unannounced channels are included in the response or not. If set,
     *unannounced channels are included. Unannounced channels are both private
     *channels, and public channels that are not yet announced to the network.
     * </pre>
     *
     * <code>bool include_unannounced = 1;</code>
     * @return The includeUnannounced.
     */
    boolean getIncludeUnannounced();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChannelGraphRequest}
   */
  public  static final class ChannelGraphRequest extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelGraphRequest, ChannelGraphRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelGraphRequest)
      ChannelGraphRequestOrBuilder {
    private ChannelGraphRequest() {
    }
    public static final int INCLUDE_UNANNOUNCED_FIELD_NUMBER = 1;
    private boolean includeUnannounced_;
    /**
     * <pre>
     *Whether unannounced channels are included in the response or not. If set,
     *unannounced channels are included. Unannounced channels are both private
     *channels, and public channels that are not yet announced to the network.
     * </pre>
     *
     * <code>bool include_unannounced = 1;</code>
     * @return The includeUnannounced.
     */
    @java.lang.Override
    public boolean getIncludeUnannounced() {
      return includeUnannounced_;
    }
    /**
     * <pre>
     *Whether unannounced channels are included in the response or not. If set,
     *unannounced channels are included. Unannounced channels are both private
     *channels, and public channels that are not yet announced to the network.
     * </pre>
     *
     * <code>bool include_unannounced = 1;</code>
     * @param value The includeUnannounced to set.
     */
    private void setIncludeUnannounced(boolean value) {
      
      includeUnannounced_ = value;
    }
    /**
     * <pre>
     *Whether unannounced channels are included in the response or not. If set,
     *unannounced channels are included. Unannounced channels are both private
     *channels, and public channels that are not yet announced to the network.
     * </pre>
     *
     * <code>bool include_unannounced = 1;</code>
     */
    private void clearIncludeUnannounced() {
      
      includeUnannounced_ = false;
    }

    public static co.anode.anodium.Rpc.ChannelGraphRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelGraphRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelGraphRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelGraphRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelGraphRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelGraphRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelGraphRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelGraphRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelGraphRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelGraphRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelGraphRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelGraphRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelGraphRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChannelGraphRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelGraphRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelGraphRequest)
        co.anode.anodium.Rpc.ChannelGraphRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelGraphRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *Whether unannounced channels are included in the response or not. If set,
       *unannounced channels are included. Unannounced channels are both private
       *channels, and public channels that are not yet announced to the network.
       * </pre>
       *
       * <code>bool include_unannounced = 1;</code>
       * @return The includeUnannounced.
       */
      @java.lang.Override
      public boolean getIncludeUnannounced() {
        return instance.getIncludeUnannounced();
      }
      /**
       * <pre>
       *Whether unannounced channels are included in the response or not. If set,
       *unannounced channels are included. Unannounced channels are both private
       *channels, and public channels that are not yet announced to the network.
       * </pre>
       *
       * <code>bool include_unannounced = 1;</code>
       * @param value The includeUnannounced to set.
       * @return This builder for chaining.
       */
      public Builder setIncludeUnannounced(boolean value) {
        copyOnWrite();
        instance.setIncludeUnannounced(value);
        return this;
      }
      /**
       * <pre>
       *Whether unannounced channels are included in the response or not. If set,
       *unannounced channels are included. Unannounced channels are both private
       *channels, and public channels that are not yet announced to the network.
       * </pre>
       *
       * <code>bool include_unannounced = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearIncludeUnannounced() {
        copyOnWrite();
        instance.clearIncludeUnannounced();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelGraphRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelGraphRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "includeUnannounced_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u0007";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelGraphRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelGraphRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelGraphRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelGraphRequest)
    private static final co.anode.anodium.Rpc.ChannelGraphRequest DEFAULT_INSTANCE;
    static {
      ChannelGraphRequest defaultInstance = new ChannelGraphRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelGraphRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelGraphRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelGraphRequest> PARSER;

    public static com.google.protobuf.Parser<ChannelGraphRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelGraphOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelGraph)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The list of `LightningNode`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
     */
    java.util.List<co.anode.anodium.Rpc.LightningNode> 
        getNodesList();
    /**
     * <pre>
     * The list of `LightningNode`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
     */
    co.anode.anodium.Rpc.LightningNode getNodes(int index);
    /**
     * <pre>
     * The list of `LightningNode`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
     */
    int getNodesCount();

    /**
     * <pre>
     * The list of `ChannelEdge`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
     */
    java.util.List<co.anode.anodium.Rpc.ChannelEdge> 
        getEdgesList();
    /**
     * <pre>
     * The list of `ChannelEdge`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
     */
    co.anode.anodium.Rpc.ChannelEdge getEdges(int index);
    /**
     * <pre>
     * The list of `ChannelEdge`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
     */
    int getEdgesCount();
  }
  /**
   * <pre>
   * Returns a new instance of the directed channel graph.
   * </pre>
   *
   * Protobuf type {@code co.anode.anodium.ChannelGraph}
   */
  public  static final class ChannelGraph extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelGraph, ChannelGraph.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelGraph)
      ChannelGraphOrBuilder {
    private ChannelGraph() {
      nodes_ = emptyProtobufList();
      edges_ = emptyProtobufList();
    }
    public static final int NODES_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.LightningNode> nodes_;
    /**
     * <pre>
     * The list of `LightningNode`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.LightningNode> getNodesList() {
      return nodes_;
    }
    /**
     * <pre>
     * The list of `LightningNode`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.LightningNodeOrBuilder> 
        getNodesOrBuilderList() {
      return nodes_;
    }
    /**
     * <pre>
     * The list of `LightningNode`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
     */
    @java.lang.Override
    public int getNodesCount() {
      return nodes_.size();
    }
    /**
     * <pre>
     * The list of `LightningNode`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.LightningNode getNodes(int index) {
      return nodes_.get(index);
    }
    /**
     * <pre>
     * The list of `LightningNode`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
     */
    public co.anode.anodium.Rpc.LightningNodeOrBuilder getNodesOrBuilder(
        int index) {
      return nodes_.get(index);
    }
    private void ensureNodesIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.LightningNode> tmp = nodes_;
      if (!tmp.isModifiable()) {
        nodes_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * The list of `LightningNode`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
     */
    private void setNodes(
        int index, co.anode.anodium.Rpc.LightningNode value) {
      value.getClass();
  ensureNodesIsMutable();
      nodes_.set(index, value);
    }
    /**
     * <pre>
     * The list of `LightningNode`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
     */
    private void addNodes(co.anode.anodium.Rpc.LightningNode value) {
      value.getClass();
  ensureNodesIsMutable();
      nodes_.add(value);
    }
    /**
     * <pre>
     * The list of `LightningNode`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
     */
    private void addNodes(
        int index, co.anode.anodium.Rpc.LightningNode value) {
      value.getClass();
  ensureNodesIsMutable();
      nodes_.add(index, value);
    }
    /**
     * <pre>
     * The list of `LightningNode`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
     */
    private void addAllNodes(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.LightningNode> values) {
      ensureNodesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, nodes_);
    }
    /**
     * <pre>
     * The list of `LightningNode`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
     */
    private void clearNodes() {
      nodes_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The list of `LightningNode`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
     */
    private void removeNodes(int index) {
      ensureNodesIsMutable();
      nodes_.remove(index);
    }

    public static final int EDGES_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.ChannelEdge> edges_;
    /**
     * <pre>
     * The list of `ChannelEdge`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.ChannelEdge> getEdgesList() {
      return edges_;
    }
    /**
     * <pre>
     * The list of `ChannelEdge`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.ChannelEdgeOrBuilder> 
        getEdgesOrBuilderList() {
      return edges_;
    }
    /**
     * <pre>
     * The list of `ChannelEdge`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
     */
    @java.lang.Override
    public int getEdgesCount() {
      return edges_.size();
    }
    /**
     * <pre>
     * The list of `ChannelEdge`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelEdge getEdges(int index) {
      return edges_.get(index);
    }
    /**
     * <pre>
     * The list of `ChannelEdge`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
     */
    public co.anode.anodium.Rpc.ChannelEdgeOrBuilder getEdgesOrBuilder(
        int index) {
      return edges_.get(index);
    }
    private void ensureEdgesIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.ChannelEdge> tmp = edges_;
      if (!tmp.isModifiable()) {
        edges_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * The list of `ChannelEdge`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
     */
    private void setEdges(
        int index, co.anode.anodium.Rpc.ChannelEdge value) {
      value.getClass();
  ensureEdgesIsMutable();
      edges_.set(index, value);
    }
    /**
     * <pre>
     * The list of `ChannelEdge`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
     */
    private void addEdges(co.anode.anodium.Rpc.ChannelEdge value) {
      value.getClass();
  ensureEdgesIsMutable();
      edges_.add(value);
    }
    /**
     * <pre>
     * The list of `ChannelEdge`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
     */
    private void addEdges(
        int index, co.anode.anodium.Rpc.ChannelEdge value) {
      value.getClass();
  ensureEdgesIsMutable();
      edges_.add(index, value);
    }
    /**
     * <pre>
     * The list of `ChannelEdge`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
     */
    private void addAllEdges(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.ChannelEdge> values) {
      ensureEdgesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, edges_);
    }
    /**
     * <pre>
     * The list of `ChannelEdge`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
     */
    private void clearEdges() {
      edges_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The list of `ChannelEdge`s in this channel graph
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
     */
    private void removeEdges(int index) {
      ensureEdgesIsMutable();
      edges_.remove(index);
    }

    public static co.anode.anodium.Rpc.ChannelGraph parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelGraph parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelGraph parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelGraph parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelGraph parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelGraph parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelGraph parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelGraph parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelGraph parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelGraph parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelGraph parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelGraph parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelGraph prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Returns a new instance of the directed channel graph.
     * </pre>
     *
     * Protobuf type {@code co.anode.anodium.ChannelGraph}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelGraph, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelGraph)
        co.anode.anodium.Rpc.ChannelGraphOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelGraph.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The list of `LightningNode`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.LightningNode> getNodesList() {
        return java.util.Collections.unmodifiableList(
            instance.getNodesList());
      }
      /**
       * <pre>
       * The list of `LightningNode`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
       */
      @java.lang.Override
      public int getNodesCount() {
        return instance.getNodesCount();
      }/**
       * <pre>
       * The list of `LightningNode`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.LightningNode getNodes(int index) {
        return instance.getNodes(index);
      }
      /**
       * <pre>
       * The list of `LightningNode`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
       */
      public Builder setNodes(
          int index, co.anode.anodium.Rpc.LightningNode value) {
        copyOnWrite();
        instance.setNodes(index, value);
        return this;
      }
      /**
       * <pre>
       * The list of `LightningNode`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
       */
      public Builder setNodes(
          int index, co.anode.anodium.Rpc.LightningNode.Builder builderForValue) {
        copyOnWrite();
        instance.setNodes(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of `LightningNode`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
       */
      public Builder addNodes(co.anode.anodium.Rpc.LightningNode value) {
        copyOnWrite();
        instance.addNodes(value);
        return this;
      }
      /**
       * <pre>
       * The list of `LightningNode`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
       */
      public Builder addNodes(
          int index, co.anode.anodium.Rpc.LightningNode value) {
        copyOnWrite();
        instance.addNodes(index, value);
        return this;
      }
      /**
       * <pre>
       * The list of `LightningNode`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
       */
      public Builder addNodes(
          co.anode.anodium.Rpc.LightningNode.Builder builderForValue) {
        copyOnWrite();
        instance.addNodes(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of `LightningNode`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
       */
      public Builder addNodes(
          int index, co.anode.anodium.Rpc.LightningNode.Builder builderForValue) {
        copyOnWrite();
        instance.addNodes(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of `LightningNode`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
       */
      public Builder addAllNodes(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.LightningNode> values) {
        copyOnWrite();
        instance.addAllNodes(values);
        return this;
      }
      /**
       * <pre>
       * The list of `LightningNode`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
       */
      public Builder clearNodes() {
        copyOnWrite();
        instance.clearNodes();
        return this;
      }
      /**
       * <pre>
       * The list of `LightningNode`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.LightningNode nodes = 1;</code>
       */
      public Builder removeNodes(int index) {
        copyOnWrite();
        instance.removeNodes(index);
        return this;
      }

      /**
       * <pre>
       * The list of `ChannelEdge`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.ChannelEdge> getEdgesList() {
        return java.util.Collections.unmodifiableList(
            instance.getEdgesList());
      }
      /**
       * <pre>
       * The list of `ChannelEdge`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
       */
      @java.lang.Override
      public int getEdgesCount() {
        return instance.getEdgesCount();
      }/**
       * <pre>
       * The list of `ChannelEdge`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelEdge getEdges(int index) {
        return instance.getEdges(index);
      }
      /**
       * <pre>
       * The list of `ChannelEdge`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
       */
      public Builder setEdges(
          int index, co.anode.anodium.Rpc.ChannelEdge value) {
        copyOnWrite();
        instance.setEdges(index, value);
        return this;
      }
      /**
       * <pre>
       * The list of `ChannelEdge`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
       */
      public Builder setEdges(
          int index, co.anode.anodium.Rpc.ChannelEdge.Builder builderForValue) {
        copyOnWrite();
        instance.setEdges(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of `ChannelEdge`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
       */
      public Builder addEdges(co.anode.anodium.Rpc.ChannelEdge value) {
        copyOnWrite();
        instance.addEdges(value);
        return this;
      }
      /**
       * <pre>
       * The list of `ChannelEdge`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
       */
      public Builder addEdges(
          int index, co.anode.anodium.Rpc.ChannelEdge value) {
        copyOnWrite();
        instance.addEdges(index, value);
        return this;
      }
      /**
       * <pre>
       * The list of `ChannelEdge`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
       */
      public Builder addEdges(
          co.anode.anodium.Rpc.ChannelEdge.Builder builderForValue) {
        copyOnWrite();
        instance.addEdges(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of `ChannelEdge`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
       */
      public Builder addEdges(
          int index, co.anode.anodium.Rpc.ChannelEdge.Builder builderForValue) {
        copyOnWrite();
        instance.addEdges(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of `ChannelEdge`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
       */
      public Builder addAllEdges(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.ChannelEdge> values) {
        copyOnWrite();
        instance.addAllEdges(values);
        return this;
      }
      /**
       * <pre>
       * The list of `ChannelEdge`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
       */
      public Builder clearEdges() {
        copyOnWrite();
        instance.clearEdges();
        return this;
      }
      /**
       * <pre>
       * The list of `ChannelEdge`s in this channel graph
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelEdge edges = 2;</code>
       */
      public Builder removeEdges(int index) {
        copyOnWrite();
        instance.removeEdges(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelGraph)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelGraph();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "nodes_",
              co.anode.anodium.Rpc.LightningNode.class,
              "edges_",
              co.anode.anodium.Rpc.ChannelEdge.class,
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0002\u0000\u0001\u001b\u0002\u001b" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelGraph> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelGraph.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelGraph>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelGraph)
    private static final co.anode.anodium.Rpc.ChannelGraph DEFAULT_INSTANCE;
    static {
      ChannelGraph defaultInstance = new ChannelGraph();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelGraph.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelGraph getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelGraph> PARSER;

    public static com.google.protobuf.Parser<ChannelGraph> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface NodeMetricsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.NodeMetricsRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The requested node metrics.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
     * @return A list containing the types.
     */
    java.util.List<co.anode.anodium.Rpc.NodeMetricType> getTypesList();
    /**
     * <pre>
     * The requested node metrics.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
     * @return The count of types.
     */
    int getTypesCount();
    /**
     * <pre>
     * The requested node metrics.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
     * @param index The index of the element to return.
     * @return The types at the given index.
     */
    co.anode.anodium.Rpc.NodeMetricType getTypes(int index);
    /**
     * <pre>
     * The requested node metrics.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
     * @return A list containing the enum numeric values on the wire for types.
     */
    java.util.List<java.lang.Integer>
    getTypesValueList();
    /**
     * <pre>
     * The requested node metrics.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
     * @param index The index of the value to return.
     * @return The enum numeric value on the wire of types at the given index.
     */
    int getTypesValue(int index);
  }
  /**
   * Protobuf type {@code co.anode.anodium.NodeMetricsRequest}
   */
  public  static final class NodeMetricsRequest extends
      com.google.protobuf.GeneratedMessageLite<
          NodeMetricsRequest, NodeMetricsRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.NodeMetricsRequest)
      NodeMetricsRequestOrBuilder {
    private NodeMetricsRequest() {
      types_ = emptyIntList();
    }
    public static final int TYPES_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.IntList types_;
    private static final com.google.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, co.anode.anodium.Rpc.NodeMetricType> types_converter_ =
            new com.google.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, co.anode.anodium.Rpc.NodeMetricType>() {
              @java.lang.Override
              public co.anode.anodium.Rpc.NodeMetricType convert(java.lang.Integer from) {
                co.anode.anodium.Rpc.NodeMetricType result = co.anode.anodium.Rpc.NodeMetricType.forNumber(from);
                return result == null ? co.anode.anodium.Rpc.NodeMetricType.UNRECOGNIZED : result;
              }
            };
    /**
     * <pre>
     * The requested node metrics.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
     * @return A list containing the types.
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.NodeMetricType> getTypesList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, co.anode.anodium.Rpc.NodeMetricType>(types_, types_converter_);
    }
    /**
     * <pre>
     * The requested node metrics.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
     * @return The count of types.
     */
    @java.lang.Override
    public int getTypesCount() {
      return types_.size();
    }
    /**
     * <pre>
     * The requested node metrics.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
     * @param index The index of the element to return.
     * @return The types at the given index.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.NodeMetricType getTypes(int index) {
      return types_converter_.convert(types_.getInt(index));
    }
    /**
     * <pre>
     * The requested node metrics.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
     * @return A list containing the enum numeric values on the wire for types.
     */
    @java.lang.Override
    public java.util.List<java.lang.Integer>
    getTypesValueList() {
      return types_;
    }
    /**
     * <pre>
     * The requested node metrics.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
     * @param index The index of the value to return.
     * @return The enum numeric value on the wire of types at the given index.
     */
    @java.lang.Override
    public int getTypesValue(int index) {
      return types_.getInt(index);
    }
    private int typesMemoizedSerializedSize;
    private void ensureTypesIsMutable() {
      com.google.protobuf.Internal.IntList tmp = types_;
      if (!tmp.isModifiable()) {
        types_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
      }
    }
    /**
     * <pre>
     * The requested node metrics.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
     * @param index The index to set the value at.
     * @param value The types to set.
     */
    private void setTypes(
        int index, co.anode.anodium.Rpc.NodeMetricType value) {
      value.getClass();
  ensureTypesIsMutable();
      types_.setInt(index, value.getNumber());
    }
    /**
     * <pre>
     * The requested node metrics.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
     * @param value The types to add.
     */
    private void addTypes(co.anode.anodium.Rpc.NodeMetricType value) {
      value.getClass();
  ensureTypesIsMutable();
      types_.addInt(value.getNumber());
    }
    /**
     * <pre>
     * The requested node metrics.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
     * @param values The types to add.
     */
    private void addAllTypes(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.NodeMetricType> values) {
      ensureTypesIsMutable();
      for (co.anode.anodium.Rpc.NodeMetricType value : values) {
        types_.addInt(value.getNumber());
      }
    }
    /**
     * <pre>
     * The requested node metrics.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
     */
    private void clearTypes() {
      types_ = emptyIntList();
    }
    /**
     * <pre>
     * The requested node metrics.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
     * @param value The enum numeric value on the wire for types to set.
     */
    private void setTypesValue(
        int index, int value) {
      ensureTypesIsMutable();
      types_.setInt(index, value);
    }
    /**
     * <pre>
     * The requested node metrics.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
     * @param value The enum numeric value on the wire for types to add.
     */
    private void addTypesValue(int value) {
      ensureTypesIsMutable();
      types_.addInt(value);
    }
    /**
     * <pre>
     * The requested node metrics.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
     * @param values The enum numeric values on the wire for types to add.
     */
    private void addAllTypesValue(
        java.lang.Iterable<java.lang.Integer> values) {
      ensureTypesIsMutable();
      for (int value : values) {
        types_.addInt(value);
      }
    }

    public static co.anode.anodium.Rpc.NodeMetricsRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodeMetricsRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeMetricsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodeMetricsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeMetricsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodeMetricsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeMetricsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodeMetricsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeMetricsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodeMetricsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeMetricsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodeMetricsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.NodeMetricsRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.NodeMetricsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.NodeMetricsRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.NodeMetricsRequest)
        co.anode.anodium.Rpc.NodeMetricsRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.NodeMetricsRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The requested node metrics.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
       * @return A list containing the types.
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.NodeMetricType> getTypesList() {
        return instance.getTypesList();
      }
      /**
       * <pre>
       * The requested node metrics.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
       * @return The count of types.
       */
      @java.lang.Override
      public int getTypesCount() {
        return instance.getTypesCount();
      }
      /**
       * <pre>
       * The requested node metrics.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
       * @param index The index of the element to return.
       * @return The types at the given index.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.NodeMetricType getTypes(int index) {
        return instance.getTypes(index);
      }
      /**
       * <pre>
       * The requested node metrics.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
       * @param index The index to set the value at.
       * @param value The types to set.
       * @return This builder for chaining.
       */
      public Builder setTypes(
          int index, co.anode.anodium.Rpc.NodeMetricType value) {
        copyOnWrite();
        instance.setTypes(index, value);
        return this;
      }
      /**
       * <pre>
       * The requested node metrics.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
       * @param value The types to add.
       * @return This builder for chaining.
       */
      public Builder addTypes(co.anode.anodium.Rpc.NodeMetricType value) {
        copyOnWrite();
        instance.addTypes(value);
        return this;
      }
      /**
       * <pre>
       * The requested node metrics.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
       * @param values The types to add.
       * @return This builder for chaining.
       */
      public Builder addAllTypes(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.NodeMetricType> values) {
        copyOnWrite();
        instance.addAllTypes(values);  return this;
      }
      /**
       * <pre>
       * The requested node metrics.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTypes() {
        copyOnWrite();
        instance.clearTypes();
        return this;
      }
      /**
       * <pre>
       * The requested node metrics.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
       * @return A list containing the enum numeric values on the wire for types.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
      getTypesValueList() {
        return java.util.Collections.unmodifiableList(
            instance.getTypesValueList());
      }
      /**
       * <pre>
       * The requested node metrics.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
       * @param index The index of the value to return.
       * @return The enum numeric value on the wire of types at the given index.
       */
      @java.lang.Override
      public int getTypesValue(int index) {
        return instance.getTypesValue(index);
      }
      /**
       * <pre>
       * The requested node metrics.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
       * @param index The index to set the value at.
       * @param value The enum numeric value on the wire for types to set.
       * @return This builder for chaining.
       */
      public Builder setTypesValue(
          int index, int value) {
        copyOnWrite();
        instance.setTypesValue(index, value);
        return this;
      }
      /**
       * <pre>
       * The requested node metrics.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
       * @param value The enum numeric value on the wire for types to add.
       * @return This builder for chaining.
       */
      public Builder addTypesValue(int value) {
        instance.addTypesValue(value);
        return this;
      }
      /**
       * <pre>
       * The requested node metrics.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.NodeMetricType types = 1;</code>
       * @param values The enum numeric values on the wire for types to add.
       * @return This builder for chaining.
       */
      public Builder addAllTypesValue(
          java.lang.Iterable<java.lang.Integer> values) {
        copyOnWrite();
        instance.addAllTypesValue(values);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.NodeMetricsRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.NodeMetricsRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "types_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0000\u0001,";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.NodeMetricsRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.NodeMetricsRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.NodeMetricsRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.NodeMetricsRequest)
    private static final co.anode.anodium.Rpc.NodeMetricsRequest DEFAULT_INSTANCE;
    static {
      NodeMetricsRequest defaultInstance = new NodeMetricsRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        NodeMetricsRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.NodeMetricsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<NodeMetricsRequest> PARSER;

    public static com.google.protobuf.Parser<NodeMetricsRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface NodeMetricsResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.NodeMetricsResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *Betweenness centrality is the sum of the ratio of shortest paths that pass
     *through the node for each pair of nodes in the graph (not counting paths
     *starting or ending at this node).
     *Map of node pubkey to betweenness centrality of the node. Normalized
     *values are in the [0,1] closed interval.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.FloatMetric&gt; betweenness_centrality = 1;</code>
     */
    int getBetweennessCentralityCount();
    /**
     * <pre>
     *Betweenness centrality is the sum of the ratio of shortest paths that pass
     *through the node for each pair of nodes in the graph (not counting paths
     *starting or ending at this node).
     *Map of node pubkey to betweenness centrality of the node. Normalized
     *values are in the [0,1] closed interval.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.FloatMetric&gt; betweenness_centrality = 1;</code>
     */
    boolean containsBetweennessCentrality(
        java.lang.String key);
    /**
     * Use {@link #getBetweennessCentralityMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, co.anode.anodium.Rpc.FloatMetric>
    getBetweennessCentrality();
    /**
     * <pre>
     *Betweenness centrality is the sum of the ratio of shortest paths that pass
     *through the node for each pair of nodes in the graph (not counting paths
     *starting or ending at this node).
     *Map of node pubkey to betweenness centrality of the node. Normalized
     *values are in the [0,1] closed interval.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.FloatMetric&gt; betweenness_centrality = 1;</code>
     */
    java.util.Map<java.lang.String, co.anode.anodium.Rpc.FloatMetric>
    getBetweennessCentralityMap();
    /**
     * <pre>
     *Betweenness centrality is the sum of the ratio of shortest paths that pass
     *through the node for each pair of nodes in the graph (not counting paths
     *starting or ending at this node).
     *Map of node pubkey to betweenness centrality of the node. Normalized
     *values are in the [0,1] closed interval.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.FloatMetric&gt; betweenness_centrality = 1;</code>
     */

    co.anode.anodium.Rpc.FloatMetric getBetweennessCentralityOrDefault(
        java.lang.String key,
        co.anode.anodium.Rpc.FloatMetric defaultValue);
    /**
     * <pre>
     *Betweenness centrality is the sum of the ratio of shortest paths that pass
     *through the node for each pair of nodes in the graph (not counting paths
     *starting or ending at this node).
     *Map of node pubkey to betweenness centrality of the node. Normalized
     *values are in the [0,1] closed interval.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.FloatMetric&gt; betweenness_centrality = 1;</code>
     */

    co.anode.anodium.Rpc.FloatMetric getBetweennessCentralityOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code co.anode.anodium.NodeMetricsResponse}
   */
  public  static final class NodeMetricsResponse extends
      com.google.protobuf.GeneratedMessageLite<
          NodeMetricsResponse, NodeMetricsResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.NodeMetricsResponse)
      NodeMetricsResponseOrBuilder {
    private NodeMetricsResponse() {
    }
    public static final int BETWEENNESS_CENTRALITY_FIELD_NUMBER = 1;
    private static final class BetweennessCentralityDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, co.anode.anodium.Rpc.FloatMetric> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, co.anode.anodium.Rpc.FloatMetric>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  co.anode.anodium.Rpc.FloatMetric.getDefaultInstance());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, co.anode.anodium.Rpc.FloatMetric> betweennessCentrality_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, co.anode.anodium.Rpc.FloatMetric>
    internalGetBetweennessCentrality() {
      return betweennessCentrality_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, co.anode.anodium.Rpc.FloatMetric>
    internalGetMutableBetweennessCentrality() {
      if (!betweennessCentrality_.isMutable()) {
        betweennessCentrality_ = betweennessCentrality_.mutableCopy();
      }
      return betweennessCentrality_;
    }
    @java.lang.Override

    public int getBetweennessCentralityCount() {
      return internalGetBetweennessCentrality().size();
    }
    /**
     * <pre>
     *Betweenness centrality is the sum of the ratio of shortest paths that pass
     *through the node for each pair of nodes in the graph (not counting paths
     *starting or ending at this node).
     *Map of node pubkey to betweenness centrality of the node. Normalized
     *values are in the [0,1] closed interval.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.FloatMetric&gt; betweenness_centrality = 1;</code>
     */
    @java.lang.Override

    public boolean containsBetweennessCentrality(
        java.lang.String key) {
      key.getClass();
      return internalGetBetweennessCentrality().containsKey(key);
    }
    /**
     * Use {@link #getBetweennessCentralityMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, co.anode.anodium.Rpc.FloatMetric> getBetweennessCentrality() {
      return getBetweennessCentralityMap();
    }
    /**
     * <pre>
     *Betweenness centrality is the sum of the ratio of shortest paths that pass
     *through the node for each pair of nodes in the graph (not counting paths
     *starting or ending at this node).
     *Map of node pubkey to betweenness centrality of the node. Normalized
     *values are in the [0,1] closed interval.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.FloatMetric&gt; betweenness_centrality = 1;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, co.anode.anodium.Rpc.FloatMetric> getBetweennessCentralityMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetBetweennessCentrality());
    }
    /**
     * <pre>
     *Betweenness centrality is the sum of the ratio of shortest paths that pass
     *through the node for each pair of nodes in the graph (not counting paths
     *starting or ending at this node).
     *Map of node pubkey to betweenness centrality of the node. Normalized
     *values are in the [0,1] closed interval.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.FloatMetric&gt; betweenness_centrality = 1;</code>
     */
    @java.lang.Override

    public co.anode.anodium.Rpc.FloatMetric getBetweennessCentralityOrDefault(
        java.lang.String key,
        co.anode.anodium.Rpc.FloatMetric defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, co.anode.anodium.Rpc.FloatMetric> map =
          internalGetBetweennessCentrality();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     *Betweenness centrality is the sum of the ratio of shortest paths that pass
     *through the node for each pair of nodes in the graph (not counting paths
     *starting or ending at this node).
     *Map of node pubkey to betweenness centrality of the node. Normalized
     *values are in the [0,1] closed interval.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.FloatMetric&gt; betweenness_centrality = 1;</code>
     */
    @java.lang.Override

    public co.anode.anodium.Rpc.FloatMetric getBetweennessCentralityOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, co.anode.anodium.Rpc.FloatMetric> map =
          internalGetBetweennessCentrality();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     *Betweenness centrality is the sum of the ratio of shortest paths that pass
     *through the node for each pair of nodes in the graph (not counting paths
     *starting or ending at this node).
     *Map of node pubkey to betweenness centrality of the node. Normalized
     *values are in the [0,1] closed interval.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.FloatMetric&gt; betweenness_centrality = 1;</code>
     */
    private java.util.Map<java.lang.String, co.anode.anodium.Rpc.FloatMetric>
    getMutableBetweennessCentralityMap() {
      return internalGetMutableBetweennessCentrality();
    }

    public static co.anode.anodium.Rpc.NodeMetricsResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodeMetricsResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeMetricsResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodeMetricsResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeMetricsResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodeMetricsResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeMetricsResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodeMetricsResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeMetricsResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodeMetricsResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeMetricsResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodeMetricsResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.NodeMetricsResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.NodeMetricsResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.NodeMetricsResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.NodeMetricsResponse)
        co.anode.anodium.Rpc.NodeMetricsResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.NodeMetricsResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      @java.lang.Override

      public int getBetweennessCentralityCount() {
        return instance.getBetweennessCentralityMap().size();
      }
      /**
       * <pre>
       *Betweenness centrality is the sum of the ratio of shortest paths that pass
       *through the node for each pair of nodes in the graph (not counting paths
       *starting or ending at this node).
       *Map of node pubkey to betweenness centrality of the node. Normalized
       *values are in the [0,1] closed interval.
       * </pre>
       *
       * <code>map&lt;string, .co.anode.anodium.FloatMetric&gt; betweenness_centrality = 1;</code>
       */
      @java.lang.Override

      public boolean containsBetweennessCentrality(
          java.lang.String key) {
        key.getClass();
        return instance.getBetweennessCentralityMap().containsKey(key);
      }

      public Builder clearBetweennessCentrality() {
        copyOnWrite();
        instance.getMutableBetweennessCentralityMap().clear();
        return this;
      }
      /**
       * <pre>
       *Betweenness centrality is the sum of the ratio of shortest paths that pass
       *through the node for each pair of nodes in the graph (not counting paths
       *starting or ending at this node).
       *Map of node pubkey to betweenness centrality of the node. Normalized
       *values are in the [0,1] closed interval.
       * </pre>
       *
       * <code>map&lt;string, .co.anode.anodium.FloatMetric&gt; betweenness_centrality = 1;</code>
       */

      public Builder removeBetweennessCentrality(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableBetweennessCentralityMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getBetweennessCentralityMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, co.anode.anodium.Rpc.FloatMetric> getBetweennessCentrality() {
        return getBetweennessCentralityMap();
      }
      /**
       * <pre>
       *Betweenness centrality is the sum of the ratio of shortest paths that pass
       *through the node for each pair of nodes in the graph (not counting paths
       *starting or ending at this node).
       *Map of node pubkey to betweenness centrality of the node. Normalized
       *values are in the [0,1] closed interval.
       * </pre>
       *
       * <code>map&lt;string, .co.anode.anodium.FloatMetric&gt; betweenness_centrality = 1;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, co.anode.anodium.Rpc.FloatMetric> getBetweennessCentralityMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getBetweennessCentralityMap());
      }
      /**
       * <pre>
       *Betweenness centrality is the sum of the ratio of shortest paths that pass
       *through the node for each pair of nodes in the graph (not counting paths
       *starting or ending at this node).
       *Map of node pubkey to betweenness centrality of the node. Normalized
       *values are in the [0,1] closed interval.
       * </pre>
       *
       * <code>map&lt;string, .co.anode.anodium.FloatMetric&gt; betweenness_centrality = 1;</code>
       */
      @java.lang.Override

      public co.anode.anodium.Rpc.FloatMetric getBetweennessCentralityOrDefault(
          java.lang.String key,
          co.anode.anodium.Rpc.FloatMetric defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, co.anode.anodium.Rpc.FloatMetric> map =
            instance.getBetweennessCentralityMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       *Betweenness centrality is the sum of the ratio of shortest paths that pass
       *through the node for each pair of nodes in the graph (not counting paths
       *starting or ending at this node).
       *Map of node pubkey to betweenness centrality of the node. Normalized
       *values are in the [0,1] closed interval.
       * </pre>
       *
       * <code>map&lt;string, .co.anode.anodium.FloatMetric&gt; betweenness_centrality = 1;</code>
       */
      @java.lang.Override

      public co.anode.anodium.Rpc.FloatMetric getBetweennessCentralityOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, co.anode.anodium.Rpc.FloatMetric> map =
            instance.getBetweennessCentralityMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       *Betweenness centrality is the sum of the ratio of shortest paths that pass
       *through the node for each pair of nodes in the graph (not counting paths
       *starting or ending at this node).
       *Map of node pubkey to betweenness centrality of the node. Normalized
       *values are in the [0,1] closed interval.
       * </pre>
       *
       * <code>map&lt;string, .co.anode.anodium.FloatMetric&gt; betweenness_centrality = 1;</code>
       */
      public Builder putBetweennessCentrality(
          java.lang.String key,
          co.anode.anodium.Rpc.FloatMetric value) {
        key.getClass();
        value.getClass();
        copyOnWrite();
        instance.getMutableBetweennessCentralityMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       *Betweenness centrality is the sum of the ratio of shortest paths that pass
       *through the node for each pair of nodes in the graph (not counting paths
       *starting or ending at this node).
       *Map of node pubkey to betweenness centrality of the node. Normalized
       *values are in the [0,1] closed interval.
       * </pre>
       *
       * <code>map&lt;string, .co.anode.anodium.FloatMetric&gt; betweenness_centrality = 1;</code>
       */
      public Builder putAllBetweennessCentrality(
          java.util.Map<java.lang.String, co.anode.anodium.Rpc.FloatMetric> values) {
        copyOnWrite();
        instance.getMutableBetweennessCentralityMap().putAll(values);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.NodeMetricsResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.NodeMetricsResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "betweennessCentrality_",
              BetweennessCentralityDefaultEntryHolder.defaultEntry,
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0001\u0000\u0000\u00012";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.NodeMetricsResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.NodeMetricsResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.NodeMetricsResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.NodeMetricsResponse)
    private static final co.anode.anodium.Rpc.NodeMetricsResponse DEFAULT_INSTANCE;
    static {
      NodeMetricsResponse defaultInstance = new NodeMetricsResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        NodeMetricsResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.NodeMetricsResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<NodeMetricsResponse> PARSER;

    public static com.google.protobuf.Parser<NodeMetricsResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FloatMetricOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.FloatMetric)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Arbitrary float value.
     * </pre>
     *
     * <code>double value = 1;</code>
     * @return The value.
     */
    double getValue();

    /**
     * <pre>
     * The value normalized to [0,1] or [-1,1].
     * </pre>
     *
     * <code>double normalized_value = 2;</code>
     * @return The normalizedValue.
     */
    double getNormalizedValue();
  }
  /**
   * Protobuf type {@code co.anode.anodium.FloatMetric}
   */
  public  static final class FloatMetric extends
      com.google.protobuf.GeneratedMessageLite<
          FloatMetric, FloatMetric.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.FloatMetric)
      FloatMetricOrBuilder {
    private FloatMetric() {
    }
    public static final int VALUE_FIELD_NUMBER = 1;
    private double value_;
    /**
     * <pre>
     * Arbitrary float value.
     * </pre>
     *
     * <code>double value = 1;</code>
     * @return The value.
     */
    @java.lang.Override
    public double getValue() {
      return value_;
    }
    /**
     * <pre>
     * Arbitrary float value.
     * </pre>
     *
     * <code>double value = 1;</code>
     * @param value The value to set.
     */
    private void setValue(double value) {
      
      value_ = value;
    }
    /**
     * <pre>
     * Arbitrary float value.
     * </pre>
     *
     * <code>double value = 1;</code>
     */
    private void clearValue() {
      
      value_ = 0D;
    }

    public static final int NORMALIZED_VALUE_FIELD_NUMBER = 2;
    private double normalizedValue_;
    /**
     * <pre>
     * The value normalized to [0,1] or [-1,1].
     * </pre>
     *
     * <code>double normalized_value = 2;</code>
     * @return The normalizedValue.
     */
    @java.lang.Override
    public double getNormalizedValue() {
      return normalizedValue_;
    }
    /**
     * <pre>
     * The value normalized to [0,1] or [-1,1].
     * </pre>
     *
     * <code>double normalized_value = 2;</code>
     * @param value The normalizedValue to set.
     */
    private void setNormalizedValue(double value) {
      
      normalizedValue_ = value;
    }
    /**
     * <pre>
     * The value normalized to [0,1] or [-1,1].
     * </pre>
     *
     * <code>double normalized_value = 2;</code>
     */
    private void clearNormalizedValue() {
      
      normalizedValue_ = 0D;
    }

    public static co.anode.anodium.Rpc.FloatMetric parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FloatMetric parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FloatMetric parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FloatMetric parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FloatMetric parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FloatMetric parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FloatMetric parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FloatMetric parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FloatMetric parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FloatMetric parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FloatMetric parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FloatMetric parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.FloatMetric prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.FloatMetric}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.FloatMetric, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.FloatMetric)
        co.anode.anodium.Rpc.FloatMetricOrBuilder {
      // Construct using co.anode.anodium.Rpc.FloatMetric.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Arbitrary float value.
       * </pre>
       *
       * <code>double value = 1;</code>
       * @return The value.
       */
      @java.lang.Override
      public double getValue() {
        return instance.getValue();
      }
      /**
       * <pre>
       * Arbitrary float value.
       * </pre>
       *
       * <code>double value = 1;</code>
       * @param value The value to set.
       * @return This builder for chaining.
       */
      public Builder setValue(double value) {
        copyOnWrite();
        instance.setValue(value);
        return this;
      }
      /**
       * <pre>
       * Arbitrary float value.
       * </pre>
       *
       * <code>double value = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearValue() {
        copyOnWrite();
        instance.clearValue();
        return this;
      }

      /**
       * <pre>
       * The value normalized to [0,1] or [-1,1].
       * </pre>
       *
       * <code>double normalized_value = 2;</code>
       * @return The normalizedValue.
       */
      @java.lang.Override
      public double getNormalizedValue() {
        return instance.getNormalizedValue();
      }
      /**
       * <pre>
       * The value normalized to [0,1] or [-1,1].
       * </pre>
       *
       * <code>double normalized_value = 2;</code>
       * @param value The normalizedValue to set.
       * @return This builder for chaining.
       */
      public Builder setNormalizedValue(double value) {
        copyOnWrite();
        instance.setNormalizedValue(value);
        return this;
      }
      /**
       * <pre>
       * The value normalized to [0,1] or [-1,1].
       * </pre>
       *
       * <code>double normalized_value = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNormalizedValue() {
        copyOnWrite();
        instance.clearNormalizedValue();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.FloatMetric)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.FloatMetric();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "value_",
              "normalizedValue_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0000\u0002\u0000" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.FloatMetric> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.FloatMetric.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.FloatMetric>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.FloatMetric)
    private static final co.anode.anodium.Rpc.FloatMetric DEFAULT_INSTANCE;
    static {
      FloatMetric defaultInstance = new FloatMetric();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        FloatMetric.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.FloatMetric getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FloatMetric> PARSER;

    public static com.google.protobuf.Parser<FloatMetric> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChanInfoRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChanInfoRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    long getChanId();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChanInfoRequest}
   */
  public  static final class ChanInfoRequest extends
      com.google.protobuf.GeneratedMessageLite<
          ChanInfoRequest, ChanInfoRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChanInfoRequest)
      ChanInfoRequestOrBuilder {
    private ChanInfoRequest() {
    }
    public static final int CHAN_ID_FIELD_NUMBER = 1;
    private long chanId_;
    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    @java.lang.Override
    public long getChanId() {
      return chanId_;
    }
    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     * @param value The chanId to set.
     */
    private void setChanId(long value) {
      
      chanId_ = value;
    }
    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     */
    private void clearChanId() {
      
      chanId_ = 0L;
    }

    public static co.anode.anodium.Rpc.ChanInfoRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChanInfoRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanInfoRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChanInfoRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanInfoRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChanInfoRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanInfoRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChanInfoRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanInfoRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChanInfoRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChanInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChanInfoRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChanInfoRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChanInfoRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChanInfoRequest)
        co.anode.anodium.Rpc.ChanInfoRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChanInfoRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The unique channel ID for the channel. The first 3 bytes are the block
       *height, the next 3 the index within the block, and the last 2 bytes are the
       *output index for the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
       * @return The chanId.
       */
      @java.lang.Override
      public long getChanId() {
        return instance.getChanId();
      }
      /**
       * <pre>
       *The unique channel ID for the channel. The first 3 bytes are the block
       *height, the next 3 the index within the block, and the last 2 bytes are the
       *output index for the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
       * @param value The chanId to set.
       * @return This builder for chaining.
       */
      public Builder setChanId(long value) {
        copyOnWrite();
        instance.setChanId(value);
        return this;
      }
      /**
       * <pre>
       *The unique channel ID for the channel. The first 3 bytes are the block
       *height, the next 3 the index within the block, and the last 2 bytes are the
       *output index for the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearChanId() {
        copyOnWrite();
        instance.clearChanId();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChanInfoRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChanInfoRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "chanId_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChanInfoRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChanInfoRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChanInfoRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChanInfoRequest)
    private static final co.anode.anodium.Rpc.ChanInfoRequest DEFAULT_INSTANCE;
    static {
      ChanInfoRequest defaultInstance = new ChanInfoRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChanInfoRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChanInfoRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChanInfoRequest> PARSER;

    public static com.google.protobuf.Parser<ChanInfoRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface NetworkInfoRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.NetworkInfoRequest)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.NetworkInfoRequest}
   */
  public  static final class NetworkInfoRequest extends
      com.google.protobuf.GeneratedMessageLite<
          NetworkInfoRequest, NetworkInfoRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.NetworkInfoRequest)
      NetworkInfoRequestOrBuilder {
    private NetworkInfoRequest() {
    }
    public static co.anode.anodium.Rpc.NetworkInfoRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NetworkInfoRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NetworkInfoRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NetworkInfoRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NetworkInfoRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NetworkInfoRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NetworkInfoRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NetworkInfoRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NetworkInfoRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NetworkInfoRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NetworkInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NetworkInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.NetworkInfoRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.NetworkInfoRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.NetworkInfoRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.NetworkInfoRequest)
        co.anode.anodium.Rpc.NetworkInfoRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.NetworkInfoRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.NetworkInfoRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.NetworkInfoRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.NetworkInfoRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.NetworkInfoRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.NetworkInfoRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.NetworkInfoRequest)
    private static final co.anode.anodium.Rpc.NetworkInfoRequest DEFAULT_INSTANCE;
    static {
      NetworkInfoRequest defaultInstance = new NetworkInfoRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        NetworkInfoRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.NetworkInfoRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<NetworkInfoRequest> PARSER;

    public static com.google.protobuf.Parser<NetworkInfoRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface NetworkInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.NetworkInfo)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>uint32 graph_diameter = 1;</code>
     * @return The graphDiameter.
     */
    int getGraphDiameter();

    /**
     * <code>double avg_out_degree = 2;</code>
     * @return The avgOutDegree.
     */
    double getAvgOutDegree();

    /**
     * <code>uint32 max_out_degree = 3;</code>
     * @return The maxOutDegree.
     */
    int getMaxOutDegree();

    /**
     * <code>uint32 num_nodes = 4;</code>
     * @return The numNodes.
     */
    int getNumNodes();

    /**
     * <code>uint32 num_channels = 5;</code>
     * @return The numChannels.
     */
    int getNumChannels();

    /**
     * <code>int64 total_network_capacity = 6;</code>
     * @return The totalNetworkCapacity.
     */
    long getTotalNetworkCapacity();

    /**
     * <code>double avg_channel_size = 7;</code>
     * @return The avgChannelSize.
     */
    double getAvgChannelSize();

    /**
     * <code>int64 min_channel_size = 8;</code>
     * @return The minChannelSize.
     */
    long getMinChannelSize();

    /**
     * <code>int64 max_channel_size = 9;</code>
     * @return The maxChannelSize.
     */
    long getMaxChannelSize();

    /**
     * <code>int64 median_channel_size_sat = 10;</code>
     * @return The medianChannelSizeSat.
     */
    long getMedianChannelSizeSat();

    /**
     * <pre>
     * The number of edges marked as zombies.
     * </pre>
     *
     * <code>uint64 num_zombie_chans = 11;</code>
     * @return The numZombieChans.
     */
    long getNumZombieChans();
  }
  /**
   * Protobuf type {@code co.anode.anodium.NetworkInfo}
   */
  public  static final class NetworkInfo extends
      com.google.protobuf.GeneratedMessageLite<
          NetworkInfo, NetworkInfo.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.NetworkInfo)
      NetworkInfoOrBuilder {
    private NetworkInfo() {
    }
    public static final int GRAPH_DIAMETER_FIELD_NUMBER = 1;
    private int graphDiameter_;
    /**
     * <code>uint32 graph_diameter = 1;</code>
     * @return The graphDiameter.
     */
    @java.lang.Override
    public int getGraphDiameter() {
      return graphDiameter_;
    }
    /**
     * <code>uint32 graph_diameter = 1;</code>
     * @param value The graphDiameter to set.
     */
    private void setGraphDiameter(int value) {
      
      graphDiameter_ = value;
    }
    /**
     * <code>uint32 graph_diameter = 1;</code>
     */
    private void clearGraphDiameter() {
      
      graphDiameter_ = 0;
    }

    public static final int AVG_OUT_DEGREE_FIELD_NUMBER = 2;
    private double avgOutDegree_;
    /**
     * <code>double avg_out_degree = 2;</code>
     * @return The avgOutDegree.
     */
    @java.lang.Override
    public double getAvgOutDegree() {
      return avgOutDegree_;
    }
    /**
     * <code>double avg_out_degree = 2;</code>
     * @param value The avgOutDegree to set.
     */
    private void setAvgOutDegree(double value) {
      
      avgOutDegree_ = value;
    }
    /**
     * <code>double avg_out_degree = 2;</code>
     */
    private void clearAvgOutDegree() {
      
      avgOutDegree_ = 0D;
    }

    public static final int MAX_OUT_DEGREE_FIELD_NUMBER = 3;
    private int maxOutDegree_;
    /**
     * <code>uint32 max_out_degree = 3;</code>
     * @return The maxOutDegree.
     */
    @java.lang.Override
    public int getMaxOutDegree() {
      return maxOutDegree_;
    }
    /**
     * <code>uint32 max_out_degree = 3;</code>
     * @param value The maxOutDegree to set.
     */
    private void setMaxOutDegree(int value) {
      
      maxOutDegree_ = value;
    }
    /**
     * <code>uint32 max_out_degree = 3;</code>
     */
    private void clearMaxOutDegree() {
      
      maxOutDegree_ = 0;
    }

    public static final int NUM_NODES_FIELD_NUMBER = 4;
    private int numNodes_;
    /**
     * <code>uint32 num_nodes = 4;</code>
     * @return The numNodes.
     */
    @java.lang.Override
    public int getNumNodes() {
      return numNodes_;
    }
    /**
     * <code>uint32 num_nodes = 4;</code>
     * @param value The numNodes to set.
     */
    private void setNumNodes(int value) {
      
      numNodes_ = value;
    }
    /**
     * <code>uint32 num_nodes = 4;</code>
     */
    private void clearNumNodes() {
      
      numNodes_ = 0;
    }

    public static final int NUM_CHANNELS_FIELD_NUMBER = 5;
    private int numChannels_;
    /**
     * <code>uint32 num_channels = 5;</code>
     * @return The numChannels.
     */
    @java.lang.Override
    public int getNumChannels() {
      return numChannels_;
    }
    /**
     * <code>uint32 num_channels = 5;</code>
     * @param value The numChannels to set.
     */
    private void setNumChannels(int value) {
      
      numChannels_ = value;
    }
    /**
     * <code>uint32 num_channels = 5;</code>
     */
    private void clearNumChannels() {
      
      numChannels_ = 0;
    }

    public static final int TOTAL_NETWORK_CAPACITY_FIELD_NUMBER = 6;
    private long totalNetworkCapacity_;
    /**
     * <code>int64 total_network_capacity = 6;</code>
     * @return The totalNetworkCapacity.
     */
    @java.lang.Override
    public long getTotalNetworkCapacity() {
      return totalNetworkCapacity_;
    }
    /**
     * <code>int64 total_network_capacity = 6;</code>
     * @param value The totalNetworkCapacity to set.
     */
    private void setTotalNetworkCapacity(long value) {
      
      totalNetworkCapacity_ = value;
    }
    /**
     * <code>int64 total_network_capacity = 6;</code>
     */
    private void clearTotalNetworkCapacity() {
      
      totalNetworkCapacity_ = 0L;
    }

    public static final int AVG_CHANNEL_SIZE_FIELD_NUMBER = 7;
    private double avgChannelSize_;
    /**
     * <code>double avg_channel_size = 7;</code>
     * @return The avgChannelSize.
     */
    @java.lang.Override
    public double getAvgChannelSize() {
      return avgChannelSize_;
    }
    /**
     * <code>double avg_channel_size = 7;</code>
     * @param value The avgChannelSize to set.
     */
    private void setAvgChannelSize(double value) {
      
      avgChannelSize_ = value;
    }
    /**
     * <code>double avg_channel_size = 7;</code>
     */
    private void clearAvgChannelSize() {
      
      avgChannelSize_ = 0D;
    }

    public static final int MIN_CHANNEL_SIZE_FIELD_NUMBER = 8;
    private long minChannelSize_;
    /**
     * <code>int64 min_channel_size = 8;</code>
     * @return The minChannelSize.
     */
    @java.lang.Override
    public long getMinChannelSize() {
      return minChannelSize_;
    }
    /**
     * <code>int64 min_channel_size = 8;</code>
     * @param value The minChannelSize to set.
     */
    private void setMinChannelSize(long value) {
      
      minChannelSize_ = value;
    }
    /**
     * <code>int64 min_channel_size = 8;</code>
     */
    private void clearMinChannelSize() {
      
      minChannelSize_ = 0L;
    }

    public static final int MAX_CHANNEL_SIZE_FIELD_NUMBER = 9;
    private long maxChannelSize_;
    /**
     * <code>int64 max_channel_size = 9;</code>
     * @return The maxChannelSize.
     */
    @java.lang.Override
    public long getMaxChannelSize() {
      return maxChannelSize_;
    }
    /**
     * <code>int64 max_channel_size = 9;</code>
     * @param value The maxChannelSize to set.
     */
    private void setMaxChannelSize(long value) {
      
      maxChannelSize_ = value;
    }
    /**
     * <code>int64 max_channel_size = 9;</code>
     */
    private void clearMaxChannelSize() {
      
      maxChannelSize_ = 0L;
    }

    public static final int MEDIAN_CHANNEL_SIZE_SAT_FIELD_NUMBER = 10;
    private long medianChannelSizeSat_;
    /**
     * <code>int64 median_channel_size_sat = 10;</code>
     * @return The medianChannelSizeSat.
     */
    @java.lang.Override
    public long getMedianChannelSizeSat() {
      return medianChannelSizeSat_;
    }
    /**
     * <code>int64 median_channel_size_sat = 10;</code>
     * @param value The medianChannelSizeSat to set.
     */
    private void setMedianChannelSizeSat(long value) {
      
      medianChannelSizeSat_ = value;
    }
    /**
     * <code>int64 median_channel_size_sat = 10;</code>
     */
    private void clearMedianChannelSizeSat() {
      
      medianChannelSizeSat_ = 0L;
    }

    public static final int NUM_ZOMBIE_CHANS_FIELD_NUMBER = 11;
    private long numZombieChans_;
    /**
     * <pre>
     * The number of edges marked as zombies.
     * </pre>
     *
     * <code>uint64 num_zombie_chans = 11;</code>
     * @return The numZombieChans.
     */
    @java.lang.Override
    public long getNumZombieChans() {
      return numZombieChans_;
    }
    /**
     * <pre>
     * The number of edges marked as zombies.
     * </pre>
     *
     * <code>uint64 num_zombie_chans = 11;</code>
     * @param value The numZombieChans to set.
     */
    private void setNumZombieChans(long value) {
      
      numZombieChans_ = value;
    }
    /**
     * <pre>
     * The number of edges marked as zombies.
     * </pre>
     *
     * <code>uint64 num_zombie_chans = 11;</code>
     */
    private void clearNumZombieChans() {
      
      numZombieChans_ = 0L;
    }

    public static co.anode.anodium.Rpc.NetworkInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NetworkInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NetworkInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NetworkInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NetworkInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NetworkInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NetworkInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NetworkInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NetworkInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NetworkInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NetworkInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NetworkInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.NetworkInfo prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.NetworkInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.NetworkInfo, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.NetworkInfo)
        co.anode.anodium.Rpc.NetworkInfoOrBuilder {
      // Construct using co.anode.anodium.Rpc.NetworkInfo.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>uint32 graph_diameter = 1;</code>
       * @return The graphDiameter.
       */
      @java.lang.Override
      public int getGraphDiameter() {
        return instance.getGraphDiameter();
      }
      /**
       * <code>uint32 graph_diameter = 1;</code>
       * @param value The graphDiameter to set.
       * @return This builder for chaining.
       */
      public Builder setGraphDiameter(int value) {
        copyOnWrite();
        instance.setGraphDiameter(value);
        return this;
      }
      /**
       * <code>uint32 graph_diameter = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearGraphDiameter() {
        copyOnWrite();
        instance.clearGraphDiameter();
        return this;
      }

      /**
       * <code>double avg_out_degree = 2;</code>
       * @return The avgOutDegree.
       */
      @java.lang.Override
      public double getAvgOutDegree() {
        return instance.getAvgOutDegree();
      }
      /**
       * <code>double avg_out_degree = 2;</code>
       * @param value The avgOutDegree to set.
       * @return This builder for chaining.
       */
      public Builder setAvgOutDegree(double value) {
        copyOnWrite();
        instance.setAvgOutDegree(value);
        return this;
      }
      /**
       * <code>double avg_out_degree = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAvgOutDegree() {
        copyOnWrite();
        instance.clearAvgOutDegree();
        return this;
      }

      /**
       * <code>uint32 max_out_degree = 3;</code>
       * @return The maxOutDegree.
       */
      @java.lang.Override
      public int getMaxOutDegree() {
        return instance.getMaxOutDegree();
      }
      /**
       * <code>uint32 max_out_degree = 3;</code>
       * @param value The maxOutDegree to set.
       * @return This builder for chaining.
       */
      public Builder setMaxOutDegree(int value) {
        copyOnWrite();
        instance.setMaxOutDegree(value);
        return this;
      }
      /**
       * <code>uint32 max_out_degree = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxOutDegree() {
        copyOnWrite();
        instance.clearMaxOutDegree();
        return this;
      }

      /**
       * <code>uint32 num_nodes = 4;</code>
       * @return The numNodes.
       */
      @java.lang.Override
      public int getNumNodes() {
        return instance.getNumNodes();
      }
      /**
       * <code>uint32 num_nodes = 4;</code>
       * @param value The numNodes to set.
       * @return This builder for chaining.
       */
      public Builder setNumNodes(int value) {
        copyOnWrite();
        instance.setNumNodes(value);
        return this;
      }
      /**
       * <code>uint32 num_nodes = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumNodes() {
        copyOnWrite();
        instance.clearNumNodes();
        return this;
      }

      /**
       * <code>uint32 num_channels = 5;</code>
       * @return The numChannels.
       */
      @java.lang.Override
      public int getNumChannels() {
        return instance.getNumChannels();
      }
      /**
       * <code>uint32 num_channels = 5;</code>
       * @param value The numChannels to set.
       * @return This builder for chaining.
       */
      public Builder setNumChannels(int value) {
        copyOnWrite();
        instance.setNumChannels(value);
        return this;
      }
      /**
       * <code>uint32 num_channels = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumChannels() {
        copyOnWrite();
        instance.clearNumChannels();
        return this;
      }

      /**
       * <code>int64 total_network_capacity = 6;</code>
       * @return The totalNetworkCapacity.
       */
      @java.lang.Override
      public long getTotalNetworkCapacity() {
        return instance.getTotalNetworkCapacity();
      }
      /**
       * <code>int64 total_network_capacity = 6;</code>
       * @param value The totalNetworkCapacity to set.
       * @return This builder for chaining.
       */
      public Builder setTotalNetworkCapacity(long value) {
        copyOnWrite();
        instance.setTotalNetworkCapacity(value);
        return this;
      }
      /**
       * <code>int64 total_network_capacity = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearTotalNetworkCapacity() {
        copyOnWrite();
        instance.clearTotalNetworkCapacity();
        return this;
      }

      /**
       * <code>double avg_channel_size = 7;</code>
       * @return The avgChannelSize.
       */
      @java.lang.Override
      public double getAvgChannelSize() {
        return instance.getAvgChannelSize();
      }
      /**
       * <code>double avg_channel_size = 7;</code>
       * @param value The avgChannelSize to set.
       * @return This builder for chaining.
       */
      public Builder setAvgChannelSize(double value) {
        copyOnWrite();
        instance.setAvgChannelSize(value);
        return this;
      }
      /**
       * <code>double avg_channel_size = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearAvgChannelSize() {
        copyOnWrite();
        instance.clearAvgChannelSize();
        return this;
      }

      /**
       * <code>int64 min_channel_size = 8;</code>
       * @return The minChannelSize.
       */
      @java.lang.Override
      public long getMinChannelSize() {
        return instance.getMinChannelSize();
      }
      /**
       * <code>int64 min_channel_size = 8;</code>
       * @param value The minChannelSize to set.
       * @return This builder for chaining.
       */
      public Builder setMinChannelSize(long value) {
        copyOnWrite();
        instance.setMinChannelSize(value);
        return this;
      }
      /**
       * <code>int64 min_channel_size = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinChannelSize() {
        copyOnWrite();
        instance.clearMinChannelSize();
        return this;
      }

      /**
       * <code>int64 max_channel_size = 9;</code>
       * @return The maxChannelSize.
       */
      @java.lang.Override
      public long getMaxChannelSize() {
        return instance.getMaxChannelSize();
      }
      /**
       * <code>int64 max_channel_size = 9;</code>
       * @param value The maxChannelSize to set.
       * @return This builder for chaining.
       */
      public Builder setMaxChannelSize(long value) {
        copyOnWrite();
        instance.setMaxChannelSize(value);
        return this;
      }
      /**
       * <code>int64 max_channel_size = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxChannelSize() {
        copyOnWrite();
        instance.clearMaxChannelSize();
        return this;
      }

      /**
       * <code>int64 median_channel_size_sat = 10;</code>
       * @return The medianChannelSizeSat.
       */
      @java.lang.Override
      public long getMedianChannelSizeSat() {
        return instance.getMedianChannelSizeSat();
      }
      /**
       * <code>int64 median_channel_size_sat = 10;</code>
       * @param value The medianChannelSizeSat to set.
       * @return This builder for chaining.
       */
      public Builder setMedianChannelSizeSat(long value) {
        copyOnWrite();
        instance.setMedianChannelSizeSat(value);
        return this;
      }
      /**
       * <code>int64 median_channel_size_sat = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearMedianChannelSizeSat() {
        copyOnWrite();
        instance.clearMedianChannelSizeSat();
        return this;
      }

      /**
       * <pre>
       * The number of edges marked as zombies.
       * </pre>
       *
       * <code>uint64 num_zombie_chans = 11;</code>
       * @return The numZombieChans.
       */
      @java.lang.Override
      public long getNumZombieChans() {
        return instance.getNumZombieChans();
      }
      /**
       * <pre>
       * The number of edges marked as zombies.
       * </pre>
       *
       * <code>uint64 num_zombie_chans = 11;</code>
       * @param value The numZombieChans to set.
       * @return This builder for chaining.
       */
      public Builder setNumZombieChans(long value) {
        copyOnWrite();
        instance.setNumZombieChans(value);
        return this;
      }
      /**
       * <pre>
       * The number of edges marked as zombies.
       * </pre>
       *
       * <code>uint64 num_zombie_chans = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumZombieChans() {
        copyOnWrite();
        instance.clearNumZombieChans();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.NetworkInfo)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.NetworkInfo();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "graphDiameter_",
              "avgOutDegree_",
              "maxOutDegree_",
              "numNodes_",
              "numChannels_",
              "totalNetworkCapacity_",
              "avgChannelSize_",
              "minChannelSize_",
              "maxChannelSize_",
              "medianChannelSizeSat_",
              "numZombieChans_",
            };
            java.lang.String info =
                "\u0000\u000b\u0000\u0000\u0001\u000b\u000b\u0000\u0000\u0000\u0001\u000b\u0002\u0000" +
                "\u0003\u000b\u0004\u000b\u0005\u000b\u0006\u0002\u0007\u0000\b\u0002\t\u0002\n\u0002" +
                "\u000b\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.NetworkInfo> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.NetworkInfo.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.NetworkInfo>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.NetworkInfo)
    private static final co.anode.anodium.Rpc.NetworkInfo DEFAULT_INSTANCE;
    static {
      NetworkInfo defaultInstance = new NetworkInfo();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        NetworkInfo.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.NetworkInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<NetworkInfo> PARSER;

    public static com.google.protobuf.Parser<NetworkInfo> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface StopRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.StopRequest)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.StopRequest}
   */
  public  static final class StopRequest extends
      com.google.protobuf.GeneratedMessageLite<
          StopRequest, StopRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.StopRequest)
      StopRequestOrBuilder {
    private StopRequest() {
    }
    public static co.anode.anodium.Rpc.StopRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.StopRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.StopRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.StopRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.StopRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.StopRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.StopRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.StopRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.StopRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.StopRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.StopRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.StopRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.StopRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.StopRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.StopRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.StopRequest)
        co.anode.anodium.Rpc.StopRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.StopRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.StopRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.StopRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.StopRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.StopRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.StopRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.StopRequest)
    private static final co.anode.anodium.Rpc.StopRequest DEFAULT_INSTANCE;
    static {
      StopRequest defaultInstance = new StopRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        StopRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.StopRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<StopRequest> PARSER;

    public static com.google.protobuf.Parser<StopRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface StopResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.StopResponse)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.StopResponse}
   */
  public  static final class StopResponse extends
      com.google.protobuf.GeneratedMessageLite<
          StopResponse, StopResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.StopResponse)
      StopResponseOrBuilder {
    private StopResponse() {
    }
    public static co.anode.anodium.Rpc.StopResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.StopResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.StopResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.StopResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.StopResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.StopResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.StopResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.StopResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.StopResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.StopResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.StopResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.StopResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.StopResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.StopResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.StopResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.StopResponse)
        co.anode.anodium.Rpc.StopResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.StopResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.StopResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.StopResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.StopResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.StopResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.StopResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.StopResponse)
    private static final co.anode.anodium.Rpc.StopResponse DEFAULT_INSTANCE;
    static {
      StopResponse defaultInstance = new StopResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        StopResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.StopResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<StopResponse> PARSER;

    public static com.google.protobuf.Parser<StopResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface GraphTopologySubscriptionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.GraphTopologySubscription)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.GraphTopologySubscription}
   */
  public  static final class GraphTopologySubscription extends
      com.google.protobuf.GeneratedMessageLite<
          GraphTopologySubscription, GraphTopologySubscription.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.GraphTopologySubscription)
      GraphTopologySubscriptionOrBuilder {
    private GraphTopologySubscription() {
    }
    public static co.anode.anodium.Rpc.GraphTopologySubscription parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GraphTopologySubscription parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GraphTopologySubscription parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GraphTopologySubscription parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GraphTopologySubscription parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GraphTopologySubscription parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GraphTopologySubscription parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GraphTopologySubscription parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GraphTopologySubscription parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GraphTopologySubscription parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GraphTopologySubscription parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GraphTopologySubscription parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.GraphTopologySubscription prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.GraphTopologySubscription}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.GraphTopologySubscription, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.GraphTopologySubscription)
        co.anode.anodium.Rpc.GraphTopologySubscriptionOrBuilder {
      // Construct using co.anode.anodium.Rpc.GraphTopologySubscription.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.GraphTopologySubscription)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.GraphTopologySubscription();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.GraphTopologySubscription> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.GraphTopologySubscription.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.GraphTopologySubscription>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.GraphTopologySubscription)
    private static final co.anode.anodium.Rpc.GraphTopologySubscription DEFAULT_INSTANCE;
    static {
      GraphTopologySubscription defaultInstance = new GraphTopologySubscription();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        GraphTopologySubscription.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.GraphTopologySubscription getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<GraphTopologySubscription> PARSER;

    public static com.google.protobuf.Parser<GraphTopologySubscription> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface GraphTopologyUpdateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.GraphTopologyUpdate)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
     */
    java.util.List<co.anode.anodium.Rpc.NodeUpdate> 
        getNodeUpdatesList();
    /**
     * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
     */
    co.anode.anodium.Rpc.NodeUpdate getNodeUpdates(int index);
    /**
     * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
     */
    int getNodeUpdatesCount();

    /**
     * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
     */
    java.util.List<co.anode.anodium.Rpc.ChannelEdgeUpdate> 
        getChannelUpdatesList();
    /**
     * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
     */
    co.anode.anodium.Rpc.ChannelEdgeUpdate getChannelUpdates(int index);
    /**
     * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
     */
    int getChannelUpdatesCount();

    /**
     * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
     */
    java.util.List<co.anode.anodium.Rpc.ClosedChannelUpdate> 
        getClosedChansList();
    /**
     * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
     */
    co.anode.anodium.Rpc.ClosedChannelUpdate getClosedChans(int index);
    /**
     * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
     */
    int getClosedChansCount();
  }
  /**
   * Protobuf type {@code co.anode.anodium.GraphTopologyUpdate}
   */
  public  static final class GraphTopologyUpdate extends
      com.google.protobuf.GeneratedMessageLite<
          GraphTopologyUpdate, GraphTopologyUpdate.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.GraphTopologyUpdate)
      GraphTopologyUpdateOrBuilder {
    private GraphTopologyUpdate() {
      nodeUpdates_ = emptyProtobufList();
      channelUpdates_ = emptyProtobufList();
      closedChans_ = emptyProtobufList();
    }
    public static final int NODE_UPDATES_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.NodeUpdate> nodeUpdates_;
    /**
     * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.NodeUpdate> getNodeUpdatesList() {
      return nodeUpdates_;
    }
    /**
     * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.NodeUpdateOrBuilder> 
        getNodeUpdatesOrBuilderList() {
      return nodeUpdates_;
    }
    /**
     * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
     */
    @java.lang.Override
    public int getNodeUpdatesCount() {
      return nodeUpdates_.size();
    }
    /**
     * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.NodeUpdate getNodeUpdates(int index) {
      return nodeUpdates_.get(index);
    }
    /**
     * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
     */
    public co.anode.anodium.Rpc.NodeUpdateOrBuilder getNodeUpdatesOrBuilder(
        int index) {
      return nodeUpdates_.get(index);
    }
    private void ensureNodeUpdatesIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.NodeUpdate> tmp = nodeUpdates_;
      if (!tmp.isModifiable()) {
        nodeUpdates_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
     */
    private void setNodeUpdates(
        int index, co.anode.anodium.Rpc.NodeUpdate value) {
      value.getClass();
  ensureNodeUpdatesIsMutable();
      nodeUpdates_.set(index, value);
    }
    /**
     * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
     */
    private void addNodeUpdates(co.anode.anodium.Rpc.NodeUpdate value) {
      value.getClass();
  ensureNodeUpdatesIsMutable();
      nodeUpdates_.add(value);
    }
    /**
     * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
     */
    private void addNodeUpdates(
        int index, co.anode.anodium.Rpc.NodeUpdate value) {
      value.getClass();
  ensureNodeUpdatesIsMutable();
      nodeUpdates_.add(index, value);
    }
    /**
     * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
     */
    private void addAllNodeUpdates(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.NodeUpdate> values) {
      ensureNodeUpdatesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, nodeUpdates_);
    }
    /**
     * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
     */
    private void clearNodeUpdates() {
      nodeUpdates_ = emptyProtobufList();
    }
    /**
     * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
     */
    private void removeNodeUpdates(int index) {
      ensureNodeUpdatesIsMutable();
      nodeUpdates_.remove(index);
    }

    public static final int CHANNEL_UPDATES_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.ChannelEdgeUpdate> channelUpdates_;
    /**
     * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.ChannelEdgeUpdate> getChannelUpdatesList() {
      return channelUpdates_;
    }
    /**
     * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.ChannelEdgeUpdateOrBuilder> 
        getChannelUpdatesOrBuilderList() {
      return channelUpdates_;
    }
    /**
     * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
     */
    @java.lang.Override
    public int getChannelUpdatesCount() {
      return channelUpdates_.size();
    }
    /**
     * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelEdgeUpdate getChannelUpdates(int index) {
      return channelUpdates_.get(index);
    }
    /**
     * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
     */
    public co.anode.anodium.Rpc.ChannelEdgeUpdateOrBuilder getChannelUpdatesOrBuilder(
        int index) {
      return channelUpdates_.get(index);
    }
    private void ensureChannelUpdatesIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.ChannelEdgeUpdate> tmp = channelUpdates_;
      if (!tmp.isModifiable()) {
        channelUpdates_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
     */
    private void setChannelUpdates(
        int index, co.anode.anodium.Rpc.ChannelEdgeUpdate value) {
      value.getClass();
  ensureChannelUpdatesIsMutable();
      channelUpdates_.set(index, value);
    }
    /**
     * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
     */
    private void addChannelUpdates(co.anode.anodium.Rpc.ChannelEdgeUpdate value) {
      value.getClass();
  ensureChannelUpdatesIsMutable();
      channelUpdates_.add(value);
    }
    /**
     * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
     */
    private void addChannelUpdates(
        int index, co.anode.anodium.Rpc.ChannelEdgeUpdate value) {
      value.getClass();
  ensureChannelUpdatesIsMutable();
      channelUpdates_.add(index, value);
    }
    /**
     * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
     */
    private void addAllChannelUpdates(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.ChannelEdgeUpdate> values) {
      ensureChannelUpdatesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, channelUpdates_);
    }
    /**
     * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
     */
    private void clearChannelUpdates() {
      channelUpdates_ = emptyProtobufList();
    }
    /**
     * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
     */
    private void removeChannelUpdates(int index) {
      ensureChannelUpdatesIsMutable();
      channelUpdates_.remove(index);
    }

    public static final int CLOSED_CHANS_FIELD_NUMBER = 3;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.ClosedChannelUpdate> closedChans_;
    /**
     * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.ClosedChannelUpdate> getClosedChansList() {
      return closedChans_;
    }
    /**
     * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.ClosedChannelUpdateOrBuilder> 
        getClosedChansOrBuilderList() {
      return closedChans_;
    }
    /**
     * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
     */
    @java.lang.Override
    public int getClosedChansCount() {
      return closedChans_.size();
    }
    /**
     * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ClosedChannelUpdate getClosedChans(int index) {
      return closedChans_.get(index);
    }
    /**
     * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
     */
    public co.anode.anodium.Rpc.ClosedChannelUpdateOrBuilder getClosedChansOrBuilder(
        int index) {
      return closedChans_.get(index);
    }
    private void ensureClosedChansIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.ClosedChannelUpdate> tmp = closedChans_;
      if (!tmp.isModifiable()) {
        closedChans_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
     */
    private void setClosedChans(
        int index, co.anode.anodium.Rpc.ClosedChannelUpdate value) {
      value.getClass();
  ensureClosedChansIsMutable();
      closedChans_.set(index, value);
    }
    /**
     * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
     */
    private void addClosedChans(co.anode.anodium.Rpc.ClosedChannelUpdate value) {
      value.getClass();
  ensureClosedChansIsMutable();
      closedChans_.add(value);
    }
    /**
     * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
     */
    private void addClosedChans(
        int index, co.anode.anodium.Rpc.ClosedChannelUpdate value) {
      value.getClass();
  ensureClosedChansIsMutable();
      closedChans_.add(index, value);
    }
    /**
     * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
     */
    private void addAllClosedChans(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.ClosedChannelUpdate> values) {
      ensureClosedChansIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, closedChans_);
    }
    /**
     * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
     */
    private void clearClosedChans() {
      closedChans_ = emptyProtobufList();
    }
    /**
     * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
     */
    private void removeClosedChans(int index) {
      ensureClosedChansIsMutable();
      closedChans_.remove(index);
    }

    public static co.anode.anodium.Rpc.GraphTopologyUpdate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GraphTopologyUpdate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GraphTopologyUpdate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GraphTopologyUpdate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GraphTopologyUpdate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.GraphTopologyUpdate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GraphTopologyUpdate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GraphTopologyUpdate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GraphTopologyUpdate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GraphTopologyUpdate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.GraphTopologyUpdate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.GraphTopologyUpdate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.GraphTopologyUpdate prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.GraphTopologyUpdate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.GraphTopologyUpdate, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.GraphTopologyUpdate)
        co.anode.anodium.Rpc.GraphTopologyUpdateOrBuilder {
      // Construct using co.anode.anodium.Rpc.GraphTopologyUpdate.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.NodeUpdate> getNodeUpdatesList() {
        return java.util.Collections.unmodifiableList(
            instance.getNodeUpdatesList());
      }
      /**
       * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
       */
      @java.lang.Override
      public int getNodeUpdatesCount() {
        return instance.getNodeUpdatesCount();
      }/**
       * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.NodeUpdate getNodeUpdates(int index) {
        return instance.getNodeUpdates(index);
      }
      /**
       * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
       */
      public Builder setNodeUpdates(
          int index, co.anode.anodium.Rpc.NodeUpdate value) {
        copyOnWrite();
        instance.setNodeUpdates(index, value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
       */
      public Builder setNodeUpdates(
          int index, co.anode.anodium.Rpc.NodeUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.setNodeUpdates(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
       */
      public Builder addNodeUpdates(co.anode.anodium.Rpc.NodeUpdate value) {
        copyOnWrite();
        instance.addNodeUpdates(value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
       */
      public Builder addNodeUpdates(
          int index, co.anode.anodium.Rpc.NodeUpdate value) {
        copyOnWrite();
        instance.addNodeUpdates(index, value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
       */
      public Builder addNodeUpdates(
          co.anode.anodium.Rpc.NodeUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.addNodeUpdates(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
       */
      public Builder addNodeUpdates(
          int index, co.anode.anodium.Rpc.NodeUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.addNodeUpdates(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
       */
      public Builder addAllNodeUpdates(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.NodeUpdate> values) {
        copyOnWrite();
        instance.addAllNodeUpdates(values);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
       */
      public Builder clearNodeUpdates() {
        copyOnWrite();
        instance.clearNodeUpdates();
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.NodeUpdate node_updates = 1;</code>
       */
      public Builder removeNodeUpdates(int index) {
        copyOnWrite();
        instance.removeNodeUpdates(index);
        return this;
      }

      /**
       * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.ChannelEdgeUpdate> getChannelUpdatesList() {
        return java.util.Collections.unmodifiableList(
            instance.getChannelUpdatesList());
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
       */
      @java.lang.Override
      public int getChannelUpdatesCount() {
        return instance.getChannelUpdatesCount();
      }/**
       * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelEdgeUpdate getChannelUpdates(int index) {
        return instance.getChannelUpdates(index);
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
       */
      public Builder setChannelUpdates(
          int index, co.anode.anodium.Rpc.ChannelEdgeUpdate value) {
        copyOnWrite();
        instance.setChannelUpdates(index, value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
       */
      public Builder setChannelUpdates(
          int index, co.anode.anodium.Rpc.ChannelEdgeUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.setChannelUpdates(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
       */
      public Builder addChannelUpdates(co.anode.anodium.Rpc.ChannelEdgeUpdate value) {
        copyOnWrite();
        instance.addChannelUpdates(value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
       */
      public Builder addChannelUpdates(
          int index, co.anode.anodium.Rpc.ChannelEdgeUpdate value) {
        copyOnWrite();
        instance.addChannelUpdates(index, value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
       */
      public Builder addChannelUpdates(
          co.anode.anodium.Rpc.ChannelEdgeUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.addChannelUpdates(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
       */
      public Builder addChannelUpdates(
          int index, co.anode.anodium.Rpc.ChannelEdgeUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.addChannelUpdates(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
       */
      public Builder addAllChannelUpdates(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.ChannelEdgeUpdate> values) {
        copyOnWrite();
        instance.addAllChannelUpdates(values);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
       */
      public Builder clearChannelUpdates() {
        copyOnWrite();
        instance.clearChannelUpdates();
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ChannelEdgeUpdate channel_updates = 2;</code>
       */
      public Builder removeChannelUpdates(int index) {
        copyOnWrite();
        instance.removeChannelUpdates(index);
        return this;
      }

      /**
       * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.ClosedChannelUpdate> getClosedChansList() {
        return java.util.Collections.unmodifiableList(
            instance.getClosedChansList());
      }
      /**
       * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
       */
      @java.lang.Override
      public int getClosedChansCount() {
        return instance.getClosedChansCount();
      }/**
       * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ClosedChannelUpdate getClosedChans(int index) {
        return instance.getClosedChans(index);
      }
      /**
       * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
       */
      public Builder setClosedChans(
          int index, co.anode.anodium.Rpc.ClosedChannelUpdate value) {
        copyOnWrite();
        instance.setClosedChans(index, value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
       */
      public Builder setClosedChans(
          int index, co.anode.anodium.Rpc.ClosedChannelUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.setClosedChans(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
       */
      public Builder addClosedChans(co.anode.anodium.Rpc.ClosedChannelUpdate value) {
        copyOnWrite();
        instance.addClosedChans(value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
       */
      public Builder addClosedChans(
          int index, co.anode.anodium.Rpc.ClosedChannelUpdate value) {
        copyOnWrite();
        instance.addClosedChans(index, value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
       */
      public Builder addClosedChans(
          co.anode.anodium.Rpc.ClosedChannelUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.addClosedChans(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
       */
      public Builder addClosedChans(
          int index, co.anode.anodium.Rpc.ClosedChannelUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.addClosedChans(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
       */
      public Builder addAllClosedChans(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.ClosedChannelUpdate> values) {
        copyOnWrite();
        instance.addAllClosedChans(values);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
       */
      public Builder clearClosedChans() {
        copyOnWrite();
        instance.clearClosedChans();
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.ClosedChannelUpdate closed_chans = 3;</code>
       */
      public Builder removeClosedChans(int index) {
        copyOnWrite();
        instance.removeClosedChans(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.GraphTopologyUpdate)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.GraphTopologyUpdate();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "nodeUpdates_",
              co.anode.anodium.Rpc.NodeUpdate.class,
              "channelUpdates_",
              co.anode.anodium.Rpc.ChannelEdgeUpdate.class,
              "closedChans_",
              co.anode.anodium.Rpc.ClosedChannelUpdate.class,
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0003\u0003\u0000\u0003\u0000\u0001\u001b\u0002\u001b" +
                "\u0003\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.GraphTopologyUpdate> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.GraphTopologyUpdate.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.GraphTopologyUpdate>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.GraphTopologyUpdate)
    private static final co.anode.anodium.Rpc.GraphTopologyUpdate DEFAULT_INSTANCE;
    static {
      GraphTopologyUpdate defaultInstance = new GraphTopologyUpdate();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        GraphTopologyUpdate.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.GraphTopologyUpdate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<GraphTopologyUpdate> PARSER;

    public static com.google.protobuf.Parser<GraphTopologyUpdate> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface NodeUpdateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.NodeUpdate)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>repeated string addresses = 1;</code>
     * @return A list containing the addresses.
     */
    java.util.List<java.lang.String>
        getAddressesList();
    /**
     * <code>repeated string addresses = 1;</code>
     * @return The count of addresses.
     */
    int getAddressesCount();
    /**
     * <code>repeated string addresses = 1;</code>
     * @param index The index of the element to return.
     * @return The addresses at the given index.
     */
    java.lang.String getAddresses(int index);
    /**
     * <code>repeated string addresses = 1;</code>
     * @param index The index of the element to return.
     * @return The addresses at the given index.
     */
    com.google.protobuf.ByteString
        getAddressesBytes(int index);

    /**
     * <code>string identity_key = 2;</code>
     * @return The identityKey.
     */
    java.lang.String getIdentityKey();
    /**
     * <code>string identity_key = 2;</code>
     * @return The bytes for identityKey.
     */
    com.google.protobuf.ByteString
        getIdentityKeyBytes();

    /**
     * <code>bytes global_features = 3;</code>
     * @return The globalFeatures.
     */
    com.google.protobuf.ByteString getGlobalFeatures();

    /**
     * <code>string alias = 4;</code>
     * @return The alias.
     */
    java.lang.String getAlias();
    /**
     * <code>string alias = 4;</code>
     * @return The bytes for alias.
     */
    com.google.protobuf.ByteString
        getAliasBytes();

    /**
     * <code>string color = 5;</code>
     * @return The color.
     */
    java.lang.String getColor();
    /**
     * <code>string color = 5;</code>
     * @return The bytes for color.
     */
    com.google.protobuf.ByteString
        getColorBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.NodeUpdate}
   */
  public  static final class NodeUpdate extends
      com.google.protobuf.GeneratedMessageLite<
          NodeUpdate, NodeUpdate.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.NodeUpdate)
      NodeUpdateOrBuilder {
    private NodeUpdate() {
      addresses_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
      identityKey_ = "";
      globalFeatures_ = com.google.protobuf.ByteString.EMPTY;
      alias_ = "";
      color_ = "";
    }
    public static final int ADDRESSES_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<java.lang.String> addresses_;
    /**
     * <code>repeated string addresses = 1;</code>
     * @return A list containing the addresses.
     */
    @java.lang.Override
    public java.util.List<java.lang.String> getAddressesList() {
      return addresses_;
    }
    /**
     * <code>repeated string addresses = 1;</code>
     * @return The count of addresses.
     */
    @java.lang.Override
    public int getAddressesCount() {
      return addresses_.size();
    }
    /**
     * <code>repeated string addresses = 1;</code>
     * @param index The index of the element to return.
     * @return The addresses at the given index.
     */
    @java.lang.Override
    public java.lang.String getAddresses(int index) {
      return addresses_.get(index);
    }
    /**
     * <code>repeated string addresses = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the addresses at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAddressesBytes(int index) {
      return com.google.protobuf.ByteString.copyFromUtf8(
          addresses_.get(index));
    }
    private void ensureAddressesIsMutable() {
      com.google.protobuf.Internal.ProtobufList<java.lang.String> tmp =
          addresses_;  if (!tmp.isModifiable()) {
        addresses_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <code>repeated string addresses = 1;</code>
     * @param index The index to set the value at.
     * @param value The addresses to set.
     */
    private void setAddresses(
        int index, java.lang.String value) {
      value.getClass();
  ensureAddressesIsMutable();
      addresses_.set(index, value);
    }
    /**
     * <code>repeated string addresses = 1;</code>
     * @param value The addresses to add.
     */
    private void addAddresses(
        java.lang.String value) {
      value.getClass();
  ensureAddressesIsMutable();
      addresses_.add(value);
    }
    /**
     * <code>repeated string addresses = 1;</code>
     * @param values The addresses to add.
     */
    private void addAllAddresses(
        java.lang.Iterable<java.lang.String> values) {
      ensureAddressesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, addresses_);
    }
    /**
     * <code>repeated string addresses = 1;</code>
     */
    private void clearAddresses() {
      addresses_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    /**
     * <code>repeated string addresses = 1;</code>
     * @param value The bytes of the addresses to add.
     */
    private void addAddressesBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      ensureAddressesIsMutable();
      addresses_.add(value.toStringUtf8());
    }

    public static final int IDENTITY_KEY_FIELD_NUMBER = 2;
    private java.lang.String identityKey_;
    /**
     * <code>string identity_key = 2;</code>
     * @return The identityKey.
     */
    @java.lang.Override
    public java.lang.String getIdentityKey() {
      return identityKey_;
    }
    /**
     * <code>string identity_key = 2;</code>
     * @return The bytes for identityKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getIdentityKeyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(identityKey_);
    }
    /**
     * <code>string identity_key = 2;</code>
     * @param value The identityKey to set.
     */
    private void setIdentityKey(
        java.lang.String value) {
      value.getClass();
  
      identityKey_ = value;
    }
    /**
     * <code>string identity_key = 2;</code>
     */
    private void clearIdentityKey() {
      
      identityKey_ = getDefaultInstance().getIdentityKey();
    }
    /**
     * <code>string identity_key = 2;</code>
     * @param value The bytes for identityKey to set.
     */
    private void setIdentityKeyBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      identityKey_ = value.toStringUtf8();
      
    }

    public static final int GLOBAL_FEATURES_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString globalFeatures_;
    /**
     * <code>bytes global_features = 3;</code>
     * @return The globalFeatures.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getGlobalFeatures() {
      return globalFeatures_;
    }
    /**
     * <code>bytes global_features = 3;</code>
     * @param value The globalFeatures to set.
     */
    private void setGlobalFeatures(com.google.protobuf.ByteString value) {
      value.getClass();
  
      globalFeatures_ = value;
    }
    /**
     * <code>bytes global_features = 3;</code>
     */
    private void clearGlobalFeatures() {
      
      globalFeatures_ = getDefaultInstance().getGlobalFeatures();
    }

    public static final int ALIAS_FIELD_NUMBER = 4;
    private java.lang.String alias_;
    /**
     * <code>string alias = 4;</code>
     * @return The alias.
     */
    @java.lang.Override
    public java.lang.String getAlias() {
      return alias_;
    }
    /**
     * <code>string alias = 4;</code>
     * @return The bytes for alias.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAliasBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(alias_);
    }
    /**
     * <code>string alias = 4;</code>
     * @param value The alias to set.
     */
    private void setAlias(
        java.lang.String value) {
      value.getClass();
  
      alias_ = value;
    }
    /**
     * <code>string alias = 4;</code>
     */
    private void clearAlias() {
      
      alias_ = getDefaultInstance().getAlias();
    }
    /**
     * <code>string alias = 4;</code>
     * @param value The bytes for alias to set.
     */
    private void setAliasBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      alias_ = value.toStringUtf8();
      
    }

    public static final int COLOR_FIELD_NUMBER = 5;
    private java.lang.String color_;
    /**
     * <code>string color = 5;</code>
     * @return The color.
     */
    @java.lang.Override
    public java.lang.String getColor() {
      return color_;
    }
    /**
     * <code>string color = 5;</code>
     * @return The bytes for color.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getColorBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(color_);
    }
    /**
     * <code>string color = 5;</code>
     * @param value The color to set.
     */
    private void setColor(
        java.lang.String value) {
      value.getClass();
  
      color_ = value;
    }
    /**
     * <code>string color = 5;</code>
     */
    private void clearColor() {
      
      color_ = getDefaultInstance().getColor();
    }
    /**
     * <code>string color = 5;</code>
     * @param value The bytes for color to set.
     */
    private void setColorBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      color_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.NodeUpdate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodeUpdate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeUpdate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodeUpdate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeUpdate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.NodeUpdate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeUpdate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodeUpdate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeUpdate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodeUpdate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.NodeUpdate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.NodeUpdate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.NodeUpdate prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.NodeUpdate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.NodeUpdate, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.NodeUpdate)
        co.anode.anodium.Rpc.NodeUpdateOrBuilder {
      // Construct using co.anode.anodium.Rpc.NodeUpdate.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>repeated string addresses = 1;</code>
       * @return A list containing the addresses.
       */
      @java.lang.Override
      public java.util.List<java.lang.String>
          getAddressesList() {
        return java.util.Collections.unmodifiableList(
            instance.getAddressesList());
      }
      /**
       * <code>repeated string addresses = 1;</code>
       * @return The count of addresses.
       */
      @java.lang.Override
      public int getAddressesCount() {
        return instance.getAddressesCount();
      }
      /**
       * <code>repeated string addresses = 1;</code>
       * @param index The index of the element to return.
       * @return The addresses at the given index.
       */
      @java.lang.Override
      public java.lang.String getAddresses(int index) {
        return instance.getAddresses(index);
      }
      /**
       * <code>repeated string addresses = 1;</code>
       * @param index The index of the value to return.
       * @return The bytes of the addresses at the given index.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getAddressesBytes(int index) {
        return instance.getAddressesBytes(index);
      }
      /**
       * <code>repeated string addresses = 1;</code>
       * @param index The index to set the value at.
       * @param value The addresses to set.
       * @return This builder for chaining.
       */
      public Builder setAddresses(
          int index, java.lang.String value) {
        copyOnWrite();
        instance.setAddresses(index, value);
        return this;
      }
      /**
       * <code>repeated string addresses = 1;</code>
       * @param value The addresses to add.
       * @return This builder for chaining.
       */
      public Builder addAddresses(
          java.lang.String value) {
        copyOnWrite();
        instance.addAddresses(value);
        return this;
      }
      /**
       * <code>repeated string addresses = 1;</code>
       * @param values The addresses to add.
       * @return This builder for chaining.
       */
      public Builder addAllAddresses(
          java.lang.Iterable<java.lang.String> values) {
        copyOnWrite();
        instance.addAllAddresses(values);
        return this;
      }
      /**
       * <code>repeated string addresses = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAddresses() {
        copyOnWrite();
        instance.clearAddresses();
        return this;
      }
      /**
       * <code>repeated string addresses = 1;</code>
       * @param value The bytes of the addresses to add.
       * @return This builder for chaining.
       */
      public Builder addAddressesBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addAddressesBytes(value);
        return this;
      }

      /**
       * <code>string identity_key = 2;</code>
       * @return The identityKey.
       */
      @java.lang.Override
      public java.lang.String getIdentityKey() {
        return instance.getIdentityKey();
      }
      /**
       * <code>string identity_key = 2;</code>
       * @return The bytes for identityKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getIdentityKeyBytes() {
        return instance.getIdentityKeyBytes();
      }
      /**
       * <code>string identity_key = 2;</code>
       * @param value The identityKey to set.
       * @return This builder for chaining.
       */
      public Builder setIdentityKey(
          java.lang.String value) {
        copyOnWrite();
        instance.setIdentityKey(value);
        return this;
      }
      /**
       * <code>string identity_key = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearIdentityKey() {
        copyOnWrite();
        instance.clearIdentityKey();
        return this;
      }
      /**
       * <code>string identity_key = 2;</code>
       * @param value The bytes for identityKey to set.
       * @return This builder for chaining.
       */
      public Builder setIdentityKeyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setIdentityKeyBytes(value);
        return this;
      }

      /**
       * <code>bytes global_features = 3;</code>
       * @return The globalFeatures.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getGlobalFeatures() {
        return instance.getGlobalFeatures();
      }
      /**
       * <code>bytes global_features = 3;</code>
       * @param value The globalFeatures to set.
       * @return This builder for chaining.
       */
      public Builder setGlobalFeatures(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setGlobalFeatures(value);
        return this;
      }
      /**
       * <code>bytes global_features = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearGlobalFeatures() {
        copyOnWrite();
        instance.clearGlobalFeatures();
        return this;
      }

      /**
       * <code>string alias = 4;</code>
       * @return The alias.
       */
      @java.lang.Override
      public java.lang.String getAlias() {
        return instance.getAlias();
      }
      /**
       * <code>string alias = 4;</code>
       * @return The bytes for alias.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getAliasBytes() {
        return instance.getAliasBytes();
      }
      /**
       * <code>string alias = 4;</code>
       * @param value The alias to set.
       * @return This builder for chaining.
       */
      public Builder setAlias(
          java.lang.String value) {
        copyOnWrite();
        instance.setAlias(value);
        return this;
      }
      /**
       * <code>string alias = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearAlias() {
        copyOnWrite();
        instance.clearAlias();
        return this;
      }
      /**
       * <code>string alias = 4;</code>
       * @param value The bytes for alias to set.
       * @return This builder for chaining.
       */
      public Builder setAliasBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setAliasBytes(value);
        return this;
      }

      /**
       * <code>string color = 5;</code>
       * @return The color.
       */
      @java.lang.Override
      public java.lang.String getColor() {
        return instance.getColor();
      }
      /**
       * <code>string color = 5;</code>
       * @return The bytes for color.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getColorBytes() {
        return instance.getColorBytes();
      }
      /**
       * <code>string color = 5;</code>
       * @param value The color to set.
       * @return This builder for chaining.
       */
      public Builder setColor(
          java.lang.String value) {
        copyOnWrite();
        instance.setColor(value);
        return this;
      }
      /**
       * <code>string color = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearColor() {
        copyOnWrite();
        instance.clearColor();
        return this;
      }
      /**
       * <code>string color = 5;</code>
       * @param value The bytes for color to set.
       * @return This builder for chaining.
       */
      public Builder setColorBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setColorBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.NodeUpdate)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.NodeUpdate();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "addresses_",
              "identityKey_",
              "globalFeatures_",
              "alias_",
              "color_",
            };
            java.lang.String info =
                "\u0000\u0005\u0000\u0000\u0001\u0005\u0005\u0000\u0001\u0000\u0001\u021a\u0002\u0208" +
                "\u0003\n\u0004\u0208\u0005\u0208";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.NodeUpdate> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.NodeUpdate.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.NodeUpdate>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.NodeUpdate)
    private static final co.anode.anodium.Rpc.NodeUpdate DEFAULT_INSTANCE;
    static {
      NodeUpdate defaultInstance = new NodeUpdate();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        NodeUpdate.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.NodeUpdate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<NodeUpdate> PARSER;

    public static com.google.protobuf.Parser<NodeUpdate> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelEdgeUpdateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelEdgeUpdate)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    long getChanId();

    /**
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     * @return Whether the chanPoint field is set.
     */
    boolean hasChanPoint();
    /**
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     * @return The chanPoint.
     */
    co.anode.anodium.Rpc.ChannelPoint getChanPoint();

    /**
     * <code>int64 capacity = 3;</code>
     * @return The capacity.
     */
    long getCapacity();

    /**
     * <code>.co.anode.anodium.RoutingPolicy routing_policy = 4;</code>
     * @return Whether the routingPolicy field is set.
     */
    boolean hasRoutingPolicy();
    /**
     * <code>.co.anode.anodium.RoutingPolicy routing_policy = 4;</code>
     * @return The routingPolicy.
     */
    co.anode.anodium.Rpc.RoutingPolicy getRoutingPolicy();

    /**
     * <code>string advertising_node = 5;</code>
     * @return The advertisingNode.
     */
    java.lang.String getAdvertisingNode();
    /**
     * <code>string advertising_node = 5;</code>
     * @return The bytes for advertisingNode.
     */
    com.google.protobuf.ByteString
        getAdvertisingNodeBytes();

    /**
     * <code>string connecting_node = 6;</code>
     * @return The connectingNode.
     */
    java.lang.String getConnectingNode();
    /**
     * <code>string connecting_node = 6;</code>
     * @return The bytes for connectingNode.
     */
    com.google.protobuf.ByteString
        getConnectingNodeBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChannelEdgeUpdate}
   */
  public  static final class ChannelEdgeUpdate extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelEdgeUpdate, ChannelEdgeUpdate.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelEdgeUpdate)
      ChannelEdgeUpdateOrBuilder {
    private ChannelEdgeUpdate() {
      advertisingNode_ = "";
      connectingNode_ = "";
    }
    public static final int CHAN_ID_FIELD_NUMBER = 1;
    private long chanId_;
    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    @java.lang.Override
    public long getChanId() {
      return chanId_;
    }
    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     * @param value The chanId to set.
     */
    private void setChanId(long value) {
      
      chanId_ = value;
    }
    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     */
    private void clearChanId() {
      
      chanId_ = 0L;
    }

    public static final int CHAN_POINT_FIELD_NUMBER = 2;
    private co.anode.anodium.Rpc.ChannelPoint chanPoint_;
    /**
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     */
    @java.lang.Override
    public boolean hasChanPoint() {
      return chanPoint_ != null;
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelPoint getChanPoint() {
      return chanPoint_ == null ? co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance() : chanPoint_;
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     */
    private void setChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  chanPoint_ = value;
      
      }
    /**
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  if (chanPoint_ != null &&
          chanPoint_ != co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance()) {
        chanPoint_ =
          co.anode.anodium.Rpc.ChannelPoint.newBuilder(chanPoint_).mergeFrom(value).buildPartial();
      } else {
        chanPoint_ = value;
      }
      
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     */
    private void clearChanPoint() {  chanPoint_ = null;
      
    }

    public static final int CAPACITY_FIELD_NUMBER = 3;
    private long capacity_;
    /**
     * <code>int64 capacity = 3;</code>
     * @return The capacity.
     */
    @java.lang.Override
    public long getCapacity() {
      return capacity_;
    }
    /**
     * <code>int64 capacity = 3;</code>
     * @param value The capacity to set.
     */
    private void setCapacity(long value) {
      
      capacity_ = value;
    }
    /**
     * <code>int64 capacity = 3;</code>
     */
    private void clearCapacity() {
      
      capacity_ = 0L;
    }

    public static final int ROUTING_POLICY_FIELD_NUMBER = 4;
    private co.anode.anodium.Rpc.RoutingPolicy routingPolicy_;
    /**
     * <code>.co.anode.anodium.RoutingPolicy routing_policy = 4;</code>
     */
    @java.lang.Override
    public boolean hasRoutingPolicy() {
      return routingPolicy_ != null;
    }
    /**
     * <code>.co.anode.anodium.RoutingPolicy routing_policy = 4;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.RoutingPolicy getRoutingPolicy() {
      return routingPolicy_ == null ? co.anode.anodium.Rpc.RoutingPolicy.getDefaultInstance() : routingPolicy_;
    }
    /**
     * <code>.co.anode.anodium.RoutingPolicy routing_policy = 4;</code>
     */
    private void setRoutingPolicy(co.anode.anodium.Rpc.RoutingPolicy value) {
      value.getClass();
  routingPolicy_ = value;
      
      }
    /**
     * <code>.co.anode.anodium.RoutingPolicy routing_policy = 4;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeRoutingPolicy(co.anode.anodium.Rpc.RoutingPolicy value) {
      value.getClass();
  if (routingPolicy_ != null &&
          routingPolicy_ != co.anode.anodium.Rpc.RoutingPolicy.getDefaultInstance()) {
        routingPolicy_ =
          co.anode.anodium.Rpc.RoutingPolicy.newBuilder(routingPolicy_).mergeFrom(value).buildPartial();
      } else {
        routingPolicy_ = value;
      }
      
    }
    /**
     * <code>.co.anode.anodium.RoutingPolicy routing_policy = 4;</code>
     */
    private void clearRoutingPolicy() {  routingPolicy_ = null;
      
    }

    public static final int ADVERTISING_NODE_FIELD_NUMBER = 5;
    private java.lang.String advertisingNode_;
    /**
     * <code>string advertising_node = 5;</code>
     * @return The advertisingNode.
     */
    @java.lang.Override
    public java.lang.String getAdvertisingNode() {
      return advertisingNode_;
    }
    /**
     * <code>string advertising_node = 5;</code>
     * @return The bytes for advertisingNode.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAdvertisingNodeBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(advertisingNode_);
    }
    /**
     * <code>string advertising_node = 5;</code>
     * @param value The advertisingNode to set.
     */
    private void setAdvertisingNode(
        java.lang.String value) {
      value.getClass();
  
      advertisingNode_ = value;
    }
    /**
     * <code>string advertising_node = 5;</code>
     */
    private void clearAdvertisingNode() {
      
      advertisingNode_ = getDefaultInstance().getAdvertisingNode();
    }
    /**
     * <code>string advertising_node = 5;</code>
     * @param value The bytes for advertisingNode to set.
     */
    private void setAdvertisingNodeBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      advertisingNode_ = value.toStringUtf8();
      
    }

    public static final int CONNECTING_NODE_FIELD_NUMBER = 6;
    private java.lang.String connectingNode_;
    /**
     * <code>string connecting_node = 6;</code>
     * @return The connectingNode.
     */
    @java.lang.Override
    public java.lang.String getConnectingNode() {
      return connectingNode_;
    }
    /**
     * <code>string connecting_node = 6;</code>
     * @return The bytes for connectingNode.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getConnectingNodeBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(connectingNode_);
    }
    /**
     * <code>string connecting_node = 6;</code>
     * @param value The connectingNode to set.
     */
    private void setConnectingNode(
        java.lang.String value) {
      value.getClass();
  
      connectingNode_ = value;
    }
    /**
     * <code>string connecting_node = 6;</code>
     */
    private void clearConnectingNode() {
      
      connectingNode_ = getDefaultInstance().getConnectingNode();
    }
    /**
     * <code>string connecting_node = 6;</code>
     * @param value The bytes for connectingNode to set.
     */
    private void setConnectingNodeBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      connectingNode_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.ChannelEdgeUpdate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelEdgeUpdate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEdgeUpdate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelEdgeUpdate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEdgeUpdate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelEdgeUpdate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEdgeUpdate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelEdgeUpdate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEdgeUpdate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelEdgeUpdate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelEdgeUpdate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelEdgeUpdate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelEdgeUpdate prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChannelEdgeUpdate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelEdgeUpdate, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelEdgeUpdate)
        co.anode.anodium.Rpc.ChannelEdgeUpdateOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelEdgeUpdate.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The unique channel ID for the channel. The first 3 bytes are the block
       *height, the next 3 the index within the block, and the last 2 bytes are the
       *output index for the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
       * @return The chanId.
       */
      @java.lang.Override
      public long getChanId() {
        return instance.getChanId();
      }
      /**
       * <pre>
       *The unique channel ID for the channel. The first 3 bytes are the block
       *height, the next 3 the index within the block, and the last 2 bytes are the
       *output index for the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
       * @param value The chanId to set.
       * @return This builder for chaining.
       */
      public Builder setChanId(long value) {
        copyOnWrite();
        instance.setChanId(value);
        return this;
      }
      /**
       * <pre>
       *The unique channel ID for the channel. The first 3 bytes are the block
       *height, the next 3 the index within the block, and the last 2 bytes are the
       *output index for the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearChanId() {
        copyOnWrite();
        instance.clearChanId();
        return this;
      }

      /**
       * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
       */
      @java.lang.Override
      public boolean hasChanPoint() {
        return instance.hasChanPoint();
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelPoint getChanPoint() {
        return instance.getChanPoint();
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
       */
      public Builder setChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.setChanPoint(value);
        return this;
        }
      /**
       * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
       */
      public Builder setChanPoint(
          co.anode.anodium.Rpc.ChannelPoint.Builder builderForValue) {
        copyOnWrite();
        instance.setChanPoint(builderForValue.build());
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
       */
      public Builder mergeChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.mergeChanPoint(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
       */
      public Builder clearChanPoint() {  copyOnWrite();
        instance.clearChanPoint();
        return this;
      }

      /**
       * <code>int64 capacity = 3;</code>
       * @return The capacity.
       */
      @java.lang.Override
      public long getCapacity() {
        return instance.getCapacity();
      }
      /**
       * <code>int64 capacity = 3;</code>
       * @param value The capacity to set.
       * @return This builder for chaining.
       */
      public Builder setCapacity(long value) {
        copyOnWrite();
        instance.setCapacity(value);
        return this;
      }
      /**
       * <code>int64 capacity = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearCapacity() {
        copyOnWrite();
        instance.clearCapacity();
        return this;
      }

      /**
       * <code>.co.anode.anodium.RoutingPolicy routing_policy = 4;</code>
       */
      @java.lang.Override
      public boolean hasRoutingPolicy() {
        return instance.hasRoutingPolicy();
      }
      /**
       * <code>.co.anode.anodium.RoutingPolicy routing_policy = 4;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.RoutingPolicy getRoutingPolicy() {
        return instance.getRoutingPolicy();
      }
      /**
       * <code>.co.anode.anodium.RoutingPolicy routing_policy = 4;</code>
       */
      public Builder setRoutingPolicy(co.anode.anodium.Rpc.RoutingPolicy value) {
        copyOnWrite();
        instance.setRoutingPolicy(value);
        return this;
        }
      /**
       * <code>.co.anode.anodium.RoutingPolicy routing_policy = 4;</code>
       */
      public Builder setRoutingPolicy(
          co.anode.anodium.Rpc.RoutingPolicy.Builder builderForValue) {
        copyOnWrite();
        instance.setRoutingPolicy(builderForValue.build());
        return this;
      }
      /**
       * <code>.co.anode.anodium.RoutingPolicy routing_policy = 4;</code>
       */
      public Builder mergeRoutingPolicy(co.anode.anodium.Rpc.RoutingPolicy value) {
        copyOnWrite();
        instance.mergeRoutingPolicy(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.RoutingPolicy routing_policy = 4;</code>
       */
      public Builder clearRoutingPolicy() {  copyOnWrite();
        instance.clearRoutingPolicy();
        return this;
      }

      /**
       * <code>string advertising_node = 5;</code>
       * @return The advertisingNode.
       */
      @java.lang.Override
      public java.lang.String getAdvertisingNode() {
        return instance.getAdvertisingNode();
      }
      /**
       * <code>string advertising_node = 5;</code>
       * @return The bytes for advertisingNode.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getAdvertisingNodeBytes() {
        return instance.getAdvertisingNodeBytes();
      }
      /**
       * <code>string advertising_node = 5;</code>
       * @param value The advertisingNode to set.
       * @return This builder for chaining.
       */
      public Builder setAdvertisingNode(
          java.lang.String value) {
        copyOnWrite();
        instance.setAdvertisingNode(value);
        return this;
      }
      /**
       * <code>string advertising_node = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearAdvertisingNode() {
        copyOnWrite();
        instance.clearAdvertisingNode();
        return this;
      }
      /**
       * <code>string advertising_node = 5;</code>
       * @param value The bytes for advertisingNode to set.
       * @return This builder for chaining.
       */
      public Builder setAdvertisingNodeBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setAdvertisingNodeBytes(value);
        return this;
      }

      /**
       * <code>string connecting_node = 6;</code>
       * @return The connectingNode.
       */
      @java.lang.Override
      public java.lang.String getConnectingNode() {
        return instance.getConnectingNode();
      }
      /**
       * <code>string connecting_node = 6;</code>
       * @return The bytes for connectingNode.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getConnectingNodeBytes() {
        return instance.getConnectingNodeBytes();
      }
      /**
       * <code>string connecting_node = 6;</code>
       * @param value The connectingNode to set.
       * @return This builder for chaining.
       */
      public Builder setConnectingNode(
          java.lang.String value) {
        copyOnWrite();
        instance.setConnectingNode(value);
        return this;
      }
      /**
       * <code>string connecting_node = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearConnectingNode() {
        copyOnWrite();
        instance.clearConnectingNode();
        return this;
      }
      /**
       * <code>string connecting_node = 6;</code>
       * @param value The bytes for connectingNode to set.
       * @return This builder for chaining.
       */
      public Builder setConnectingNodeBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setConnectingNodeBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelEdgeUpdate)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelEdgeUpdate();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "chanId_",
              "chanPoint_",
              "capacity_",
              "routingPolicy_",
              "advertisingNode_",
              "connectingNode_",
            };
            java.lang.String info =
                "\u0000\u0006\u0000\u0000\u0001\u0006\u0006\u0000\u0000\u0000\u0001\u0003\u0002\t" +
                "\u0003\u0002\u0004\t\u0005\u0208\u0006\u0208";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelEdgeUpdate> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelEdgeUpdate.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelEdgeUpdate>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelEdgeUpdate)
    private static final co.anode.anodium.Rpc.ChannelEdgeUpdate DEFAULT_INSTANCE;
    static {
      ChannelEdgeUpdate defaultInstance = new ChannelEdgeUpdate();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelEdgeUpdate.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelEdgeUpdate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelEdgeUpdate> PARSER;

    public static com.google.protobuf.Parser<ChannelEdgeUpdate> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ClosedChannelUpdateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ClosedChannelUpdate)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    long getChanId();

    /**
     * <code>int64 capacity = 2;</code>
     * @return The capacity.
     */
    long getCapacity();

    /**
     * <code>uint32 closed_height = 3;</code>
     * @return The closedHeight.
     */
    int getClosedHeight();

    /**
     * <code>.co.anode.anodium.ChannelPoint chan_point = 4;</code>
     * @return Whether the chanPoint field is set.
     */
    boolean hasChanPoint();
    /**
     * <code>.co.anode.anodium.ChannelPoint chan_point = 4;</code>
     * @return The chanPoint.
     */
    co.anode.anodium.Rpc.ChannelPoint getChanPoint();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ClosedChannelUpdate}
   */
  public  static final class ClosedChannelUpdate extends
      com.google.protobuf.GeneratedMessageLite<
          ClosedChannelUpdate, ClosedChannelUpdate.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ClosedChannelUpdate)
      ClosedChannelUpdateOrBuilder {
    private ClosedChannelUpdate() {
    }
    public static final int CHAN_ID_FIELD_NUMBER = 1;
    private long chanId_;
    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    @java.lang.Override
    public long getChanId() {
      return chanId_;
    }
    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     * @param value The chanId to set.
     */
    private void setChanId(long value) {
      
      chanId_ = value;
    }
    /**
     * <pre>
     *The unique channel ID for the channel. The first 3 bytes are the block
     *height, the next 3 the index within the block, and the last 2 bytes are the
     *output index for the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     */
    private void clearChanId() {
      
      chanId_ = 0L;
    }

    public static final int CAPACITY_FIELD_NUMBER = 2;
    private long capacity_;
    /**
     * <code>int64 capacity = 2;</code>
     * @return The capacity.
     */
    @java.lang.Override
    public long getCapacity() {
      return capacity_;
    }
    /**
     * <code>int64 capacity = 2;</code>
     * @param value The capacity to set.
     */
    private void setCapacity(long value) {
      
      capacity_ = value;
    }
    /**
     * <code>int64 capacity = 2;</code>
     */
    private void clearCapacity() {
      
      capacity_ = 0L;
    }

    public static final int CLOSED_HEIGHT_FIELD_NUMBER = 3;
    private int closedHeight_;
    /**
     * <code>uint32 closed_height = 3;</code>
     * @return The closedHeight.
     */
    @java.lang.Override
    public int getClosedHeight() {
      return closedHeight_;
    }
    /**
     * <code>uint32 closed_height = 3;</code>
     * @param value The closedHeight to set.
     */
    private void setClosedHeight(int value) {
      
      closedHeight_ = value;
    }
    /**
     * <code>uint32 closed_height = 3;</code>
     */
    private void clearClosedHeight() {
      
      closedHeight_ = 0;
    }

    public static final int CHAN_POINT_FIELD_NUMBER = 4;
    private co.anode.anodium.Rpc.ChannelPoint chanPoint_;
    /**
     * <code>.co.anode.anodium.ChannelPoint chan_point = 4;</code>
     */
    @java.lang.Override
    public boolean hasChanPoint() {
      return chanPoint_ != null;
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint chan_point = 4;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelPoint getChanPoint() {
      return chanPoint_ == null ? co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance() : chanPoint_;
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint chan_point = 4;</code>
     */
    private void setChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  chanPoint_ = value;
      
      }
    /**
     * <code>.co.anode.anodium.ChannelPoint chan_point = 4;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  if (chanPoint_ != null &&
          chanPoint_ != co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance()) {
        chanPoint_ =
          co.anode.anodium.Rpc.ChannelPoint.newBuilder(chanPoint_).mergeFrom(value).buildPartial();
      } else {
        chanPoint_ = value;
      }
      
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint chan_point = 4;</code>
     */
    private void clearChanPoint() {  chanPoint_ = null;
      
    }

    public static co.anode.anodium.Rpc.ClosedChannelUpdate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ClosedChannelUpdate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ClosedChannelUpdate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ClosedChannelUpdate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ClosedChannelUpdate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ClosedChannelUpdate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ClosedChannelUpdate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ClosedChannelUpdate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ClosedChannelUpdate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ClosedChannelUpdate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ClosedChannelUpdate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ClosedChannelUpdate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ClosedChannelUpdate prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ClosedChannelUpdate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ClosedChannelUpdate, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ClosedChannelUpdate)
        co.anode.anodium.Rpc.ClosedChannelUpdateOrBuilder {
      // Construct using co.anode.anodium.Rpc.ClosedChannelUpdate.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The unique channel ID for the channel. The first 3 bytes are the block
       *height, the next 3 the index within the block, and the last 2 bytes are the
       *output index for the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
       * @return The chanId.
       */
      @java.lang.Override
      public long getChanId() {
        return instance.getChanId();
      }
      /**
       * <pre>
       *The unique channel ID for the channel. The first 3 bytes are the block
       *height, the next 3 the index within the block, and the last 2 bytes are the
       *output index for the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
       * @param value The chanId to set.
       * @return This builder for chaining.
       */
      public Builder setChanId(long value) {
        copyOnWrite();
        instance.setChanId(value);
        return this;
      }
      /**
       * <pre>
       *The unique channel ID for the channel. The first 3 bytes are the block
       *height, the next 3 the index within the block, and the last 2 bytes are the
       *output index for the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearChanId() {
        copyOnWrite();
        instance.clearChanId();
        return this;
      }

      /**
       * <code>int64 capacity = 2;</code>
       * @return The capacity.
       */
      @java.lang.Override
      public long getCapacity() {
        return instance.getCapacity();
      }
      /**
       * <code>int64 capacity = 2;</code>
       * @param value The capacity to set.
       * @return This builder for chaining.
       */
      public Builder setCapacity(long value) {
        copyOnWrite();
        instance.setCapacity(value);
        return this;
      }
      /**
       * <code>int64 capacity = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearCapacity() {
        copyOnWrite();
        instance.clearCapacity();
        return this;
      }

      /**
       * <code>uint32 closed_height = 3;</code>
       * @return The closedHeight.
       */
      @java.lang.Override
      public int getClosedHeight() {
        return instance.getClosedHeight();
      }
      /**
       * <code>uint32 closed_height = 3;</code>
       * @param value The closedHeight to set.
       * @return This builder for chaining.
       */
      public Builder setClosedHeight(int value) {
        copyOnWrite();
        instance.setClosedHeight(value);
        return this;
      }
      /**
       * <code>uint32 closed_height = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearClosedHeight() {
        copyOnWrite();
        instance.clearClosedHeight();
        return this;
      }

      /**
       * <code>.co.anode.anodium.ChannelPoint chan_point = 4;</code>
       */
      @java.lang.Override
      public boolean hasChanPoint() {
        return instance.hasChanPoint();
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint chan_point = 4;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelPoint getChanPoint() {
        return instance.getChanPoint();
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint chan_point = 4;</code>
       */
      public Builder setChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.setChanPoint(value);
        return this;
        }
      /**
       * <code>.co.anode.anodium.ChannelPoint chan_point = 4;</code>
       */
      public Builder setChanPoint(
          co.anode.anodium.Rpc.ChannelPoint.Builder builderForValue) {
        copyOnWrite();
        instance.setChanPoint(builderForValue.build());
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint chan_point = 4;</code>
       */
      public Builder mergeChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.mergeChanPoint(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint chan_point = 4;</code>
       */
      public Builder clearChanPoint() {  copyOnWrite();
        instance.clearChanPoint();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ClosedChannelUpdate)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ClosedChannelUpdate();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "chanId_",
              "capacity_",
              "closedHeight_",
              "chanPoint_",
            };
            java.lang.String info =
                "\u0000\u0004\u0000\u0000\u0001\u0004\u0004\u0000\u0000\u0000\u0001\u0003\u0002\u0002" +
                "\u0003\u000b\u0004\t";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ClosedChannelUpdate> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ClosedChannelUpdate.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ClosedChannelUpdate>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ClosedChannelUpdate)
    private static final co.anode.anodium.Rpc.ClosedChannelUpdate DEFAULT_INSTANCE;
    static {
      ClosedChannelUpdate defaultInstance = new ClosedChannelUpdate();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ClosedChannelUpdate.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ClosedChannelUpdate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ClosedChannelUpdate> PARSER;

    public static com.google.protobuf.Parser<ClosedChannelUpdate> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface HopHintOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.HopHint)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The public key of the node at the start of the channel.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     * @return The nodeId.
     */
    java.lang.String getNodeId();
    /**
     * <pre>
     * The public key of the node at the start of the channel.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     * @return The bytes for nodeId.
     */
    com.google.protobuf.ByteString
        getNodeIdBytes();

    /**
     * <pre>
     * The unique identifier of the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 2 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    long getChanId();

    /**
     * <pre>
     * The base fee of the channel denominated in millisatoshis.
     * </pre>
     *
     * <code>uint32 fee_base_msat = 3;</code>
     * @return The feeBaseMsat.
     */
    int getFeeBaseMsat();

    /**
     * <pre>
     *The fee rate of the channel for sending one satoshi across it denominated in
     *millionths of a satoshi.
     * </pre>
     *
     * <code>uint32 fee_proportional_millionths = 4;</code>
     * @return The feeProportionalMillionths.
     */
    int getFeeProportionalMillionths();

    /**
     * <pre>
     * The time-lock delta of the channel.
     * </pre>
     *
     * <code>uint32 cltv_expiry_delta = 5;</code>
     * @return The cltvExpiryDelta.
     */
    int getCltvExpiryDelta();
  }
  /**
   * Protobuf type {@code co.anode.anodium.HopHint}
   */
  public  static final class HopHint extends
      com.google.protobuf.GeneratedMessageLite<
          HopHint, HopHint.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.HopHint)
      HopHintOrBuilder {
    private HopHint() {
      nodeId_ = "";
    }
    public static final int NODE_ID_FIELD_NUMBER = 1;
    private java.lang.String nodeId_;
    /**
     * <pre>
     * The public key of the node at the start of the channel.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     * @return The nodeId.
     */
    @java.lang.Override
    public java.lang.String getNodeId() {
      return nodeId_;
    }
    /**
     * <pre>
     * The public key of the node at the start of the channel.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     * @return The bytes for nodeId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNodeIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(nodeId_);
    }
    /**
     * <pre>
     * The public key of the node at the start of the channel.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     * @param value The nodeId to set.
     */
    private void setNodeId(
        java.lang.String value) {
      value.getClass();
  
      nodeId_ = value;
    }
    /**
     * <pre>
     * The public key of the node at the start of the channel.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     */
    private void clearNodeId() {
      
      nodeId_ = getDefaultInstance().getNodeId();
    }
    /**
     * <pre>
     * The public key of the node at the start of the channel.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     * @param value The bytes for nodeId to set.
     */
    private void setNodeIdBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      nodeId_ = value.toStringUtf8();
      
    }

    public static final int CHAN_ID_FIELD_NUMBER = 2;
    private long chanId_;
    /**
     * <pre>
     * The unique identifier of the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 2 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    @java.lang.Override
    public long getChanId() {
      return chanId_;
    }
    /**
     * <pre>
     * The unique identifier of the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 2 [jstype = JS_STRING];</code>
     * @param value The chanId to set.
     */
    private void setChanId(long value) {
      
      chanId_ = value;
    }
    /**
     * <pre>
     * The unique identifier of the channel.
     * </pre>
     *
     * <code>uint64 chan_id = 2 [jstype = JS_STRING];</code>
     */
    private void clearChanId() {
      
      chanId_ = 0L;
    }

    public static final int FEE_BASE_MSAT_FIELD_NUMBER = 3;
    private int feeBaseMsat_;
    /**
     * <pre>
     * The base fee of the channel denominated in millisatoshis.
     * </pre>
     *
     * <code>uint32 fee_base_msat = 3;</code>
     * @return The feeBaseMsat.
     */
    @java.lang.Override
    public int getFeeBaseMsat() {
      return feeBaseMsat_;
    }
    /**
     * <pre>
     * The base fee of the channel denominated in millisatoshis.
     * </pre>
     *
     * <code>uint32 fee_base_msat = 3;</code>
     * @param value The feeBaseMsat to set.
     */
    private void setFeeBaseMsat(int value) {
      
      feeBaseMsat_ = value;
    }
    /**
     * <pre>
     * The base fee of the channel denominated in millisatoshis.
     * </pre>
     *
     * <code>uint32 fee_base_msat = 3;</code>
     */
    private void clearFeeBaseMsat() {
      
      feeBaseMsat_ = 0;
    }

    public static final int FEE_PROPORTIONAL_MILLIONTHS_FIELD_NUMBER = 4;
    private int feeProportionalMillionths_;
    /**
     * <pre>
     *The fee rate of the channel for sending one satoshi across it denominated in
     *millionths of a satoshi.
     * </pre>
     *
     * <code>uint32 fee_proportional_millionths = 4;</code>
     * @return The feeProportionalMillionths.
     */
    @java.lang.Override
    public int getFeeProportionalMillionths() {
      return feeProportionalMillionths_;
    }
    /**
     * <pre>
     *The fee rate of the channel for sending one satoshi across it denominated in
     *millionths of a satoshi.
     * </pre>
     *
     * <code>uint32 fee_proportional_millionths = 4;</code>
     * @param value The feeProportionalMillionths to set.
     */
    private void setFeeProportionalMillionths(int value) {
      
      feeProportionalMillionths_ = value;
    }
    /**
     * <pre>
     *The fee rate of the channel for sending one satoshi across it denominated in
     *millionths of a satoshi.
     * </pre>
     *
     * <code>uint32 fee_proportional_millionths = 4;</code>
     */
    private void clearFeeProportionalMillionths() {
      
      feeProportionalMillionths_ = 0;
    }

    public static final int CLTV_EXPIRY_DELTA_FIELD_NUMBER = 5;
    private int cltvExpiryDelta_;
    /**
     * <pre>
     * The time-lock delta of the channel.
     * </pre>
     *
     * <code>uint32 cltv_expiry_delta = 5;</code>
     * @return The cltvExpiryDelta.
     */
    @java.lang.Override
    public int getCltvExpiryDelta() {
      return cltvExpiryDelta_;
    }
    /**
     * <pre>
     * The time-lock delta of the channel.
     * </pre>
     *
     * <code>uint32 cltv_expiry_delta = 5;</code>
     * @param value The cltvExpiryDelta to set.
     */
    private void setCltvExpiryDelta(int value) {
      
      cltvExpiryDelta_ = value;
    }
    /**
     * <pre>
     * The time-lock delta of the channel.
     * </pre>
     *
     * <code>uint32 cltv_expiry_delta = 5;</code>
     */
    private void clearCltvExpiryDelta() {
      
      cltvExpiryDelta_ = 0;
    }

    public static co.anode.anodium.Rpc.HopHint parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.HopHint parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.HopHint parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.HopHint parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.HopHint parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.HopHint parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.HopHint parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.HopHint parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.HopHint parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.HopHint parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.HopHint parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.HopHint parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.HopHint prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.HopHint}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.HopHint, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.HopHint)
        co.anode.anodium.Rpc.HopHintOrBuilder {
      // Construct using co.anode.anodium.Rpc.HopHint.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The public key of the node at the start of the channel.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       * @return The nodeId.
       */
      @java.lang.Override
      public java.lang.String getNodeId() {
        return instance.getNodeId();
      }
      /**
       * <pre>
       * The public key of the node at the start of the channel.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       * @return The bytes for nodeId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNodeIdBytes() {
        return instance.getNodeIdBytes();
      }
      /**
       * <pre>
       * The public key of the node at the start of the channel.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       * @param value The nodeId to set.
       * @return This builder for chaining.
       */
      public Builder setNodeId(
          java.lang.String value) {
        copyOnWrite();
        instance.setNodeId(value);
        return this;
      }
      /**
       * <pre>
       * The public key of the node at the start of the channel.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearNodeId() {
        copyOnWrite();
        instance.clearNodeId();
        return this;
      }
      /**
       * <pre>
       * The public key of the node at the start of the channel.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       * @param value The bytes for nodeId to set.
       * @return This builder for chaining.
       */
      public Builder setNodeIdBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNodeIdBytes(value);
        return this;
      }

      /**
       * <pre>
       * The unique identifier of the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 2 [jstype = JS_STRING];</code>
       * @return The chanId.
       */
      @java.lang.Override
      public long getChanId() {
        return instance.getChanId();
      }
      /**
       * <pre>
       * The unique identifier of the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 2 [jstype = JS_STRING];</code>
       * @param value The chanId to set.
       * @return This builder for chaining.
       */
      public Builder setChanId(long value) {
        copyOnWrite();
        instance.setChanId(value);
        return this;
      }
      /**
       * <pre>
       * The unique identifier of the channel.
       * </pre>
       *
       * <code>uint64 chan_id = 2 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearChanId() {
        copyOnWrite();
        instance.clearChanId();
        return this;
      }

      /**
       * <pre>
       * The base fee of the channel denominated in millisatoshis.
       * </pre>
       *
       * <code>uint32 fee_base_msat = 3;</code>
       * @return The feeBaseMsat.
       */
      @java.lang.Override
      public int getFeeBaseMsat() {
        return instance.getFeeBaseMsat();
      }
      /**
       * <pre>
       * The base fee of the channel denominated in millisatoshis.
       * </pre>
       *
       * <code>uint32 fee_base_msat = 3;</code>
       * @param value The feeBaseMsat to set.
       * @return This builder for chaining.
       */
      public Builder setFeeBaseMsat(int value) {
        copyOnWrite();
        instance.setFeeBaseMsat(value);
        return this;
      }
      /**
       * <pre>
       * The base fee of the channel denominated in millisatoshis.
       * </pre>
       *
       * <code>uint32 fee_base_msat = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearFeeBaseMsat() {
        copyOnWrite();
        instance.clearFeeBaseMsat();
        return this;
      }

      /**
       * <pre>
       *The fee rate of the channel for sending one satoshi across it denominated in
       *millionths of a satoshi.
       * </pre>
       *
       * <code>uint32 fee_proportional_millionths = 4;</code>
       * @return The feeProportionalMillionths.
       */
      @java.lang.Override
      public int getFeeProportionalMillionths() {
        return instance.getFeeProportionalMillionths();
      }
      /**
       * <pre>
       *The fee rate of the channel for sending one satoshi across it denominated in
       *millionths of a satoshi.
       * </pre>
       *
       * <code>uint32 fee_proportional_millionths = 4;</code>
       * @param value The feeProportionalMillionths to set.
       * @return This builder for chaining.
       */
      public Builder setFeeProportionalMillionths(int value) {
        copyOnWrite();
        instance.setFeeProportionalMillionths(value);
        return this;
      }
      /**
       * <pre>
       *The fee rate of the channel for sending one satoshi across it denominated in
       *millionths of a satoshi.
       * </pre>
       *
       * <code>uint32 fee_proportional_millionths = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearFeeProportionalMillionths() {
        copyOnWrite();
        instance.clearFeeProportionalMillionths();
        return this;
      }

      /**
       * <pre>
       * The time-lock delta of the channel.
       * </pre>
       *
       * <code>uint32 cltv_expiry_delta = 5;</code>
       * @return The cltvExpiryDelta.
       */
      @java.lang.Override
      public int getCltvExpiryDelta() {
        return instance.getCltvExpiryDelta();
      }
      /**
       * <pre>
       * The time-lock delta of the channel.
       * </pre>
       *
       * <code>uint32 cltv_expiry_delta = 5;</code>
       * @param value The cltvExpiryDelta to set.
       * @return This builder for chaining.
       */
      public Builder setCltvExpiryDelta(int value) {
        copyOnWrite();
        instance.setCltvExpiryDelta(value);
        return this;
      }
      /**
       * <pre>
       * The time-lock delta of the channel.
       * </pre>
       *
       * <code>uint32 cltv_expiry_delta = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearCltvExpiryDelta() {
        copyOnWrite();
        instance.clearCltvExpiryDelta();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.HopHint)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.HopHint();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "nodeId_",
              "chanId_",
              "feeBaseMsat_",
              "feeProportionalMillionths_",
              "cltvExpiryDelta_",
            };
            java.lang.String info =
                "\u0000\u0005\u0000\u0000\u0001\u0005\u0005\u0000\u0000\u0000\u0001\u0208\u0002\u0003" +
                "\u0003\u000b\u0004\u000b\u0005\u000b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.HopHint> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.HopHint.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.HopHint>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.HopHint)
    private static final co.anode.anodium.Rpc.HopHint DEFAULT_INSTANCE;
    static {
      HopHint defaultInstance = new HopHint();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        HopHint.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.HopHint getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<HopHint> PARSER;

    public static com.google.protobuf.Parser<HopHint> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface RouteHintOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.RouteHint)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *A list of hop hints that when chained together can assist in reaching a
     *specific destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
     */
    java.util.List<co.anode.anodium.Rpc.HopHint> 
        getHopHintsList();
    /**
     * <pre>
     *A list of hop hints that when chained together can assist in reaching a
     *specific destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
     */
    co.anode.anodium.Rpc.HopHint getHopHints(int index);
    /**
     * <pre>
     *A list of hop hints that when chained together can assist in reaching a
     *specific destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
     */
    int getHopHintsCount();
  }
  /**
   * Protobuf type {@code co.anode.anodium.RouteHint}
   */
  public  static final class RouteHint extends
      com.google.protobuf.GeneratedMessageLite<
          RouteHint, RouteHint.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.RouteHint)
      RouteHintOrBuilder {
    private RouteHint() {
      hopHints_ = emptyProtobufList();
    }
    public static final int HOP_HINTS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.HopHint> hopHints_;
    /**
     * <pre>
     *A list of hop hints that when chained together can assist in reaching a
     *specific destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.HopHint> getHopHintsList() {
      return hopHints_;
    }
    /**
     * <pre>
     *A list of hop hints that when chained together can assist in reaching a
     *specific destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.HopHintOrBuilder> 
        getHopHintsOrBuilderList() {
      return hopHints_;
    }
    /**
     * <pre>
     *A list of hop hints that when chained together can assist in reaching a
     *specific destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
     */
    @java.lang.Override
    public int getHopHintsCount() {
      return hopHints_.size();
    }
    /**
     * <pre>
     *A list of hop hints that when chained together can assist in reaching a
     *specific destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.HopHint getHopHints(int index) {
      return hopHints_.get(index);
    }
    /**
     * <pre>
     *A list of hop hints that when chained together can assist in reaching a
     *specific destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
     */
    public co.anode.anodium.Rpc.HopHintOrBuilder getHopHintsOrBuilder(
        int index) {
      return hopHints_.get(index);
    }
    private void ensureHopHintsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.HopHint> tmp = hopHints_;
      if (!tmp.isModifiable()) {
        hopHints_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     *A list of hop hints that when chained together can assist in reaching a
     *specific destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
     */
    private void setHopHints(
        int index, co.anode.anodium.Rpc.HopHint value) {
      value.getClass();
  ensureHopHintsIsMutable();
      hopHints_.set(index, value);
    }
    /**
     * <pre>
     *A list of hop hints that when chained together can assist in reaching a
     *specific destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
     */
    private void addHopHints(co.anode.anodium.Rpc.HopHint value) {
      value.getClass();
  ensureHopHintsIsMutable();
      hopHints_.add(value);
    }
    /**
     * <pre>
     *A list of hop hints that when chained together can assist in reaching a
     *specific destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
     */
    private void addHopHints(
        int index, co.anode.anodium.Rpc.HopHint value) {
      value.getClass();
  ensureHopHintsIsMutable();
      hopHints_.add(index, value);
    }
    /**
     * <pre>
     *A list of hop hints that when chained together can assist in reaching a
     *specific destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
     */
    private void addAllHopHints(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.HopHint> values) {
      ensureHopHintsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, hopHints_);
    }
    /**
     * <pre>
     *A list of hop hints that when chained together can assist in reaching a
     *specific destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
     */
    private void clearHopHints() {
      hopHints_ = emptyProtobufList();
    }
    /**
     * <pre>
     *A list of hop hints that when chained together can assist in reaching a
     *specific destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
     */
    private void removeHopHints(int index) {
      ensureHopHintsIsMutable();
      hopHints_.remove(index);
    }

    public static co.anode.anodium.Rpc.RouteHint parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.RouteHint parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RouteHint parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.RouteHint parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RouteHint parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.RouteHint parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RouteHint parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.RouteHint parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RouteHint parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.RouteHint parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RouteHint parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.RouteHint parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.RouteHint prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.RouteHint}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.RouteHint, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.RouteHint)
        co.anode.anodium.Rpc.RouteHintOrBuilder {
      // Construct using co.anode.anodium.Rpc.RouteHint.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *A list of hop hints that when chained together can assist in reaching a
       *specific destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.HopHint> getHopHintsList() {
        return java.util.Collections.unmodifiableList(
            instance.getHopHintsList());
      }
      /**
       * <pre>
       *A list of hop hints that when chained together can assist in reaching a
       *specific destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
       */
      @java.lang.Override
      public int getHopHintsCount() {
        return instance.getHopHintsCount();
      }/**
       * <pre>
       *A list of hop hints that when chained together can assist in reaching a
       *specific destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.HopHint getHopHints(int index) {
        return instance.getHopHints(index);
      }
      /**
       * <pre>
       *A list of hop hints that when chained together can assist in reaching a
       *specific destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
       */
      public Builder setHopHints(
          int index, co.anode.anodium.Rpc.HopHint value) {
        copyOnWrite();
        instance.setHopHints(index, value);
        return this;
      }
      /**
       * <pre>
       *A list of hop hints that when chained together can assist in reaching a
       *specific destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
       */
      public Builder setHopHints(
          int index, co.anode.anodium.Rpc.HopHint.Builder builderForValue) {
        copyOnWrite();
        instance.setHopHints(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *A list of hop hints that when chained together can assist in reaching a
       *specific destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
       */
      public Builder addHopHints(co.anode.anodium.Rpc.HopHint value) {
        copyOnWrite();
        instance.addHopHints(value);
        return this;
      }
      /**
       * <pre>
       *A list of hop hints that when chained together can assist in reaching a
       *specific destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
       */
      public Builder addHopHints(
          int index, co.anode.anodium.Rpc.HopHint value) {
        copyOnWrite();
        instance.addHopHints(index, value);
        return this;
      }
      /**
       * <pre>
       *A list of hop hints that when chained together can assist in reaching a
       *specific destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
       */
      public Builder addHopHints(
          co.anode.anodium.Rpc.HopHint.Builder builderForValue) {
        copyOnWrite();
        instance.addHopHints(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *A list of hop hints that when chained together can assist in reaching a
       *specific destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
       */
      public Builder addHopHints(
          int index, co.anode.anodium.Rpc.HopHint.Builder builderForValue) {
        copyOnWrite();
        instance.addHopHints(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *A list of hop hints that when chained together can assist in reaching a
       *specific destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
       */
      public Builder addAllHopHints(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.HopHint> values) {
        copyOnWrite();
        instance.addAllHopHints(values);
        return this;
      }
      /**
       * <pre>
       *A list of hop hints that when chained together can assist in reaching a
       *specific destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
       */
      public Builder clearHopHints() {
        copyOnWrite();
        instance.clearHopHints();
        return this;
      }
      /**
       * <pre>
       *A list of hop hints that when chained together can assist in reaching a
       *specific destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HopHint hop_hints = 1;</code>
       */
      public Builder removeHopHints(int index) {
        copyOnWrite();
        instance.removeHopHints(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.RouteHint)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.RouteHint();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "hopHints_",
              co.anode.anodium.Rpc.HopHint.class,
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0000\u0001\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.RouteHint> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.RouteHint.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.RouteHint>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.RouteHint)
    private static final co.anode.anodium.Rpc.RouteHint DEFAULT_INSTANCE;
    static {
      RouteHint defaultInstance = new RouteHint();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        RouteHint.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.RouteHint getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<RouteHint> PARSER;

    public static com.google.protobuf.Parser<RouteHint> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface InvoiceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.Invoice)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *An optional memo to attach along with the invoice. Used for record keeping
     *purposes for the invoice's creator, and will also be set in the description
     *field of the encoded payment request if the description_hash field is not
     *being used.
     * </pre>
     *
     * <code>string memo = 1;</code>
     * @return The memo.
     */
    java.lang.String getMemo();
    /**
     * <pre>
     *An optional memo to attach along with the invoice. Used for record keeping
     *purposes for the invoice's creator, and will also be set in the description
     *field of the encoded payment request if the description_hash field is not
     *being used.
     * </pre>
     *
     * <code>string memo = 1;</code>
     * @return The bytes for memo.
     */
    com.google.protobuf.ByteString
        getMemoBytes();

    /**
     * <pre>
     *The hex-encoded preimage (32 byte) which will allow settling an incoming
     *HTLC payable to this preimage. When using REST, this field must be encoded
     *as base64.
     * </pre>
     *
     * <code>bytes r_preimage = 3;</code>
     * @return The rPreimage.
     */
    com.google.protobuf.ByteString getRPreimage();

    /**
     * <pre>
     *The hash of the preimage. When using REST, this field must be encoded as
     *base64.
     * </pre>
     *
     * <code>bytes r_hash = 4;</code>
     * @return The rHash.
     */
    com.google.protobuf.ByteString getRHash();

    /**
     * <pre>
     *The value of this invoice in satoshis
     *The fields value and value_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 value = 5;</code>
     * @return The value.
     */
    long getValue();

    /**
     * <pre>
     *The value of this invoice in millisatoshis
     *The fields value and value_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 value_msat = 23;</code>
     * @return The valueMsat.
     */
    long getValueMsat();

    /**
     * <pre>
     * Whether this invoice has been fulfilled
     * </pre>
     *
     * <code>bool settled = 6 [deprecated = true];</code>
     * @return The settled.
     */
    @java.lang.Deprecated boolean getSettled();

    /**
     * <pre>
     * When this invoice was created
     * </pre>
     *
     * <code>int64 creation_date = 7;</code>
     * @return The creationDate.
     */
    long getCreationDate();

    /**
     * <pre>
     * When this invoice was settled
     * </pre>
     *
     * <code>int64 settle_date = 8;</code>
     * @return The settleDate.
     */
    long getSettleDate();

    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 9;</code>
     * @return The paymentRequest.
     */
    java.lang.String getPaymentRequest();
    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 9;</code>
     * @return The bytes for paymentRequest.
     */
    com.google.protobuf.ByteString
        getPaymentRequestBytes();

    /**
     * <pre>
     *Hash (SHA-256) of a description of the payment. Used if the description of
     *payment (memo) is too long to naturally fit within the description field
     *of an encoded payment request. When using REST, this field must be encoded
     *as base64.
     * </pre>
     *
     * <code>bytes description_hash = 10;</code>
     * @return The descriptionHash.
     */
    com.google.protobuf.ByteString getDescriptionHash();

    /**
     * <pre>
     * Payment request expiry time in seconds. Default is 3600 (1 hour).
     * </pre>
     *
     * <code>int64 expiry = 11;</code>
     * @return The expiry.
     */
    long getExpiry();

    /**
     * <pre>
     * Fallback on-chain address.
     * </pre>
     *
     * <code>string fallback_addr = 12;</code>
     * @return The fallbackAddr.
     */
    java.lang.String getFallbackAddr();
    /**
     * <pre>
     * Fallback on-chain address.
     * </pre>
     *
     * <code>string fallback_addr = 12;</code>
     * @return The bytes for fallbackAddr.
     */
    com.google.protobuf.ByteString
        getFallbackAddrBytes();

    /**
     * <pre>
     * Delta to use for the time-lock of the CLTV extended to the final hop.
     * </pre>
     *
     * <code>uint64 cltv_expiry = 13;</code>
     * @return The cltvExpiry.
     */
    long getCltvExpiry();

    /**
     * <pre>
     *Route hints that can each be individually used to assist in reaching the
     *invoice's destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
     */
    java.util.List<co.anode.anodium.Rpc.RouteHint> 
        getRouteHintsList();
    /**
     * <pre>
     *Route hints that can each be individually used to assist in reaching the
     *invoice's destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
     */
    co.anode.anodium.Rpc.RouteHint getRouteHints(int index);
    /**
     * <pre>
     *Route hints that can each be individually used to assist in reaching the
     *invoice's destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
     */
    int getRouteHintsCount();

    /**
     * <pre>
     * Whether this invoice should include routing hints for private channels.
     * </pre>
     *
     * <code>bool private = 15;</code>
     * @return The private.
     */
    boolean getPrivate();

    /**
     * <pre>
     *The "add" index of this invoice. Each newly created invoice will increment
     *this index making it monotonically increasing. Callers to the
     *SubscribeInvoices call can use this to instantly get notified of all added
     *invoices with an add_index greater than this one.
     * </pre>
     *
     * <code>uint64 add_index = 16;</code>
     * @return The addIndex.
     */
    long getAddIndex();

    /**
     * <pre>
     *The "settle" index of this invoice. Each newly settled invoice will
     *increment this index making it monotonically increasing. Callers to the
     *SubscribeInvoices call can use this to instantly get notified of all
     *settled invoices with an settle_index greater than this one.
     * </pre>
     *
     * <code>uint64 settle_index = 17;</code>
     * @return The settleIndex.
     */
    long getSettleIndex();

    /**
     * <pre>
     * Deprecated, use amt_paid_sat or amt_paid_msat.
     * </pre>
     *
     * <code>int64 amt_paid = 18 [deprecated = true];</code>
     * @return The amtPaid.
     */
    @java.lang.Deprecated long getAmtPaid();

    /**
     * <pre>
     *The amount that was accepted for this invoice, in satoshis. This will ONLY
     *be set if this invoice has been settled. We provide this field as if the
     *invoice was created with a zero value, then we need to record what amount
     *was ultimately accepted. Additionally, it's possible that the sender paid
     *MORE that was specified in the original invoice. So we'll record that here
     *as well.
     * </pre>
     *
     * <code>int64 amt_paid_sat = 19;</code>
     * @return The amtPaidSat.
     */
    long getAmtPaidSat();

    /**
     * <pre>
     *The amount that was accepted for this invoice, in millisatoshis. This will
     *ONLY be set if this invoice has been settled. We provide this field as if
     *the invoice was created with a zero value, then we need to record what
     *amount was ultimately accepted. Additionally, it's possible that the sender
     *paid MORE that was specified in the original invoice. So we'll record that
     *here as well.
     * </pre>
     *
     * <code>int64 amt_paid_msat = 20;</code>
     * @return The amtPaidMsat.
     */
    long getAmtPaidMsat();

    /**
     * <pre>
     *The state the invoice is in.
     * </pre>
     *
     * <code>.co.anode.anodium.Invoice.InvoiceState state = 21;</code>
     * @return The enum numeric value on the wire for state.
     */
    int getStateValue();
    /**
     * <pre>
     *The state the invoice is in.
     * </pre>
     *
     * <code>.co.anode.anodium.Invoice.InvoiceState state = 21;</code>
     * @return The state.
     */
    co.anode.anodium.Rpc.Invoice.InvoiceState getState();

    /**
     * <pre>
     * List of HTLCs paying to this invoice [EXPERIMENTAL].
     * </pre>
     *
     * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
     */
    java.util.List<co.anode.anodium.Rpc.InvoiceHTLC> 
        getHtlcsList();
    /**
     * <pre>
     * List of HTLCs paying to this invoice [EXPERIMENTAL].
     * </pre>
     *
     * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
     */
    co.anode.anodium.Rpc.InvoiceHTLC getHtlcs(int index);
    /**
     * <pre>
     * List of HTLCs paying to this invoice [EXPERIMENTAL].
     * </pre>
     *
     * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
     */
    int getHtlcsCount();

    /**
     * <pre>
     * List of features advertised on the invoice.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 24;</code>
     */
    int getFeaturesCount();
    /**
     * <pre>
     * List of features advertised on the invoice.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 24;</code>
     */
    boolean containsFeatures(
        int key);
    /**
     * Use {@link #getFeaturesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    getFeatures();
    /**
     * <pre>
     * List of features advertised on the invoice.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 24;</code>
     */
    java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    getFeaturesMap();
    /**
     * <pre>
     * List of features advertised on the invoice.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 24;</code>
     */

    co.anode.anodium.Rpc.Feature getFeaturesOrDefault(
        int key,
        co.anode.anodium.Rpc.Feature defaultValue);
    /**
     * <pre>
     * List of features advertised on the invoice.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 24;</code>
     */

    co.anode.anodium.Rpc.Feature getFeaturesOrThrow(
        int key);

    /**
     * <pre>
     *Indicates if this invoice was a spontaneous payment that arrived via keysend
     *[EXPERIMENTAL].
     * </pre>
     *
     * <code>bool is_keysend = 25;</code>
     * @return The isKeysend.
     */
    boolean getIsKeysend();
  }
  /**
   * Protobuf type {@code co.anode.anodium.Invoice}
   */
  public  static final class Invoice extends
      com.google.protobuf.GeneratedMessageLite<
          Invoice, Invoice.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.Invoice)
      InvoiceOrBuilder {
    private Invoice() {
      memo_ = "";
      rPreimage_ = com.google.protobuf.ByteString.EMPTY;
      rHash_ = com.google.protobuf.ByteString.EMPTY;
      paymentRequest_ = "";
      descriptionHash_ = com.google.protobuf.ByteString.EMPTY;
      fallbackAddr_ = "";
      routeHints_ = emptyProtobufList();
      htlcs_ = emptyProtobufList();
    }
    /**
     * Protobuf enum {@code co.anode.anodium.Invoice.InvoiceState}
     */
    public enum InvoiceState
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>OPEN = 0;</code>
       */
      OPEN(0),
      /**
       * <code>SETTLED = 1;</code>
       */
      SETTLED(1),
      /**
       * <code>CANCELED = 2;</code>
       */
      CANCELED(2),
      /**
       * <code>ACCEPTED = 3;</code>
       */
      ACCEPTED(3),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>OPEN = 0;</code>
       */
      public static final int OPEN_VALUE = 0;
      /**
       * <code>SETTLED = 1;</code>
       */
      public static final int SETTLED_VALUE = 1;
      /**
       * <code>CANCELED = 2;</code>
       */
      public static final int CANCELED_VALUE = 2;
      /**
       * <code>ACCEPTED = 3;</code>
       */
      public static final int ACCEPTED_VALUE = 3;


      @java.lang.Override
      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static InvoiceState valueOf(int value) {
        return forNumber(value);
      }

      public static InvoiceState forNumber(int value) {
        switch (value) {
          case 0: return OPEN;
          case 1: return SETTLED;
          case 2: return CANCELED;
          case 3: return ACCEPTED;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<InvoiceState>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          InvoiceState> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<InvoiceState>() {
              @java.lang.Override
              public InvoiceState findValueByNumber(int number) {
                return InvoiceState.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return InvoiceStateVerifier.INSTANCE;
      }

      private static final class InvoiceStateVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new InvoiceStateVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return InvoiceState.forNumber(number) != null;
              }
            };

      private final int value;

      private InvoiceState(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:co.anode.anodium.Invoice.InvoiceState)
    }

    public static final int MEMO_FIELD_NUMBER = 1;
    private java.lang.String memo_;
    /**
     * <pre>
     *An optional memo to attach along with the invoice. Used for record keeping
     *purposes for the invoice's creator, and will also be set in the description
     *field of the encoded payment request if the description_hash field is not
     *being used.
     * </pre>
     *
     * <code>string memo = 1;</code>
     * @return The memo.
     */
    @java.lang.Override
    public java.lang.String getMemo() {
      return memo_;
    }
    /**
     * <pre>
     *An optional memo to attach along with the invoice. Used for record keeping
     *purposes for the invoice's creator, and will also be set in the description
     *field of the encoded payment request if the description_hash field is not
     *being used.
     * </pre>
     *
     * <code>string memo = 1;</code>
     * @return The bytes for memo.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMemoBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(memo_);
    }
    /**
     * <pre>
     *An optional memo to attach along with the invoice. Used for record keeping
     *purposes for the invoice's creator, and will also be set in the description
     *field of the encoded payment request if the description_hash field is not
     *being used.
     * </pre>
     *
     * <code>string memo = 1;</code>
     * @param value The memo to set.
     */
    private void setMemo(
        java.lang.String value) {
      value.getClass();
  
      memo_ = value;
    }
    /**
     * <pre>
     *An optional memo to attach along with the invoice. Used for record keeping
     *purposes for the invoice's creator, and will also be set in the description
     *field of the encoded payment request if the description_hash field is not
     *being used.
     * </pre>
     *
     * <code>string memo = 1;</code>
     */
    private void clearMemo() {
      
      memo_ = getDefaultInstance().getMemo();
    }
    /**
     * <pre>
     *An optional memo to attach along with the invoice. Used for record keeping
     *purposes for the invoice's creator, and will also be set in the description
     *field of the encoded payment request if the description_hash field is not
     *being used.
     * </pre>
     *
     * <code>string memo = 1;</code>
     * @param value The bytes for memo to set.
     */
    private void setMemoBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      memo_ = value.toStringUtf8();
      
    }

    public static final int R_PREIMAGE_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString rPreimage_;
    /**
     * <pre>
     *The hex-encoded preimage (32 byte) which will allow settling an incoming
     *HTLC payable to this preimage. When using REST, this field must be encoded
     *as base64.
     * </pre>
     *
     * <code>bytes r_preimage = 3;</code>
     * @return The rPreimage.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getRPreimage() {
      return rPreimage_;
    }
    /**
     * <pre>
     *The hex-encoded preimage (32 byte) which will allow settling an incoming
     *HTLC payable to this preimage. When using REST, this field must be encoded
     *as base64.
     * </pre>
     *
     * <code>bytes r_preimage = 3;</code>
     * @param value The rPreimage to set.
     */
    private void setRPreimage(com.google.protobuf.ByteString value) {
      value.getClass();
  
      rPreimage_ = value;
    }
    /**
     * <pre>
     *The hex-encoded preimage (32 byte) which will allow settling an incoming
     *HTLC payable to this preimage. When using REST, this field must be encoded
     *as base64.
     * </pre>
     *
     * <code>bytes r_preimage = 3;</code>
     */
    private void clearRPreimage() {
      
      rPreimage_ = getDefaultInstance().getRPreimage();
    }

    public static final int R_HASH_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString rHash_;
    /**
     * <pre>
     *The hash of the preimage. When using REST, this field must be encoded as
     *base64.
     * </pre>
     *
     * <code>bytes r_hash = 4;</code>
     * @return The rHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getRHash() {
      return rHash_;
    }
    /**
     * <pre>
     *The hash of the preimage. When using REST, this field must be encoded as
     *base64.
     * </pre>
     *
     * <code>bytes r_hash = 4;</code>
     * @param value The rHash to set.
     */
    private void setRHash(com.google.protobuf.ByteString value) {
      value.getClass();
  
      rHash_ = value;
    }
    /**
     * <pre>
     *The hash of the preimage. When using REST, this field must be encoded as
     *base64.
     * </pre>
     *
     * <code>bytes r_hash = 4;</code>
     */
    private void clearRHash() {
      
      rHash_ = getDefaultInstance().getRHash();
    }

    public static final int VALUE_FIELD_NUMBER = 5;
    private long value_;
    /**
     * <pre>
     *The value of this invoice in satoshis
     *The fields value and value_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 value = 5;</code>
     * @return The value.
     */
    @java.lang.Override
    public long getValue() {
      return value_;
    }
    /**
     * <pre>
     *The value of this invoice in satoshis
     *The fields value and value_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 value = 5;</code>
     * @param value The value to set.
     */
    private void setValue(long value) {
      
      value_ = value;
    }
    /**
     * <pre>
     *The value of this invoice in satoshis
     *The fields value and value_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 value = 5;</code>
     */
    private void clearValue() {
      
      value_ = 0L;
    }

    public static final int VALUE_MSAT_FIELD_NUMBER = 23;
    private long valueMsat_;
    /**
     * <pre>
     *The value of this invoice in millisatoshis
     *The fields value and value_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 value_msat = 23;</code>
     * @return The valueMsat.
     */
    @java.lang.Override
    public long getValueMsat() {
      return valueMsat_;
    }
    /**
     * <pre>
     *The value of this invoice in millisatoshis
     *The fields value and value_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 value_msat = 23;</code>
     * @param value The valueMsat to set.
     */
    private void setValueMsat(long value) {
      
      valueMsat_ = value;
    }
    /**
     * <pre>
     *The value of this invoice in millisatoshis
     *The fields value and value_msat are mutually exclusive.
     * </pre>
     *
     * <code>int64 value_msat = 23;</code>
     */
    private void clearValueMsat() {
      
      valueMsat_ = 0L;
    }

    public static final int SETTLED_FIELD_NUMBER = 6;
    private boolean settled_;
    /**
     * <pre>
     * Whether this invoice has been fulfilled
     * </pre>
     *
     * <code>bool settled = 6 [deprecated = true];</code>
     * @return The settled.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean getSettled() {
      return settled_;
    }
    /**
     * <pre>
     * Whether this invoice has been fulfilled
     * </pre>
     *
     * <code>bool settled = 6 [deprecated = true];</code>
     * @param value The settled to set.
     */
    private void setSettled(boolean value) {
      
      settled_ = value;
    }
    /**
     * <pre>
     * Whether this invoice has been fulfilled
     * </pre>
     *
     * <code>bool settled = 6 [deprecated = true];</code>
     */
    private void clearSettled() {
      
      settled_ = false;
    }

    public static final int CREATION_DATE_FIELD_NUMBER = 7;
    private long creationDate_;
    /**
     * <pre>
     * When this invoice was created
     * </pre>
     *
     * <code>int64 creation_date = 7;</code>
     * @return The creationDate.
     */
    @java.lang.Override
    public long getCreationDate() {
      return creationDate_;
    }
    /**
     * <pre>
     * When this invoice was created
     * </pre>
     *
     * <code>int64 creation_date = 7;</code>
     * @param value The creationDate to set.
     */
    private void setCreationDate(long value) {
      
      creationDate_ = value;
    }
    /**
     * <pre>
     * When this invoice was created
     * </pre>
     *
     * <code>int64 creation_date = 7;</code>
     */
    private void clearCreationDate() {
      
      creationDate_ = 0L;
    }

    public static final int SETTLE_DATE_FIELD_NUMBER = 8;
    private long settleDate_;
    /**
     * <pre>
     * When this invoice was settled
     * </pre>
     *
     * <code>int64 settle_date = 8;</code>
     * @return The settleDate.
     */
    @java.lang.Override
    public long getSettleDate() {
      return settleDate_;
    }
    /**
     * <pre>
     * When this invoice was settled
     * </pre>
     *
     * <code>int64 settle_date = 8;</code>
     * @param value The settleDate to set.
     */
    private void setSettleDate(long value) {
      
      settleDate_ = value;
    }
    /**
     * <pre>
     * When this invoice was settled
     * </pre>
     *
     * <code>int64 settle_date = 8;</code>
     */
    private void clearSettleDate() {
      
      settleDate_ = 0L;
    }

    public static final int PAYMENT_REQUEST_FIELD_NUMBER = 9;
    private java.lang.String paymentRequest_;
    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 9;</code>
     * @return The paymentRequest.
     */
    @java.lang.Override
    public java.lang.String getPaymentRequest() {
      return paymentRequest_;
    }
    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 9;</code>
     * @return The bytes for paymentRequest.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPaymentRequestBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(paymentRequest_);
    }
    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 9;</code>
     * @param value The paymentRequest to set.
     */
    private void setPaymentRequest(
        java.lang.String value) {
      value.getClass();
  
      paymentRequest_ = value;
    }
    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 9;</code>
     */
    private void clearPaymentRequest() {
      
      paymentRequest_ = getDefaultInstance().getPaymentRequest();
    }
    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 9;</code>
     * @param value The bytes for paymentRequest to set.
     */
    private void setPaymentRequestBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      paymentRequest_ = value.toStringUtf8();
      
    }

    public static final int DESCRIPTION_HASH_FIELD_NUMBER = 10;
    private com.google.protobuf.ByteString descriptionHash_;
    /**
     * <pre>
     *Hash (SHA-256) of a description of the payment. Used if the description of
     *payment (memo) is too long to naturally fit within the description field
     *of an encoded payment request. When using REST, this field must be encoded
     *as base64.
     * </pre>
     *
     * <code>bytes description_hash = 10;</code>
     * @return The descriptionHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getDescriptionHash() {
      return descriptionHash_;
    }
    /**
     * <pre>
     *Hash (SHA-256) of a description of the payment. Used if the description of
     *payment (memo) is too long to naturally fit within the description field
     *of an encoded payment request. When using REST, this field must be encoded
     *as base64.
     * </pre>
     *
     * <code>bytes description_hash = 10;</code>
     * @param value The descriptionHash to set.
     */
    private void setDescriptionHash(com.google.protobuf.ByteString value) {
      value.getClass();
  
      descriptionHash_ = value;
    }
    /**
     * <pre>
     *Hash (SHA-256) of a description of the payment. Used if the description of
     *payment (memo) is too long to naturally fit within the description field
     *of an encoded payment request. When using REST, this field must be encoded
     *as base64.
     * </pre>
     *
     * <code>bytes description_hash = 10;</code>
     */
    private void clearDescriptionHash() {
      
      descriptionHash_ = getDefaultInstance().getDescriptionHash();
    }

    public static final int EXPIRY_FIELD_NUMBER = 11;
    private long expiry_;
    /**
     * <pre>
     * Payment request expiry time in seconds. Default is 3600 (1 hour).
     * </pre>
     *
     * <code>int64 expiry = 11;</code>
     * @return The expiry.
     */
    @java.lang.Override
    public long getExpiry() {
      return expiry_;
    }
    /**
     * <pre>
     * Payment request expiry time in seconds. Default is 3600 (1 hour).
     * </pre>
     *
     * <code>int64 expiry = 11;</code>
     * @param value The expiry to set.
     */
    private void setExpiry(long value) {
      
      expiry_ = value;
    }
    /**
     * <pre>
     * Payment request expiry time in seconds. Default is 3600 (1 hour).
     * </pre>
     *
     * <code>int64 expiry = 11;</code>
     */
    private void clearExpiry() {
      
      expiry_ = 0L;
    }

    public static final int FALLBACK_ADDR_FIELD_NUMBER = 12;
    private java.lang.String fallbackAddr_;
    /**
     * <pre>
     * Fallback on-chain address.
     * </pre>
     *
     * <code>string fallback_addr = 12;</code>
     * @return The fallbackAddr.
     */
    @java.lang.Override
    public java.lang.String getFallbackAddr() {
      return fallbackAddr_;
    }
    /**
     * <pre>
     * Fallback on-chain address.
     * </pre>
     *
     * <code>string fallback_addr = 12;</code>
     * @return The bytes for fallbackAddr.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFallbackAddrBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(fallbackAddr_);
    }
    /**
     * <pre>
     * Fallback on-chain address.
     * </pre>
     *
     * <code>string fallback_addr = 12;</code>
     * @param value The fallbackAddr to set.
     */
    private void setFallbackAddr(
        java.lang.String value) {
      value.getClass();
  
      fallbackAddr_ = value;
    }
    /**
     * <pre>
     * Fallback on-chain address.
     * </pre>
     *
     * <code>string fallback_addr = 12;</code>
     */
    private void clearFallbackAddr() {
      
      fallbackAddr_ = getDefaultInstance().getFallbackAddr();
    }
    /**
     * <pre>
     * Fallback on-chain address.
     * </pre>
     *
     * <code>string fallback_addr = 12;</code>
     * @param value The bytes for fallbackAddr to set.
     */
    private void setFallbackAddrBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      fallbackAddr_ = value.toStringUtf8();
      
    }

    public static final int CLTV_EXPIRY_FIELD_NUMBER = 13;
    private long cltvExpiry_;
    /**
     * <pre>
     * Delta to use for the time-lock of the CLTV extended to the final hop.
     * </pre>
     *
     * <code>uint64 cltv_expiry = 13;</code>
     * @return The cltvExpiry.
     */
    @java.lang.Override
    public long getCltvExpiry() {
      return cltvExpiry_;
    }
    /**
     * <pre>
     * Delta to use for the time-lock of the CLTV extended to the final hop.
     * </pre>
     *
     * <code>uint64 cltv_expiry = 13;</code>
     * @param value The cltvExpiry to set.
     */
    private void setCltvExpiry(long value) {
      
      cltvExpiry_ = value;
    }
    /**
     * <pre>
     * Delta to use for the time-lock of the CLTV extended to the final hop.
     * </pre>
     *
     * <code>uint64 cltv_expiry = 13;</code>
     */
    private void clearCltvExpiry() {
      
      cltvExpiry_ = 0L;
    }

    public static final int ROUTE_HINTS_FIELD_NUMBER = 14;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.RouteHint> routeHints_;
    /**
     * <pre>
     *Route hints that can each be individually used to assist in reaching the
     *invoice's destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.RouteHint> getRouteHintsList() {
      return routeHints_;
    }
    /**
     * <pre>
     *Route hints that can each be individually used to assist in reaching the
     *invoice's destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.RouteHintOrBuilder> 
        getRouteHintsOrBuilderList() {
      return routeHints_;
    }
    /**
     * <pre>
     *Route hints that can each be individually used to assist in reaching the
     *invoice's destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
     */
    @java.lang.Override
    public int getRouteHintsCount() {
      return routeHints_.size();
    }
    /**
     * <pre>
     *Route hints that can each be individually used to assist in reaching the
     *invoice's destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.RouteHint getRouteHints(int index) {
      return routeHints_.get(index);
    }
    /**
     * <pre>
     *Route hints that can each be individually used to assist in reaching the
     *invoice's destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
     */
    public co.anode.anodium.Rpc.RouteHintOrBuilder getRouteHintsOrBuilder(
        int index) {
      return routeHints_.get(index);
    }
    private void ensureRouteHintsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.RouteHint> tmp = routeHints_;
      if (!tmp.isModifiable()) {
        routeHints_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     *Route hints that can each be individually used to assist in reaching the
     *invoice's destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
     */
    private void setRouteHints(
        int index, co.anode.anodium.Rpc.RouteHint value) {
      value.getClass();
  ensureRouteHintsIsMutable();
      routeHints_.set(index, value);
    }
    /**
     * <pre>
     *Route hints that can each be individually used to assist in reaching the
     *invoice's destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
     */
    private void addRouteHints(co.anode.anodium.Rpc.RouteHint value) {
      value.getClass();
  ensureRouteHintsIsMutable();
      routeHints_.add(value);
    }
    /**
     * <pre>
     *Route hints that can each be individually used to assist in reaching the
     *invoice's destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
     */
    private void addRouteHints(
        int index, co.anode.anodium.Rpc.RouteHint value) {
      value.getClass();
  ensureRouteHintsIsMutable();
      routeHints_.add(index, value);
    }
    /**
     * <pre>
     *Route hints that can each be individually used to assist in reaching the
     *invoice's destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
     */
    private void addAllRouteHints(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.RouteHint> values) {
      ensureRouteHintsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, routeHints_);
    }
    /**
     * <pre>
     *Route hints that can each be individually used to assist in reaching the
     *invoice's destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
     */
    private void clearRouteHints() {
      routeHints_ = emptyProtobufList();
    }
    /**
     * <pre>
     *Route hints that can each be individually used to assist in reaching the
     *invoice's destination.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
     */
    private void removeRouteHints(int index) {
      ensureRouteHintsIsMutable();
      routeHints_.remove(index);
    }

    public static final int PRIVATE_FIELD_NUMBER = 15;
    private boolean private_;
    /**
     * <pre>
     * Whether this invoice should include routing hints for private channels.
     * </pre>
     *
     * <code>bool private = 15;</code>
     * @return The private.
     */
    @java.lang.Override
    public boolean getPrivate() {
      return private_;
    }
    /**
     * <pre>
     * Whether this invoice should include routing hints for private channels.
     * </pre>
     *
     * <code>bool private = 15;</code>
     * @param value The private to set.
     */
    private void setPrivate(boolean value) {
      
      private_ = value;
    }
    /**
     * <pre>
     * Whether this invoice should include routing hints for private channels.
     * </pre>
     *
     * <code>bool private = 15;</code>
     */
    private void clearPrivate() {
      
      private_ = false;
    }

    public static final int ADD_INDEX_FIELD_NUMBER = 16;
    private long addIndex_;
    /**
     * <pre>
     *The "add" index of this invoice. Each newly created invoice will increment
     *this index making it monotonically increasing. Callers to the
     *SubscribeInvoices call can use this to instantly get notified of all added
     *invoices with an add_index greater than this one.
     * </pre>
     *
     * <code>uint64 add_index = 16;</code>
     * @return The addIndex.
     */
    @java.lang.Override
    public long getAddIndex() {
      return addIndex_;
    }
    /**
     * <pre>
     *The "add" index of this invoice. Each newly created invoice will increment
     *this index making it monotonically increasing. Callers to the
     *SubscribeInvoices call can use this to instantly get notified of all added
     *invoices with an add_index greater than this one.
     * </pre>
     *
     * <code>uint64 add_index = 16;</code>
     * @param value The addIndex to set.
     */
    private void setAddIndex(long value) {
      
      addIndex_ = value;
    }
    /**
     * <pre>
     *The "add" index of this invoice. Each newly created invoice will increment
     *this index making it monotonically increasing. Callers to the
     *SubscribeInvoices call can use this to instantly get notified of all added
     *invoices with an add_index greater than this one.
     * </pre>
     *
     * <code>uint64 add_index = 16;</code>
     */
    private void clearAddIndex() {
      
      addIndex_ = 0L;
    }

    public static final int SETTLE_INDEX_FIELD_NUMBER = 17;
    private long settleIndex_;
    /**
     * <pre>
     *The "settle" index of this invoice. Each newly settled invoice will
     *increment this index making it monotonically increasing. Callers to the
     *SubscribeInvoices call can use this to instantly get notified of all
     *settled invoices with an settle_index greater than this one.
     * </pre>
     *
     * <code>uint64 settle_index = 17;</code>
     * @return The settleIndex.
     */
    @java.lang.Override
    public long getSettleIndex() {
      return settleIndex_;
    }
    /**
     * <pre>
     *The "settle" index of this invoice. Each newly settled invoice will
     *increment this index making it monotonically increasing. Callers to the
     *SubscribeInvoices call can use this to instantly get notified of all
     *settled invoices with an settle_index greater than this one.
     * </pre>
     *
     * <code>uint64 settle_index = 17;</code>
     * @param value The settleIndex to set.
     */
    private void setSettleIndex(long value) {
      
      settleIndex_ = value;
    }
    /**
     * <pre>
     *The "settle" index of this invoice. Each newly settled invoice will
     *increment this index making it monotonically increasing. Callers to the
     *SubscribeInvoices call can use this to instantly get notified of all
     *settled invoices with an settle_index greater than this one.
     * </pre>
     *
     * <code>uint64 settle_index = 17;</code>
     */
    private void clearSettleIndex() {
      
      settleIndex_ = 0L;
    }

    public static final int AMT_PAID_FIELD_NUMBER = 18;
    private long amtPaid_;
    /**
     * <pre>
     * Deprecated, use amt_paid_sat or amt_paid_msat.
     * </pre>
     *
     * <code>int64 amt_paid = 18 [deprecated = true];</code>
     * @return The amtPaid.
     */
    @java.lang.Override
    @java.lang.Deprecated public long getAmtPaid() {
      return amtPaid_;
    }
    /**
     * <pre>
     * Deprecated, use amt_paid_sat or amt_paid_msat.
     * </pre>
     *
     * <code>int64 amt_paid = 18 [deprecated = true];</code>
     * @param value The amtPaid to set.
     */
    private void setAmtPaid(long value) {
      
      amtPaid_ = value;
    }
    /**
     * <pre>
     * Deprecated, use amt_paid_sat or amt_paid_msat.
     * </pre>
     *
     * <code>int64 amt_paid = 18 [deprecated = true];</code>
     */
    private void clearAmtPaid() {
      
      amtPaid_ = 0L;
    }

    public static final int AMT_PAID_SAT_FIELD_NUMBER = 19;
    private long amtPaidSat_;
    /**
     * <pre>
     *The amount that was accepted for this invoice, in satoshis. This will ONLY
     *be set if this invoice has been settled. We provide this field as if the
     *invoice was created with a zero value, then we need to record what amount
     *was ultimately accepted. Additionally, it's possible that the sender paid
     *MORE that was specified in the original invoice. So we'll record that here
     *as well.
     * </pre>
     *
     * <code>int64 amt_paid_sat = 19;</code>
     * @return The amtPaidSat.
     */
    @java.lang.Override
    public long getAmtPaidSat() {
      return amtPaidSat_;
    }
    /**
     * <pre>
     *The amount that was accepted for this invoice, in satoshis. This will ONLY
     *be set if this invoice has been settled. We provide this field as if the
     *invoice was created with a zero value, then we need to record what amount
     *was ultimately accepted. Additionally, it's possible that the sender paid
     *MORE that was specified in the original invoice. So we'll record that here
     *as well.
     * </pre>
     *
     * <code>int64 amt_paid_sat = 19;</code>
     * @param value The amtPaidSat to set.
     */
    private void setAmtPaidSat(long value) {
      
      amtPaidSat_ = value;
    }
    /**
     * <pre>
     *The amount that was accepted for this invoice, in satoshis. This will ONLY
     *be set if this invoice has been settled. We provide this field as if the
     *invoice was created with a zero value, then we need to record what amount
     *was ultimately accepted. Additionally, it's possible that the sender paid
     *MORE that was specified in the original invoice. So we'll record that here
     *as well.
     * </pre>
     *
     * <code>int64 amt_paid_sat = 19;</code>
     */
    private void clearAmtPaidSat() {
      
      amtPaidSat_ = 0L;
    }

    public static final int AMT_PAID_MSAT_FIELD_NUMBER = 20;
    private long amtPaidMsat_;
    /**
     * <pre>
     *The amount that was accepted for this invoice, in millisatoshis. This will
     *ONLY be set if this invoice has been settled. We provide this field as if
     *the invoice was created with a zero value, then we need to record what
     *amount was ultimately accepted. Additionally, it's possible that the sender
     *paid MORE that was specified in the original invoice. So we'll record that
     *here as well.
     * </pre>
     *
     * <code>int64 amt_paid_msat = 20;</code>
     * @return The amtPaidMsat.
     */
    @java.lang.Override
    public long getAmtPaidMsat() {
      return amtPaidMsat_;
    }
    /**
     * <pre>
     *The amount that was accepted for this invoice, in millisatoshis. This will
     *ONLY be set if this invoice has been settled. We provide this field as if
     *the invoice was created with a zero value, then we need to record what
     *amount was ultimately accepted. Additionally, it's possible that the sender
     *paid MORE that was specified in the original invoice. So we'll record that
     *here as well.
     * </pre>
     *
     * <code>int64 amt_paid_msat = 20;</code>
     * @param value The amtPaidMsat to set.
     */
    private void setAmtPaidMsat(long value) {
      
      amtPaidMsat_ = value;
    }
    /**
     * <pre>
     *The amount that was accepted for this invoice, in millisatoshis. This will
     *ONLY be set if this invoice has been settled. We provide this field as if
     *the invoice was created with a zero value, then we need to record what
     *amount was ultimately accepted. Additionally, it's possible that the sender
     *paid MORE that was specified in the original invoice. So we'll record that
     *here as well.
     * </pre>
     *
     * <code>int64 amt_paid_msat = 20;</code>
     */
    private void clearAmtPaidMsat() {
      
      amtPaidMsat_ = 0L;
    }

    public static final int STATE_FIELD_NUMBER = 21;
    private int state_;
    /**
     * <pre>
     *The state the invoice is in.
     * </pre>
     *
     * <code>.co.anode.anodium.Invoice.InvoiceState state = 21;</code>
     * @return The enum numeric value on the wire for state.
     */
    @java.lang.Override
    public int getStateValue() {
      return state_;
    }
    /**
     * <pre>
     *The state the invoice is in.
     * </pre>
     *
     * <code>.co.anode.anodium.Invoice.InvoiceState state = 21;</code>
     * @return The state.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Invoice.InvoiceState getState() {
      co.anode.anodium.Rpc.Invoice.InvoiceState result = co.anode.anodium.Rpc.Invoice.InvoiceState.forNumber(state_);
      return result == null ? co.anode.anodium.Rpc.Invoice.InvoiceState.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     *The state the invoice is in.
     * </pre>
     *
     * <code>.co.anode.anodium.Invoice.InvoiceState state = 21;</code>
     * @param value The enum numeric value on the wire for state to set.
     */
    private void setStateValue(int value) {
        state_ = value;
    }
    /**
     * <pre>
     *The state the invoice is in.
     * </pre>
     *
     * <code>.co.anode.anodium.Invoice.InvoiceState state = 21;</code>
     * @param value The state to set.
     */
    private void setState(co.anode.anodium.Rpc.Invoice.InvoiceState value) {
      state_ = value.getNumber();
      
    }
    /**
     * <pre>
     *The state the invoice is in.
     * </pre>
     *
     * <code>.co.anode.anodium.Invoice.InvoiceState state = 21;</code>
     */
    private void clearState() {
      
      state_ = 0;
    }

    public static final int HTLCS_FIELD_NUMBER = 22;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.InvoiceHTLC> htlcs_;
    /**
     * <pre>
     * List of HTLCs paying to this invoice [EXPERIMENTAL].
     * </pre>
     *
     * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.InvoiceHTLC> getHtlcsList() {
      return htlcs_;
    }
    /**
     * <pre>
     * List of HTLCs paying to this invoice [EXPERIMENTAL].
     * </pre>
     *
     * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.InvoiceHTLCOrBuilder> 
        getHtlcsOrBuilderList() {
      return htlcs_;
    }
    /**
     * <pre>
     * List of HTLCs paying to this invoice [EXPERIMENTAL].
     * </pre>
     *
     * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
     */
    @java.lang.Override
    public int getHtlcsCount() {
      return htlcs_.size();
    }
    /**
     * <pre>
     * List of HTLCs paying to this invoice [EXPERIMENTAL].
     * </pre>
     *
     * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.InvoiceHTLC getHtlcs(int index) {
      return htlcs_.get(index);
    }
    /**
     * <pre>
     * List of HTLCs paying to this invoice [EXPERIMENTAL].
     * </pre>
     *
     * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
     */
    public co.anode.anodium.Rpc.InvoiceHTLCOrBuilder getHtlcsOrBuilder(
        int index) {
      return htlcs_.get(index);
    }
    private void ensureHtlcsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.InvoiceHTLC> tmp = htlcs_;
      if (!tmp.isModifiable()) {
        htlcs_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * List of HTLCs paying to this invoice [EXPERIMENTAL].
     * </pre>
     *
     * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
     */
    private void setHtlcs(
        int index, co.anode.anodium.Rpc.InvoiceHTLC value) {
      value.getClass();
  ensureHtlcsIsMutable();
      htlcs_.set(index, value);
    }
    /**
     * <pre>
     * List of HTLCs paying to this invoice [EXPERIMENTAL].
     * </pre>
     *
     * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
     */
    private void addHtlcs(co.anode.anodium.Rpc.InvoiceHTLC value) {
      value.getClass();
  ensureHtlcsIsMutable();
      htlcs_.add(value);
    }
    /**
     * <pre>
     * List of HTLCs paying to this invoice [EXPERIMENTAL].
     * </pre>
     *
     * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
     */
    private void addHtlcs(
        int index, co.anode.anodium.Rpc.InvoiceHTLC value) {
      value.getClass();
  ensureHtlcsIsMutable();
      htlcs_.add(index, value);
    }
    /**
     * <pre>
     * List of HTLCs paying to this invoice [EXPERIMENTAL].
     * </pre>
     *
     * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
     */
    private void addAllHtlcs(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.InvoiceHTLC> values) {
      ensureHtlcsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, htlcs_);
    }
    /**
     * <pre>
     * List of HTLCs paying to this invoice [EXPERIMENTAL].
     * </pre>
     *
     * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
     */
    private void clearHtlcs() {
      htlcs_ = emptyProtobufList();
    }
    /**
     * <pre>
     * List of HTLCs paying to this invoice [EXPERIMENTAL].
     * </pre>
     *
     * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
     */
    private void removeHtlcs(int index) {
      ensureHtlcsIsMutable();
      htlcs_.remove(index);
    }

    public static final int FEATURES_FIELD_NUMBER = 24;
    private static final class FeaturesDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Integer, co.anode.anodium.Rpc.Feature> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Integer, co.anode.anodium.Rpc.Feature>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.UINT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  co.anode.anodium.Rpc.Feature.getDefaultInstance());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Integer, co.anode.anodium.Rpc.Feature> features_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    internalGetFeatures() {
      return features_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    internalGetMutableFeatures() {
      if (!features_.isMutable()) {
        features_ = features_.mutableCopy();
      }
      return features_;
    }
    @java.lang.Override

    public int getFeaturesCount() {
      return internalGetFeatures().size();
    }
    /**
     * <pre>
     * List of features advertised on the invoice.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 24;</code>
     */
    @java.lang.Override

    public boolean containsFeatures(
        int key) {
      
      return internalGetFeatures().containsKey(key);
    }
    /**
     * Use {@link #getFeaturesMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeatures() {
      return getFeaturesMap();
    }
    /**
     * <pre>
     * List of features advertised on the invoice.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 24;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeaturesMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetFeatures());
    }
    /**
     * <pre>
     * List of features advertised on the invoice.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 24;</code>
     */
    @java.lang.Override

    public co.anode.anodium.Rpc.Feature getFeaturesOrDefault(
        int key,
        co.anode.anodium.Rpc.Feature defaultValue) {
      
      java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
          internalGetFeatures();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * List of features advertised on the invoice.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 24;</code>
     */
    @java.lang.Override

    public co.anode.anodium.Rpc.Feature getFeaturesOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
          internalGetFeatures();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * List of features advertised on the invoice.
     * </pre>
     *
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 24;</code>
     */
    private java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    getMutableFeaturesMap() {
      return internalGetMutableFeatures();
    }

    public static final int IS_KEYSEND_FIELD_NUMBER = 25;
    private boolean isKeysend_;
    /**
     * <pre>
     *Indicates if this invoice was a spontaneous payment that arrived via keysend
     *[EXPERIMENTAL].
     * </pre>
     *
     * <code>bool is_keysend = 25;</code>
     * @return The isKeysend.
     */
    @java.lang.Override
    public boolean getIsKeysend() {
      return isKeysend_;
    }
    /**
     * <pre>
     *Indicates if this invoice was a spontaneous payment that arrived via keysend
     *[EXPERIMENTAL].
     * </pre>
     *
     * <code>bool is_keysend = 25;</code>
     * @param value The isKeysend to set.
     */
    private void setIsKeysend(boolean value) {
      
      isKeysend_ = value;
    }
    /**
     * <pre>
     *Indicates if this invoice was a spontaneous payment that arrived via keysend
     *[EXPERIMENTAL].
     * </pre>
     *
     * <code>bool is_keysend = 25;</code>
     */
    private void clearIsKeysend() {
      
      isKeysend_ = false;
    }

    public static co.anode.anodium.Rpc.Invoice parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Invoice parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Invoice parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Invoice parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Invoice parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Invoice parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Invoice parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Invoice parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Invoice parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Invoice parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Invoice parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Invoice parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.Invoice prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.Invoice}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.Invoice, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.Invoice)
        co.anode.anodium.Rpc.InvoiceOrBuilder {
      // Construct using co.anode.anodium.Rpc.Invoice.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *An optional memo to attach along with the invoice. Used for record keeping
       *purposes for the invoice's creator, and will also be set in the description
       *field of the encoded payment request if the description_hash field is not
       *being used.
       * </pre>
       *
       * <code>string memo = 1;</code>
       * @return The memo.
       */
      @java.lang.Override
      public java.lang.String getMemo() {
        return instance.getMemo();
      }
      /**
       * <pre>
       *An optional memo to attach along with the invoice. Used for record keeping
       *purposes for the invoice's creator, and will also be set in the description
       *field of the encoded payment request if the description_hash field is not
       *being used.
       * </pre>
       *
       * <code>string memo = 1;</code>
       * @return The bytes for memo.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getMemoBytes() {
        return instance.getMemoBytes();
      }
      /**
       * <pre>
       *An optional memo to attach along with the invoice. Used for record keeping
       *purposes for the invoice's creator, and will also be set in the description
       *field of the encoded payment request if the description_hash field is not
       *being used.
       * </pre>
       *
       * <code>string memo = 1;</code>
       * @param value The memo to set.
       * @return This builder for chaining.
       */
      public Builder setMemo(
          java.lang.String value) {
        copyOnWrite();
        instance.setMemo(value);
        return this;
      }
      /**
       * <pre>
       *An optional memo to attach along with the invoice. Used for record keeping
       *purposes for the invoice's creator, and will also be set in the description
       *field of the encoded payment request if the description_hash field is not
       *being used.
       * </pre>
       *
       * <code>string memo = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearMemo() {
        copyOnWrite();
        instance.clearMemo();
        return this;
      }
      /**
       * <pre>
       *An optional memo to attach along with the invoice. Used for record keeping
       *purposes for the invoice's creator, and will also be set in the description
       *field of the encoded payment request if the description_hash field is not
       *being used.
       * </pre>
       *
       * <code>string memo = 1;</code>
       * @param value The bytes for memo to set.
       * @return This builder for chaining.
       */
      public Builder setMemoBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setMemoBytes(value);
        return this;
      }

      /**
       * <pre>
       *The hex-encoded preimage (32 byte) which will allow settling an incoming
       *HTLC payable to this preimage. When using REST, this field must be encoded
       *as base64.
       * </pre>
       *
       * <code>bytes r_preimage = 3;</code>
       * @return The rPreimage.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getRPreimage() {
        return instance.getRPreimage();
      }
      /**
       * <pre>
       *The hex-encoded preimage (32 byte) which will allow settling an incoming
       *HTLC payable to this preimage. When using REST, this field must be encoded
       *as base64.
       * </pre>
       *
       * <code>bytes r_preimage = 3;</code>
       * @param value The rPreimage to set.
       * @return This builder for chaining.
       */
      public Builder setRPreimage(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setRPreimage(value);
        return this;
      }
      /**
       * <pre>
       *The hex-encoded preimage (32 byte) which will allow settling an incoming
       *HTLC payable to this preimage. When using REST, this field must be encoded
       *as base64.
       * </pre>
       *
       * <code>bytes r_preimage = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearRPreimage() {
        copyOnWrite();
        instance.clearRPreimage();
        return this;
      }

      /**
       * <pre>
       *The hash of the preimage. When using REST, this field must be encoded as
       *base64.
       * </pre>
       *
       * <code>bytes r_hash = 4;</code>
       * @return The rHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getRHash() {
        return instance.getRHash();
      }
      /**
       * <pre>
       *The hash of the preimage. When using REST, this field must be encoded as
       *base64.
       * </pre>
       *
       * <code>bytes r_hash = 4;</code>
       * @param value The rHash to set.
       * @return This builder for chaining.
       */
      public Builder setRHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setRHash(value);
        return this;
      }
      /**
       * <pre>
       *The hash of the preimage. When using REST, this field must be encoded as
       *base64.
       * </pre>
       *
       * <code>bytes r_hash = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearRHash() {
        copyOnWrite();
        instance.clearRHash();
        return this;
      }

      /**
       * <pre>
       *The value of this invoice in satoshis
       *The fields value and value_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 value = 5;</code>
       * @return The value.
       */
      @java.lang.Override
      public long getValue() {
        return instance.getValue();
      }
      /**
       * <pre>
       *The value of this invoice in satoshis
       *The fields value and value_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 value = 5;</code>
       * @param value The value to set.
       * @return This builder for chaining.
       */
      public Builder setValue(long value) {
        copyOnWrite();
        instance.setValue(value);
        return this;
      }
      /**
       * <pre>
       *The value of this invoice in satoshis
       *The fields value and value_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 value = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearValue() {
        copyOnWrite();
        instance.clearValue();
        return this;
      }

      /**
       * <pre>
       *The value of this invoice in millisatoshis
       *The fields value and value_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 value_msat = 23;</code>
       * @return The valueMsat.
       */
      @java.lang.Override
      public long getValueMsat() {
        return instance.getValueMsat();
      }
      /**
       * <pre>
       *The value of this invoice in millisatoshis
       *The fields value and value_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 value_msat = 23;</code>
       * @param value The valueMsat to set.
       * @return This builder for chaining.
       */
      public Builder setValueMsat(long value) {
        copyOnWrite();
        instance.setValueMsat(value);
        return this;
      }
      /**
       * <pre>
       *The value of this invoice in millisatoshis
       *The fields value and value_msat are mutually exclusive.
       * </pre>
       *
       * <code>int64 value_msat = 23;</code>
       * @return This builder for chaining.
       */
      public Builder clearValueMsat() {
        copyOnWrite();
        instance.clearValueMsat();
        return this;
      }

      /**
       * <pre>
       * Whether this invoice has been fulfilled
       * </pre>
       *
       * <code>bool settled = 6 [deprecated = true];</code>
       * @return The settled.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean getSettled() {
        return instance.getSettled();
      }
      /**
       * <pre>
       * Whether this invoice has been fulfilled
       * </pre>
       *
       * <code>bool settled = 6 [deprecated = true];</code>
       * @param value The settled to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setSettled(boolean value) {
        copyOnWrite();
        instance.setSettled(value);
        return this;
      }
      /**
       * <pre>
       * Whether this invoice has been fulfilled
       * </pre>
       *
       * <code>bool settled = 6 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearSettled() {
        copyOnWrite();
        instance.clearSettled();
        return this;
      }

      /**
       * <pre>
       * When this invoice was created
       * </pre>
       *
       * <code>int64 creation_date = 7;</code>
       * @return The creationDate.
       */
      @java.lang.Override
      public long getCreationDate() {
        return instance.getCreationDate();
      }
      /**
       * <pre>
       * When this invoice was created
       * </pre>
       *
       * <code>int64 creation_date = 7;</code>
       * @param value The creationDate to set.
       * @return This builder for chaining.
       */
      public Builder setCreationDate(long value) {
        copyOnWrite();
        instance.setCreationDate(value);
        return this;
      }
      /**
       * <pre>
       * When this invoice was created
       * </pre>
       *
       * <code>int64 creation_date = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearCreationDate() {
        copyOnWrite();
        instance.clearCreationDate();
        return this;
      }

      /**
       * <pre>
       * When this invoice was settled
       * </pre>
       *
       * <code>int64 settle_date = 8;</code>
       * @return The settleDate.
       */
      @java.lang.Override
      public long getSettleDate() {
        return instance.getSettleDate();
      }
      /**
       * <pre>
       * When this invoice was settled
       * </pre>
       *
       * <code>int64 settle_date = 8;</code>
       * @param value The settleDate to set.
       * @return This builder for chaining.
       */
      public Builder setSettleDate(long value) {
        copyOnWrite();
        instance.setSettleDate(value);
        return this;
      }
      /**
       * <pre>
       * When this invoice was settled
       * </pre>
       *
       * <code>int64 settle_date = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearSettleDate() {
        copyOnWrite();
        instance.clearSettleDate();
        return this;
      }

      /**
       * <pre>
       *A bare-bones invoice for a payment within the Lightning Network. With the
       *details of the invoice, the sender has all the data necessary to send a
       *payment to the recipient.
       * </pre>
       *
       * <code>string payment_request = 9;</code>
       * @return The paymentRequest.
       */
      @java.lang.Override
      public java.lang.String getPaymentRequest() {
        return instance.getPaymentRequest();
      }
      /**
       * <pre>
       *A bare-bones invoice for a payment within the Lightning Network. With the
       *details of the invoice, the sender has all the data necessary to send a
       *payment to the recipient.
       * </pre>
       *
       * <code>string payment_request = 9;</code>
       * @return The bytes for paymentRequest.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPaymentRequestBytes() {
        return instance.getPaymentRequestBytes();
      }
      /**
       * <pre>
       *A bare-bones invoice for a payment within the Lightning Network. With the
       *details of the invoice, the sender has all the data necessary to send a
       *payment to the recipient.
       * </pre>
       *
       * <code>string payment_request = 9;</code>
       * @param value The paymentRequest to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentRequest(
          java.lang.String value) {
        copyOnWrite();
        instance.setPaymentRequest(value);
        return this;
      }
      /**
       * <pre>
       *A bare-bones invoice for a payment within the Lightning Network. With the
       *details of the invoice, the sender has all the data necessary to send a
       *payment to the recipient.
       * </pre>
       *
       * <code>string payment_request = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaymentRequest() {
        copyOnWrite();
        instance.clearPaymentRequest();
        return this;
      }
      /**
       * <pre>
       *A bare-bones invoice for a payment within the Lightning Network. With the
       *details of the invoice, the sender has all the data necessary to send a
       *payment to the recipient.
       * </pre>
       *
       * <code>string payment_request = 9;</code>
       * @param value The bytes for paymentRequest to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentRequestBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPaymentRequestBytes(value);
        return this;
      }

      /**
       * <pre>
       *Hash (SHA-256) of a description of the payment. Used if the description of
       *payment (memo) is too long to naturally fit within the description field
       *of an encoded payment request. When using REST, this field must be encoded
       *as base64.
       * </pre>
       *
       * <code>bytes description_hash = 10;</code>
       * @return The descriptionHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getDescriptionHash() {
        return instance.getDescriptionHash();
      }
      /**
       * <pre>
       *Hash (SHA-256) of a description of the payment. Used if the description of
       *payment (memo) is too long to naturally fit within the description field
       *of an encoded payment request. When using REST, this field must be encoded
       *as base64.
       * </pre>
       *
       * <code>bytes description_hash = 10;</code>
       * @param value The descriptionHash to set.
       * @return This builder for chaining.
       */
      public Builder setDescriptionHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setDescriptionHash(value);
        return this;
      }
      /**
       * <pre>
       *Hash (SHA-256) of a description of the payment. Used if the description of
       *payment (memo) is too long to naturally fit within the description field
       *of an encoded payment request. When using REST, this field must be encoded
       *as base64.
       * </pre>
       *
       * <code>bytes description_hash = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearDescriptionHash() {
        copyOnWrite();
        instance.clearDescriptionHash();
        return this;
      }

      /**
       * <pre>
       * Payment request expiry time in seconds. Default is 3600 (1 hour).
       * </pre>
       *
       * <code>int64 expiry = 11;</code>
       * @return The expiry.
       */
      @java.lang.Override
      public long getExpiry() {
        return instance.getExpiry();
      }
      /**
       * <pre>
       * Payment request expiry time in seconds. Default is 3600 (1 hour).
       * </pre>
       *
       * <code>int64 expiry = 11;</code>
       * @param value The expiry to set.
       * @return This builder for chaining.
       */
      public Builder setExpiry(long value) {
        copyOnWrite();
        instance.setExpiry(value);
        return this;
      }
      /**
       * <pre>
       * Payment request expiry time in seconds. Default is 3600 (1 hour).
       * </pre>
       *
       * <code>int64 expiry = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearExpiry() {
        copyOnWrite();
        instance.clearExpiry();
        return this;
      }

      /**
       * <pre>
       * Fallback on-chain address.
       * </pre>
       *
       * <code>string fallback_addr = 12;</code>
       * @return The fallbackAddr.
       */
      @java.lang.Override
      public java.lang.String getFallbackAddr() {
        return instance.getFallbackAddr();
      }
      /**
       * <pre>
       * Fallback on-chain address.
       * </pre>
       *
       * <code>string fallback_addr = 12;</code>
       * @return The bytes for fallbackAddr.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getFallbackAddrBytes() {
        return instance.getFallbackAddrBytes();
      }
      /**
       * <pre>
       * Fallback on-chain address.
       * </pre>
       *
       * <code>string fallback_addr = 12;</code>
       * @param value The fallbackAddr to set.
       * @return This builder for chaining.
       */
      public Builder setFallbackAddr(
          java.lang.String value) {
        copyOnWrite();
        instance.setFallbackAddr(value);
        return this;
      }
      /**
       * <pre>
       * Fallback on-chain address.
       * </pre>
       *
       * <code>string fallback_addr = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearFallbackAddr() {
        copyOnWrite();
        instance.clearFallbackAddr();
        return this;
      }
      /**
       * <pre>
       * Fallback on-chain address.
       * </pre>
       *
       * <code>string fallback_addr = 12;</code>
       * @param value The bytes for fallbackAddr to set.
       * @return This builder for chaining.
       */
      public Builder setFallbackAddrBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setFallbackAddrBytes(value);
        return this;
      }

      /**
       * <pre>
       * Delta to use for the time-lock of the CLTV extended to the final hop.
       * </pre>
       *
       * <code>uint64 cltv_expiry = 13;</code>
       * @return The cltvExpiry.
       */
      @java.lang.Override
      public long getCltvExpiry() {
        return instance.getCltvExpiry();
      }
      /**
       * <pre>
       * Delta to use for the time-lock of the CLTV extended to the final hop.
       * </pre>
       *
       * <code>uint64 cltv_expiry = 13;</code>
       * @param value The cltvExpiry to set.
       * @return This builder for chaining.
       */
      public Builder setCltvExpiry(long value) {
        copyOnWrite();
        instance.setCltvExpiry(value);
        return this;
      }
      /**
       * <pre>
       * Delta to use for the time-lock of the CLTV extended to the final hop.
       * </pre>
       *
       * <code>uint64 cltv_expiry = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearCltvExpiry() {
        copyOnWrite();
        instance.clearCltvExpiry();
        return this;
      }

      /**
       * <pre>
       *Route hints that can each be individually used to assist in reaching the
       *invoice's destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.RouteHint> getRouteHintsList() {
        return java.util.Collections.unmodifiableList(
            instance.getRouteHintsList());
      }
      /**
       * <pre>
       *Route hints that can each be individually used to assist in reaching the
       *invoice's destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
       */
      @java.lang.Override
      public int getRouteHintsCount() {
        return instance.getRouteHintsCount();
      }/**
       * <pre>
       *Route hints that can each be individually used to assist in reaching the
       *invoice's destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.RouteHint getRouteHints(int index) {
        return instance.getRouteHints(index);
      }
      /**
       * <pre>
       *Route hints that can each be individually used to assist in reaching the
       *invoice's destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
       */
      public Builder setRouteHints(
          int index, co.anode.anodium.Rpc.RouteHint value) {
        copyOnWrite();
        instance.setRouteHints(index, value);
        return this;
      }
      /**
       * <pre>
       *Route hints that can each be individually used to assist in reaching the
       *invoice's destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
       */
      public Builder setRouteHints(
          int index, co.anode.anodium.Rpc.RouteHint.Builder builderForValue) {
        copyOnWrite();
        instance.setRouteHints(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Route hints that can each be individually used to assist in reaching the
       *invoice's destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
       */
      public Builder addRouteHints(co.anode.anodium.Rpc.RouteHint value) {
        copyOnWrite();
        instance.addRouteHints(value);
        return this;
      }
      /**
       * <pre>
       *Route hints that can each be individually used to assist in reaching the
       *invoice's destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
       */
      public Builder addRouteHints(
          int index, co.anode.anodium.Rpc.RouteHint value) {
        copyOnWrite();
        instance.addRouteHints(index, value);
        return this;
      }
      /**
       * <pre>
       *Route hints that can each be individually used to assist in reaching the
       *invoice's destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
       */
      public Builder addRouteHints(
          co.anode.anodium.Rpc.RouteHint.Builder builderForValue) {
        copyOnWrite();
        instance.addRouteHints(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Route hints that can each be individually used to assist in reaching the
       *invoice's destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
       */
      public Builder addRouteHints(
          int index, co.anode.anodium.Rpc.RouteHint.Builder builderForValue) {
        copyOnWrite();
        instance.addRouteHints(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Route hints that can each be individually used to assist in reaching the
       *invoice's destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
       */
      public Builder addAllRouteHints(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.RouteHint> values) {
        copyOnWrite();
        instance.addAllRouteHints(values);
        return this;
      }
      /**
       * <pre>
       *Route hints that can each be individually used to assist in reaching the
       *invoice's destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
       */
      public Builder clearRouteHints() {
        copyOnWrite();
        instance.clearRouteHints();
        return this;
      }
      /**
       * <pre>
       *Route hints that can each be individually used to assist in reaching the
       *invoice's destination.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 14;</code>
       */
      public Builder removeRouteHints(int index) {
        copyOnWrite();
        instance.removeRouteHints(index);
        return this;
      }

      /**
       * <pre>
       * Whether this invoice should include routing hints for private channels.
       * </pre>
       *
       * <code>bool private = 15;</code>
       * @return The private.
       */
      @java.lang.Override
      public boolean getPrivate() {
        return instance.getPrivate();
      }
      /**
       * <pre>
       * Whether this invoice should include routing hints for private channels.
       * </pre>
       *
       * <code>bool private = 15;</code>
       * @param value The private to set.
       * @return This builder for chaining.
       */
      public Builder setPrivate(boolean value) {
        copyOnWrite();
        instance.setPrivate(value);
        return this;
      }
      /**
       * <pre>
       * Whether this invoice should include routing hints for private channels.
       * </pre>
       *
       * <code>bool private = 15;</code>
       * @return This builder for chaining.
       */
      public Builder clearPrivate() {
        copyOnWrite();
        instance.clearPrivate();
        return this;
      }

      /**
       * <pre>
       *The "add" index of this invoice. Each newly created invoice will increment
       *this index making it monotonically increasing. Callers to the
       *SubscribeInvoices call can use this to instantly get notified of all added
       *invoices with an add_index greater than this one.
       * </pre>
       *
       * <code>uint64 add_index = 16;</code>
       * @return The addIndex.
       */
      @java.lang.Override
      public long getAddIndex() {
        return instance.getAddIndex();
      }
      /**
       * <pre>
       *The "add" index of this invoice. Each newly created invoice will increment
       *this index making it monotonically increasing. Callers to the
       *SubscribeInvoices call can use this to instantly get notified of all added
       *invoices with an add_index greater than this one.
       * </pre>
       *
       * <code>uint64 add_index = 16;</code>
       * @param value The addIndex to set.
       * @return This builder for chaining.
       */
      public Builder setAddIndex(long value) {
        copyOnWrite();
        instance.setAddIndex(value);
        return this;
      }
      /**
       * <pre>
       *The "add" index of this invoice. Each newly created invoice will increment
       *this index making it monotonically increasing. Callers to the
       *SubscribeInvoices call can use this to instantly get notified of all added
       *invoices with an add_index greater than this one.
       * </pre>
       *
       * <code>uint64 add_index = 16;</code>
       * @return This builder for chaining.
       */
      public Builder clearAddIndex() {
        copyOnWrite();
        instance.clearAddIndex();
        return this;
      }

      /**
       * <pre>
       *The "settle" index of this invoice. Each newly settled invoice will
       *increment this index making it monotonically increasing. Callers to the
       *SubscribeInvoices call can use this to instantly get notified of all
       *settled invoices with an settle_index greater than this one.
       * </pre>
       *
       * <code>uint64 settle_index = 17;</code>
       * @return The settleIndex.
       */
      @java.lang.Override
      public long getSettleIndex() {
        return instance.getSettleIndex();
      }
      /**
       * <pre>
       *The "settle" index of this invoice. Each newly settled invoice will
       *increment this index making it monotonically increasing. Callers to the
       *SubscribeInvoices call can use this to instantly get notified of all
       *settled invoices with an settle_index greater than this one.
       * </pre>
       *
       * <code>uint64 settle_index = 17;</code>
       * @param value The settleIndex to set.
       * @return This builder for chaining.
       */
      public Builder setSettleIndex(long value) {
        copyOnWrite();
        instance.setSettleIndex(value);
        return this;
      }
      /**
       * <pre>
       *The "settle" index of this invoice. Each newly settled invoice will
       *increment this index making it monotonically increasing. Callers to the
       *SubscribeInvoices call can use this to instantly get notified of all
       *settled invoices with an settle_index greater than this one.
       * </pre>
       *
       * <code>uint64 settle_index = 17;</code>
       * @return This builder for chaining.
       */
      public Builder clearSettleIndex() {
        copyOnWrite();
        instance.clearSettleIndex();
        return this;
      }

      /**
       * <pre>
       * Deprecated, use amt_paid_sat or amt_paid_msat.
       * </pre>
       *
       * <code>int64 amt_paid = 18 [deprecated = true];</code>
       * @return The amtPaid.
       */
      @java.lang.Override
      @java.lang.Deprecated public long getAmtPaid() {
        return instance.getAmtPaid();
      }
      /**
       * <pre>
       * Deprecated, use amt_paid_sat or amt_paid_msat.
       * </pre>
       *
       * <code>int64 amt_paid = 18 [deprecated = true];</code>
       * @param value The amtPaid to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setAmtPaid(long value) {
        copyOnWrite();
        instance.setAmtPaid(value);
        return this;
      }
      /**
       * <pre>
       * Deprecated, use amt_paid_sat or amt_paid_msat.
       * </pre>
       *
       * <code>int64 amt_paid = 18 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearAmtPaid() {
        copyOnWrite();
        instance.clearAmtPaid();
        return this;
      }

      /**
       * <pre>
       *The amount that was accepted for this invoice, in satoshis. This will ONLY
       *be set if this invoice has been settled. We provide this field as if the
       *invoice was created with a zero value, then we need to record what amount
       *was ultimately accepted. Additionally, it's possible that the sender paid
       *MORE that was specified in the original invoice. So we'll record that here
       *as well.
       * </pre>
       *
       * <code>int64 amt_paid_sat = 19;</code>
       * @return The amtPaidSat.
       */
      @java.lang.Override
      public long getAmtPaidSat() {
        return instance.getAmtPaidSat();
      }
      /**
       * <pre>
       *The amount that was accepted for this invoice, in satoshis. This will ONLY
       *be set if this invoice has been settled. We provide this field as if the
       *invoice was created with a zero value, then we need to record what amount
       *was ultimately accepted. Additionally, it's possible that the sender paid
       *MORE that was specified in the original invoice. So we'll record that here
       *as well.
       * </pre>
       *
       * <code>int64 amt_paid_sat = 19;</code>
       * @param value The amtPaidSat to set.
       * @return This builder for chaining.
       */
      public Builder setAmtPaidSat(long value) {
        copyOnWrite();
        instance.setAmtPaidSat(value);
        return this;
      }
      /**
       * <pre>
       *The amount that was accepted for this invoice, in satoshis. This will ONLY
       *be set if this invoice has been settled. We provide this field as if the
       *invoice was created with a zero value, then we need to record what amount
       *was ultimately accepted. Additionally, it's possible that the sender paid
       *MORE that was specified in the original invoice. So we'll record that here
       *as well.
       * </pre>
       *
       * <code>int64 amt_paid_sat = 19;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmtPaidSat() {
        copyOnWrite();
        instance.clearAmtPaidSat();
        return this;
      }

      /**
       * <pre>
       *The amount that was accepted for this invoice, in millisatoshis. This will
       *ONLY be set if this invoice has been settled. We provide this field as if
       *the invoice was created with a zero value, then we need to record what
       *amount was ultimately accepted. Additionally, it's possible that the sender
       *paid MORE that was specified in the original invoice. So we'll record that
       *here as well.
       * </pre>
       *
       * <code>int64 amt_paid_msat = 20;</code>
       * @return The amtPaidMsat.
       */
      @java.lang.Override
      public long getAmtPaidMsat() {
        return instance.getAmtPaidMsat();
      }
      /**
       * <pre>
       *The amount that was accepted for this invoice, in millisatoshis. This will
       *ONLY be set if this invoice has been settled. We provide this field as if
       *the invoice was created with a zero value, then we need to record what
       *amount was ultimately accepted. Additionally, it's possible that the sender
       *paid MORE that was specified in the original invoice. So we'll record that
       *here as well.
       * </pre>
       *
       * <code>int64 amt_paid_msat = 20;</code>
       * @param value The amtPaidMsat to set.
       * @return This builder for chaining.
       */
      public Builder setAmtPaidMsat(long value) {
        copyOnWrite();
        instance.setAmtPaidMsat(value);
        return this;
      }
      /**
       * <pre>
       *The amount that was accepted for this invoice, in millisatoshis. This will
       *ONLY be set if this invoice has been settled. We provide this field as if
       *the invoice was created with a zero value, then we need to record what
       *amount was ultimately accepted. Additionally, it's possible that the sender
       *paid MORE that was specified in the original invoice. So we'll record that
       *here as well.
       * </pre>
       *
       * <code>int64 amt_paid_msat = 20;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmtPaidMsat() {
        copyOnWrite();
        instance.clearAmtPaidMsat();
        return this;
      }

      /**
       * <pre>
       *The state the invoice is in.
       * </pre>
       *
       * <code>.co.anode.anodium.Invoice.InvoiceState state = 21;</code>
       * @return The enum numeric value on the wire for state.
       */
      @java.lang.Override
      public int getStateValue() {
        return instance.getStateValue();
      }
      /**
       * <pre>
       *The state the invoice is in.
       * </pre>
       *
       * <code>.co.anode.anodium.Invoice.InvoiceState state = 21;</code>
       * @param value The state to set.
       * @return This builder for chaining.
       */
      public Builder setStateValue(int value) {
        copyOnWrite();
        instance.setStateValue(value);
        return this;
      }
      /**
       * <pre>
       *The state the invoice is in.
       * </pre>
       *
       * <code>.co.anode.anodium.Invoice.InvoiceState state = 21;</code>
       * @return The state.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Invoice.InvoiceState getState() {
        return instance.getState();
      }
      /**
       * <pre>
       *The state the invoice is in.
       * </pre>
       *
       * <code>.co.anode.anodium.Invoice.InvoiceState state = 21;</code>
       * @param value The enum numeric value on the wire for state to set.
       * @return This builder for chaining.
       */
      public Builder setState(co.anode.anodium.Rpc.Invoice.InvoiceState value) {
        copyOnWrite();
        instance.setState(value);
        return this;
      }
      /**
       * <pre>
       *The state the invoice is in.
       * </pre>
       *
       * <code>.co.anode.anodium.Invoice.InvoiceState state = 21;</code>
       * @return This builder for chaining.
       */
      public Builder clearState() {
        copyOnWrite();
        instance.clearState();
        return this;
      }

      /**
       * <pre>
       * List of HTLCs paying to this invoice [EXPERIMENTAL].
       * </pre>
       *
       * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.InvoiceHTLC> getHtlcsList() {
        return java.util.Collections.unmodifiableList(
            instance.getHtlcsList());
      }
      /**
       * <pre>
       * List of HTLCs paying to this invoice [EXPERIMENTAL].
       * </pre>
       *
       * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
       */
      @java.lang.Override
      public int getHtlcsCount() {
        return instance.getHtlcsCount();
      }/**
       * <pre>
       * List of HTLCs paying to this invoice [EXPERIMENTAL].
       * </pre>
       *
       * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.InvoiceHTLC getHtlcs(int index) {
        return instance.getHtlcs(index);
      }
      /**
       * <pre>
       * List of HTLCs paying to this invoice [EXPERIMENTAL].
       * </pre>
       *
       * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
       */
      public Builder setHtlcs(
          int index, co.anode.anodium.Rpc.InvoiceHTLC value) {
        copyOnWrite();
        instance.setHtlcs(index, value);
        return this;
      }
      /**
       * <pre>
       * List of HTLCs paying to this invoice [EXPERIMENTAL].
       * </pre>
       *
       * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
       */
      public Builder setHtlcs(
          int index, co.anode.anodium.Rpc.InvoiceHTLC.Builder builderForValue) {
        copyOnWrite();
        instance.setHtlcs(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * List of HTLCs paying to this invoice [EXPERIMENTAL].
       * </pre>
       *
       * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
       */
      public Builder addHtlcs(co.anode.anodium.Rpc.InvoiceHTLC value) {
        copyOnWrite();
        instance.addHtlcs(value);
        return this;
      }
      /**
       * <pre>
       * List of HTLCs paying to this invoice [EXPERIMENTAL].
       * </pre>
       *
       * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
       */
      public Builder addHtlcs(
          int index, co.anode.anodium.Rpc.InvoiceHTLC value) {
        copyOnWrite();
        instance.addHtlcs(index, value);
        return this;
      }
      /**
       * <pre>
       * List of HTLCs paying to this invoice [EXPERIMENTAL].
       * </pre>
       *
       * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
       */
      public Builder addHtlcs(
          co.anode.anodium.Rpc.InvoiceHTLC.Builder builderForValue) {
        copyOnWrite();
        instance.addHtlcs(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * List of HTLCs paying to this invoice [EXPERIMENTAL].
       * </pre>
       *
       * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
       */
      public Builder addHtlcs(
          int index, co.anode.anodium.Rpc.InvoiceHTLC.Builder builderForValue) {
        copyOnWrite();
        instance.addHtlcs(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * List of HTLCs paying to this invoice [EXPERIMENTAL].
       * </pre>
       *
       * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
       */
      public Builder addAllHtlcs(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.InvoiceHTLC> values) {
        copyOnWrite();
        instance.addAllHtlcs(values);
        return this;
      }
      /**
       * <pre>
       * List of HTLCs paying to this invoice [EXPERIMENTAL].
       * </pre>
       *
       * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
       */
      public Builder clearHtlcs() {
        copyOnWrite();
        instance.clearHtlcs();
        return this;
      }
      /**
       * <pre>
       * List of HTLCs paying to this invoice [EXPERIMENTAL].
       * </pre>
       *
       * <code>repeated .co.anode.anodium.InvoiceHTLC htlcs = 22;</code>
       */
      public Builder removeHtlcs(int index) {
        copyOnWrite();
        instance.removeHtlcs(index);
        return this;
      }

      @java.lang.Override

      public int getFeaturesCount() {
        return instance.getFeaturesMap().size();
      }
      /**
       * <pre>
       * List of features advertised on the invoice.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 24;</code>
       */
      @java.lang.Override

      public boolean containsFeatures(
          int key) {
        
        return instance.getFeaturesMap().containsKey(key);
      }

      public Builder clearFeatures() {
        copyOnWrite();
        instance.getMutableFeaturesMap().clear();
        return this;
      }
      /**
       * <pre>
       * List of features advertised on the invoice.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 24;</code>
       */

      public Builder removeFeatures(
          int key) {
        
        copyOnWrite();
        instance.getMutableFeaturesMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getFeaturesMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeatures() {
        return getFeaturesMap();
      }
      /**
       * <pre>
       * List of features advertised on the invoice.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 24;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeaturesMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getFeaturesMap());
      }
      /**
       * <pre>
       * List of features advertised on the invoice.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 24;</code>
       */
      @java.lang.Override

      public co.anode.anodium.Rpc.Feature getFeaturesOrDefault(
          int key,
          co.anode.anodium.Rpc.Feature defaultValue) {
        
        java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
            instance.getFeaturesMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * List of features advertised on the invoice.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 24;</code>
       */
      @java.lang.Override

      public co.anode.anodium.Rpc.Feature getFeaturesOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
            instance.getFeaturesMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * List of features advertised on the invoice.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 24;</code>
       */
      public Builder putFeatures(
          int key,
          co.anode.anodium.Rpc.Feature value) {
        
        value.getClass();
        copyOnWrite();
        instance.getMutableFeaturesMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * List of features advertised on the invoice.
       * </pre>
       *
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 24;</code>
       */
      public Builder putAllFeatures(
          java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> values) {
        copyOnWrite();
        instance.getMutableFeaturesMap().putAll(values);
        return this;
      }

      /**
       * <pre>
       *Indicates if this invoice was a spontaneous payment that arrived via keysend
       *[EXPERIMENTAL].
       * </pre>
       *
       * <code>bool is_keysend = 25;</code>
       * @return The isKeysend.
       */
      @java.lang.Override
      public boolean getIsKeysend() {
        return instance.getIsKeysend();
      }
      /**
       * <pre>
       *Indicates if this invoice was a spontaneous payment that arrived via keysend
       *[EXPERIMENTAL].
       * </pre>
       *
       * <code>bool is_keysend = 25;</code>
       * @param value The isKeysend to set.
       * @return This builder for chaining.
       */
      public Builder setIsKeysend(boolean value) {
        copyOnWrite();
        instance.setIsKeysend(value);
        return this;
      }
      /**
       * <pre>
       *Indicates if this invoice was a spontaneous payment that arrived via keysend
       *[EXPERIMENTAL].
       * </pre>
       *
       * <code>bool is_keysend = 25;</code>
       * @return This builder for chaining.
       */
      public Builder clearIsKeysend() {
        copyOnWrite();
        instance.clearIsKeysend();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.Invoice)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.Invoice();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "memo_",
              "rPreimage_",
              "rHash_",
              "value_",
              "settled_",
              "creationDate_",
              "settleDate_",
              "paymentRequest_",
              "descriptionHash_",
              "expiry_",
              "fallbackAddr_",
              "cltvExpiry_",
              "routeHints_",
              co.anode.anodium.Rpc.RouteHint.class,
              "private_",
              "addIndex_",
              "settleIndex_",
              "amtPaid_",
              "amtPaidSat_",
              "amtPaidMsat_",
              "state_",
              "htlcs_",
              co.anode.anodium.Rpc.InvoiceHTLC.class,
              "valueMsat_",
              "features_",
              FeaturesDefaultEntryHolder.defaultEntry,
              "isKeysend_",
            };
            java.lang.String info =
                "\u0000\u0018\u0000\u0000\u0001\u0019\u0018\u0001\u0002\u0000\u0001\u0208\u0003\n" +
                "\u0004\n\u0005\u0002\u0006\u0007\u0007\u0002\b\u0002\t\u0208\n\n\u000b\u0002\f\u0208" +
                "\r\u0003\u000e\u001b\u000f\u0007\u0010\u0003\u0011\u0003\u0012\u0002\u0013\u0002" +
                "\u0014\u0002\u0015\f\u0016\u001b\u0017\u0002\u00182\u0019\u0007";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.Invoice> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.Invoice.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.Invoice>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.Invoice)
    private static final co.anode.anodium.Rpc.Invoice DEFAULT_INSTANCE;
    static {
      Invoice defaultInstance = new Invoice();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Invoice.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.Invoice getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Invoice> PARSER;

    public static com.google.protobuf.Parser<Invoice> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface InvoiceHTLCOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.InvoiceHTLC)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Short channel id over which the htlc was received.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    long getChanId();

    /**
     * <pre>
     * Index identifying the htlc on the channel.
     * </pre>
     *
     * <code>uint64 htlc_index = 2;</code>
     * @return The htlcIndex.
     */
    long getHtlcIndex();

    /**
     * <pre>
     * The amount of the htlc in msat.
     * </pre>
     *
     * <code>uint64 amt_msat = 3;</code>
     * @return The amtMsat.
     */
    long getAmtMsat();

    /**
     * <pre>
     * Block height at which this htlc was accepted.
     * </pre>
     *
     * <code>int32 accept_height = 4;</code>
     * @return The acceptHeight.
     */
    int getAcceptHeight();

    /**
     * <pre>
     * Time at which this htlc was accepted.
     * </pre>
     *
     * <code>int64 accept_time = 5;</code>
     * @return The acceptTime.
     */
    long getAcceptTime();

    /**
     * <pre>
     * Time at which this htlc was settled or canceled.
     * </pre>
     *
     * <code>int64 resolve_time = 6;</code>
     * @return The resolveTime.
     */
    long getResolveTime();

    /**
     * <pre>
     * Block height at which this htlc expires.
     * </pre>
     *
     * <code>int32 expiry_height = 7;</code>
     * @return The expiryHeight.
     */
    int getExpiryHeight();

    /**
     * <pre>
     * Current state the htlc is in.
     * </pre>
     *
     * <code>.co.anode.anodium.InvoiceHTLCState state = 8;</code>
     * @return The enum numeric value on the wire for state.
     */
    int getStateValue();
    /**
     * <pre>
     * Current state the htlc is in.
     * </pre>
     *
     * <code>.co.anode.anodium.InvoiceHTLCState state = 8;</code>
     * @return The state.
     */
    co.anode.anodium.Rpc.InvoiceHTLCState getState();

    /**
     * <pre>
     * Custom tlv records.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 9;</code>
     */
    int getCustomRecordsCount();
    /**
     * <pre>
     * Custom tlv records.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 9;</code>
     */
    boolean containsCustomRecords(
        long key);
    /**
     * Use {@link #getCustomRecordsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Long, com.google.protobuf.ByteString>
    getCustomRecords();
    /**
     * <pre>
     * Custom tlv records.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 9;</code>
     */
    java.util.Map<java.lang.Long, com.google.protobuf.ByteString>
    getCustomRecordsMap();
    /**
     * <pre>
     * Custom tlv records.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 9;</code>
     */

    com.google.protobuf.ByteString getCustomRecordsOrDefault(
        long key,
        com.google.protobuf.ByteString defaultValue);
    /**
     * <pre>
     * Custom tlv records.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 9;</code>
     */

    com.google.protobuf.ByteString getCustomRecordsOrThrow(
        long key);

    /**
     * <pre>
     * The total amount of the mpp payment in msat.
     * </pre>
     *
     * <code>uint64 mpp_total_amt_msat = 10;</code>
     * @return The mppTotalAmtMsat.
     */
    long getMppTotalAmtMsat();
  }
  /**
   * <pre>
   * Details of an HTLC that paid to an invoice
   * </pre>
   *
   * Protobuf type {@code co.anode.anodium.InvoiceHTLC}
   */
  public  static final class InvoiceHTLC extends
      com.google.protobuf.GeneratedMessageLite<
          InvoiceHTLC, InvoiceHTLC.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.InvoiceHTLC)
      InvoiceHTLCOrBuilder {
    private InvoiceHTLC() {
    }
    public static final int CHAN_ID_FIELD_NUMBER = 1;
    private long chanId_;
    /**
     * <pre>
     * Short channel id over which the htlc was received.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    @java.lang.Override
    public long getChanId() {
      return chanId_;
    }
    /**
     * <pre>
     * Short channel id over which the htlc was received.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     * @param value The chanId to set.
     */
    private void setChanId(long value) {
      
      chanId_ = value;
    }
    /**
     * <pre>
     * Short channel id over which the htlc was received.
     * </pre>
     *
     * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
     */
    private void clearChanId() {
      
      chanId_ = 0L;
    }

    public static final int HTLC_INDEX_FIELD_NUMBER = 2;
    private long htlcIndex_;
    /**
     * <pre>
     * Index identifying the htlc on the channel.
     * </pre>
     *
     * <code>uint64 htlc_index = 2;</code>
     * @return The htlcIndex.
     */
    @java.lang.Override
    public long getHtlcIndex() {
      return htlcIndex_;
    }
    /**
     * <pre>
     * Index identifying the htlc on the channel.
     * </pre>
     *
     * <code>uint64 htlc_index = 2;</code>
     * @param value The htlcIndex to set.
     */
    private void setHtlcIndex(long value) {
      
      htlcIndex_ = value;
    }
    /**
     * <pre>
     * Index identifying the htlc on the channel.
     * </pre>
     *
     * <code>uint64 htlc_index = 2;</code>
     */
    private void clearHtlcIndex() {
      
      htlcIndex_ = 0L;
    }

    public static final int AMT_MSAT_FIELD_NUMBER = 3;
    private long amtMsat_;
    /**
     * <pre>
     * The amount of the htlc in msat.
     * </pre>
     *
     * <code>uint64 amt_msat = 3;</code>
     * @return The amtMsat.
     */
    @java.lang.Override
    public long getAmtMsat() {
      return amtMsat_;
    }
    /**
     * <pre>
     * The amount of the htlc in msat.
     * </pre>
     *
     * <code>uint64 amt_msat = 3;</code>
     * @param value The amtMsat to set.
     */
    private void setAmtMsat(long value) {
      
      amtMsat_ = value;
    }
    /**
     * <pre>
     * The amount of the htlc in msat.
     * </pre>
     *
     * <code>uint64 amt_msat = 3;</code>
     */
    private void clearAmtMsat() {
      
      amtMsat_ = 0L;
    }

    public static final int ACCEPT_HEIGHT_FIELD_NUMBER = 4;
    private int acceptHeight_;
    /**
     * <pre>
     * Block height at which this htlc was accepted.
     * </pre>
     *
     * <code>int32 accept_height = 4;</code>
     * @return The acceptHeight.
     */
    @java.lang.Override
    public int getAcceptHeight() {
      return acceptHeight_;
    }
    /**
     * <pre>
     * Block height at which this htlc was accepted.
     * </pre>
     *
     * <code>int32 accept_height = 4;</code>
     * @param value The acceptHeight to set.
     */
    private void setAcceptHeight(int value) {
      
      acceptHeight_ = value;
    }
    /**
     * <pre>
     * Block height at which this htlc was accepted.
     * </pre>
     *
     * <code>int32 accept_height = 4;</code>
     */
    private void clearAcceptHeight() {
      
      acceptHeight_ = 0;
    }

    public static final int ACCEPT_TIME_FIELD_NUMBER = 5;
    private long acceptTime_;
    /**
     * <pre>
     * Time at which this htlc was accepted.
     * </pre>
     *
     * <code>int64 accept_time = 5;</code>
     * @return The acceptTime.
     */
    @java.lang.Override
    public long getAcceptTime() {
      return acceptTime_;
    }
    /**
     * <pre>
     * Time at which this htlc was accepted.
     * </pre>
     *
     * <code>int64 accept_time = 5;</code>
     * @param value The acceptTime to set.
     */
    private void setAcceptTime(long value) {
      
      acceptTime_ = value;
    }
    /**
     * <pre>
     * Time at which this htlc was accepted.
     * </pre>
     *
     * <code>int64 accept_time = 5;</code>
     */
    private void clearAcceptTime() {
      
      acceptTime_ = 0L;
    }

    public static final int RESOLVE_TIME_FIELD_NUMBER = 6;
    private long resolveTime_;
    /**
     * <pre>
     * Time at which this htlc was settled or canceled.
     * </pre>
     *
     * <code>int64 resolve_time = 6;</code>
     * @return The resolveTime.
     */
    @java.lang.Override
    public long getResolveTime() {
      return resolveTime_;
    }
    /**
     * <pre>
     * Time at which this htlc was settled or canceled.
     * </pre>
     *
     * <code>int64 resolve_time = 6;</code>
     * @param value The resolveTime to set.
     */
    private void setResolveTime(long value) {
      
      resolveTime_ = value;
    }
    /**
     * <pre>
     * Time at which this htlc was settled or canceled.
     * </pre>
     *
     * <code>int64 resolve_time = 6;</code>
     */
    private void clearResolveTime() {
      
      resolveTime_ = 0L;
    }

    public static final int EXPIRY_HEIGHT_FIELD_NUMBER = 7;
    private int expiryHeight_;
    /**
     * <pre>
     * Block height at which this htlc expires.
     * </pre>
     *
     * <code>int32 expiry_height = 7;</code>
     * @return The expiryHeight.
     */
    @java.lang.Override
    public int getExpiryHeight() {
      return expiryHeight_;
    }
    /**
     * <pre>
     * Block height at which this htlc expires.
     * </pre>
     *
     * <code>int32 expiry_height = 7;</code>
     * @param value The expiryHeight to set.
     */
    private void setExpiryHeight(int value) {
      
      expiryHeight_ = value;
    }
    /**
     * <pre>
     * Block height at which this htlc expires.
     * </pre>
     *
     * <code>int32 expiry_height = 7;</code>
     */
    private void clearExpiryHeight() {
      
      expiryHeight_ = 0;
    }

    public static final int STATE_FIELD_NUMBER = 8;
    private int state_;
    /**
     * <pre>
     * Current state the htlc is in.
     * </pre>
     *
     * <code>.co.anode.anodium.InvoiceHTLCState state = 8;</code>
     * @return The enum numeric value on the wire for state.
     */
    @java.lang.Override
    public int getStateValue() {
      return state_;
    }
    /**
     * <pre>
     * Current state the htlc is in.
     * </pre>
     *
     * <code>.co.anode.anodium.InvoiceHTLCState state = 8;</code>
     * @return The state.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.InvoiceHTLCState getState() {
      co.anode.anodium.Rpc.InvoiceHTLCState result = co.anode.anodium.Rpc.InvoiceHTLCState.forNumber(state_);
      return result == null ? co.anode.anodium.Rpc.InvoiceHTLCState.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * Current state the htlc is in.
     * </pre>
     *
     * <code>.co.anode.anodium.InvoiceHTLCState state = 8;</code>
     * @param value The enum numeric value on the wire for state to set.
     */
    private void setStateValue(int value) {
        state_ = value;
    }
    /**
     * <pre>
     * Current state the htlc is in.
     * </pre>
     *
     * <code>.co.anode.anodium.InvoiceHTLCState state = 8;</code>
     * @param value The state to set.
     */
    private void setState(co.anode.anodium.Rpc.InvoiceHTLCState value) {
      state_ = value.getNumber();
      
    }
    /**
     * <pre>
     * Current state the htlc is in.
     * </pre>
     *
     * <code>.co.anode.anodium.InvoiceHTLCState state = 8;</code>
     */
    private void clearState() {
      
      state_ = 0;
    }

    public static final int CUSTOM_RECORDS_FIELD_NUMBER = 9;
    private static final class CustomRecordsDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Long, com.google.protobuf.ByteString> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Long, com.google.protobuf.ByteString>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.UINT64,
                  0L,
                  com.google.protobuf.WireFormat.FieldType.BYTES,
                  com.google.protobuf.ByteString.EMPTY);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Long, com.google.protobuf.ByteString> customRecords_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Long, com.google.protobuf.ByteString>
    internalGetCustomRecords() {
      return customRecords_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Long, com.google.protobuf.ByteString>
    internalGetMutableCustomRecords() {
      if (!customRecords_.isMutable()) {
        customRecords_ = customRecords_.mutableCopy();
      }
      return customRecords_;
    }
    @java.lang.Override

    public int getCustomRecordsCount() {
      return internalGetCustomRecords().size();
    }
    /**
     * <pre>
     * Custom tlv records.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 9;</code>
     */
    @java.lang.Override

    public boolean containsCustomRecords(
        long key) {
      
      return internalGetCustomRecords().containsKey(key);
    }
    /**
     * Use {@link #getCustomRecordsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getCustomRecords() {
      return getCustomRecordsMap();
    }
    /**
     * <pre>
     * Custom tlv records.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 9;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getCustomRecordsMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetCustomRecords());
    }
    /**
     * <pre>
     * Custom tlv records.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 9;</code>
     */
    @java.lang.Override

    public com.google.protobuf.ByteString getCustomRecordsOrDefault(
        long key,
        com.google.protobuf.ByteString defaultValue) {
      
      java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
          internalGetCustomRecords();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Custom tlv records.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 9;</code>
     */
    @java.lang.Override

    public com.google.protobuf.ByteString getCustomRecordsOrThrow(
        long key) {
      
      java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
          internalGetCustomRecords();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * Custom tlv records.
     * </pre>
     *
     * <code>map&lt;uint64, bytes&gt; custom_records = 9;</code>
     */
    private java.util.Map<java.lang.Long, com.google.protobuf.ByteString>
    getMutableCustomRecordsMap() {
      return internalGetMutableCustomRecords();
    }

    public static final int MPP_TOTAL_AMT_MSAT_FIELD_NUMBER = 10;
    private long mppTotalAmtMsat_;
    /**
     * <pre>
     * The total amount of the mpp payment in msat.
     * </pre>
     *
     * <code>uint64 mpp_total_amt_msat = 10;</code>
     * @return The mppTotalAmtMsat.
     */
    @java.lang.Override
    public long getMppTotalAmtMsat() {
      return mppTotalAmtMsat_;
    }
    /**
     * <pre>
     * The total amount of the mpp payment in msat.
     * </pre>
     *
     * <code>uint64 mpp_total_amt_msat = 10;</code>
     * @param value The mppTotalAmtMsat to set.
     */
    private void setMppTotalAmtMsat(long value) {
      
      mppTotalAmtMsat_ = value;
    }
    /**
     * <pre>
     * The total amount of the mpp payment in msat.
     * </pre>
     *
     * <code>uint64 mpp_total_amt_msat = 10;</code>
     */
    private void clearMppTotalAmtMsat() {
      
      mppTotalAmtMsat_ = 0L;
    }

    public static co.anode.anodium.Rpc.InvoiceHTLC parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.InvoiceHTLC parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.InvoiceHTLC parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.InvoiceHTLC parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.InvoiceHTLC parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.InvoiceHTLC parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.InvoiceHTLC parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.InvoiceHTLC parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.InvoiceHTLC parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.InvoiceHTLC parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.InvoiceHTLC parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.InvoiceHTLC parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.InvoiceHTLC prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Details of an HTLC that paid to an invoice
     * </pre>
     *
     * Protobuf type {@code co.anode.anodium.InvoiceHTLC}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.InvoiceHTLC, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.InvoiceHTLC)
        co.anode.anodium.Rpc.InvoiceHTLCOrBuilder {
      // Construct using co.anode.anodium.Rpc.InvoiceHTLC.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Short channel id over which the htlc was received.
       * </pre>
       *
       * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
       * @return The chanId.
       */
      @java.lang.Override
      public long getChanId() {
        return instance.getChanId();
      }
      /**
       * <pre>
       * Short channel id over which the htlc was received.
       * </pre>
       *
       * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
       * @param value The chanId to set.
       * @return This builder for chaining.
       */
      public Builder setChanId(long value) {
        copyOnWrite();
        instance.setChanId(value);
        return this;
      }
      /**
       * <pre>
       * Short channel id over which the htlc was received.
       * </pre>
       *
       * <code>uint64 chan_id = 1 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearChanId() {
        copyOnWrite();
        instance.clearChanId();
        return this;
      }

      /**
       * <pre>
       * Index identifying the htlc on the channel.
       * </pre>
       *
       * <code>uint64 htlc_index = 2;</code>
       * @return The htlcIndex.
       */
      @java.lang.Override
      public long getHtlcIndex() {
        return instance.getHtlcIndex();
      }
      /**
       * <pre>
       * Index identifying the htlc on the channel.
       * </pre>
       *
       * <code>uint64 htlc_index = 2;</code>
       * @param value The htlcIndex to set.
       * @return This builder for chaining.
       */
      public Builder setHtlcIndex(long value) {
        copyOnWrite();
        instance.setHtlcIndex(value);
        return this;
      }
      /**
       * <pre>
       * Index identifying the htlc on the channel.
       * </pre>
       *
       * <code>uint64 htlc_index = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearHtlcIndex() {
        copyOnWrite();
        instance.clearHtlcIndex();
        return this;
      }

      /**
       * <pre>
       * The amount of the htlc in msat.
       * </pre>
       *
       * <code>uint64 amt_msat = 3;</code>
       * @return The amtMsat.
       */
      @java.lang.Override
      public long getAmtMsat() {
        return instance.getAmtMsat();
      }
      /**
       * <pre>
       * The amount of the htlc in msat.
       * </pre>
       *
       * <code>uint64 amt_msat = 3;</code>
       * @param value The amtMsat to set.
       * @return This builder for chaining.
       */
      public Builder setAmtMsat(long value) {
        copyOnWrite();
        instance.setAmtMsat(value);
        return this;
      }
      /**
       * <pre>
       * The amount of the htlc in msat.
       * </pre>
       *
       * <code>uint64 amt_msat = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmtMsat() {
        copyOnWrite();
        instance.clearAmtMsat();
        return this;
      }

      /**
       * <pre>
       * Block height at which this htlc was accepted.
       * </pre>
       *
       * <code>int32 accept_height = 4;</code>
       * @return The acceptHeight.
       */
      @java.lang.Override
      public int getAcceptHeight() {
        return instance.getAcceptHeight();
      }
      /**
       * <pre>
       * Block height at which this htlc was accepted.
       * </pre>
       *
       * <code>int32 accept_height = 4;</code>
       * @param value The acceptHeight to set.
       * @return This builder for chaining.
       */
      public Builder setAcceptHeight(int value) {
        copyOnWrite();
        instance.setAcceptHeight(value);
        return this;
      }
      /**
       * <pre>
       * Block height at which this htlc was accepted.
       * </pre>
       *
       * <code>int32 accept_height = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearAcceptHeight() {
        copyOnWrite();
        instance.clearAcceptHeight();
        return this;
      }

      /**
       * <pre>
       * Time at which this htlc was accepted.
       * </pre>
       *
       * <code>int64 accept_time = 5;</code>
       * @return The acceptTime.
       */
      @java.lang.Override
      public long getAcceptTime() {
        return instance.getAcceptTime();
      }
      /**
       * <pre>
       * Time at which this htlc was accepted.
       * </pre>
       *
       * <code>int64 accept_time = 5;</code>
       * @param value The acceptTime to set.
       * @return This builder for chaining.
       */
      public Builder setAcceptTime(long value) {
        copyOnWrite();
        instance.setAcceptTime(value);
        return this;
      }
      /**
       * <pre>
       * Time at which this htlc was accepted.
       * </pre>
       *
       * <code>int64 accept_time = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearAcceptTime() {
        copyOnWrite();
        instance.clearAcceptTime();
        return this;
      }

      /**
       * <pre>
       * Time at which this htlc was settled or canceled.
       * </pre>
       *
       * <code>int64 resolve_time = 6;</code>
       * @return The resolveTime.
       */
      @java.lang.Override
      public long getResolveTime() {
        return instance.getResolveTime();
      }
      /**
       * <pre>
       * Time at which this htlc was settled or canceled.
       * </pre>
       *
       * <code>int64 resolve_time = 6;</code>
       * @param value The resolveTime to set.
       * @return This builder for chaining.
       */
      public Builder setResolveTime(long value) {
        copyOnWrite();
        instance.setResolveTime(value);
        return this;
      }
      /**
       * <pre>
       * Time at which this htlc was settled or canceled.
       * </pre>
       *
       * <code>int64 resolve_time = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearResolveTime() {
        copyOnWrite();
        instance.clearResolveTime();
        return this;
      }

      /**
       * <pre>
       * Block height at which this htlc expires.
       * </pre>
       *
       * <code>int32 expiry_height = 7;</code>
       * @return The expiryHeight.
       */
      @java.lang.Override
      public int getExpiryHeight() {
        return instance.getExpiryHeight();
      }
      /**
       * <pre>
       * Block height at which this htlc expires.
       * </pre>
       *
       * <code>int32 expiry_height = 7;</code>
       * @param value The expiryHeight to set.
       * @return This builder for chaining.
       */
      public Builder setExpiryHeight(int value) {
        copyOnWrite();
        instance.setExpiryHeight(value);
        return this;
      }
      /**
       * <pre>
       * Block height at which this htlc expires.
       * </pre>
       *
       * <code>int32 expiry_height = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearExpiryHeight() {
        copyOnWrite();
        instance.clearExpiryHeight();
        return this;
      }

      /**
       * <pre>
       * Current state the htlc is in.
       * </pre>
       *
       * <code>.co.anode.anodium.InvoiceHTLCState state = 8;</code>
       * @return The enum numeric value on the wire for state.
       */
      @java.lang.Override
      public int getStateValue() {
        return instance.getStateValue();
      }
      /**
       * <pre>
       * Current state the htlc is in.
       * </pre>
       *
       * <code>.co.anode.anodium.InvoiceHTLCState state = 8;</code>
       * @param value The state to set.
       * @return This builder for chaining.
       */
      public Builder setStateValue(int value) {
        copyOnWrite();
        instance.setStateValue(value);
        return this;
      }
      /**
       * <pre>
       * Current state the htlc is in.
       * </pre>
       *
       * <code>.co.anode.anodium.InvoiceHTLCState state = 8;</code>
       * @return The state.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.InvoiceHTLCState getState() {
        return instance.getState();
      }
      /**
       * <pre>
       * Current state the htlc is in.
       * </pre>
       *
       * <code>.co.anode.anodium.InvoiceHTLCState state = 8;</code>
       * @param value The enum numeric value on the wire for state to set.
       * @return This builder for chaining.
       */
      public Builder setState(co.anode.anodium.Rpc.InvoiceHTLCState value) {
        copyOnWrite();
        instance.setState(value);
        return this;
      }
      /**
       * <pre>
       * Current state the htlc is in.
       * </pre>
       *
       * <code>.co.anode.anodium.InvoiceHTLCState state = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearState() {
        copyOnWrite();
        instance.clearState();
        return this;
      }

      @java.lang.Override

      public int getCustomRecordsCount() {
        return instance.getCustomRecordsMap().size();
      }
      /**
       * <pre>
       * Custom tlv records.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; custom_records = 9;</code>
       */
      @java.lang.Override

      public boolean containsCustomRecords(
          long key) {
        
        return instance.getCustomRecordsMap().containsKey(key);
      }

      public Builder clearCustomRecords() {
        copyOnWrite();
        instance.getMutableCustomRecordsMap().clear();
        return this;
      }
      /**
       * <pre>
       * Custom tlv records.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; custom_records = 9;</code>
       */

      public Builder removeCustomRecords(
          long key) {
        
        copyOnWrite();
        instance.getMutableCustomRecordsMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getCustomRecordsMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getCustomRecords() {
        return getCustomRecordsMap();
      }
      /**
       * <pre>
       * Custom tlv records.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; custom_records = 9;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.Long, com.google.protobuf.ByteString> getCustomRecordsMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getCustomRecordsMap());
      }
      /**
       * <pre>
       * Custom tlv records.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; custom_records = 9;</code>
       */
      @java.lang.Override

      public com.google.protobuf.ByteString getCustomRecordsOrDefault(
          long key,
          com.google.protobuf.ByteString defaultValue) {
        
        java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
            instance.getCustomRecordsMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Custom tlv records.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; custom_records = 9;</code>
       */
      @java.lang.Override

      public com.google.protobuf.ByteString getCustomRecordsOrThrow(
          long key) {
        
        java.util.Map<java.lang.Long, com.google.protobuf.ByteString> map =
            instance.getCustomRecordsMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * Custom tlv records.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; custom_records = 9;</code>
       */
      public Builder putCustomRecords(
          long key,
          com.google.protobuf.ByteString value) {
        
        value.getClass();
        copyOnWrite();
        instance.getMutableCustomRecordsMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * Custom tlv records.
       * </pre>
       *
       * <code>map&lt;uint64, bytes&gt; custom_records = 9;</code>
       */
      public Builder putAllCustomRecords(
          java.util.Map<java.lang.Long, com.google.protobuf.ByteString> values) {
        copyOnWrite();
        instance.getMutableCustomRecordsMap().putAll(values);
        return this;
      }

      /**
       * <pre>
       * The total amount of the mpp payment in msat.
       * </pre>
       *
       * <code>uint64 mpp_total_amt_msat = 10;</code>
       * @return The mppTotalAmtMsat.
       */
      @java.lang.Override
      public long getMppTotalAmtMsat() {
        return instance.getMppTotalAmtMsat();
      }
      /**
       * <pre>
       * The total amount of the mpp payment in msat.
       * </pre>
       *
       * <code>uint64 mpp_total_amt_msat = 10;</code>
       * @param value The mppTotalAmtMsat to set.
       * @return This builder for chaining.
       */
      public Builder setMppTotalAmtMsat(long value) {
        copyOnWrite();
        instance.setMppTotalAmtMsat(value);
        return this;
      }
      /**
       * <pre>
       * The total amount of the mpp payment in msat.
       * </pre>
       *
       * <code>uint64 mpp_total_amt_msat = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearMppTotalAmtMsat() {
        copyOnWrite();
        instance.clearMppTotalAmtMsat();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.InvoiceHTLC)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.InvoiceHTLC();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "chanId_",
              "htlcIndex_",
              "amtMsat_",
              "acceptHeight_",
              "acceptTime_",
              "resolveTime_",
              "expiryHeight_",
              "state_",
              "customRecords_",
              CustomRecordsDefaultEntryHolder.defaultEntry,
              "mppTotalAmtMsat_",
            };
            java.lang.String info =
                "\u0000\n\u0000\u0000\u0001\n\n\u0001\u0000\u0000\u0001\u0003\u0002\u0003\u0003\u0003" +
                "\u0004\u0004\u0005\u0002\u0006\u0002\u0007\u0004\b\f\t2\n\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.InvoiceHTLC> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.InvoiceHTLC.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.InvoiceHTLC>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.InvoiceHTLC)
    private static final co.anode.anodium.Rpc.InvoiceHTLC DEFAULT_INSTANCE;
    static {
      InvoiceHTLC defaultInstance = new InvoiceHTLC();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        InvoiceHTLC.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.InvoiceHTLC getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<InvoiceHTLC> PARSER;

    public static com.google.protobuf.Parser<InvoiceHTLC> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface AddInvoiceResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.AddInvoiceResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>bytes r_hash = 1;</code>
     * @return The rHash.
     */
    com.google.protobuf.ByteString getRHash();

    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 2;</code>
     * @return The paymentRequest.
     */
    java.lang.String getPaymentRequest();
    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 2;</code>
     * @return The bytes for paymentRequest.
     */
    com.google.protobuf.ByteString
        getPaymentRequestBytes();

    /**
     * <pre>
     *The "add" index of this invoice. Each newly created invoice will increment
     *this index making it monotonically increasing. Callers to the
     *SubscribeInvoices call can use this to instantly get notified of all added
     *invoices with an add_index greater than this one.
     * </pre>
     *
     * <code>uint64 add_index = 16;</code>
     * @return The addIndex.
     */
    long getAddIndex();
  }
  /**
   * Protobuf type {@code co.anode.anodium.AddInvoiceResponse}
   */
  public  static final class AddInvoiceResponse extends
      com.google.protobuf.GeneratedMessageLite<
          AddInvoiceResponse, AddInvoiceResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.AddInvoiceResponse)
      AddInvoiceResponseOrBuilder {
    private AddInvoiceResponse() {
      rHash_ = com.google.protobuf.ByteString.EMPTY;
      paymentRequest_ = "";
    }
    public static final int R_HASH_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString rHash_;
    /**
     * <code>bytes r_hash = 1;</code>
     * @return The rHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getRHash() {
      return rHash_;
    }
    /**
     * <code>bytes r_hash = 1;</code>
     * @param value The rHash to set.
     */
    private void setRHash(com.google.protobuf.ByteString value) {
      value.getClass();
  
      rHash_ = value;
    }
    /**
     * <code>bytes r_hash = 1;</code>
     */
    private void clearRHash() {
      
      rHash_ = getDefaultInstance().getRHash();
    }

    public static final int PAYMENT_REQUEST_FIELD_NUMBER = 2;
    private java.lang.String paymentRequest_;
    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 2;</code>
     * @return The paymentRequest.
     */
    @java.lang.Override
    public java.lang.String getPaymentRequest() {
      return paymentRequest_;
    }
    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 2;</code>
     * @return The bytes for paymentRequest.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPaymentRequestBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(paymentRequest_);
    }
    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 2;</code>
     * @param value The paymentRequest to set.
     */
    private void setPaymentRequest(
        java.lang.String value) {
      value.getClass();
  
      paymentRequest_ = value;
    }
    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 2;</code>
     */
    private void clearPaymentRequest() {
      
      paymentRequest_ = getDefaultInstance().getPaymentRequest();
    }
    /**
     * <pre>
     *A bare-bones invoice for a payment within the Lightning Network. With the
     *details of the invoice, the sender has all the data necessary to send a
     *payment to the recipient.
     * </pre>
     *
     * <code>string payment_request = 2;</code>
     * @param value The bytes for paymentRequest to set.
     */
    private void setPaymentRequestBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      paymentRequest_ = value.toStringUtf8();
      
    }

    public static final int ADD_INDEX_FIELD_NUMBER = 16;
    private long addIndex_;
    /**
     * <pre>
     *The "add" index of this invoice. Each newly created invoice will increment
     *this index making it monotonically increasing. Callers to the
     *SubscribeInvoices call can use this to instantly get notified of all added
     *invoices with an add_index greater than this one.
     * </pre>
     *
     * <code>uint64 add_index = 16;</code>
     * @return The addIndex.
     */
    @java.lang.Override
    public long getAddIndex() {
      return addIndex_;
    }
    /**
     * <pre>
     *The "add" index of this invoice. Each newly created invoice will increment
     *this index making it monotonically increasing. Callers to the
     *SubscribeInvoices call can use this to instantly get notified of all added
     *invoices with an add_index greater than this one.
     * </pre>
     *
     * <code>uint64 add_index = 16;</code>
     * @param value The addIndex to set.
     */
    private void setAddIndex(long value) {
      
      addIndex_ = value;
    }
    /**
     * <pre>
     *The "add" index of this invoice. Each newly created invoice will increment
     *this index making it monotonically increasing. Callers to the
     *SubscribeInvoices call can use this to instantly get notified of all added
     *invoices with an add_index greater than this one.
     * </pre>
     *
     * <code>uint64 add_index = 16;</code>
     */
    private void clearAddIndex() {
      
      addIndex_ = 0L;
    }

    public static co.anode.anodium.Rpc.AddInvoiceResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.AddInvoiceResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.AddInvoiceResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.AddInvoiceResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.AddInvoiceResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.AddInvoiceResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.AddInvoiceResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.AddInvoiceResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.AddInvoiceResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.AddInvoiceResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.AddInvoiceResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.AddInvoiceResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.AddInvoiceResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.AddInvoiceResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.AddInvoiceResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.AddInvoiceResponse)
        co.anode.anodium.Rpc.AddInvoiceResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.AddInvoiceResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>bytes r_hash = 1;</code>
       * @return The rHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getRHash() {
        return instance.getRHash();
      }
      /**
       * <code>bytes r_hash = 1;</code>
       * @param value The rHash to set.
       * @return This builder for chaining.
       */
      public Builder setRHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setRHash(value);
        return this;
      }
      /**
       * <code>bytes r_hash = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRHash() {
        copyOnWrite();
        instance.clearRHash();
        return this;
      }

      /**
       * <pre>
       *A bare-bones invoice for a payment within the Lightning Network. With the
       *details of the invoice, the sender has all the data necessary to send a
       *payment to the recipient.
       * </pre>
       *
       * <code>string payment_request = 2;</code>
       * @return The paymentRequest.
       */
      @java.lang.Override
      public java.lang.String getPaymentRequest() {
        return instance.getPaymentRequest();
      }
      /**
       * <pre>
       *A bare-bones invoice for a payment within the Lightning Network. With the
       *details of the invoice, the sender has all the data necessary to send a
       *payment to the recipient.
       * </pre>
       *
       * <code>string payment_request = 2;</code>
       * @return The bytes for paymentRequest.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPaymentRequestBytes() {
        return instance.getPaymentRequestBytes();
      }
      /**
       * <pre>
       *A bare-bones invoice for a payment within the Lightning Network. With the
       *details of the invoice, the sender has all the data necessary to send a
       *payment to the recipient.
       * </pre>
       *
       * <code>string payment_request = 2;</code>
       * @param value The paymentRequest to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentRequest(
          java.lang.String value) {
        copyOnWrite();
        instance.setPaymentRequest(value);
        return this;
      }
      /**
       * <pre>
       *A bare-bones invoice for a payment within the Lightning Network. With the
       *details of the invoice, the sender has all the data necessary to send a
       *payment to the recipient.
       * </pre>
       *
       * <code>string payment_request = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaymentRequest() {
        copyOnWrite();
        instance.clearPaymentRequest();
        return this;
      }
      /**
       * <pre>
       *A bare-bones invoice for a payment within the Lightning Network. With the
       *details of the invoice, the sender has all the data necessary to send a
       *payment to the recipient.
       * </pre>
       *
       * <code>string payment_request = 2;</code>
       * @param value The bytes for paymentRequest to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentRequestBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPaymentRequestBytes(value);
        return this;
      }

      /**
       * <pre>
       *The "add" index of this invoice. Each newly created invoice will increment
       *this index making it monotonically increasing. Callers to the
       *SubscribeInvoices call can use this to instantly get notified of all added
       *invoices with an add_index greater than this one.
       * </pre>
       *
       * <code>uint64 add_index = 16;</code>
       * @return The addIndex.
       */
      @java.lang.Override
      public long getAddIndex() {
        return instance.getAddIndex();
      }
      /**
       * <pre>
       *The "add" index of this invoice. Each newly created invoice will increment
       *this index making it monotonically increasing. Callers to the
       *SubscribeInvoices call can use this to instantly get notified of all added
       *invoices with an add_index greater than this one.
       * </pre>
       *
       * <code>uint64 add_index = 16;</code>
       * @param value The addIndex to set.
       * @return This builder for chaining.
       */
      public Builder setAddIndex(long value) {
        copyOnWrite();
        instance.setAddIndex(value);
        return this;
      }
      /**
       * <pre>
       *The "add" index of this invoice. Each newly created invoice will increment
       *this index making it monotonically increasing. Callers to the
       *SubscribeInvoices call can use this to instantly get notified of all added
       *invoices with an add_index greater than this one.
       * </pre>
       *
       * <code>uint64 add_index = 16;</code>
       * @return This builder for chaining.
       */
      public Builder clearAddIndex() {
        copyOnWrite();
        instance.clearAddIndex();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.AddInvoiceResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.AddInvoiceResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "rHash_",
              "paymentRequest_",
              "addIndex_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0010\u0003\u0000\u0000\u0000\u0001\n\u0002\u0208" +
                "\u0010\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.AddInvoiceResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.AddInvoiceResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.AddInvoiceResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.AddInvoiceResponse)
    private static final co.anode.anodium.Rpc.AddInvoiceResponse DEFAULT_INSTANCE;
    static {
      AddInvoiceResponse defaultInstance = new AddInvoiceResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        AddInvoiceResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.AddInvoiceResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<AddInvoiceResponse> PARSER;

    public static com.google.protobuf.Parser<AddInvoiceResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PaymentHashOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.PaymentHash)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The hex-encoded payment hash of the invoice to be looked up. The passed
     *payment hash must be exactly 32 bytes, otherwise an error is returned.
     *Deprecated now that the REST gateway supports base64 encoding of bytes
     *fields.
     * </pre>
     *
     * <code>string r_hash_str = 1 [deprecated = true];</code>
     * @return The rHashStr.
     */
    @java.lang.Deprecated java.lang.String getRHashStr();
    /**
     * <pre>
     *The hex-encoded payment hash of the invoice to be looked up. The passed
     *payment hash must be exactly 32 bytes, otherwise an error is returned.
     *Deprecated now that the REST gateway supports base64 encoding of bytes
     *fields.
     * </pre>
     *
     * <code>string r_hash_str = 1 [deprecated = true];</code>
     * @return The bytes for rHashStr.
     */
    @java.lang.Deprecated com.google.protobuf.ByteString
        getRHashStrBytes();

    /**
     * <pre>
     *The payment hash of the invoice to be looked up. When using REST, this field
     *must be encoded as base64.
     * </pre>
     *
     * <code>bytes r_hash = 2;</code>
     * @return The rHash.
     */
    com.google.protobuf.ByteString getRHash();
  }
  /**
   * Protobuf type {@code co.anode.anodium.PaymentHash}
   */
  public  static final class PaymentHash extends
      com.google.protobuf.GeneratedMessageLite<
          PaymentHash, PaymentHash.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.PaymentHash)
      PaymentHashOrBuilder {
    private PaymentHash() {
      rHashStr_ = "";
      rHash_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int R_HASH_STR_FIELD_NUMBER = 1;
    private java.lang.String rHashStr_;
    /**
     * <pre>
     *The hex-encoded payment hash of the invoice to be looked up. The passed
     *payment hash must be exactly 32 bytes, otherwise an error is returned.
     *Deprecated now that the REST gateway supports base64 encoding of bytes
     *fields.
     * </pre>
     *
     * <code>string r_hash_str = 1 [deprecated = true];</code>
     * @return The rHashStr.
     */
    @java.lang.Override
    @java.lang.Deprecated public java.lang.String getRHashStr() {
      return rHashStr_;
    }
    /**
     * <pre>
     *The hex-encoded payment hash of the invoice to be looked up. The passed
     *payment hash must be exactly 32 bytes, otherwise an error is returned.
     *Deprecated now that the REST gateway supports base64 encoding of bytes
     *fields.
     * </pre>
     *
     * <code>string r_hash_str = 1 [deprecated = true];</code>
     * @return The bytes for rHashStr.
     */
    @java.lang.Override
    @java.lang.Deprecated public com.google.protobuf.ByteString
        getRHashStrBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(rHashStr_);
    }
    /**
     * <pre>
     *The hex-encoded payment hash of the invoice to be looked up. The passed
     *payment hash must be exactly 32 bytes, otherwise an error is returned.
     *Deprecated now that the REST gateway supports base64 encoding of bytes
     *fields.
     * </pre>
     *
     * <code>string r_hash_str = 1 [deprecated = true];</code>
     * @param value The rHashStr to set.
     */
    private void setRHashStr(
        java.lang.String value) {
      value.getClass();
  
      rHashStr_ = value;
    }
    /**
     * <pre>
     *The hex-encoded payment hash of the invoice to be looked up. The passed
     *payment hash must be exactly 32 bytes, otherwise an error is returned.
     *Deprecated now that the REST gateway supports base64 encoding of bytes
     *fields.
     * </pre>
     *
     * <code>string r_hash_str = 1 [deprecated = true];</code>
     */
    private void clearRHashStr() {
      
      rHashStr_ = getDefaultInstance().getRHashStr();
    }
    /**
     * <pre>
     *The hex-encoded payment hash of the invoice to be looked up. The passed
     *payment hash must be exactly 32 bytes, otherwise an error is returned.
     *Deprecated now that the REST gateway supports base64 encoding of bytes
     *fields.
     * </pre>
     *
     * <code>string r_hash_str = 1 [deprecated = true];</code>
     * @param value The bytes for rHashStr to set.
     */
    private void setRHashStrBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      rHashStr_ = value.toStringUtf8();
      
    }

    public static final int R_HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString rHash_;
    /**
     * <pre>
     *The payment hash of the invoice to be looked up. When using REST, this field
     *must be encoded as base64.
     * </pre>
     *
     * <code>bytes r_hash = 2;</code>
     * @return The rHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getRHash() {
      return rHash_;
    }
    /**
     * <pre>
     *The payment hash of the invoice to be looked up. When using REST, this field
     *must be encoded as base64.
     * </pre>
     *
     * <code>bytes r_hash = 2;</code>
     * @param value The rHash to set.
     */
    private void setRHash(com.google.protobuf.ByteString value) {
      value.getClass();
  
      rHash_ = value;
    }
    /**
     * <pre>
     *The payment hash of the invoice to be looked up. When using REST, this field
     *must be encoded as base64.
     * </pre>
     *
     * <code>bytes r_hash = 2;</code>
     */
    private void clearRHash() {
      
      rHash_ = getDefaultInstance().getRHash();
    }

    public static co.anode.anodium.Rpc.PaymentHash parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PaymentHash parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PaymentHash parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PaymentHash parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PaymentHash parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PaymentHash parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PaymentHash parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PaymentHash parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PaymentHash parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PaymentHash parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PaymentHash parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PaymentHash parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.PaymentHash prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.PaymentHash}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.PaymentHash, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.PaymentHash)
        co.anode.anodium.Rpc.PaymentHashOrBuilder {
      // Construct using co.anode.anodium.Rpc.PaymentHash.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The hex-encoded payment hash of the invoice to be looked up. The passed
       *payment hash must be exactly 32 bytes, otherwise an error is returned.
       *Deprecated now that the REST gateway supports base64 encoding of bytes
       *fields.
       * </pre>
       *
       * <code>string r_hash_str = 1 [deprecated = true];</code>
       * @return The rHashStr.
       */
      @java.lang.Override
      @java.lang.Deprecated public java.lang.String getRHashStr() {
        return instance.getRHashStr();
      }
      /**
       * <pre>
       *The hex-encoded payment hash of the invoice to be looked up. The passed
       *payment hash must be exactly 32 bytes, otherwise an error is returned.
       *Deprecated now that the REST gateway supports base64 encoding of bytes
       *fields.
       * </pre>
       *
       * <code>string r_hash_str = 1 [deprecated = true];</code>
       * @return The bytes for rHashStr.
       */
      @java.lang.Override
      @java.lang.Deprecated public com.google.protobuf.ByteString
          getRHashStrBytes() {
        return instance.getRHashStrBytes();
      }
      /**
       * <pre>
       *The hex-encoded payment hash of the invoice to be looked up. The passed
       *payment hash must be exactly 32 bytes, otherwise an error is returned.
       *Deprecated now that the REST gateway supports base64 encoding of bytes
       *fields.
       * </pre>
       *
       * <code>string r_hash_str = 1 [deprecated = true];</code>
       * @param value The rHashStr to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setRHashStr(
          java.lang.String value) {
        copyOnWrite();
        instance.setRHashStr(value);
        return this;
      }
      /**
       * <pre>
       *The hex-encoded payment hash of the invoice to be looked up. The passed
       *payment hash must be exactly 32 bytes, otherwise an error is returned.
       *Deprecated now that the REST gateway supports base64 encoding of bytes
       *fields.
       * </pre>
       *
       * <code>string r_hash_str = 1 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearRHashStr() {
        copyOnWrite();
        instance.clearRHashStr();
        return this;
      }
      /**
       * <pre>
       *The hex-encoded payment hash of the invoice to be looked up. The passed
       *payment hash must be exactly 32 bytes, otherwise an error is returned.
       *Deprecated now that the REST gateway supports base64 encoding of bytes
       *fields.
       * </pre>
       *
       * <code>string r_hash_str = 1 [deprecated = true];</code>
       * @param value The bytes for rHashStr to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setRHashStrBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setRHashStrBytes(value);
        return this;
      }

      /**
       * <pre>
       *The payment hash of the invoice to be looked up. When using REST, this field
       *must be encoded as base64.
       * </pre>
       *
       * <code>bytes r_hash = 2;</code>
       * @return The rHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getRHash() {
        return instance.getRHash();
      }
      /**
       * <pre>
       *The payment hash of the invoice to be looked up. When using REST, this field
       *must be encoded as base64.
       * </pre>
       *
       * <code>bytes r_hash = 2;</code>
       * @param value The rHash to set.
       * @return This builder for chaining.
       */
      public Builder setRHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setRHash(value);
        return this;
      }
      /**
       * <pre>
       *The payment hash of the invoice to be looked up. When using REST, this field
       *must be encoded as base64.
       * </pre>
       *
       * <code>bytes r_hash = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearRHash() {
        copyOnWrite();
        instance.clearRHash();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.PaymentHash)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.PaymentHash();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "rHashStr_",
              "rHash_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0208\u0002\n" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.PaymentHash> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.PaymentHash.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.PaymentHash>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.PaymentHash)
    private static final co.anode.anodium.Rpc.PaymentHash DEFAULT_INSTANCE;
    static {
      PaymentHash defaultInstance = new PaymentHash();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        PaymentHash.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.PaymentHash getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<PaymentHash> PARSER;

    public static com.google.protobuf.Parser<PaymentHash> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ListInvoiceRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ListInvoiceRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *If set, only invoices that are not settled and not canceled will be returned
     *in the response.
     * </pre>
     *
     * <code>bool pending_only = 1;</code>
     * @return The pendingOnly.
     */
    boolean getPendingOnly();

    /**
     * <pre>
     *The index of an invoice that will be used as either the start or end of a
     *query to determine which invoices should be returned in the response.
     * </pre>
     *
     * <code>uint64 index_offset = 4;</code>
     * @return The indexOffset.
     */
    long getIndexOffset();

    /**
     * <pre>
     * The max number of invoices to return in the response to this query.
     * </pre>
     *
     * <code>uint64 num_max_invoices = 5;</code>
     * @return The numMaxInvoices.
     */
    long getNumMaxInvoices();

    /**
     * <pre>
     *If set, the invoices returned will result from seeking backwards from the
     *specified index offset. This can be used to paginate backwards.
     * </pre>
     *
     * <code>bool reversed = 6;</code>
     * @return The reversed.
     */
    boolean getReversed();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ListInvoiceRequest}
   */
  public  static final class ListInvoiceRequest extends
      com.google.protobuf.GeneratedMessageLite<
          ListInvoiceRequest, ListInvoiceRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ListInvoiceRequest)
      ListInvoiceRequestOrBuilder {
    private ListInvoiceRequest() {
    }
    public static final int PENDING_ONLY_FIELD_NUMBER = 1;
    private boolean pendingOnly_;
    /**
     * <pre>
     *If set, only invoices that are not settled and not canceled will be returned
     *in the response.
     * </pre>
     *
     * <code>bool pending_only = 1;</code>
     * @return The pendingOnly.
     */
    @java.lang.Override
    public boolean getPendingOnly() {
      return pendingOnly_;
    }
    /**
     * <pre>
     *If set, only invoices that are not settled and not canceled will be returned
     *in the response.
     * </pre>
     *
     * <code>bool pending_only = 1;</code>
     * @param value The pendingOnly to set.
     */
    private void setPendingOnly(boolean value) {
      
      pendingOnly_ = value;
    }
    /**
     * <pre>
     *If set, only invoices that are not settled and not canceled will be returned
     *in the response.
     * </pre>
     *
     * <code>bool pending_only = 1;</code>
     */
    private void clearPendingOnly() {
      
      pendingOnly_ = false;
    }

    public static final int INDEX_OFFSET_FIELD_NUMBER = 4;
    private long indexOffset_;
    /**
     * <pre>
     *The index of an invoice that will be used as either the start or end of a
     *query to determine which invoices should be returned in the response.
     * </pre>
     *
     * <code>uint64 index_offset = 4;</code>
     * @return The indexOffset.
     */
    @java.lang.Override
    public long getIndexOffset() {
      return indexOffset_;
    }
    /**
     * <pre>
     *The index of an invoice that will be used as either the start or end of a
     *query to determine which invoices should be returned in the response.
     * </pre>
     *
     * <code>uint64 index_offset = 4;</code>
     * @param value The indexOffset to set.
     */
    private void setIndexOffset(long value) {
      
      indexOffset_ = value;
    }
    /**
     * <pre>
     *The index of an invoice that will be used as either the start or end of a
     *query to determine which invoices should be returned in the response.
     * </pre>
     *
     * <code>uint64 index_offset = 4;</code>
     */
    private void clearIndexOffset() {
      
      indexOffset_ = 0L;
    }

    public static final int NUM_MAX_INVOICES_FIELD_NUMBER = 5;
    private long numMaxInvoices_;
    /**
     * <pre>
     * The max number of invoices to return in the response to this query.
     * </pre>
     *
     * <code>uint64 num_max_invoices = 5;</code>
     * @return The numMaxInvoices.
     */
    @java.lang.Override
    public long getNumMaxInvoices() {
      return numMaxInvoices_;
    }
    /**
     * <pre>
     * The max number of invoices to return in the response to this query.
     * </pre>
     *
     * <code>uint64 num_max_invoices = 5;</code>
     * @param value The numMaxInvoices to set.
     */
    private void setNumMaxInvoices(long value) {
      
      numMaxInvoices_ = value;
    }
    /**
     * <pre>
     * The max number of invoices to return in the response to this query.
     * </pre>
     *
     * <code>uint64 num_max_invoices = 5;</code>
     */
    private void clearNumMaxInvoices() {
      
      numMaxInvoices_ = 0L;
    }

    public static final int REVERSED_FIELD_NUMBER = 6;
    private boolean reversed_;
    /**
     * <pre>
     *If set, the invoices returned will result from seeking backwards from the
     *specified index offset. This can be used to paginate backwards.
     * </pre>
     *
     * <code>bool reversed = 6;</code>
     * @return The reversed.
     */
    @java.lang.Override
    public boolean getReversed() {
      return reversed_;
    }
    /**
     * <pre>
     *If set, the invoices returned will result from seeking backwards from the
     *specified index offset. This can be used to paginate backwards.
     * </pre>
     *
     * <code>bool reversed = 6;</code>
     * @param value The reversed to set.
     */
    private void setReversed(boolean value) {
      
      reversed_ = value;
    }
    /**
     * <pre>
     *If set, the invoices returned will result from seeking backwards from the
     *specified index offset. This can be used to paginate backwards.
     * </pre>
     *
     * <code>bool reversed = 6;</code>
     */
    private void clearReversed() {
      
      reversed_ = false;
    }

    public static co.anode.anodium.Rpc.ListInvoiceRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListInvoiceRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListInvoiceRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListInvoiceRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListInvoiceRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListInvoiceRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListInvoiceRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListInvoiceRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListInvoiceRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListInvoiceRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListInvoiceRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListInvoiceRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ListInvoiceRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ListInvoiceRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ListInvoiceRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ListInvoiceRequest)
        co.anode.anodium.Rpc.ListInvoiceRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.ListInvoiceRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *If set, only invoices that are not settled and not canceled will be returned
       *in the response.
       * </pre>
       *
       * <code>bool pending_only = 1;</code>
       * @return The pendingOnly.
       */
      @java.lang.Override
      public boolean getPendingOnly() {
        return instance.getPendingOnly();
      }
      /**
       * <pre>
       *If set, only invoices that are not settled and not canceled will be returned
       *in the response.
       * </pre>
       *
       * <code>bool pending_only = 1;</code>
       * @param value The pendingOnly to set.
       * @return This builder for chaining.
       */
      public Builder setPendingOnly(boolean value) {
        copyOnWrite();
        instance.setPendingOnly(value);
        return this;
      }
      /**
       * <pre>
       *If set, only invoices that are not settled and not canceled will be returned
       *in the response.
       * </pre>
       *
       * <code>bool pending_only = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPendingOnly() {
        copyOnWrite();
        instance.clearPendingOnly();
        return this;
      }

      /**
       * <pre>
       *The index of an invoice that will be used as either the start or end of a
       *query to determine which invoices should be returned in the response.
       * </pre>
       *
       * <code>uint64 index_offset = 4;</code>
       * @return The indexOffset.
       */
      @java.lang.Override
      public long getIndexOffset() {
        return instance.getIndexOffset();
      }
      /**
       * <pre>
       *The index of an invoice that will be used as either the start or end of a
       *query to determine which invoices should be returned in the response.
       * </pre>
       *
       * <code>uint64 index_offset = 4;</code>
       * @param value The indexOffset to set.
       * @return This builder for chaining.
       */
      public Builder setIndexOffset(long value) {
        copyOnWrite();
        instance.setIndexOffset(value);
        return this;
      }
      /**
       * <pre>
       *The index of an invoice that will be used as either the start or end of a
       *query to determine which invoices should be returned in the response.
       * </pre>
       *
       * <code>uint64 index_offset = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearIndexOffset() {
        copyOnWrite();
        instance.clearIndexOffset();
        return this;
      }

      /**
       * <pre>
       * The max number of invoices to return in the response to this query.
       * </pre>
       *
       * <code>uint64 num_max_invoices = 5;</code>
       * @return The numMaxInvoices.
       */
      @java.lang.Override
      public long getNumMaxInvoices() {
        return instance.getNumMaxInvoices();
      }
      /**
       * <pre>
       * The max number of invoices to return in the response to this query.
       * </pre>
       *
       * <code>uint64 num_max_invoices = 5;</code>
       * @param value The numMaxInvoices to set.
       * @return This builder for chaining.
       */
      public Builder setNumMaxInvoices(long value) {
        copyOnWrite();
        instance.setNumMaxInvoices(value);
        return this;
      }
      /**
       * <pre>
       * The max number of invoices to return in the response to this query.
       * </pre>
       *
       * <code>uint64 num_max_invoices = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumMaxInvoices() {
        copyOnWrite();
        instance.clearNumMaxInvoices();
        return this;
      }

      /**
       * <pre>
       *If set, the invoices returned will result from seeking backwards from the
       *specified index offset. This can be used to paginate backwards.
       * </pre>
       *
       * <code>bool reversed = 6;</code>
       * @return The reversed.
       */
      @java.lang.Override
      public boolean getReversed() {
        return instance.getReversed();
      }
      /**
       * <pre>
       *If set, the invoices returned will result from seeking backwards from the
       *specified index offset. This can be used to paginate backwards.
       * </pre>
       *
       * <code>bool reversed = 6;</code>
       * @param value The reversed to set.
       * @return This builder for chaining.
       */
      public Builder setReversed(boolean value) {
        copyOnWrite();
        instance.setReversed(value);
        return this;
      }
      /**
       * <pre>
       *If set, the invoices returned will result from seeking backwards from the
       *specified index offset. This can be used to paginate backwards.
       * </pre>
       *
       * <code>bool reversed = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearReversed() {
        copyOnWrite();
        instance.clearReversed();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ListInvoiceRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ListInvoiceRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "pendingOnly_",
              "indexOffset_",
              "numMaxInvoices_",
              "reversed_",
            };
            java.lang.String info =
                "\u0000\u0004\u0000\u0000\u0001\u0006\u0004\u0000\u0000\u0000\u0001\u0007\u0004\u0003" +
                "\u0005\u0003\u0006\u0007";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ListInvoiceRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ListInvoiceRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ListInvoiceRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ListInvoiceRequest)
    private static final co.anode.anodium.Rpc.ListInvoiceRequest DEFAULT_INSTANCE;
    static {
      ListInvoiceRequest defaultInstance = new ListInvoiceRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ListInvoiceRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ListInvoiceRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ListInvoiceRequest> PARSER;

    public static com.google.protobuf.Parser<ListInvoiceRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ListInvoiceResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ListInvoiceResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *A list of invoices from the time slice of the time series specified in the
     *request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
     */
    java.util.List<co.anode.anodium.Rpc.Invoice> 
        getInvoicesList();
    /**
     * <pre>
     *A list of invoices from the time slice of the time series specified in the
     *request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
     */
    co.anode.anodium.Rpc.Invoice getInvoices(int index);
    /**
     * <pre>
     *A list of invoices from the time slice of the time series specified in the
     *request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
     */
    int getInvoicesCount();

    /**
     * <pre>
     *The index of the last item in the set of returned invoices. This can be used
     *to seek further, pagination style.
     * </pre>
     *
     * <code>uint64 last_index_offset = 2;</code>
     * @return The lastIndexOffset.
     */
    long getLastIndexOffset();

    /**
     * <pre>
     *The index of the last item in the set of returned invoices. This can be used
     *to seek backwards, pagination style.
     * </pre>
     *
     * <code>uint64 first_index_offset = 3;</code>
     * @return The firstIndexOffset.
     */
    long getFirstIndexOffset();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ListInvoiceResponse}
   */
  public  static final class ListInvoiceResponse extends
      com.google.protobuf.GeneratedMessageLite<
          ListInvoiceResponse, ListInvoiceResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ListInvoiceResponse)
      ListInvoiceResponseOrBuilder {
    private ListInvoiceResponse() {
      invoices_ = emptyProtobufList();
    }
    public static final int INVOICES_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Invoice> invoices_;
    /**
     * <pre>
     *A list of invoices from the time slice of the time series specified in the
     *request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.Invoice> getInvoicesList() {
      return invoices_;
    }
    /**
     * <pre>
     *A list of invoices from the time slice of the time series specified in the
     *request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.InvoiceOrBuilder> 
        getInvoicesOrBuilderList() {
      return invoices_;
    }
    /**
     * <pre>
     *A list of invoices from the time slice of the time series specified in the
     *request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
     */
    @java.lang.Override
    public int getInvoicesCount() {
      return invoices_.size();
    }
    /**
     * <pre>
     *A list of invoices from the time slice of the time series specified in the
     *request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Invoice getInvoices(int index) {
      return invoices_.get(index);
    }
    /**
     * <pre>
     *A list of invoices from the time slice of the time series specified in the
     *request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
     */
    public co.anode.anodium.Rpc.InvoiceOrBuilder getInvoicesOrBuilder(
        int index) {
      return invoices_.get(index);
    }
    private void ensureInvoicesIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Invoice> tmp = invoices_;
      if (!tmp.isModifiable()) {
        invoices_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     *A list of invoices from the time slice of the time series specified in the
     *request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
     */
    private void setInvoices(
        int index, co.anode.anodium.Rpc.Invoice value) {
      value.getClass();
  ensureInvoicesIsMutable();
      invoices_.set(index, value);
    }
    /**
     * <pre>
     *A list of invoices from the time slice of the time series specified in the
     *request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
     */
    private void addInvoices(co.anode.anodium.Rpc.Invoice value) {
      value.getClass();
  ensureInvoicesIsMutable();
      invoices_.add(value);
    }
    /**
     * <pre>
     *A list of invoices from the time slice of the time series specified in the
     *request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
     */
    private void addInvoices(
        int index, co.anode.anodium.Rpc.Invoice value) {
      value.getClass();
  ensureInvoicesIsMutable();
      invoices_.add(index, value);
    }
    /**
     * <pre>
     *A list of invoices from the time slice of the time series specified in the
     *request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
     */
    private void addAllInvoices(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.Invoice> values) {
      ensureInvoicesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, invoices_);
    }
    /**
     * <pre>
     *A list of invoices from the time slice of the time series specified in the
     *request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
     */
    private void clearInvoices() {
      invoices_ = emptyProtobufList();
    }
    /**
     * <pre>
     *A list of invoices from the time slice of the time series specified in the
     *request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
     */
    private void removeInvoices(int index) {
      ensureInvoicesIsMutable();
      invoices_.remove(index);
    }

    public static final int LAST_INDEX_OFFSET_FIELD_NUMBER = 2;
    private long lastIndexOffset_;
    /**
     * <pre>
     *The index of the last item in the set of returned invoices. This can be used
     *to seek further, pagination style.
     * </pre>
     *
     * <code>uint64 last_index_offset = 2;</code>
     * @return The lastIndexOffset.
     */
    @java.lang.Override
    public long getLastIndexOffset() {
      return lastIndexOffset_;
    }
    /**
     * <pre>
     *The index of the last item in the set of returned invoices. This can be used
     *to seek further, pagination style.
     * </pre>
     *
     * <code>uint64 last_index_offset = 2;</code>
     * @param value The lastIndexOffset to set.
     */
    private void setLastIndexOffset(long value) {
      
      lastIndexOffset_ = value;
    }
    /**
     * <pre>
     *The index of the last item in the set of returned invoices. This can be used
     *to seek further, pagination style.
     * </pre>
     *
     * <code>uint64 last_index_offset = 2;</code>
     */
    private void clearLastIndexOffset() {
      
      lastIndexOffset_ = 0L;
    }

    public static final int FIRST_INDEX_OFFSET_FIELD_NUMBER = 3;
    private long firstIndexOffset_;
    /**
     * <pre>
     *The index of the last item in the set of returned invoices. This can be used
     *to seek backwards, pagination style.
     * </pre>
     *
     * <code>uint64 first_index_offset = 3;</code>
     * @return The firstIndexOffset.
     */
    @java.lang.Override
    public long getFirstIndexOffset() {
      return firstIndexOffset_;
    }
    /**
     * <pre>
     *The index of the last item in the set of returned invoices. This can be used
     *to seek backwards, pagination style.
     * </pre>
     *
     * <code>uint64 first_index_offset = 3;</code>
     * @param value The firstIndexOffset to set.
     */
    private void setFirstIndexOffset(long value) {
      
      firstIndexOffset_ = value;
    }
    /**
     * <pre>
     *The index of the last item in the set of returned invoices. This can be used
     *to seek backwards, pagination style.
     * </pre>
     *
     * <code>uint64 first_index_offset = 3;</code>
     */
    private void clearFirstIndexOffset() {
      
      firstIndexOffset_ = 0L;
    }

    public static co.anode.anodium.Rpc.ListInvoiceResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListInvoiceResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListInvoiceResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListInvoiceResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListInvoiceResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListInvoiceResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListInvoiceResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListInvoiceResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListInvoiceResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListInvoiceResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListInvoiceResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListInvoiceResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ListInvoiceResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ListInvoiceResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ListInvoiceResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ListInvoiceResponse)
        co.anode.anodium.Rpc.ListInvoiceResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.ListInvoiceResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *A list of invoices from the time slice of the time series specified in the
       *request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.Invoice> getInvoicesList() {
        return java.util.Collections.unmodifiableList(
            instance.getInvoicesList());
      }
      /**
       * <pre>
       *A list of invoices from the time slice of the time series specified in the
       *request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
       */
      @java.lang.Override
      public int getInvoicesCount() {
        return instance.getInvoicesCount();
      }/**
       * <pre>
       *A list of invoices from the time slice of the time series specified in the
       *request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Invoice getInvoices(int index) {
        return instance.getInvoices(index);
      }
      /**
       * <pre>
       *A list of invoices from the time slice of the time series specified in the
       *request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
       */
      public Builder setInvoices(
          int index, co.anode.anodium.Rpc.Invoice value) {
        copyOnWrite();
        instance.setInvoices(index, value);
        return this;
      }
      /**
       * <pre>
       *A list of invoices from the time slice of the time series specified in the
       *request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
       */
      public Builder setInvoices(
          int index, co.anode.anodium.Rpc.Invoice.Builder builderForValue) {
        copyOnWrite();
        instance.setInvoices(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *A list of invoices from the time slice of the time series specified in the
       *request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
       */
      public Builder addInvoices(co.anode.anodium.Rpc.Invoice value) {
        copyOnWrite();
        instance.addInvoices(value);
        return this;
      }
      /**
       * <pre>
       *A list of invoices from the time slice of the time series specified in the
       *request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
       */
      public Builder addInvoices(
          int index, co.anode.anodium.Rpc.Invoice value) {
        copyOnWrite();
        instance.addInvoices(index, value);
        return this;
      }
      /**
       * <pre>
       *A list of invoices from the time slice of the time series specified in the
       *request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
       */
      public Builder addInvoices(
          co.anode.anodium.Rpc.Invoice.Builder builderForValue) {
        copyOnWrite();
        instance.addInvoices(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *A list of invoices from the time slice of the time series specified in the
       *request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
       */
      public Builder addInvoices(
          int index, co.anode.anodium.Rpc.Invoice.Builder builderForValue) {
        copyOnWrite();
        instance.addInvoices(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *A list of invoices from the time slice of the time series specified in the
       *request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
       */
      public Builder addAllInvoices(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.Invoice> values) {
        copyOnWrite();
        instance.addAllInvoices(values);
        return this;
      }
      /**
       * <pre>
       *A list of invoices from the time slice of the time series specified in the
       *request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
       */
      public Builder clearInvoices() {
        copyOnWrite();
        instance.clearInvoices();
        return this;
      }
      /**
       * <pre>
       *A list of invoices from the time slice of the time series specified in the
       *request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Invoice invoices = 1;</code>
       */
      public Builder removeInvoices(int index) {
        copyOnWrite();
        instance.removeInvoices(index);
        return this;
      }

      /**
       * <pre>
       *The index of the last item in the set of returned invoices. This can be used
       *to seek further, pagination style.
       * </pre>
       *
       * <code>uint64 last_index_offset = 2;</code>
       * @return The lastIndexOffset.
       */
      @java.lang.Override
      public long getLastIndexOffset() {
        return instance.getLastIndexOffset();
      }
      /**
       * <pre>
       *The index of the last item in the set of returned invoices. This can be used
       *to seek further, pagination style.
       * </pre>
       *
       * <code>uint64 last_index_offset = 2;</code>
       * @param value The lastIndexOffset to set.
       * @return This builder for chaining.
       */
      public Builder setLastIndexOffset(long value) {
        copyOnWrite();
        instance.setLastIndexOffset(value);
        return this;
      }
      /**
       * <pre>
       *The index of the last item in the set of returned invoices. This can be used
       *to seek further, pagination style.
       * </pre>
       *
       * <code>uint64 last_index_offset = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearLastIndexOffset() {
        copyOnWrite();
        instance.clearLastIndexOffset();
        return this;
      }

      /**
       * <pre>
       *The index of the last item in the set of returned invoices. This can be used
       *to seek backwards, pagination style.
       * </pre>
       *
       * <code>uint64 first_index_offset = 3;</code>
       * @return The firstIndexOffset.
       */
      @java.lang.Override
      public long getFirstIndexOffset() {
        return instance.getFirstIndexOffset();
      }
      /**
       * <pre>
       *The index of the last item in the set of returned invoices. This can be used
       *to seek backwards, pagination style.
       * </pre>
       *
       * <code>uint64 first_index_offset = 3;</code>
       * @param value The firstIndexOffset to set.
       * @return This builder for chaining.
       */
      public Builder setFirstIndexOffset(long value) {
        copyOnWrite();
        instance.setFirstIndexOffset(value);
        return this;
      }
      /**
       * <pre>
       *The index of the last item in the set of returned invoices. This can be used
       *to seek backwards, pagination style.
       * </pre>
       *
       * <code>uint64 first_index_offset = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearFirstIndexOffset() {
        copyOnWrite();
        instance.clearFirstIndexOffset();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ListInvoiceResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ListInvoiceResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "invoices_",
              co.anode.anodium.Rpc.Invoice.class,
              "lastIndexOffset_",
              "firstIndexOffset_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0003\u0003\u0000\u0001\u0000\u0001\u001b\u0002\u0003" +
                "\u0003\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ListInvoiceResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ListInvoiceResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ListInvoiceResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ListInvoiceResponse)
    private static final co.anode.anodium.Rpc.ListInvoiceResponse DEFAULT_INSTANCE;
    static {
      ListInvoiceResponse defaultInstance = new ListInvoiceResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ListInvoiceResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ListInvoiceResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ListInvoiceResponse> PARSER;

    public static com.google.protobuf.Parser<ListInvoiceResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface InvoiceSubscriptionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.InvoiceSubscription)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *If specified (non-zero), then we'll first start by sending out
     *notifications for all added indexes with an add_index greater than this
     *value. This allows callers to catch up on any events they missed while they
     *weren't connected to the streaming RPC.
     * </pre>
     *
     * <code>uint64 add_index = 1;</code>
     * @return The addIndex.
     */
    long getAddIndex();

    /**
     * <pre>
     *If specified (non-zero), then we'll first start by sending out
     *notifications for all settled indexes with an settle_index greater than
     *this value. This allows callers to catch up on any events they missed while
     *they weren't connected to the streaming RPC.
     * </pre>
     *
     * <code>uint64 settle_index = 2;</code>
     * @return The settleIndex.
     */
    long getSettleIndex();
  }
  /**
   * Protobuf type {@code co.anode.anodium.InvoiceSubscription}
   */
  public  static final class InvoiceSubscription extends
      com.google.protobuf.GeneratedMessageLite<
          InvoiceSubscription, InvoiceSubscription.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.InvoiceSubscription)
      InvoiceSubscriptionOrBuilder {
    private InvoiceSubscription() {
    }
    public static final int ADD_INDEX_FIELD_NUMBER = 1;
    private long addIndex_;
    /**
     * <pre>
     *If specified (non-zero), then we'll first start by sending out
     *notifications for all added indexes with an add_index greater than this
     *value. This allows callers to catch up on any events they missed while they
     *weren't connected to the streaming RPC.
     * </pre>
     *
     * <code>uint64 add_index = 1;</code>
     * @return The addIndex.
     */
    @java.lang.Override
    public long getAddIndex() {
      return addIndex_;
    }
    /**
     * <pre>
     *If specified (non-zero), then we'll first start by sending out
     *notifications for all added indexes with an add_index greater than this
     *value. This allows callers to catch up on any events they missed while they
     *weren't connected to the streaming RPC.
     * </pre>
     *
     * <code>uint64 add_index = 1;</code>
     * @param value The addIndex to set.
     */
    private void setAddIndex(long value) {
      
      addIndex_ = value;
    }
    /**
     * <pre>
     *If specified (non-zero), then we'll first start by sending out
     *notifications for all added indexes with an add_index greater than this
     *value. This allows callers to catch up on any events they missed while they
     *weren't connected to the streaming RPC.
     * </pre>
     *
     * <code>uint64 add_index = 1;</code>
     */
    private void clearAddIndex() {
      
      addIndex_ = 0L;
    }

    public static final int SETTLE_INDEX_FIELD_NUMBER = 2;
    private long settleIndex_;
    /**
     * <pre>
     *If specified (non-zero), then we'll first start by sending out
     *notifications for all settled indexes with an settle_index greater than
     *this value. This allows callers to catch up on any events they missed while
     *they weren't connected to the streaming RPC.
     * </pre>
     *
     * <code>uint64 settle_index = 2;</code>
     * @return The settleIndex.
     */
    @java.lang.Override
    public long getSettleIndex() {
      return settleIndex_;
    }
    /**
     * <pre>
     *If specified (non-zero), then we'll first start by sending out
     *notifications for all settled indexes with an settle_index greater than
     *this value. This allows callers to catch up on any events they missed while
     *they weren't connected to the streaming RPC.
     * </pre>
     *
     * <code>uint64 settle_index = 2;</code>
     * @param value The settleIndex to set.
     */
    private void setSettleIndex(long value) {
      
      settleIndex_ = value;
    }
    /**
     * <pre>
     *If specified (non-zero), then we'll first start by sending out
     *notifications for all settled indexes with an settle_index greater than
     *this value. This allows callers to catch up on any events they missed while
     *they weren't connected to the streaming RPC.
     * </pre>
     *
     * <code>uint64 settle_index = 2;</code>
     */
    private void clearSettleIndex() {
      
      settleIndex_ = 0L;
    }

    public static co.anode.anodium.Rpc.InvoiceSubscription parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.InvoiceSubscription parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.InvoiceSubscription parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.InvoiceSubscription parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.InvoiceSubscription parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.InvoiceSubscription parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.InvoiceSubscription parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.InvoiceSubscription parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.InvoiceSubscription parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.InvoiceSubscription parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.InvoiceSubscription parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.InvoiceSubscription parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.InvoiceSubscription prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.InvoiceSubscription}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.InvoiceSubscription, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.InvoiceSubscription)
        co.anode.anodium.Rpc.InvoiceSubscriptionOrBuilder {
      // Construct using co.anode.anodium.Rpc.InvoiceSubscription.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *If specified (non-zero), then we'll first start by sending out
       *notifications for all added indexes with an add_index greater than this
       *value. This allows callers to catch up on any events they missed while they
       *weren't connected to the streaming RPC.
       * </pre>
       *
       * <code>uint64 add_index = 1;</code>
       * @return The addIndex.
       */
      @java.lang.Override
      public long getAddIndex() {
        return instance.getAddIndex();
      }
      /**
       * <pre>
       *If specified (non-zero), then we'll first start by sending out
       *notifications for all added indexes with an add_index greater than this
       *value. This allows callers to catch up on any events they missed while they
       *weren't connected to the streaming RPC.
       * </pre>
       *
       * <code>uint64 add_index = 1;</code>
       * @param value The addIndex to set.
       * @return This builder for chaining.
       */
      public Builder setAddIndex(long value) {
        copyOnWrite();
        instance.setAddIndex(value);
        return this;
      }
      /**
       * <pre>
       *If specified (non-zero), then we'll first start by sending out
       *notifications for all added indexes with an add_index greater than this
       *value. This allows callers to catch up on any events they missed while they
       *weren't connected to the streaming RPC.
       * </pre>
       *
       * <code>uint64 add_index = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAddIndex() {
        copyOnWrite();
        instance.clearAddIndex();
        return this;
      }

      /**
       * <pre>
       *If specified (non-zero), then we'll first start by sending out
       *notifications for all settled indexes with an settle_index greater than
       *this value. This allows callers to catch up on any events they missed while
       *they weren't connected to the streaming RPC.
       * </pre>
       *
       * <code>uint64 settle_index = 2;</code>
       * @return The settleIndex.
       */
      @java.lang.Override
      public long getSettleIndex() {
        return instance.getSettleIndex();
      }
      /**
       * <pre>
       *If specified (non-zero), then we'll first start by sending out
       *notifications for all settled indexes with an settle_index greater than
       *this value. This allows callers to catch up on any events they missed while
       *they weren't connected to the streaming RPC.
       * </pre>
       *
       * <code>uint64 settle_index = 2;</code>
       * @param value The settleIndex to set.
       * @return This builder for chaining.
       */
      public Builder setSettleIndex(long value) {
        copyOnWrite();
        instance.setSettleIndex(value);
        return this;
      }
      /**
       * <pre>
       *If specified (non-zero), then we'll first start by sending out
       *notifications for all settled indexes with an settle_index greater than
       *this value. This allows callers to catch up on any events they missed while
       *they weren't connected to the streaming RPC.
       * </pre>
       *
       * <code>uint64 settle_index = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSettleIndex() {
        copyOnWrite();
        instance.clearSettleIndex();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.InvoiceSubscription)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.InvoiceSubscription();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "addIndex_",
              "settleIndex_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0003\u0002\u0003" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.InvoiceSubscription> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.InvoiceSubscription.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.InvoiceSubscription>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.InvoiceSubscription)
    private static final co.anode.anodium.Rpc.InvoiceSubscription DEFAULT_INSTANCE;
    static {
      InvoiceSubscription defaultInstance = new InvoiceSubscription();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        InvoiceSubscription.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.InvoiceSubscription getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<InvoiceSubscription> PARSER;

    public static com.google.protobuf.Parser<InvoiceSubscription> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PaymentOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.Payment)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The payment hash
     * </pre>
     *
     * <code>string payment_hash = 1;</code>
     * @return The paymentHash.
     */
    java.lang.String getPaymentHash();
    /**
     * <pre>
     * The payment hash
     * </pre>
     *
     * <code>string payment_hash = 1;</code>
     * @return The bytes for paymentHash.
     */
    com.google.protobuf.ByteString
        getPaymentHashBytes();

    /**
     * <pre>
     * Deprecated, use value_sat or value_msat.
     * </pre>
     *
     * <code>int64 value = 2 [deprecated = true];</code>
     * @return The value.
     */
    @java.lang.Deprecated long getValue();

    /**
     * <pre>
     * Deprecated, use creation_time_ns
     * </pre>
     *
     * <code>int64 creation_date = 3 [deprecated = true];</code>
     * @return The creationDate.
     */
    @java.lang.Deprecated long getCreationDate();

    /**
     * <pre>
     * Deprecated, use fee_sat or fee_msat.
     * </pre>
     *
     * <code>int64 fee = 5 [deprecated = true];</code>
     * @return The fee.
     */
    @java.lang.Deprecated long getFee();

    /**
     * <pre>
     * The payment preimage
     * </pre>
     *
     * <code>string payment_preimage = 6;</code>
     * @return The paymentPreimage.
     */
    java.lang.String getPaymentPreimage();
    /**
     * <pre>
     * The payment preimage
     * </pre>
     *
     * <code>string payment_preimage = 6;</code>
     * @return The bytes for paymentPreimage.
     */
    com.google.protobuf.ByteString
        getPaymentPreimageBytes();

    /**
     * <pre>
     * The value of the payment in satoshis
     * </pre>
     *
     * <code>int64 value_sat = 7;</code>
     * @return The valueSat.
     */
    long getValueSat();

    /**
     * <pre>
     * The value of the payment in milli-satoshis
     * </pre>
     *
     * <code>int64 value_msat = 8;</code>
     * @return The valueMsat.
     */
    long getValueMsat();

    /**
     * <pre>
     * The optional payment request being fulfilled.
     * </pre>
     *
     * <code>string payment_request = 9;</code>
     * @return The paymentRequest.
     */
    java.lang.String getPaymentRequest();
    /**
     * <pre>
     * The optional payment request being fulfilled.
     * </pre>
     *
     * <code>string payment_request = 9;</code>
     * @return The bytes for paymentRequest.
     */
    com.google.protobuf.ByteString
        getPaymentRequestBytes();

    /**
     * <pre>
     * The status of the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.Payment.PaymentStatus status = 10;</code>
     * @return The enum numeric value on the wire for status.
     */
    int getStatusValue();
    /**
     * <pre>
     * The status of the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.Payment.PaymentStatus status = 10;</code>
     * @return The status.
     */
    co.anode.anodium.Rpc.Payment.PaymentStatus getStatus();

    /**
     * <pre>
     *  The fee paid for this payment in satoshis
     * </pre>
     *
     * <code>int64 fee_sat = 11;</code>
     * @return The feeSat.
     */
    long getFeeSat();

    /**
     * <pre>
     *  The fee paid for this payment in milli-satoshis
     * </pre>
     *
     * <code>int64 fee_msat = 12;</code>
     * @return The feeMsat.
     */
    long getFeeMsat();

    /**
     * <pre>
     * The time in UNIX nanoseconds at which the payment was created.
     * </pre>
     *
     * <code>int64 creation_time_ns = 13;</code>
     * @return The creationTimeNs.
     */
    long getCreationTimeNs();

    /**
     * <pre>
     * The HTLCs made in attempt to settle the payment.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
     */
    java.util.List<co.anode.anodium.Rpc.HTLCAttempt> 
        getHtlcsList();
    /**
     * <pre>
     * The HTLCs made in attempt to settle the payment.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
     */
    co.anode.anodium.Rpc.HTLCAttempt getHtlcs(int index);
    /**
     * <pre>
     * The HTLCs made in attempt to settle the payment.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
     */
    int getHtlcsCount();

    /**
     * <pre>
     *The creation index of this payment. Each payment can be uniquely identified
     *by this index, which may not strictly increment by 1 for payments made in
     *older versions of lnd.
     * </pre>
     *
     * <code>uint64 payment_index = 15;</code>
     * @return The paymentIndex.
     */
    long getPaymentIndex();

    /**
     * <code>.co.anode.anodium.PaymentFailureReason failure_reason = 16;</code>
     * @return The enum numeric value on the wire for failureReason.
     */
    int getFailureReasonValue();
    /**
     * <code>.co.anode.anodium.PaymentFailureReason failure_reason = 16;</code>
     * @return The failureReason.
     */
    co.anode.anodium.Rpc.PaymentFailureReason getFailureReason();
  }
  /**
   * Protobuf type {@code co.anode.anodium.Payment}
   */
  public  static final class Payment extends
      com.google.protobuf.GeneratedMessageLite<
          Payment, Payment.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.Payment)
      PaymentOrBuilder {
    private Payment() {
      paymentHash_ = "";
      paymentPreimage_ = "";
      paymentRequest_ = "";
      htlcs_ = emptyProtobufList();
    }
    /**
     * Protobuf enum {@code co.anode.anodium.Payment.PaymentStatus}
     */
    public enum PaymentStatus
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>UNKNOWN = 0;</code>
       */
      UNKNOWN(0),
      /**
       * <code>IN_FLIGHT = 1;</code>
       */
      IN_FLIGHT(1),
      /**
       * <code>SUCCEEDED = 2;</code>
       */
      SUCCEEDED(2),
      /**
       * <code>FAILED = 3;</code>
       */
      FAILED(3),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>UNKNOWN = 0;</code>
       */
      public static final int UNKNOWN_VALUE = 0;
      /**
       * <code>IN_FLIGHT = 1;</code>
       */
      public static final int IN_FLIGHT_VALUE = 1;
      /**
       * <code>SUCCEEDED = 2;</code>
       */
      public static final int SUCCEEDED_VALUE = 2;
      /**
       * <code>FAILED = 3;</code>
       */
      public static final int FAILED_VALUE = 3;


      @java.lang.Override
      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static PaymentStatus valueOf(int value) {
        return forNumber(value);
      }

      public static PaymentStatus forNumber(int value) {
        switch (value) {
          case 0: return UNKNOWN;
          case 1: return IN_FLIGHT;
          case 2: return SUCCEEDED;
          case 3: return FAILED;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<PaymentStatus>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          PaymentStatus> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<PaymentStatus>() {
              @java.lang.Override
              public PaymentStatus findValueByNumber(int number) {
                return PaymentStatus.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return PaymentStatusVerifier.INSTANCE;
      }

      private static final class PaymentStatusVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new PaymentStatusVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return PaymentStatus.forNumber(number) != null;
              }
            };

      private final int value;

      private PaymentStatus(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:co.anode.anodium.Payment.PaymentStatus)
    }

    public static final int PAYMENT_HASH_FIELD_NUMBER = 1;
    private java.lang.String paymentHash_;
    /**
     * <pre>
     * The payment hash
     * </pre>
     *
     * <code>string payment_hash = 1;</code>
     * @return The paymentHash.
     */
    @java.lang.Override
    public java.lang.String getPaymentHash() {
      return paymentHash_;
    }
    /**
     * <pre>
     * The payment hash
     * </pre>
     *
     * <code>string payment_hash = 1;</code>
     * @return The bytes for paymentHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPaymentHashBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(paymentHash_);
    }
    /**
     * <pre>
     * The payment hash
     * </pre>
     *
     * <code>string payment_hash = 1;</code>
     * @param value The paymentHash to set.
     */
    private void setPaymentHash(
        java.lang.String value) {
      value.getClass();
  
      paymentHash_ = value;
    }
    /**
     * <pre>
     * The payment hash
     * </pre>
     *
     * <code>string payment_hash = 1;</code>
     */
    private void clearPaymentHash() {
      
      paymentHash_ = getDefaultInstance().getPaymentHash();
    }
    /**
     * <pre>
     * The payment hash
     * </pre>
     *
     * <code>string payment_hash = 1;</code>
     * @param value The bytes for paymentHash to set.
     */
    private void setPaymentHashBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      paymentHash_ = value.toStringUtf8();
      
    }

    public static final int VALUE_FIELD_NUMBER = 2;
    private long value_;
    /**
     * <pre>
     * Deprecated, use value_sat or value_msat.
     * </pre>
     *
     * <code>int64 value = 2 [deprecated = true];</code>
     * @return The value.
     */
    @java.lang.Override
    @java.lang.Deprecated public long getValue() {
      return value_;
    }
    /**
     * <pre>
     * Deprecated, use value_sat or value_msat.
     * </pre>
     *
     * <code>int64 value = 2 [deprecated = true];</code>
     * @param value The value to set.
     */
    private void setValue(long value) {
      
      value_ = value;
    }
    /**
     * <pre>
     * Deprecated, use value_sat or value_msat.
     * </pre>
     *
     * <code>int64 value = 2 [deprecated = true];</code>
     */
    private void clearValue() {
      
      value_ = 0L;
    }

    public static final int CREATION_DATE_FIELD_NUMBER = 3;
    private long creationDate_;
    /**
     * <pre>
     * Deprecated, use creation_time_ns
     * </pre>
     *
     * <code>int64 creation_date = 3 [deprecated = true];</code>
     * @return The creationDate.
     */
    @java.lang.Override
    @java.lang.Deprecated public long getCreationDate() {
      return creationDate_;
    }
    /**
     * <pre>
     * Deprecated, use creation_time_ns
     * </pre>
     *
     * <code>int64 creation_date = 3 [deprecated = true];</code>
     * @param value The creationDate to set.
     */
    private void setCreationDate(long value) {
      
      creationDate_ = value;
    }
    /**
     * <pre>
     * Deprecated, use creation_time_ns
     * </pre>
     *
     * <code>int64 creation_date = 3 [deprecated = true];</code>
     */
    private void clearCreationDate() {
      
      creationDate_ = 0L;
    }

    public static final int FEE_FIELD_NUMBER = 5;
    private long fee_;
    /**
     * <pre>
     * Deprecated, use fee_sat or fee_msat.
     * </pre>
     *
     * <code>int64 fee = 5 [deprecated = true];</code>
     * @return The fee.
     */
    @java.lang.Override
    @java.lang.Deprecated public long getFee() {
      return fee_;
    }
    /**
     * <pre>
     * Deprecated, use fee_sat or fee_msat.
     * </pre>
     *
     * <code>int64 fee = 5 [deprecated = true];</code>
     * @param value The fee to set.
     */
    private void setFee(long value) {
      
      fee_ = value;
    }
    /**
     * <pre>
     * Deprecated, use fee_sat or fee_msat.
     * </pre>
     *
     * <code>int64 fee = 5 [deprecated = true];</code>
     */
    private void clearFee() {
      
      fee_ = 0L;
    }

    public static final int PAYMENT_PREIMAGE_FIELD_NUMBER = 6;
    private java.lang.String paymentPreimage_;
    /**
     * <pre>
     * The payment preimage
     * </pre>
     *
     * <code>string payment_preimage = 6;</code>
     * @return The paymentPreimage.
     */
    @java.lang.Override
    public java.lang.String getPaymentPreimage() {
      return paymentPreimage_;
    }
    /**
     * <pre>
     * The payment preimage
     * </pre>
     *
     * <code>string payment_preimage = 6;</code>
     * @return The bytes for paymentPreimage.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPaymentPreimageBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(paymentPreimage_);
    }
    /**
     * <pre>
     * The payment preimage
     * </pre>
     *
     * <code>string payment_preimage = 6;</code>
     * @param value The paymentPreimage to set.
     */
    private void setPaymentPreimage(
        java.lang.String value) {
      value.getClass();
  
      paymentPreimage_ = value;
    }
    /**
     * <pre>
     * The payment preimage
     * </pre>
     *
     * <code>string payment_preimage = 6;</code>
     */
    private void clearPaymentPreimage() {
      
      paymentPreimage_ = getDefaultInstance().getPaymentPreimage();
    }
    /**
     * <pre>
     * The payment preimage
     * </pre>
     *
     * <code>string payment_preimage = 6;</code>
     * @param value The bytes for paymentPreimage to set.
     */
    private void setPaymentPreimageBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      paymentPreimage_ = value.toStringUtf8();
      
    }

    public static final int VALUE_SAT_FIELD_NUMBER = 7;
    private long valueSat_;
    /**
     * <pre>
     * The value of the payment in satoshis
     * </pre>
     *
     * <code>int64 value_sat = 7;</code>
     * @return The valueSat.
     */
    @java.lang.Override
    public long getValueSat() {
      return valueSat_;
    }
    /**
     * <pre>
     * The value of the payment in satoshis
     * </pre>
     *
     * <code>int64 value_sat = 7;</code>
     * @param value The valueSat to set.
     */
    private void setValueSat(long value) {
      
      valueSat_ = value;
    }
    /**
     * <pre>
     * The value of the payment in satoshis
     * </pre>
     *
     * <code>int64 value_sat = 7;</code>
     */
    private void clearValueSat() {
      
      valueSat_ = 0L;
    }

    public static final int VALUE_MSAT_FIELD_NUMBER = 8;
    private long valueMsat_;
    /**
     * <pre>
     * The value of the payment in milli-satoshis
     * </pre>
     *
     * <code>int64 value_msat = 8;</code>
     * @return The valueMsat.
     */
    @java.lang.Override
    public long getValueMsat() {
      return valueMsat_;
    }
    /**
     * <pre>
     * The value of the payment in milli-satoshis
     * </pre>
     *
     * <code>int64 value_msat = 8;</code>
     * @param value The valueMsat to set.
     */
    private void setValueMsat(long value) {
      
      valueMsat_ = value;
    }
    /**
     * <pre>
     * The value of the payment in milli-satoshis
     * </pre>
     *
     * <code>int64 value_msat = 8;</code>
     */
    private void clearValueMsat() {
      
      valueMsat_ = 0L;
    }

    public static final int PAYMENT_REQUEST_FIELD_NUMBER = 9;
    private java.lang.String paymentRequest_;
    /**
     * <pre>
     * The optional payment request being fulfilled.
     * </pre>
     *
     * <code>string payment_request = 9;</code>
     * @return The paymentRequest.
     */
    @java.lang.Override
    public java.lang.String getPaymentRequest() {
      return paymentRequest_;
    }
    /**
     * <pre>
     * The optional payment request being fulfilled.
     * </pre>
     *
     * <code>string payment_request = 9;</code>
     * @return The bytes for paymentRequest.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPaymentRequestBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(paymentRequest_);
    }
    /**
     * <pre>
     * The optional payment request being fulfilled.
     * </pre>
     *
     * <code>string payment_request = 9;</code>
     * @param value The paymentRequest to set.
     */
    private void setPaymentRequest(
        java.lang.String value) {
      value.getClass();
  
      paymentRequest_ = value;
    }
    /**
     * <pre>
     * The optional payment request being fulfilled.
     * </pre>
     *
     * <code>string payment_request = 9;</code>
     */
    private void clearPaymentRequest() {
      
      paymentRequest_ = getDefaultInstance().getPaymentRequest();
    }
    /**
     * <pre>
     * The optional payment request being fulfilled.
     * </pre>
     *
     * <code>string payment_request = 9;</code>
     * @param value The bytes for paymentRequest to set.
     */
    private void setPaymentRequestBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      paymentRequest_ = value.toStringUtf8();
      
    }

    public static final int STATUS_FIELD_NUMBER = 10;
    private int status_;
    /**
     * <pre>
     * The status of the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.Payment.PaymentStatus status = 10;</code>
     * @return The enum numeric value on the wire for status.
     */
    @java.lang.Override
    public int getStatusValue() {
      return status_;
    }
    /**
     * <pre>
     * The status of the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.Payment.PaymentStatus status = 10;</code>
     * @return The status.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Payment.PaymentStatus getStatus() {
      co.anode.anodium.Rpc.Payment.PaymentStatus result = co.anode.anodium.Rpc.Payment.PaymentStatus.forNumber(status_);
      return result == null ? co.anode.anodium.Rpc.Payment.PaymentStatus.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * The status of the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.Payment.PaymentStatus status = 10;</code>
     * @param value The enum numeric value on the wire for status to set.
     */
    private void setStatusValue(int value) {
        status_ = value;
    }
    /**
     * <pre>
     * The status of the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.Payment.PaymentStatus status = 10;</code>
     * @param value The status to set.
     */
    private void setStatus(co.anode.anodium.Rpc.Payment.PaymentStatus value) {
      status_ = value.getNumber();
      
    }
    /**
     * <pre>
     * The status of the payment.
     * </pre>
     *
     * <code>.co.anode.anodium.Payment.PaymentStatus status = 10;</code>
     */
    private void clearStatus() {
      
      status_ = 0;
    }

    public static final int FEE_SAT_FIELD_NUMBER = 11;
    private long feeSat_;
    /**
     * <pre>
     *  The fee paid for this payment in satoshis
     * </pre>
     *
     * <code>int64 fee_sat = 11;</code>
     * @return The feeSat.
     */
    @java.lang.Override
    public long getFeeSat() {
      return feeSat_;
    }
    /**
     * <pre>
     *  The fee paid for this payment in satoshis
     * </pre>
     *
     * <code>int64 fee_sat = 11;</code>
     * @param value The feeSat to set.
     */
    private void setFeeSat(long value) {
      
      feeSat_ = value;
    }
    /**
     * <pre>
     *  The fee paid for this payment in satoshis
     * </pre>
     *
     * <code>int64 fee_sat = 11;</code>
     */
    private void clearFeeSat() {
      
      feeSat_ = 0L;
    }

    public static final int FEE_MSAT_FIELD_NUMBER = 12;
    private long feeMsat_;
    /**
     * <pre>
     *  The fee paid for this payment in milli-satoshis
     * </pre>
     *
     * <code>int64 fee_msat = 12;</code>
     * @return The feeMsat.
     */
    @java.lang.Override
    public long getFeeMsat() {
      return feeMsat_;
    }
    /**
     * <pre>
     *  The fee paid for this payment in milli-satoshis
     * </pre>
     *
     * <code>int64 fee_msat = 12;</code>
     * @param value The feeMsat to set.
     */
    private void setFeeMsat(long value) {
      
      feeMsat_ = value;
    }
    /**
     * <pre>
     *  The fee paid for this payment in milli-satoshis
     * </pre>
     *
     * <code>int64 fee_msat = 12;</code>
     */
    private void clearFeeMsat() {
      
      feeMsat_ = 0L;
    }

    public static final int CREATION_TIME_NS_FIELD_NUMBER = 13;
    private long creationTimeNs_;
    /**
     * <pre>
     * The time in UNIX nanoseconds at which the payment was created.
     * </pre>
     *
     * <code>int64 creation_time_ns = 13;</code>
     * @return The creationTimeNs.
     */
    @java.lang.Override
    public long getCreationTimeNs() {
      return creationTimeNs_;
    }
    /**
     * <pre>
     * The time in UNIX nanoseconds at which the payment was created.
     * </pre>
     *
     * <code>int64 creation_time_ns = 13;</code>
     * @param value The creationTimeNs to set.
     */
    private void setCreationTimeNs(long value) {
      
      creationTimeNs_ = value;
    }
    /**
     * <pre>
     * The time in UNIX nanoseconds at which the payment was created.
     * </pre>
     *
     * <code>int64 creation_time_ns = 13;</code>
     */
    private void clearCreationTimeNs() {
      
      creationTimeNs_ = 0L;
    }

    public static final int HTLCS_FIELD_NUMBER = 14;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.HTLCAttempt> htlcs_;
    /**
     * <pre>
     * The HTLCs made in attempt to settle the payment.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.HTLCAttempt> getHtlcsList() {
      return htlcs_;
    }
    /**
     * <pre>
     * The HTLCs made in attempt to settle the payment.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.HTLCAttemptOrBuilder> 
        getHtlcsOrBuilderList() {
      return htlcs_;
    }
    /**
     * <pre>
     * The HTLCs made in attempt to settle the payment.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
     */
    @java.lang.Override
    public int getHtlcsCount() {
      return htlcs_.size();
    }
    /**
     * <pre>
     * The HTLCs made in attempt to settle the payment.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.HTLCAttempt getHtlcs(int index) {
      return htlcs_.get(index);
    }
    /**
     * <pre>
     * The HTLCs made in attempt to settle the payment.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
     */
    public co.anode.anodium.Rpc.HTLCAttemptOrBuilder getHtlcsOrBuilder(
        int index) {
      return htlcs_.get(index);
    }
    private void ensureHtlcsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.HTLCAttempt> tmp = htlcs_;
      if (!tmp.isModifiable()) {
        htlcs_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * The HTLCs made in attempt to settle the payment.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
     */
    private void setHtlcs(
        int index, co.anode.anodium.Rpc.HTLCAttempt value) {
      value.getClass();
  ensureHtlcsIsMutable();
      htlcs_.set(index, value);
    }
    /**
     * <pre>
     * The HTLCs made in attempt to settle the payment.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
     */
    private void addHtlcs(co.anode.anodium.Rpc.HTLCAttempt value) {
      value.getClass();
  ensureHtlcsIsMutable();
      htlcs_.add(value);
    }
    /**
     * <pre>
     * The HTLCs made in attempt to settle the payment.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
     */
    private void addHtlcs(
        int index, co.anode.anodium.Rpc.HTLCAttempt value) {
      value.getClass();
  ensureHtlcsIsMutable();
      htlcs_.add(index, value);
    }
    /**
     * <pre>
     * The HTLCs made in attempt to settle the payment.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
     */
    private void addAllHtlcs(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.HTLCAttempt> values) {
      ensureHtlcsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, htlcs_);
    }
    /**
     * <pre>
     * The HTLCs made in attempt to settle the payment.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
     */
    private void clearHtlcs() {
      htlcs_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The HTLCs made in attempt to settle the payment.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
     */
    private void removeHtlcs(int index) {
      ensureHtlcsIsMutable();
      htlcs_.remove(index);
    }

    public static final int PAYMENT_INDEX_FIELD_NUMBER = 15;
    private long paymentIndex_;
    /**
     * <pre>
     *The creation index of this payment. Each payment can be uniquely identified
     *by this index, which may not strictly increment by 1 for payments made in
     *older versions of lnd.
     * </pre>
     *
     * <code>uint64 payment_index = 15;</code>
     * @return The paymentIndex.
     */
    @java.lang.Override
    public long getPaymentIndex() {
      return paymentIndex_;
    }
    /**
     * <pre>
     *The creation index of this payment. Each payment can be uniquely identified
     *by this index, which may not strictly increment by 1 for payments made in
     *older versions of lnd.
     * </pre>
     *
     * <code>uint64 payment_index = 15;</code>
     * @param value The paymentIndex to set.
     */
    private void setPaymentIndex(long value) {
      
      paymentIndex_ = value;
    }
    /**
     * <pre>
     *The creation index of this payment. Each payment can be uniquely identified
     *by this index, which may not strictly increment by 1 for payments made in
     *older versions of lnd.
     * </pre>
     *
     * <code>uint64 payment_index = 15;</code>
     */
    private void clearPaymentIndex() {
      
      paymentIndex_ = 0L;
    }

    public static final int FAILURE_REASON_FIELD_NUMBER = 16;
    private int failureReason_;
    /**
     * <code>.co.anode.anodium.PaymentFailureReason failure_reason = 16;</code>
     * @return The enum numeric value on the wire for failureReason.
     */
    @java.lang.Override
    public int getFailureReasonValue() {
      return failureReason_;
    }
    /**
     * <code>.co.anode.anodium.PaymentFailureReason failure_reason = 16;</code>
     * @return The failureReason.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.PaymentFailureReason getFailureReason() {
      co.anode.anodium.Rpc.PaymentFailureReason result = co.anode.anodium.Rpc.PaymentFailureReason.forNumber(failureReason_);
      return result == null ? co.anode.anodium.Rpc.PaymentFailureReason.UNRECOGNIZED : result;
    }
    /**
     * <code>.co.anode.anodium.PaymentFailureReason failure_reason = 16;</code>
     * @param value The enum numeric value on the wire for failureReason to set.
     */
    private void setFailureReasonValue(int value) {
        failureReason_ = value;
    }
    /**
     * <code>.co.anode.anodium.PaymentFailureReason failure_reason = 16;</code>
     * @param value The failureReason to set.
     */
    private void setFailureReason(co.anode.anodium.Rpc.PaymentFailureReason value) {
      failureReason_ = value.getNumber();
      
    }
    /**
     * <code>.co.anode.anodium.PaymentFailureReason failure_reason = 16;</code>
     */
    private void clearFailureReason() {
      
      failureReason_ = 0;
    }

    public static co.anode.anodium.Rpc.Payment parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Payment parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Payment parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Payment parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Payment parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Payment parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Payment parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Payment parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Payment parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Payment parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Payment parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Payment parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.Payment prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.Payment}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.Payment, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.Payment)
        co.anode.anodium.Rpc.PaymentOrBuilder {
      // Construct using co.anode.anodium.Rpc.Payment.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The payment hash
       * </pre>
       *
       * <code>string payment_hash = 1;</code>
       * @return The paymentHash.
       */
      @java.lang.Override
      public java.lang.String getPaymentHash() {
        return instance.getPaymentHash();
      }
      /**
       * <pre>
       * The payment hash
       * </pre>
       *
       * <code>string payment_hash = 1;</code>
       * @return The bytes for paymentHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPaymentHashBytes() {
        return instance.getPaymentHashBytes();
      }
      /**
       * <pre>
       * The payment hash
       * </pre>
       *
       * <code>string payment_hash = 1;</code>
       * @param value The paymentHash to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentHash(
          java.lang.String value) {
        copyOnWrite();
        instance.setPaymentHash(value);
        return this;
      }
      /**
       * <pre>
       * The payment hash
       * </pre>
       *
       * <code>string payment_hash = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaymentHash() {
        copyOnWrite();
        instance.clearPaymentHash();
        return this;
      }
      /**
       * <pre>
       * The payment hash
       * </pre>
       *
       * <code>string payment_hash = 1;</code>
       * @param value The bytes for paymentHash to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentHashBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPaymentHashBytes(value);
        return this;
      }

      /**
       * <pre>
       * Deprecated, use value_sat or value_msat.
       * </pre>
       *
       * <code>int64 value = 2 [deprecated = true];</code>
       * @return The value.
       */
      @java.lang.Override
      @java.lang.Deprecated public long getValue() {
        return instance.getValue();
      }
      /**
       * <pre>
       * Deprecated, use value_sat or value_msat.
       * </pre>
       *
       * <code>int64 value = 2 [deprecated = true];</code>
       * @param value The value to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setValue(long value) {
        copyOnWrite();
        instance.setValue(value);
        return this;
      }
      /**
       * <pre>
       * Deprecated, use value_sat or value_msat.
       * </pre>
       *
       * <code>int64 value = 2 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearValue() {
        copyOnWrite();
        instance.clearValue();
        return this;
      }

      /**
       * <pre>
       * Deprecated, use creation_time_ns
       * </pre>
       *
       * <code>int64 creation_date = 3 [deprecated = true];</code>
       * @return The creationDate.
       */
      @java.lang.Override
      @java.lang.Deprecated public long getCreationDate() {
        return instance.getCreationDate();
      }
      /**
       * <pre>
       * Deprecated, use creation_time_ns
       * </pre>
       *
       * <code>int64 creation_date = 3 [deprecated = true];</code>
       * @param value The creationDate to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setCreationDate(long value) {
        copyOnWrite();
        instance.setCreationDate(value);
        return this;
      }
      /**
       * <pre>
       * Deprecated, use creation_time_ns
       * </pre>
       *
       * <code>int64 creation_date = 3 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearCreationDate() {
        copyOnWrite();
        instance.clearCreationDate();
        return this;
      }

      /**
       * <pre>
       * Deprecated, use fee_sat or fee_msat.
       * </pre>
       *
       * <code>int64 fee = 5 [deprecated = true];</code>
       * @return The fee.
       */
      @java.lang.Override
      @java.lang.Deprecated public long getFee() {
        return instance.getFee();
      }
      /**
       * <pre>
       * Deprecated, use fee_sat or fee_msat.
       * </pre>
       *
       * <code>int64 fee = 5 [deprecated = true];</code>
       * @param value The fee to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setFee(long value) {
        copyOnWrite();
        instance.setFee(value);
        return this;
      }
      /**
       * <pre>
       * Deprecated, use fee_sat or fee_msat.
       * </pre>
       *
       * <code>int64 fee = 5 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearFee() {
        copyOnWrite();
        instance.clearFee();
        return this;
      }

      /**
       * <pre>
       * The payment preimage
       * </pre>
       *
       * <code>string payment_preimage = 6;</code>
       * @return The paymentPreimage.
       */
      @java.lang.Override
      public java.lang.String getPaymentPreimage() {
        return instance.getPaymentPreimage();
      }
      /**
       * <pre>
       * The payment preimage
       * </pre>
       *
       * <code>string payment_preimage = 6;</code>
       * @return The bytes for paymentPreimage.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPaymentPreimageBytes() {
        return instance.getPaymentPreimageBytes();
      }
      /**
       * <pre>
       * The payment preimage
       * </pre>
       *
       * <code>string payment_preimage = 6;</code>
       * @param value The paymentPreimage to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentPreimage(
          java.lang.String value) {
        copyOnWrite();
        instance.setPaymentPreimage(value);
        return this;
      }
      /**
       * <pre>
       * The payment preimage
       * </pre>
       *
       * <code>string payment_preimage = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaymentPreimage() {
        copyOnWrite();
        instance.clearPaymentPreimage();
        return this;
      }
      /**
       * <pre>
       * The payment preimage
       * </pre>
       *
       * <code>string payment_preimage = 6;</code>
       * @param value The bytes for paymentPreimage to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentPreimageBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPaymentPreimageBytes(value);
        return this;
      }

      /**
       * <pre>
       * The value of the payment in satoshis
       * </pre>
       *
       * <code>int64 value_sat = 7;</code>
       * @return The valueSat.
       */
      @java.lang.Override
      public long getValueSat() {
        return instance.getValueSat();
      }
      /**
       * <pre>
       * The value of the payment in satoshis
       * </pre>
       *
       * <code>int64 value_sat = 7;</code>
       * @param value The valueSat to set.
       * @return This builder for chaining.
       */
      public Builder setValueSat(long value) {
        copyOnWrite();
        instance.setValueSat(value);
        return this;
      }
      /**
       * <pre>
       * The value of the payment in satoshis
       * </pre>
       *
       * <code>int64 value_sat = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearValueSat() {
        copyOnWrite();
        instance.clearValueSat();
        return this;
      }

      /**
       * <pre>
       * The value of the payment in milli-satoshis
       * </pre>
       *
       * <code>int64 value_msat = 8;</code>
       * @return The valueMsat.
       */
      @java.lang.Override
      public long getValueMsat() {
        return instance.getValueMsat();
      }
      /**
       * <pre>
       * The value of the payment in milli-satoshis
       * </pre>
       *
       * <code>int64 value_msat = 8;</code>
       * @param value The valueMsat to set.
       * @return This builder for chaining.
       */
      public Builder setValueMsat(long value) {
        copyOnWrite();
        instance.setValueMsat(value);
        return this;
      }
      /**
       * <pre>
       * The value of the payment in milli-satoshis
       * </pre>
       *
       * <code>int64 value_msat = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearValueMsat() {
        copyOnWrite();
        instance.clearValueMsat();
        return this;
      }

      /**
       * <pre>
       * The optional payment request being fulfilled.
       * </pre>
       *
       * <code>string payment_request = 9;</code>
       * @return The paymentRequest.
       */
      @java.lang.Override
      public java.lang.String getPaymentRequest() {
        return instance.getPaymentRequest();
      }
      /**
       * <pre>
       * The optional payment request being fulfilled.
       * </pre>
       *
       * <code>string payment_request = 9;</code>
       * @return The bytes for paymentRequest.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPaymentRequestBytes() {
        return instance.getPaymentRequestBytes();
      }
      /**
       * <pre>
       * The optional payment request being fulfilled.
       * </pre>
       *
       * <code>string payment_request = 9;</code>
       * @param value The paymentRequest to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentRequest(
          java.lang.String value) {
        copyOnWrite();
        instance.setPaymentRequest(value);
        return this;
      }
      /**
       * <pre>
       * The optional payment request being fulfilled.
       * </pre>
       *
       * <code>string payment_request = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaymentRequest() {
        copyOnWrite();
        instance.clearPaymentRequest();
        return this;
      }
      /**
       * <pre>
       * The optional payment request being fulfilled.
       * </pre>
       *
       * <code>string payment_request = 9;</code>
       * @param value The bytes for paymentRequest to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentRequestBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPaymentRequestBytes(value);
        return this;
      }

      /**
       * <pre>
       * The status of the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.Payment.PaymentStatus status = 10;</code>
       * @return The enum numeric value on the wire for status.
       */
      @java.lang.Override
      public int getStatusValue() {
        return instance.getStatusValue();
      }
      /**
       * <pre>
       * The status of the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.Payment.PaymentStatus status = 10;</code>
       * @param value The status to set.
       * @return This builder for chaining.
       */
      public Builder setStatusValue(int value) {
        copyOnWrite();
        instance.setStatusValue(value);
        return this;
      }
      /**
       * <pre>
       * The status of the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.Payment.PaymentStatus status = 10;</code>
       * @return The status.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Payment.PaymentStatus getStatus() {
        return instance.getStatus();
      }
      /**
       * <pre>
       * The status of the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.Payment.PaymentStatus status = 10;</code>
       * @param value The enum numeric value on the wire for status to set.
       * @return This builder for chaining.
       */
      public Builder setStatus(co.anode.anodium.Rpc.Payment.PaymentStatus value) {
        copyOnWrite();
        instance.setStatus(value);
        return this;
      }
      /**
       * <pre>
       * The status of the payment.
       * </pre>
       *
       * <code>.co.anode.anodium.Payment.PaymentStatus status = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearStatus() {
        copyOnWrite();
        instance.clearStatus();
        return this;
      }

      /**
       * <pre>
       *  The fee paid for this payment in satoshis
       * </pre>
       *
       * <code>int64 fee_sat = 11;</code>
       * @return The feeSat.
       */
      @java.lang.Override
      public long getFeeSat() {
        return instance.getFeeSat();
      }
      /**
       * <pre>
       *  The fee paid for this payment in satoshis
       * </pre>
       *
       * <code>int64 fee_sat = 11;</code>
       * @param value The feeSat to set.
       * @return This builder for chaining.
       */
      public Builder setFeeSat(long value) {
        copyOnWrite();
        instance.setFeeSat(value);
        return this;
      }
      /**
       * <pre>
       *  The fee paid for this payment in satoshis
       * </pre>
       *
       * <code>int64 fee_sat = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearFeeSat() {
        copyOnWrite();
        instance.clearFeeSat();
        return this;
      }

      /**
       * <pre>
       *  The fee paid for this payment in milli-satoshis
       * </pre>
       *
       * <code>int64 fee_msat = 12;</code>
       * @return The feeMsat.
       */
      @java.lang.Override
      public long getFeeMsat() {
        return instance.getFeeMsat();
      }
      /**
       * <pre>
       *  The fee paid for this payment in milli-satoshis
       * </pre>
       *
       * <code>int64 fee_msat = 12;</code>
       * @param value The feeMsat to set.
       * @return This builder for chaining.
       */
      public Builder setFeeMsat(long value) {
        copyOnWrite();
        instance.setFeeMsat(value);
        return this;
      }
      /**
       * <pre>
       *  The fee paid for this payment in milli-satoshis
       * </pre>
       *
       * <code>int64 fee_msat = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearFeeMsat() {
        copyOnWrite();
        instance.clearFeeMsat();
        return this;
      }

      /**
       * <pre>
       * The time in UNIX nanoseconds at which the payment was created.
       * </pre>
       *
       * <code>int64 creation_time_ns = 13;</code>
       * @return The creationTimeNs.
       */
      @java.lang.Override
      public long getCreationTimeNs() {
        return instance.getCreationTimeNs();
      }
      /**
       * <pre>
       * The time in UNIX nanoseconds at which the payment was created.
       * </pre>
       *
       * <code>int64 creation_time_ns = 13;</code>
       * @param value The creationTimeNs to set.
       * @return This builder for chaining.
       */
      public Builder setCreationTimeNs(long value) {
        copyOnWrite();
        instance.setCreationTimeNs(value);
        return this;
      }
      /**
       * <pre>
       * The time in UNIX nanoseconds at which the payment was created.
       * </pre>
       *
       * <code>int64 creation_time_ns = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearCreationTimeNs() {
        copyOnWrite();
        instance.clearCreationTimeNs();
        return this;
      }

      /**
       * <pre>
       * The HTLCs made in attempt to settle the payment.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.HTLCAttempt> getHtlcsList() {
        return java.util.Collections.unmodifiableList(
            instance.getHtlcsList());
      }
      /**
       * <pre>
       * The HTLCs made in attempt to settle the payment.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
       */
      @java.lang.Override
      public int getHtlcsCount() {
        return instance.getHtlcsCount();
      }/**
       * <pre>
       * The HTLCs made in attempt to settle the payment.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.HTLCAttempt getHtlcs(int index) {
        return instance.getHtlcs(index);
      }
      /**
       * <pre>
       * The HTLCs made in attempt to settle the payment.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
       */
      public Builder setHtlcs(
          int index, co.anode.anodium.Rpc.HTLCAttempt value) {
        copyOnWrite();
        instance.setHtlcs(index, value);
        return this;
      }
      /**
       * <pre>
       * The HTLCs made in attempt to settle the payment.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
       */
      public Builder setHtlcs(
          int index, co.anode.anodium.Rpc.HTLCAttempt.Builder builderForValue) {
        copyOnWrite();
        instance.setHtlcs(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The HTLCs made in attempt to settle the payment.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
       */
      public Builder addHtlcs(co.anode.anodium.Rpc.HTLCAttempt value) {
        copyOnWrite();
        instance.addHtlcs(value);
        return this;
      }
      /**
       * <pre>
       * The HTLCs made in attempt to settle the payment.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
       */
      public Builder addHtlcs(
          int index, co.anode.anodium.Rpc.HTLCAttempt value) {
        copyOnWrite();
        instance.addHtlcs(index, value);
        return this;
      }
      /**
       * <pre>
       * The HTLCs made in attempt to settle the payment.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
       */
      public Builder addHtlcs(
          co.anode.anodium.Rpc.HTLCAttempt.Builder builderForValue) {
        copyOnWrite();
        instance.addHtlcs(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The HTLCs made in attempt to settle the payment.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
       */
      public Builder addHtlcs(
          int index, co.anode.anodium.Rpc.HTLCAttempt.Builder builderForValue) {
        copyOnWrite();
        instance.addHtlcs(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The HTLCs made in attempt to settle the payment.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
       */
      public Builder addAllHtlcs(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.HTLCAttempt> values) {
        copyOnWrite();
        instance.addAllHtlcs(values);
        return this;
      }
      /**
       * <pre>
       * The HTLCs made in attempt to settle the payment.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
       */
      public Builder clearHtlcs() {
        copyOnWrite();
        instance.clearHtlcs();
        return this;
      }
      /**
       * <pre>
       * The HTLCs made in attempt to settle the payment.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.HTLCAttempt htlcs = 14;</code>
       */
      public Builder removeHtlcs(int index) {
        copyOnWrite();
        instance.removeHtlcs(index);
        return this;
      }

      /**
       * <pre>
       *The creation index of this payment. Each payment can be uniquely identified
       *by this index, which may not strictly increment by 1 for payments made in
       *older versions of lnd.
       * </pre>
       *
       * <code>uint64 payment_index = 15;</code>
       * @return The paymentIndex.
       */
      @java.lang.Override
      public long getPaymentIndex() {
        return instance.getPaymentIndex();
      }
      /**
       * <pre>
       *The creation index of this payment. Each payment can be uniquely identified
       *by this index, which may not strictly increment by 1 for payments made in
       *older versions of lnd.
       * </pre>
       *
       * <code>uint64 payment_index = 15;</code>
       * @param value The paymentIndex to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentIndex(long value) {
        copyOnWrite();
        instance.setPaymentIndex(value);
        return this;
      }
      /**
       * <pre>
       *The creation index of this payment. Each payment can be uniquely identified
       *by this index, which may not strictly increment by 1 for payments made in
       *older versions of lnd.
       * </pre>
       *
       * <code>uint64 payment_index = 15;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaymentIndex() {
        copyOnWrite();
        instance.clearPaymentIndex();
        return this;
      }

      /**
       * <code>.co.anode.anodium.PaymentFailureReason failure_reason = 16;</code>
       * @return The enum numeric value on the wire for failureReason.
       */
      @java.lang.Override
      public int getFailureReasonValue() {
        return instance.getFailureReasonValue();
      }
      /**
       * <code>.co.anode.anodium.PaymentFailureReason failure_reason = 16;</code>
       * @param value The failureReason to set.
       * @return This builder for chaining.
       */
      public Builder setFailureReasonValue(int value) {
        copyOnWrite();
        instance.setFailureReasonValue(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.PaymentFailureReason failure_reason = 16;</code>
       * @return The failureReason.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.PaymentFailureReason getFailureReason() {
        return instance.getFailureReason();
      }
      /**
       * <code>.co.anode.anodium.PaymentFailureReason failure_reason = 16;</code>
       * @param value The enum numeric value on the wire for failureReason to set.
       * @return This builder for chaining.
       */
      public Builder setFailureReason(co.anode.anodium.Rpc.PaymentFailureReason value) {
        copyOnWrite();
        instance.setFailureReason(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.PaymentFailureReason failure_reason = 16;</code>
       * @return This builder for chaining.
       */
      public Builder clearFailureReason() {
        copyOnWrite();
        instance.clearFailureReason();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.Payment)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.Payment();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "paymentHash_",
              "value_",
              "creationDate_",
              "fee_",
              "paymentPreimage_",
              "valueSat_",
              "valueMsat_",
              "paymentRequest_",
              "status_",
              "feeSat_",
              "feeMsat_",
              "creationTimeNs_",
              "htlcs_",
              co.anode.anodium.Rpc.HTLCAttempt.class,
              "paymentIndex_",
              "failureReason_",
            };
            java.lang.String info =
                "\u0000\u000f\u0000\u0000\u0001\u0010\u000f\u0000\u0001\u0000\u0001\u0208\u0002\u0002" +
                "\u0003\u0002\u0005\u0002\u0006\u0208\u0007\u0002\b\u0002\t\u0208\n\f\u000b\u0002" +
                "\f\u0002\r\u0002\u000e\u001b\u000f\u0003\u0010\f";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.Payment> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.Payment.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.Payment>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.Payment)
    private static final co.anode.anodium.Rpc.Payment DEFAULT_INSTANCE;
    static {
      Payment defaultInstance = new Payment();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Payment.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.Payment getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Payment> PARSER;

    public static com.google.protobuf.Parser<Payment> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface HTLCAttemptOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.HTLCAttempt)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The status of the HTLC.
     * </pre>
     *
     * <code>.co.anode.anodium.HTLCAttempt.HTLCStatus status = 1;</code>
     * @return The enum numeric value on the wire for status.
     */
    int getStatusValue();
    /**
     * <pre>
     * The status of the HTLC.
     * </pre>
     *
     * <code>.co.anode.anodium.HTLCAttempt.HTLCStatus status = 1;</code>
     * @return The status.
     */
    co.anode.anodium.Rpc.HTLCAttempt.HTLCStatus getStatus();

    /**
     * <pre>
     * The route taken by this HTLC.
     * </pre>
     *
     * <code>.co.anode.anodium.Route route = 2;</code>
     * @return Whether the route field is set.
     */
    boolean hasRoute();
    /**
     * <pre>
     * The route taken by this HTLC.
     * </pre>
     *
     * <code>.co.anode.anodium.Route route = 2;</code>
     * @return The route.
     */
    co.anode.anodium.Rpc.Route getRoute();

    /**
     * <pre>
     * The time in UNIX nanoseconds at which this HTLC was sent.
     * </pre>
     *
     * <code>int64 attempt_time_ns = 3;</code>
     * @return The attemptTimeNs.
     */
    long getAttemptTimeNs();

    /**
     * <pre>
     *The time in UNIX nanoseconds at which this HTLC was settled or failed.
     *This value will not be set if the HTLC is still IN_FLIGHT.
     * </pre>
     *
     * <code>int64 resolve_time_ns = 4;</code>
     * @return The resolveTimeNs.
     */
    long getResolveTimeNs();

    /**
     * <pre>
     * Detailed htlc failure info.
     * </pre>
     *
     * <code>.co.anode.anodium.Failure failure = 5;</code>
     * @return Whether the failure field is set.
     */
    boolean hasFailure();
    /**
     * <pre>
     * Detailed htlc failure info.
     * </pre>
     *
     * <code>.co.anode.anodium.Failure failure = 5;</code>
     * @return The failure.
     */
    co.anode.anodium.Rpc.Failure getFailure();

    /**
     * <pre>
     * The preimage that was used to settle the HTLC.
     * </pre>
     *
     * <code>bytes preimage = 6;</code>
     * @return The preimage.
     */
    com.google.protobuf.ByteString getPreimage();
  }
  /**
   * Protobuf type {@code co.anode.anodium.HTLCAttempt}
   */
  public  static final class HTLCAttempt extends
      com.google.protobuf.GeneratedMessageLite<
          HTLCAttempt, HTLCAttempt.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.HTLCAttempt)
      HTLCAttemptOrBuilder {
    private HTLCAttempt() {
      preimage_ = com.google.protobuf.ByteString.EMPTY;
    }
    /**
     * Protobuf enum {@code co.anode.anodium.HTLCAttempt.HTLCStatus}
     */
    public enum HTLCStatus
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>IN_FLIGHT = 0;</code>
       */
      IN_FLIGHT(0),
      /**
       * <code>SUCCEEDED = 1;</code>
       */
      SUCCEEDED(1),
      /**
       * <code>FAILED = 2;</code>
       */
      FAILED(2),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>IN_FLIGHT = 0;</code>
       */
      public static final int IN_FLIGHT_VALUE = 0;
      /**
       * <code>SUCCEEDED = 1;</code>
       */
      public static final int SUCCEEDED_VALUE = 1;
      /**
       * <code>FAILED = 2;</code>
       */
      public static final int FAILED_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static HTLCStatus valueOf(int value) {
        return forNumber(value);
      }

      public static HTLCStatus forNumber(int value) {
        switch (value) {
          case 0: return IN_FLIGHT;
          case 1: return SUCCEEDED;
          case 2: return FAILED;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<HTLCStatus>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          HTLCStatus> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<HTLCStatus>() {
              @java.lang.Override
              public HTLCStatus findValueByNumber(int number) {
                return HTLCStatus.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return HTLCStatusVerifier.INSTANCE;
      }

      private static final class HTLCStatusVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new HTLCStatusVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return HTLCStatus.forNumber(number) != null;
              }
            };

      private final int value;

      private HTLCStatus(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:co.anode.anodium.HTLCAttempt.HTLCStatus)
    }

    public static final int STATUS_FIELD_NUMBER = 1;
    private int status_;
    /**
     * <pre>
     * The status of the HTLC.
     * </pre>
     *
     * <code>.co.anode.anodium.HTLCAttempt.HTLCStatus status = 1;</code>
     * @return The enum numeric value on the wire for status.
     */
    @java.lang.Override
    public int getStatusValue() {
      return status_;
    }
    /**
     * <pre>
     * The status of the HTLC.
     * </pre>
     *
     * <code>.co.anode.anodium.HTLCAttempt.HTLCStatus status = 1;</code>
     * @return The status.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.HTLCAttempt.HTLCStatus getStatus() {
      co.anode.anodium.Rpc.HTLCAttempt.HTLCStatus result = co.anode.anodium.Rpc.HTLCAttempt.HTLCStatus.forNumber(status_);
      return result == null ? co.anode.anodium.Rpc.HTLCAttempt.HTLCStatus.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * The status of the HTLC.
     * </pre>
     *
     * <code>.co.anode.anodium.HTLCAttempt.HTLCStatus status = 1;</code>
     * @param value The enum numeric value on the wire for status to set.
     */
    private void setStatusValue(int value) {
        status_ = value;
    }
    /**
     * <pre>
     * The status of the HTLC.
     * </pre>
     *
     * <code>.co.anode.anodium.HTLCAttempt.HTLCStatus status = 1;</code>
     * @param value The status to set.
     */
    private void setStatus(co.anode.anodium.Rpc.HTLCAttempt.HTLCStatus value) {
      status_ = value.getNumber();
      
    }
    /**
     * <pre>
     * The status of the HTLC.
     * </pre>
     *
     * <code>.co.anode.anodium.HTLCAttempt.HTLCStatus status = 1;</code>
     */
    private void clearStatus() {
      
      status_ = 0;
    }

    public static final int ROUTE_FIELD_NUMBER = 2;
    private co.anode.anodium.Rpc.Route route_;
    /**
     * <pre>
     * The route taken by this HTLC.
     * </pre>
     *
     * <code>.co.anode.anodium.Route route = 2;</code>
     */
    @java.lang.Override
    public boolean hasRoute() {
      return route_ != null;
    }
    /**
     * <pre>
     * The route taken by this HTLC.
     * </pre>
     *
     * <code>.co.anode.anodium.Route route = 2;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Route getRoute() {
      return route_ == null ? co.anode.anodium.Rpc.Route.getDefaultInstance() : route_;
    }
    /**
     * <pre>
     * The route taken by this HTLC.
     * </pre>
     *
     * <code>.co.anode.anodium.Route route = 2;</code>
     */
    private void setRoute(co.anode.anodium.Rpc.Route value) {
      value.getClass();
  route_ = value;
      
      }
    /**
     * <pre>
     * The route taken by this HTLC.
     * </pre>
     *
     * <code>.co.anode.anodium.Route route = 2;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeRoute(co.anode.anodium.Rpc.Route value) {
      value.getClass();
  if (route_ != null &&
          route_ != co.anode.anodium.Rpc.Route.getDefaultInstance()) {
        route_ =
          co.anode.anodium.Rpc.Route.newBuilder(route_).mergeFrom(value).buildPartial();
      } else {
        route_ = value;
      }
      
    }
    /**
     * <pre>
     * The route taken by this HTLC.
     * </pre>
     *
     * <code>.co.anode.anodium.Route route = 2;</code>
     */
    private void clearRoute() {  route_ = null;
      
    }

    public static final int ATTEMPT_TIME_NS_FIELD_NUMBER = 3;
    private long attemptTimeNs_;
    /**
     * <pre>
     * The time in UNIX nanoseconds at which this HTLC was sent.
     * </pre>
     *
     * <code>int64 attempt_time_ns = 3;</code>
     * @return The attemptTimeNs.
     */
    @java.lang.Override
    public long getAttemptTimeNs() {
      return attemptTimeNs_;
    }
    /**
     * <pre>
     * The time in UNIX nanoseconds at which this HTLC was sent.
     * </pre>
     *
     * <code>int64 attempt_time_ns = 3;</code>
     * @param value The attemptTimeNs to set.
     */
    private void setAttemptTimeNs(long value) {
      
      attemptTimeNs_ = value;
    }
    /**
     * <pre>
     * The time in UNIX nanoseconds at which this HTLC was sent.
     * </pre>
     *
     * <code>int64 attempt_time_ns = 3;</code>
     */
    private void clearAttemptTimeNs() {
      
      attemptTimeNs_ = 0L;
    }

    public static final int RESOLVE_TIME_NS_FIELD_NUMBER = 4;
    private long resolveTimeNs_;
    /**
     * <pre>
     *The time in UNIX nanoseconds at which this HTLC was settled or failed.
     *This value will not be set if the HTLC is still IN_FLIGHT.
     * </pre>
     *
     * <code>int64 resolve_time_ns = 4;</code>
     * @return The resolveTimeNs.
     */
    @java.lang.Override
    public long getResolveTimeNs() {
      return resolveTimeNs_;
    }
    /**
     * <pre>
     *The time in UNIX nanoseconds at which this HTLC was settled or failed.
     *This value will not be set if the HTLC is still IN_FLIGHT.
     * </pre>
     *
     * <code>int64 resolve_time_ns = 4;</code>
     * @param value The resolveTimeNs to set.
     */
    private void setResolveTimeNs(long value) {
      
      resolveTimeNs_ = value;
    }
    /**
     * <pre>
     *The time in UNIX nanoseconds at which this HTLC was settled or failed.
     *This value will not be set if the HTLC is still IN_FLIGHT.
     * </pre>
     *
     * <code>int64 resolve_time_ns = 4;</code>
     */
    private void clearResolveTimeNs() {
      
      resolveTimeNs_ = 0L;
    }

    public static final int FAILURE_FIELD_NUMBER = 5;
    private co.anode.anodium.Rpc.Failure failure_;
    /**
     * <pre>
     * Detailed htlc failure info.
     * </pre>
     *
     * <code>.co.anode.anodium.Failure failure = 5;</code>
     */
    @java.lang.Override
    public boolean hasFailure() {
      return failure_ != null;
    }
    /**
     * <pre>
     * Detailed htlc failure info.
     * </pre>
     *
     * <code>.co.anode.anodium.Failure failure = 5;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Failure getFailure() {
      return failure_ == null ? co.anode.anodium.Rpc.Failure.getDefaultInstance() : failure_;
    }
    /**
     * <pre>
     * Detailed htlc failure info.
     * </pre>
     *
     * <code>.co.anode.anodium.Failure failure = 5;</code>
     */
    private void setFailure(co.anode.anodium.Rpc.Failure value) {
      value.getClass();
  failure_ = value;
      
      }
    /**
     * <pre>
     * Detailed htlc failure info.
     * </pre>
     *
     * <code>.co.anode.anodium.Failure failure = 5;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeFailure(co.anode.anodium.Rpc.Failure value) {
      value.getClass();
  if (failure_ != null &&
          failure_ != co.anode.anodium.Rpc.Failure.getDefaultInstance()) {
        failure_ =
          co.anode.anodium.Rpc.Failure.newBuilder(failure_).mergeFrom(value).buildPartial();
      } else {
        failure_ = value;
      }
      
    }
    /**
     * <pre>
     * Detailed htlc failure info.
     * </pre>
     *
     * <code>.co.anode.anodium.Failure failure = 5;</code>
     */
    private void clearFailure() {  failure_ = null;
      
    }

    public static final int PREIMAGE_FIELD_NUMBER = 6;
    private com.google.protobuf.ByteString preimage_;
    /**
     * <pre>
     * The preimage that was used to settle the HTLC.
     * </pre>
     *
     * <code>bytes preimage = 6;</code>
     * @return The preimage.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPreimage() {
      return preimage_;
    }
    /**
     * <pre>
     * The preimage that was used to settle the HTLC.
     * </pre>
     *
     * <code>bytes preimage = 6;</code>
     * @param value The preimage to set.
     */
    private void setPreimage(com.google.protobuf.ByteString value) {
      value.getClass();
  
      preimage_ = value;
    }
    /**
     * <pre>
     * The preimage that was used to settle the HTLC.
     * </pre>
     *
     * <code>bytes preimage = 6;</code>
     */
    private void clearPreimage() {
      
      preimage_ = getDefaultInstance().getPreimage();
    }

    public static co.anode.anodium.Rpc.HTLCAttempt parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.HTLCAttempt parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.HTLCAttempt parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.HTLCAttempt parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.HTLCAttempt parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.HTLCAttempt parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.HTLCAttempt parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.HTLCAttempt parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.HTLCAttempt parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.HTLCAttempt parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.HTLCAttempt parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.HTLCAttempt parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.HTLCAttempt prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.HTLCAttempt}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.HTLCAttempt, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.HTLCAttempt)
        co.anode.anodium.Rpc.HTLCAttemptOrBuilder {
      // Construct using co.anode.anodium.Rpc.HTLCAttempt.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The status of the HTLC.
       * </pre>
       *
       * <code>.co.anode.anodium.HTLCAttempt.HTLCStatus status = 1;</code>
       * @return The enum numeric value on the wire for status.
       */
      @java.lang.Override
      public int getStatusValue() {
        return instance.getStatusValue();
      }
      /**
       * <pre>
       * The status of the HTLC.
       * </pre>
       *
       * <code>.co.anode.anodium.HTLCAttempt.HTLCStatus status = 1;</code>
       * @param value The status to set.
       * @return This builder for chaining.
       */
      public Builder setStatusValue(int value) {
        copyOnWrite();
        instance.setStatusValue(value);
        return this;
      }
      /**
       * <pre>
       * The status of the HTLC.
       * </pre>
       *
       * <code>.co.anode.anodium.HTLCAttempt.HTLCStatus status = 1;</code>
       * @return The status.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.HTLCAttempt.HTLCStatus getStatus() {
        return instance.getStatus();
      }
      /**
       * <pre>
       * The status of the HTLC.
       * </pre>
       *
       * <code>.co.anode.anodium.HTLCAttempt.HTLCStatus status = 1;</code>
       * @param value The enum numeric value on the wire for status to set.
       * @return This builder for chaining.
       */
      public Builder setStatus(co.anode.anodium.Rpc.HTLCAttempt.HTLCStatus value) {
        copyOnWrite();
        instance.setStatus(value);
        return this;
      }
      /**
       * <pre>
       * The status of the HTLC.
       * </pre>
       *
       * <code>.co.anode.anodium.HTLCAttempt.HTLCStatus status = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearStatus() {
        copyOnWrite();
        instance.clearStatus();
        return this;
      }

      /**
       * <pre>
       * The route taken by this HTLC.
       * </pre>
       *
       * <code>.co.anode.anodium.Route route = 2;</code>
       */
      @java.lang.Override
      public boolean hasRoute() {
        return instance.hasRoute();
      }
      /**
       * <pre>
       * The route taken by this HTLC.
       * </pre>
       *
       * <code>.co.anode.anodium.Route route = 2;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Route getRoute() {
        return instance.getRoute();
      }
      /**
       * <pre>
       * The route taken by this HTLC.
       * </pre>
       *
       * <code>.co.anode.anodium.Route route = 2;</code>
       */
      public Builder setRoute(co.anode.anodium.Rpc.Route value) {
        copyOnWrite();
        instance.setRoute(value);
        return this;
        }
      /**
       * <pre>
       * The route taken by this HTLC.
       * </pre>
       *
       * <code>.co.anode.anodium.Route route = 2;</code>
       */
      public Builder setRoute(
          co.anode.anodium.Rpc.Route.Builder builderForValue) {
        copyOnWrite();
        instance.setRoute(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The route taken by this HTLC.
       * </pre>
       *
       * <code>.co.anode.anodium.Route route = 2;</code>
       */
      public Builder mergeRoute(co.anode.anodium.Rpc.Route value) {
        copyOnWrite();
        instance.mergeRoute(value);
        return this;
      }
      /**
       * <pre>
       * The route taken by this HTLC.
       * </pre>
       *
       * <code>.co.anode.anodium.Route route = 2;</code>
       */
      public Builder clearRoute() {  copyOnWrite();
        instance.clearRoute();
        return this;
      }

      /**
       * <pre>
       * The time in UNIX nanoseconds at which this HTLC was sent.
       * </pre>
       *
       * <code>int64 attempt_time_ns = 3;</code>
       * @return The attemptTimeNs.
       */
      @java.lang.Override
      public long getAttemptTimeNs() {
        return instance.getAttemptTimeNs();
      }
      /**
       * <pre>
       * The time in UNIX nanoseconds at which this HTLC was sent.
       * </pre>
       *
       * <code>int64 attempt_time_ns = 3;</code>
       * @param value The attemptTimeNs to set.
       * @return This builder for chaining.
       */
      public Builder setAttemptTimeNs(long value) {
        copyOnWrite();
        instance.setAttemptTimeNs(value);
        return this;
      }
      /**
       * <pre>
       * The time in UNIX nanoseconds at which this HTLC was sent.
       * </pre>
       *
       * <code>int64 attempt_time_ns = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearAttemptTimeNs() {
        copyOnWrite();
        instance.clearAttemptTimeNs();
        return this;
      }

      /**
       * <pre>
       *The time in UNIX nanoseconds at which this HTLC was settled or failed.
       *This value will not be set if the HTLC is still IN_FLIGHT.
       * </pre>
       *
       * <code>int64 resolve_time_ns = 4;</code>
       * @return The resolveTimeNs.
       */
      @java.lang.Override
      public long getResolveTimeNs() {
        return instance.getResolveTimeNs();
      }
      /**
       * <pre>
       *The time in UNIX nanoseconds at which this HTLC was settled or failed.
       *This value will not be set if the HTLC is still IN_FLIGHT.
       * </pre>
       *
       * <code>int64 resolve_time_ns = 4;</code>
       * @param value The resolveTimeNs to set.
       * @return This builder for chaining.
       */
      public Builder setResolveTimeNs(long value) {
        copyOnWrite();
        instance.setResolveTimeNs(value);
        return this;
      }
      /**
       * <pre>
       *The time in UNIX nanoseconds at which this HTLC was settled or failed.
       *This value will not be set if the HTLC is still IN_FLIGHT.
       * </pre>
       *
       * <code>int64 resolve_time_ns = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearResolveTimeNs() {
        copyOnWrite();
        instance.clearResolveTimeNs();
        return this;
      }

      /**
       * <pre>
       * Detailed htlc failure info.
       * </pre>
       *
       * <code>.co.anode.anodium.Failure failure = 5;</code>
       */
      @java.lang.Override
      public boolean hasFailure() {
        return instance.hasFailure();
      }
      /**
       * <pre>
       * Detailed htlc failure info.
       * </pre>
       *
       * <code>.co.anode.anodium.Failure failure = 5;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Failure getFailure() {
        return instance.getFailure();
      }
      /**
       * <pre>
       * Detailed htlc failure info.
       * </pre>
       *
       * <code>.co.anode.anodium.Failure failure = 5;</code>
       */
      public Builder setFailure(co.anode.anodium.Rpc.Failure value) {
        copyOnWrite();
        instance.setFailure(value);
        return this;
        }
      /**
       * <pre>
       * Detailed htlc failure info.
       * </pre>
       *
       * <code>.co.anode.anodium.Failure failure = 5;</code>
       */
      public Builder setFailure(
          co.anode.anodium.Rpc.Failure.Builder builderForValue) {
        copyOnWrite();
        instance.setFailure(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Detailed htlc failure info.
       * </pre>
       *
       * <code>.co.anode.anodium.Failure failure = 5;</code>
       */
      public Builder mergeFailure(co.anode.anodium.Rpc.Failure value) {
        copyOnWrite();
        instance.mergeFailure(value);
        return this;
      }
      /**
       * <pre>
       * Detailed htlc failure info.
       * </pre>
       *
       * <code>.co.anode.anodium.Failure failure = 5;</code>
       */
      public Builder clearFailure() {  copyOnWrite();
        instance.clearFailure();
        return this;
      }

      /**
       * <pre>
       * The preimage that was used to settle the HTLC.
       * </pre>
       *
       * <code>bytes preimage = 6;</code>
       * @return The preimage.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPreimage() {
        return instance.getPreimage();
      }
      /**
       * <pre>
       * The preimage that was used to settle the HTLC.
       * </pre>
       *
       * <code>bytes preimage = 6;</code>
       * @param value The preimage to set.
       * @return This builder for chaining.
       */
      public Builder setPreimage(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPreimage(value);
        return this;
      }
      /**
       * <pre>
       * The preimage that was used to settle the HTLC.
       * </pre>
       *
       * <code>bytes preimage = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearPreimage() {
        copyOnWrite();
        instance.clearPreimage();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.HTLCAttempt)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.HTLCAttempt();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "status_",
              "route_",
              "attemptTimeNs_",
              "resolveTimeNs_",
              "failure_",
              "preimage_",
            };
            java.lang.String info =
                "\u0000\u0006\u0000\u0000\u0001\u0006\u0006\u0000\u0000\u0000\u0001\f\u0002\t\u0003" +
                "\u0002\u0004\u0002\u0005\t\u0006\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.HTLCAttempt> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.HTLCAttempt.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.HTLCAttempt>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.HTLCAttempt)
    private static final co.anode.anodium.Rpc.HTLCAttempt DEFAULT_INSTANCE;
    static {
      HTLCAttempt defaultInstance = new HTLCAttempt();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        HTLCAttempt.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.HTLCAttempt getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<HTLCAttempt> PARSER;

    public static com.google.protobuf.Parser<HTLCAttempt> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ListPaymentsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ListPaymentsRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *If true, then return payments that have not yet fully completed. This means
     *that pending payments, as well as failed payments will show up if this
     *field is set to true. This flag doesn't change the meaning of the indices,
     *which are tied to individual payments.
     * </pre>
     *
     * <code>bool include_incomplete = 1;</code>
     * @return The includeIncomplete.
     */
    boolean getIncludeIncomplete();

    /**
     * <pre>
     *The index of a payment that will be used as either the start or end of a
     *query to determine which payments should be returned in the response. The
     *index_offset is exclusive. In the case of a zero index_offset, the query
     *will start with the oldest payment when paginating forwards, or will end
     *with the most recent payment when paginating backwards.
     * </pre>
     *
     * <code>uint64 index_offset = 2;</code>
     * @return The indexOffset.
     */
    long getIndexOffset();

    /**
     * <pre>
     * The maximal number of payments returned in the response to this query.
     * </pre>
     *
     * <code>uint64 max_payments = 3;</code>
     * @return The maxPayments.
     */
    long getMaxPayments();

    /**
     * <pre>
     *If set, the payments returned will result from seeking backwards from the
     *specified index offset. This can be used to paginate backwards. The order
     *of the returned payments is always oldest first (ascending index order).
     * </pre>
     *
     * <code>bool reversed = 4;</code>
     * @return The reversed.
     */
    boolean getReversed();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ListPaymentsRequest}
   */
  public  static final class ListPaymentsRequest extends
      com.google.protobuf.GeneratedMessageLite<
          ListPaymentsRequest, ListPaymentsRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ListPaymentsRequest)
      ListPaymentsRequestOrBuilder {
    private ListPaymentsRequest() {
    }
    public static final int INCLUDE_INCOMPLETE_FIELD_NUMBER = 1;
    private boolean includeIncomplete_;
    /**
     * <pre>
     *If true, then return payments that have not yet fully completed. This means
     *that pending payments, as well as failed payments will show up if this
     *field is set to true. This flag doesn't change the meaning of the indices,
     *which are tied to individual payments.
     * </pre>
     *
     * <code>bool include_incomplete = 1;</code>
     * @return The includeIncomplete.
     */
    @java.lang.Override
    public boolean getIncludeIncomplete() {
      return includeIncomplete_;
    }
    /**
     * <pre>
     *If true, then return payments that have not yet fully completed. This means
     *that pending payments, as well as failed payments will show up if this
     *field is set to true. This flag doesn't change the meaning of the indices,
     *which are tied to individual payments.
     * </pre>
     *
     * <code>bool include_incomplete = 1;</code>
     * @param value The includeIncomplete to set.
     */
    private void setIncludeIncomplete(boolean value) {
      
      includeIncomplete_ = value;
    }
    /**
     * <pre>
     *If true, then return payments that have not yet fully completed. This means
     *that pending payments, as well as failed payments will show up if this
     *field is set to true. This flag doesn't change the meaning of the indices,
     *which are tied to individual payments.
     * </pre>
     *
     * <code>bool include_incomplete = 1;</code>
     */
    private void clearIncludeIncomplete() {
      
      includeIncomplete_ = false;
    }

    public static final int INDEX_OFFSET_FIELD_NUMBER = 2;
    private long indexOffset_;
    /**
     * <pre>
     *The index of a payment that will be used as either the start or end of a
     *query to determine which payments should be returned in the response. The
     *index_offset is exclusive. In the case of a zero index_offset, the query
     *will start with the oldest payment when paginating forwards, or will end
     *with the most recent payment when paginating backwards.
     * </pre>
     *
     * <code>uint64 index_offset = 2;</code>
     * @return The indexOffset.
     */
    @java.lang.Override
    public long getIndexOffset() {
      return indexOffset_;
    }
    /**
     * <pre>
     *The index of a payment that will be used as either the start or end of a
     *query to determine which payments should be returned in the response. The
     *index_offset is exclusive. In the case of a zero index_offset, the query
     *will start with the oldest payment when paginating forwards, or will end
     *with the most recent payment when paginating backwards.
     * </pre>
     *
     * <code>uint64 index_offset = 2;</code>
     * @param value The indexOffset to set.
     */
    private void setIndexOffset(long value) {
      
      indexOffset_ = value;
    }
    /**
     * <pre>
     *The index of a payment that will be used as either the start or end of a
     *query to determine which payments should be returned in the response. The
     *index_offset is exclusive. In the case of a zero index_offset, the query
     *will start with the oldest payment when paginating forwards, or will end
     *with the most recent payment when paginating backwards.
     * </pre>
     *
     * <code>uint64 index_offset = 2;</code>
     */
    private void clearIndexOffset() {
      
      indexOffset_ = 0L;
    }

    public static final int MAX_PAYMENTS_FIELD_NUMBER = 3;
    private long maxPayments_;
    /**
     * <pre>
     * The maximal number of payments returned in the response to this query.
     * </pre>
     *
     * <code>uint64 max_payments = 3;</code>
     * @return The maxPayments.
     */
    @java.lang.Override
    public long getMaxPayments() {
      return maxPayments_;
    }
    /**
     * <pre>
     * The maximal number of payments returned in the response to this query.
     * </pre>
     *
     * <code>uint64 max_payments = 3;</code>
     * @param value The maxPayments to set.
     */
    private void setMaxPayments(long value) {
      
      maxPayments_ = value;
    }
    /**
     * <pre>
     * The maximal number of payments returned in the response to this query.
     * </pre>
     *
     * <code>uint64 max_payments = 3;</code>
     */
    private void clearMaxPayments() {
      
      maxPayments_ = 0L;
    }

    public static final int REVERSED_FIELD_NUMBER = 4;
    private boolean reversed_;
    /**
     * <pre>
     *If set, the payments returned will result from seeking backwards from the
     *specified index offset. This can be used to paginate backwards. The order
     *of the returned payments is always oldest first (ascending index order).
     * </pre>
     *
     * <code>bool reversed = 4;</code>
     * @return The reversed.
     */
    @java.lang.Override
    public boolean getReversed() {
      return reversed_;
    }
    /**
     * <pre>
     *If set, the payments returned will result from seeking backwards from the
     *specified index offset. This can be used to paginate backwards. The order
     *of the returned payments is always oldest first (ascending index order).
     * </pre>
     *
     * <code>bool reversed = 4;</code>
     * @param value The reversed to set.
     */
    private void setReversed(boolean value) {
      
      reversed_ = value;
    }
    /**
     * <pre>
     *If set, the payments returned will result from seeking backwards from the
     *specified index offset. This can be used to paginate backwards. The order
     *of the returned payments is always oldest first (ascending index order).
     * </pre>
     *
     * <code>bool reversed = 4;</code>
     */
    private void clearReversed() {
      
      reversed_ = false;
    }

    public static co.anode.anodium.Rpc.ListPaymentsRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListPaymentsRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPaymentsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListPaymentsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPaymentsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListPaymentsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPaymentsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListPaymentsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPaymentsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListPaymentsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPaymentsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListPaymentsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ListPaymentsRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ListPaymentsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ListPaymentsRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ListPaymentsRequest)
        co.anode.anodium.Rpc.ListPaymentsRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.ListPaymentsRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *If true, then return payments that have not yet fully completed. This means
       *that pending payments, as well as failed payments will show up if this
       *field is set to true. This flag doesn't change the meaning of the indices,
       *which are tied to individual payments.
       * </pre>
       *
       * <code>bool include_incomplete = 1;</code>
       * @return The includeIncomplete.
       */
      @java.lang.Override
      public boolean getIncludeIncomplete() {
        return instance.getIncludeIncomplete();
      }
      /**
       * <pre>
       *If true, then return payments that have not yet fully completed. This means
       *that pending payments, as well as failed payments will show up if this
       *field is set to true. This flag doesn't change the meaning of the indices,
       *which are tied to individual payments.
       * </pre>
       *
       * <code>bool include_incomplete = 1;</code>
       * @param value The includeIncomplete to set.
       * @return This builder for chaining.
       */
      public Builder setIncludeIncomplete(boolean value) {
        copyOnWrite();
        instance.setIncludeIncomplete(value);
        return this;
      }
      /**
       * <pre>
       *If true, then return payments that have not yet fully completed. This means
       *that pending payments, as well as failed payments will show up if this
       *field is set to true. This flag doesn't change the meaning of the indices,
       *which are tied to individual payments.
       * </pre>
       *
       * <code>bool include_incomplete = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearIncludeIncomplete() {
        copyOnWrite();
        instance.clearIncludeIncomplete();
        return this;
      }

      /**
       * <pre>
       *The index of a payment that will be used as either the start or end of a
       *query to determine which payments should be returned in the response. The
       *index_offset is exclusive. In the case of a zero index_offset, the query
       *will start with the oldest payment when paginating forwards, or will end
       *with the most recent payment when paginating backwards.
       * </pre>
       *
       * <code>uint64 index_offset = 2;</code>
       * @return The indexOffset.
       */
      @java.lang.Override
      public long getIndexOffset() {
        return instance.getIndexOffset();
      }
      /**
       * <pre>
       *The index of a payment that will be used as either the start or end of a
       *query to determine which payments should be returned in the response. The
       *index_offset is exclusive. In the case of a zero index_offset, the query
       *will start with the oldest payment when paginating forwards, or will end
       *with the most recent payment when paginating backwards.
       * </pre>
       *
       * <code>uint64 index_offset = 2;</code>
       * @param value The indexOffset to set.
       * @return This builder for chaining.
       */
      public Builder setIndexOffset(long value) {
        copyOnWrite();
        instance.setIndexOffset(value);
        return this;
      }
      /**
       * <pre>
       *The index of a payment that will be used as either the start or end of a
       *query to determine which payments should be returned in the response. The
       *index_offset is exclusive. In the case of a zero index_offset, the query
       *will start with the oldest payment when paginating forwards, or will end
       *with the most recent payment when paginating backwards.
       * </pre>
       *
       * <code>uint64 index_offset = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearIndexOffset() {
        copyOnWrite();
        instance.clearIndexOffset();
        return this;
      }

      /**
       * <pre>
       * The maximal number of payments returned in the response to this query.
       * </pre>
       *
       * <code>uint64 max_payments = 3;</code>
       * @return The maxPayments.
       */
      @java.lang.Override
      public long getMaxPayments() {
        return instance.getMaxPayments();
      }
      /**
       * <pre>
       * The maximal number of payments returned in the response to this query.
       * </pre>
       *
       * <code>uint64 max_payments = 3;</code>
       * @param value The maxPayments to set.
       * @return This builder for chaining.
       */
      public Builder setMaxPayments(long value) {
        copyOnWrite();
        instance.setMaxPayments(value);
        return this;
      }
      /**
       * <pre>
       * The maximal number of payments returned in the response to this query.
       * </pre>
       *
       * <code>uint64 max_payments = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxPayments() {
        copyOnWrite();
        instance.clearMaxPayments();
        return this;
      }

      /**
       * <pre>
       *If set, the payments returned will result from seeking backwards from the
       *specified index offset. This can be used to paginate backwards. The order
       *of the returned payments is always oldest first (ascending index order).
       * </pre>
       *
       * <code>bool reversed = 4;</code>
       * @return The reversed.
       */
      @java.lang.Override
      public boolean getReversed() {
        return instance.getReversed();
      }
      /**
       * <pre>
       *If set, the payments returned will result from seeking backwards from the
       *specified index offset. This can be used to paginate backwards. The order
       *of the returned payments is always oldest first (ascending index order).
       * </pre>
       *
       * <code>bool reversed = 4;</code>
       * @param value The reversed to set.
       * @return This builder for chaining.
       */
      public Builder setReversed(boolean value) {
        copyOnWrite();
        instance.setReversed(value);
        return this;
      }
      /**
       * <pre>
       *If set, the payments returned will result from seeking backwards from the
       *specified index offset. This can be used to paginate backwards. The order
       *of the returned payments is always oldest first (ascending index order).
       * </pre>
       *
       * <code>bool reversed = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearReversed() {
        copyOnWrite();
        instance.clearReversed();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ListPaymentsRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ListPaymentsRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "includeIncomplete_",
              "indexOffset_",
              "maxPayments_",
              "reversed_",
            };
            java.lang.String info =
                "\u0000\u0004\u0000\u0000\u0001\u0004\u0004\u0000\u0000\u0000\u0001\u0007\u0002\u0003" +
                "\u0003\u0003\u0004\u0007";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ListPaymentsRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ListPaymentsRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ListPaymentsRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ListPaymentsRequest)
    private static final co.anode.anodium.Rpc.ListPaymentsRequest DEFAULT_INSTANCE;
    static {
      ListPaymentsRequest defaultInstance = new ListPaymentsRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ListPaymentsRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ListPaymentsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ListPaymentsRequest> PARSER;

    public static com.google.protobuf.Parser<ListPaymentsRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ListPaymentsResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ListPaymentsResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The list of payments
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
     */
    java.util.List<co.anode.anodium.Rpc.Payment> 
        getPaymentsList();
    /**
     * <pre>
     * The list of payments
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
     */
    co.anode.anodium.Rpc.Payment getPayments(int index);
    /**
     * <pre>
     * The list of payments
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
     */
    int getPaymentsCount();

    /**
     * <pre>
     *The index of the first item in the set of returned payments. This can be
     *used as the index_offset to continue seeking backwards in the next request.
     * </pre>
     *
     * <code>uint64 first_index_offset = 2;</code>
     * @return The firstIndexOffset.
     */
    long getFirstIndexOffset();

    /**
     * <pre>
     *The index of the last item in the set of returned payments. This can be used
     *as the index_offset to continue seeking forwards in the next request.
     * </pre>
     *
     * <code>uint64 last_index_offset = 3;</code>
     * @return The lastIndexOffset.
     */
    long getLastIndexOffset();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ListPaymentsResponse}
   */
  public  static final class ListPaymentsResponse extends
      com.google.protobuf.GeneratedMessageLite<
          ListPaymentsResponse, ListPaymentsResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ListPaymentsResponse)
      ListPaymentsResponseOrBuilder {
    private ListPaymentsResponse() {
      payments_ = emptyProtobufList();
    }
    public static final int PAYMENTS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Payment> payments_;
    /**
     * <pre>
     * The list of payments
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.Payment> getPaymentsList() {
      return payments_;
    }
    /**
     * <pre>
     * The list of payments
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.PaymentOrBuilder> 
        getPaymentsOrBuilderList() {
      return payments_;
    }
    /**
     * <pre>
     * The list of payments
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
     */
    @java.lang.Override
    public int getPaymentsCount() {
      return payments_.size();
    }
    /**
     * <pre>
     * The list of payments
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Payment getPayments(int index) {
      return payments_.get(index);
    }
    /**
     * <pre>
     * The list of payments
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
     */
    public co.anode.anodium.Rpc.PaymentOrBuilder getPaymentsOrBuilder(
        int index) {
      return payments_.get(index);
    }
    private void ensurePaymentsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Payment> tmp = payments_;
      if (!tmp.isModifiable()) {
        payments_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * The list of payments
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
     */
    private void setPayments(
        int index, co.anode.anodium.Rpc.Payment value) {
      value.getClass();
  ensurePaymentsIsMutable();
      payments_.set(index, value);
    }
    /**
     * <pre>
     * The list of payments
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
     */
    private void addPayments(co.anode.anodium.Rpc.Payment value) {
      value.getClass();
  ensurePaymentsIsMutable();
      payments_.add(value);
    }
    /**
     * <pre>
     * The list of payments
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
     */
    private void addPayments(
        int index, co.anode.anodium.Rpc.Payment value) {
      value.getClass();
  ensurePaymentsIsMutable();
      payments_.add(index, value);
    }
    /**
     * <pre>
     * The list of payments
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
     */
    private void addAllPayments(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.Payment> values) {
      ensurePaymentsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, payments_);
    }
    /**
     * <pre>
     * The list of payments
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
     */
    private void clearPayments() {
      payments_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The list of payments
     * </pre>
     *
     * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
     */
    private void removePayments(int index) {
      ensurePaymentsIsMutable();
      payments_.remove(index);
    }

    public static final int FIRST_INDEX_OFFSET_FIELD_NUMBER = 2;
    private long firstIndexOffset_;
    /**
     * <pre>
     *The index of the first item in the set of returned payments. This can be
     *used as the index_offset to continue seeking backwards in the next request.
     * </pre>
     *
     * <code>uint64 first_index_offset = 2;</code>
     * @return The firstIndexOffset.
     */
    @java.lang.Override
    public long getFirstIndexOffset() {
      return firstIndexOffset_;
    }
    /**
     * <pre>
     *The index of the first item in the set of returned payments. This can be
     *used as the index_offset to continue seeking backwards in the next request.
     * </pre>
     *
     * <code>uint64 first_index_offset = 2;</code>
     * @param value The firstIndexOffset to set.
     */
    private void setFirstIndexOffset(long value) {
      
      firstIndexOffset_ = value;
    }
    /**
     * <pre>
     *The index of the first item in the set of returned payments. This can be
     *used as the index_offset to continue seeking backwards in the next request.
     * </pre>
     *
     * <code>uint64 first_index_offset = 2;</code>
     */
    private void clearFirstIndexOffset() {
      
      firstIndexOffset_ = 0L;
    }

    public static final int LAST_INDEX_OFFSET_FIELD_NUMBER = 3;
    private long lastIndexOffset_;
    /**
     * <pre>
     *The index of the last item in the set of returned payments. This can be used
     *as the index_offset to continue seeking forwards in the next request.
     * </pre>
     *
     * <code>uint64 last_index_offset = 3;</code>
     * @return The lastIndexOffset.
     */
    @java.lang.Override
    public long getLastIndexOffset() {
      return lastIndexOffset_;
    }
    /**
     * <pre>
     *The index of the last item in the set of returned payments. This can be used
     *as the index_offset to continue seeking forwards in the next request.
     * </pre>
     *
     * <code>uint64 last_index_offset = 3;</code>
     * @param value The lastIndexOffset to set.
     */
    private void setLastIndexOffset(long value) {
      
      lastIndexOffset_ = value;
    }
    /**
     * <pre>
     *The index of the last item in the set of returned payments. This can be used
     *as the index_offset to continue seeking forwards in the next request.
     * </pre>
     *
     * <code>uint64 last_index_offset = 3;</code>
     */
    private void clearLastIndexOffset() {
      
      lastIndexOffset_ = 0L;
    }

    public static co.anode.anodium.Rpc.ListPaymentsResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListPaymentsResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPaymentsResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListPaymentsResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPaymentsResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListPaymentsResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPaymentsResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListPaymentsResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPaymentsResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListPaymentsResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPaymentsResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListPaymentsResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ListPaymentsResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ListPaymentsResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ListPaymentsResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ListPaymentsResponse)
        co.anode.anodium.Rpc.ListPaymentsResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.ListPaymentsResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The list of payments
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.Payment> getPaymentsList() {
        return java.util.Collections.unmodifiableList(
            instance.getPaymentsList());
      }
      /**
       * <pre>
       * The list of payments
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
       */
      @java.lang.Override
      public int getPaymentsCount() {
        return instance.getPaymentsCount();
      }/**
       * <pre>
       * The list of payments
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Payment getPayments(int index) {
        return instance.getPayments(index);
      }
      /**
       * <pre>
       * The list of payments
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
       */
      public Builder setPayments(
          int index, co.anode.anodium.Rpc.Payment value) {
        copyOnWrite();
        instance.setPayments(index, value);
        return this;
      }
      /**
       * <pre>
       * The list of payments
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
       */
      public Builder setPayments(
          int index, co.anode.anodium.Rpc.Payment.Builder builderForValue) {
        copyOnWrite();
        instance.setPayments(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of payments
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
       */
      public Builder addPayments(co.anode.anodium.Rpc.Payment value) {
        copyOnWrite();
        instance.addPayments(value);
        return this;
      }
      /**
       * <pre>
       * The list of payments
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
       */
      public Builder addPayments(
          int index, co.anode.anodium.Rpc.Payment value) {
        copyOnWrite();
        instance.addPayments(index, value);
        return this;
      }
      /**
       * <pre>
       * The list of payments
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
       */
      public Builder addPayments(
          co.anode.anodium.Rpc.Payment.Builder builderForValue) {
        copyOnWrite();
        instance.addPayments(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of payments
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
       */
      public Builder addPayments(
          int index, co.anode.anodium.Rpc.Payment.Builder builderForValue) {
        copyOnWrite();
        instance.addPayments(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of payments
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
       */
      public Builder addAllPayments(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.Payment> values) {
        copyOnWrite();
        instance.addAllPayments(values);
        return this;
      }
      /**
       * <pre>
       * The list of payments
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
       */
      public Builder clearPayments() {
        copyOnWrite();
        instance.clearPayments();
        return this;
      }
      /**
       * <pre>
       * The list of payments
       * </pre>
       *
       * <code>repeated .co.anode.anodium.Payment payments = 1;</code>
       */
      public Builder removePayments(int index) {
        copyOnWrite();
        instance.removePayments(index);
        return this;
      }

      /**
       * <pre>
       *The index of the first item in the set of returned payments. This can be
       *used as the index_offset to continue seeking backwards in the next request.
       * </pre>
       *
       * <code>uint64 first_index_offset = 2;</code>
       * @return The firstIndexOffset.
       */
      @java.lang.Override
      public long getFirstIndexOffset() {
        return instance.getFirstIndexOffset();
      }
      /**
       * <pre>
       *The index of the first item in the set of returned payments. This can be
       *used as the index_offset to continue seeking backwards in the next request.
       * </pre>
       *
       * <code>uint64 first_index_offset = 2;</code>
       * @param value The firstIndexOffset to set.
       * @return This builder for chaining.
       */
      public Builder setFirstIndexOffset(long value) {
        copyOnWrite();
        instance.setFirstIndexOffset(value);
        return this;
      }
      /**
       * <pre>
       *The index of the first item in the set of returned payments. This can be
       *used as the index_offset to continue seeking backwards in the next request.
       * </pre>
       *
       * <code>uint64 first_index_offset = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearFirstIndexOffset() {
        copyOnWrite();
        instance.clearFirstIndexOffset();
        return this;
      }

      /**
       * <pre>
       *The index of the last item in the set of returned payments. This can be used
       *as the index_offset to continue seeking forwards in the next request.
       * </pre>
       *
       * <code>uint64 last_index_offset = 3;</code>
       * @return The lastIndexOffset.
       */
      @java.lang.Override
      public long getLastIndexOffset() {
        return instance.getLastIndexOffset();
      }
      /**
       * <pre>
       *The index of the last item in the set of returned payments. This can be used
       *as the index_offset to continue seeking forwards in the next request.
       * </pre>
       *
       * <code>uint64 last_index_offset = 3;</code>
       * @param value The lastIndexOffset to set.
       * @return This builder for chaining.
       */
      public Builder setLastIndexOffset(long value) {
        copyOnWrite();
        instance.setLastIndexOffset(value);
        return this;
      }
      /**
       * <pre>
       *The index of the last item in the set of returned payments. This can be used
       *as the index_offset to continue seeking forwards in the next request.
       * </pre>
       *
       * <code>uint64 last_index_offset = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearLastIndexOffset() {
        copyOnWrite();
        instance.clearLastIndexOffset();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ListPaymentsResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ListPaymentsResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "payments_",
              co.anode.anodium.Rpc.Payment.class,
              "firstIndexOffset_",
              "lastIndexOffset_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0003\u0003\u0000\u0001\u0000\u0001\u001b\u0002\u0003" +
                "\u0003\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ListPaymentsResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ListPaymentsResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ListPaymentsResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ListPaymentsResponse)
    private static final co.anode.anodium.Rpc.ListPaymentsResponse DEFAULT_INSTANCE;
    static {
      ListPaymentsResponse defaultInstance = new ListPaymentsResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ListPaymentsResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ListPaymentsResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ListPaymentsResponse> PARSER;

    public static com.google.protobuf.Parser<ListPaymentsResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface DeleteAllPaymentsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.DeleteAllPaymentsRequest)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.DeleteAllPaymentsRequest}
   */
  public  static final class DeleteAllPaymentsRequest extends
      com.google.protobuf.GeneratedMessageLite<
          DeleteAllPaymentsRequest, DeleteAllPaymentsRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.DeleteAllPaymentsRequest)
      DeleteAllPaymentsRequestOrBuilder {
    private DeleteAllPaymentsRequest() {
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.DeleteAllPaymentsRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.DeleteAllPaymentsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.DeleteAllPaymentsRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.DeleteAllPaymentsRequest)
        co.anode.anodium.Rpc.DeleteAllPaymentsRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.DeleteAllPaymentsRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.DeleteAllPaymentsRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.DeleteAllPaymentsRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.DeleteAllPaymentsRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.DeleteAllPaymentsRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.DeleteAllPaymentsRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.DeleteAllPaymentsRequest)
    private static final co.anode.anodium.Rpc.DeleteAllPaymentsRequest DEFAULT_INSTANCE;
    static {
      DeleteAllPaymentsRequest defaultInstance = new DeleteAllPaymentsRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        DeleteAllPaymentsRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.DeleteAllPaymentsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<DeleteAllPaymentsRequest> PARSER;

    public static com.google.protobuf.Parser<DeleteAllPaymentsRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface DeleteAllPaymentsResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.DeleteAllPaymentsResponse)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.DeleteAllPaymentsResponse}
   */
  public  static final class DeleteAllPaymentsResponse extends
      com.google.protobuf.GeneratedMessageLite<
          DeleteAllPaymentsResponse, DeleteAllPaymentsResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.DeleteAllPaymentsResponse)
      DeleteAllPaymentsResponseOrBuilder {
    private DeleteAllPaymentsResponse() {
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DeleteAllPaymentsResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.DeleteAllPaymentsResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.DeleteAllPaymentsResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.DeleteAllPaymentsResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.DeleteAllPaymentsResponse)
        co.anode.anodium.Rpc.DeleteAllPaymentsResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.DeleteAllPaymentsResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.DeleteAllPaymentsResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.DeleteAllPaymentsResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.DeleteAllPaymentsResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.DeleteAllPaymentsResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.DeleteAllPaymentsResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.DeleteAllPaymentsResponse)
    private static final co.anode.anodium.Rpc.DeleteAllPaymentsResponse DEFAULT_INSTANCE;
    static {
      DeleteAllPaymentsResponse defaultInstance = new DeleteAllPaymentsResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        DeleteAllPaymentsResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.DeleteAllPaymentsResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<DeleteAllPaymentsResponse> PARSER;

    public static com.google.protobuf.Parser<DeleteAllPaymentsResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface AbandonChannelRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.AbandonChannelRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     * @return Whether the channelPoint field is set.
     */
    boolean hasChannelPoint();
    /**
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     * @return The channelPoint.
     */
    co.anode.anodium.Rpc.ChannelPoint getChannelPoint();

    /**
     * <code>bool pending_funding_shim_only = 2;</code>
     * @return The pendingFundingShimOnly.
     */
    boolean getPendingFundingShimOnly();
  }
  /**
   * Protobuf type {@code co.anode.anodium.AbandonChannelRequest}
   */
  public  static final class AbandonChannelRequest extends
      com.google.protobuf.GeneratedMessageLite<
          AbandonChannelRequest, AbandonChannelRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.AbandonChannelRequest)
      AbandonChannelRequestOrBuilder {
    private AbandonChannelRequest() {
    }
    public static final int CHANNEL_POINT_FIELD_NUMBER = 1;
    private co.anode.anodium.Rpc.ChannelPoint channelPoint_;
    /**
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     */
    @java.lang.Override
    public boolean hasChannelPoint() {
      return channelPoint_ != null;
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelPoint getChannelPoint() {
      return channelPoint_ == null ? co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance() : channelPoint_;
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     */
    private void setChannelPoint(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  channelPoint_ = value;
      
      }
    /**
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeChannelPoint(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  if (channelPoint_ != null &&
          channelPoint_ != co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance()) {
        channelPoint_ =
          co.anode.anodium.Rpc.ChannelPoint.newBuilder(channelPoint_).mergeFrom(value).buildPartial();
      } else {
        channelPoint_ = value;
      }
      
    }
    /**
     * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
     */
    private void clearChannelPoint() {  channelPoint_ = null;
      
    }

    public static final int PENDING_FUNDING_SHIM_ONLY_FIELD_NUMBER = 2;
    private boolean pendingFundingShimOnly_;
    /**
     * <code>bool pending_funding_shim_only = 2;</code>
     * @return The pendingFundingShimOnly.
     */
    @java.lang.Override
    public boolean getPendingFundingShimOnly() {
      return pendingFundingShimOnly_;
    }
    /**
     * <code>bool pending_funding_shim_only = 2;</code>
     * @param value The pendingFundingShimOnly to set.
     */
    private void setPendingFundingShimOnly(boolean value) {
      
      pendingFundingShimOnly_ = value;
    }
    /**
     * <code>bool pending_funding_shim_only = 2;</code>
     */
    private void clearPendingFundingShimOnly() {
      
      pendingFundingShimOnly_ = false;
    }

    public static co.anode.anodium.Rpc.AbandonChannelRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.AbandonChannelRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.AbandonChannelRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.AbandonChannelRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.AbandonChannelRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.AbandonChannelRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.AbandonChannelRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.AbandonChannelRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.AbandonChannelRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.AbandonChannelRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.AbandonChannelRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.AbandonChannelRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.AbandonChannelRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.AbandonChannelRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.AbandonChannelRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.AbandonChannelRequest)
        co.anode.anodium.Rpc.AbandonChannelRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.AbandonChannelRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
       */
      @java.lang.Override
      public boolean hasChannelPoint() {
        return instance.hasChannelPoint();
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelPoint getChannelPoint() {
        return instance.getChannelPoint();
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
       */
      public Builder setChannelPoint(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.setChannelPoint(value);
        return this;
        }
      /**
       * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
       */
      public Builder setChannelPoint(
          co.anode.anodium.Rpc.ChannelPoint.Builder builderForValue) {
        copyOnWrite();
        instance.setChannelPoint(builderForValue.build());
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
       */
      public Builder mergeChannelPoint(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.mergeChannelPoint(value);
        return this;
      }
      /**
       * <code>.co.anode.anodium.ChannelPoint channel_point = 1;</code>
       */
      public Builder clearChannelPoint() {  copyOnWrite();
        instance.clearChannelPoint();
        return this;
      }

      /**
       * <code>bool pending_funding_shim_only = 2;</code>
       * @return The pendingFundingShimOnly.
       */
      @java.lang.Override
      public boolean getPendingFundingShimOnly() {
        return instance.getPendingFundingShimOnly();
      }
      /**
       * <code>bool pending_funding_shim_only = 2;</code>
       * @param value The pendingFundingShimOnly to set.
       * @return This builder for chaining.
       */
      public Builder setPendingFundingShimOnly(boolean value) {
        copyOnWrite();
        instance.setPendingFundingShimOnly(value);
        return this;
      }
      /**
       * <code>bool pending_funding_shim_only = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPendingFundingShimOnly() {
        copyOnWrite();
        instance.clearPendingFundingShimOnly();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.AbandonChannelRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.AbandonChannelRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "channelPoint_",
              "pendingFundingShimOnly_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\t\u0002\u0007" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.AbandonChannelRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.AbandonChannelRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.AbandonChannelRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.AbandonChannelRequest)
    private static final co.anode.anodium.Rpc.AbandonChannelRequest DEFAULT_INSTANCE;
    static {
      AbandonChannelRequest defaultInstance = new AbandonChannelRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        AbandonChannelRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.AbandonChannelRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<AbandonChannelRequest> PARSER;

    public static com.google.protobuf.Parser<AbandonChannelRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface AbandonChannelResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.AbandonChannelResponse)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.AbandonChannelResponse}
   */
  public  static final class AbandonChannelResponse extends
      com.google.protobuf.GeneratedMessageLite<
          AbandonChannelResponse, AbandonChannelResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.AbandonChannelResponse)
      AbandonChannelResponseOrBuilder {
    private AbandonChannelResponse() {
    }
    public static co.anode.anodium.Rpc.AbandonChannelResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.AbandonChannelResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.AbandonChannelResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.AbandonChannelResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.AbandonChannelResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.AbandonChannelResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.AbandonChannelResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.AbandonChannelResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.AbandonChannelResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.AbandonChannelResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.AbandonChannelResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.AbandonChannelResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.AbandonChannelResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.AbandonChannelResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.AbandonChannelResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.AbandonChannelResponse)
        co.anode.anodium.Rpc.AbandonChannelResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.AbandonChannelResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.AbandonChannelResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.AbandonChannelResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.AbandonChannelResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.AbandonChannelResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.AbandonChannelResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.AbandonChannelResponse)
    private static final co.anode.anodium.Rpc.AbandonChannelResponse DEFAULT_INSTANCE;
    static {
      AbandonChannelResponse defaultInstance = new AbandonChannelResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        AbandonChannelResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.AbandonChannelResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<AbandonChannelResponse> PARSER;

    public static com.google.protobuf.Parser<AbandonChannelResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface DebugLevelRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.DebugLevelRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>bool show = 1;</code>
     * @return The show.
     */
    boolean getShow();

    /**
     * <code>string level_spec = 2;</code>
     * @return The levelSpec.
     */
    java.lang.String getLevelSpec();
    /**
     * <code>string level_spec = 2;</code>
     * @return The bytes for levelSpec.
     */
    com.google.protobuf.ByteString
        getLevelSpecBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.DebugLevelRequest}
   */
  public  static final class DebugLevelRequest extends
      com.google.protobuf.GeneratedMessageLite<
          DebugLevelRequest, DebugLevelRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.DebugLevelRequest)
      DebugLevelRequestOrBuilder {
    private DebugLevelRequest() {
      levelSpec_ = "";
    }
    public static final int SHOW_FIELD_NUMBER = 1;
    private boolean show_;
    /**
     * <code>bool show = 1;</code>
     * @return The show.
     */
    @java.lang.Override
    public boolean getShow() {
      return show_;
    }
    /**
     * <code>bool show = 1;</code>
     * @param value The show to set.
     */
    private void setShow(boolean value) {
      
      show_ = value;
    }
    /**
     * <code>bool show = 1;</code>
     */
    private void clearShow() {
      
      show_ = false;
    }

    public static final int LEVEL_SPEC_FIELD_NUMBER = 2;
    private java.lang.String levelSpec_;
    /**
     * <code>string level_spec = 2;</code>
     * @return The levelSpec.
     */
    @java.lang.Override
    public java.lang.String getLevelSpec() {
      return levelSpec_;
    }
    /**
     * <code>string level_spec = 2;</code>
     * @return The bytes for levelSpec.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLevelSpecBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(levelSpec_);
    }
    /**
     * <code>string level_spec = 2;</code>
     * @param value The levelSpec to set.
     */
    private void setLevelSpec(
        java.lang.String value) {
      value.getClass();
  
      levelSpec_ = value;
    }
    /**
     * <code>string level_spec = 2;</code>
     */
    private void clearLevelSpec() {
      
      levelSpec_ = getDefaultInstance().getLevelSpec();
    }
    /**
     * <code>string level_spec = 2;</code>
     * @param value The bytes for levelSpec to set.
     */
    private void setLevelSpecBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      levelSpec_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.DebugLevelRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DebugLevelRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DebugLevelRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DebugLevelRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DebugLevelRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DebugLevelRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DebugLevelRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DebugLevelRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DebugLevelRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DebugLevelRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DebugLevelRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DebugLevelRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.DebugLevelRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.DebugLevelRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.DebugLevelRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.DebugLevelRequest)
        co.anode.anodium.Rpc.DebugLevelRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.DebugLevelRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>bool show = 1;</code>
       * @return The show.
       */
      @java.lang.Override
      public boolean getShow() {
        return instance.getShow();
      }
      /**
       * <code>bool show = 1;</code>
       * @param value The show to set.
       * @return This builder for chaining.
       */
      public Builder setShow(boolean value) {
        copyOnWrite();
        instance.setShow(value);
        return this;
      }
      /**
       * <code>bool show = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearShow() {
        copyOnWrite();
        instance.clearShow();
        return this;
      }

      /**
       * <code>string level_spec = 2;</code>
       * @return The levelSpec.
       */
      @java.lang.Override
      public java.lang.String getLevelSpec() {
        return instance.getLevelSpec();
      }
      /**
       * <code>string level_spec = 2;</code>
       * @return The bytes for levelSpec.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getLevelSpecBytes() {
        return instance.getLevelSpecBytes();
      }
      /**
       * <code>string level_spec = 2;</code>
       * @param value The levelSpec to set.
       * @return This builder for chaining.
       */
      public Builder setLevelSpec(
          java.lang.String value) {
        copyOnWrite();
        instance.setLevelSpec(value);
        return this;
      }
      /**
       * <code>string level_spec = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearLevelSpec() {
        copyOnWrite();
        instance.clearLevelSpec();
        return this;
      }
      /**
       * <code>string level_spec = 2;</code>
       * @param value The bytes for levelSpec to set.
       * @return This builder for chaining.
       */
      public Builder setLevelSpecBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLevelSpecBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.DebugLevelRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.DebugLevelRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "show_",
              "levelSpec_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0007\u0002\u0208" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.DebugLevelRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.DebugLevelRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.DebugLevelRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.DebugLevelRequest)
    private static final co.anode.anodium.Rpc.DebugLevelRequest DEFAULT_INSTANCE;
    static {
      DebugLevelRequest defaultInstance = new DebugLevelRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        DebugLevelRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.DebugLevelRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<DebugLevelRequest> PARSER;

    public static com.google.protobuf.Parser<DebugLevelRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface DebugLevelResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.DebugLevelResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>string sub_systems = 1;</code>
     * @return The subSystems.
     */
    java.lang.String getSubSystems();
    /**
     * <code>string sub_systems = 1;</code>
     * @return The bytes for subSystems.
     */
    com.google.protobuf.ByteString
        getSubSystemsBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.DebugLevelResponse}
   */
  public  static final class DebugLevelResponse extends
      com.google.protobuf.GeneratedMessageLite<
          DebugLevelResponse, DebugLevelResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.DebugLevelResponse)
      DebugLevelResponseOrBuilder {
    private DebugLevelResponse() {
      subSystems_ = "";
    }
    public static final int SUB_SYSTEMS_FIELD_NUMBER = 1;
    private java.lang.String subSystems_;
    /**
     * <code>string sub_systems = 1;</code>
     * @return The subSystems.
     */
    @java.lang.Override
    public java.lang.String getSubSystems() {
      return subSystems_;
    }
    /**
     * <code>string sub_systems = 1;</code>
     * @return The bytes for subSystems.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSubSystemsBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(subSystems_);
    }
    /**
     * <code>string sub_systems = 1;</code>
     * @param value The subSystems to set.
     */
    private void setSubSystems(
        java.lang.String value) {
      value.getClass();
  
      subSystems_ = value;
    }
    /**
     * <code>string sub_systems = 1;</code>
     */
    private void clearSubSystems() {
      
      subSystems_ = getDefaultInstance().getSubSystems();
    }
    /**
     * <code>string sub_systems = 1;</code>
     * @param value The bytes for subSystems to set.
     */
    private void setSubSystemsBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      subSystems_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.DebugLevelResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DebugLevelResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DebugLevelResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DebugLevelResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DebugLevelResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DebugLevelResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DebugLevelResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DebugLevelResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DebugLevelResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DebugLevelResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DebugLevelResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DebugLevelResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.DebugLevelResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.DebugLevelResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.DebugLevelResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.DebugLevelResponse)
        co.anode.anodium.Rpc.DebugLevelResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.DebugLevelResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>string sub_systems = 1;</code>
       * @return The subSystems.
       */
      @java.lang.Override
      public java.lang.String getSubSystems() {
        return instance.getSubSystems();
      }
      /**
       * <code>string sub_systems = 1;</code>
       * @return The bytes for subSystems.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getSubSystemsBytes() {
        return instance.getSubSystemsBytes();
      }
      /**
       * <code>string sub_systems = 1;</code>
       * @param value The subSystems to set.
       * @return This builder for chaining.
       */
      public Builder setSubSystems(
          java.lang.String value) {
        copyOnWrite();
        instance.setSubSystems(value);
        return this;
      }
      /**
       * <code>string sub_systems = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSubSystems() {
        copyOnWrite();
        instance.clearSubSystems();
        return this;
      }
      /**
       * <code>string sub_systems = 1;</code>
       * @param value The bytes for subSystems to set.
       * @return This builder for chaining.
       */
      public Builder setSubSystemsBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSubSystemsBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.DebugLevelResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.DebugLevelResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "subSystems_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u0208";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.DebugLevelResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.DebugLevelResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.DebugLevelResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.DebugLevelResponse)
    private static final co.anode.anodium.Rpc.DebugLevelResponse DEFAULT_INSTANCE;
    static {
      DebugLevelResponse defaultInstance = new DebugLevelResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        DebugLevelResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.DebugLevelResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<DebugLevelResponse> PARSER;

    public static com.google.protobuf.Parser<DebugLevelResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PayReqStringOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.PayReqString)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The payment request string to be decoded
     * </pre>
     *
     * <code>string pay_req = 1;</code>
     * @return The payReq.
     */
    java.lang.String getPayReq();
    /**
     * <pre>
     * The payment request string to be decoded
     * </pre>
     *
     * <code>string pay_req = 1;</code>
     * @return The bytes for payReq.
     */
    com.google.protobuf.ByteString
        getPayReqBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.PayReqString}
   */
  public  static final class PayReqString extends
      com.google.protobuf.GeneratedMessageLite<
          PayReqString, PayReqString.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.PayReqString)
      PayReqStringOrBuilder {
    private PayReqString() {
      payReq_ = "";
    }
    public static final int PAY_REQ_FIELD_NUMBER = 1;
    private java.lang.String payReq_;
    /**
     * <pre>
     * The payment request string to be decoded
     * </pre>
     *
     * <code>string pay_req = 1;</code>
     * @return The payReq.
     */
    @java.lang.Override
    public java.lang.String getPayReq() {
      return payReq_;
    }
    /**
     * <pre>
     * The payment request string to be decoded
     * </pre>
     *
     * <code>string pay_req = 1;</code>
     * @return The bytes for payReq.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPayReqBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(payReq_);
    }
    /**
     * <pre>
     * The payment request string to be decoded
     * </pre>
     *
     * <code>string pay_req = 1;</code>
     * @param value The payReq to set.
     */
    private void setPayReq(
        java.lang.String value) {
      value.getClass();
  
      payReq_ = value;
    }
    /**
     * <pre>
     * The payment request string to be decoded
     * </pre>
     *
     * <code>string pay_req = 1;</code>
     */
    private void clearPayReq() {
      
      payReq_ = getDefaultInstance().getPayReq();
    }
    /**
     * <pre>
     * The payment request string to be decoded
     * </pre>
     *
     * <code>string pay_req = 1;</code>
     * @param value The bytes for payReq to set.
     */
    private void setPayReqBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      payReq_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.PayReqString parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PayReqString parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PayReqString parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PayReqString parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PayReqString parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PayReqString parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PayReqString parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PayReqString parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PayReqString parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PayReqString parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PayReqString parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PayReqString parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.PayReqString prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.PayReqString}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.PayReqString, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.PayReqString)
        co.anode.anodium.Rpc.PayReqStringOrBuilder {
      // Construct using co.anode.anodium.Rpc.PayReqString.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The payment request string to be decoded
       * </pre>
       *
       * <code>string pay_req = 1;</code>
       * @return The payReq.
       */
      @java.lang.Override
      public java.lang.String getPayReq() {
        return instance.getPayReq();
      }
      /**
       * <pre>
       * The payment request string to be decoded
       * </pre>
       *
       * <code>string pay_req = 1;</code>
       * @return The bytes for payReq.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPayReqBytes() {
        return instance.getPayReqBytes();
      }
      /**
       * <pre>
       * The payment request string to be decoded
       * </pre>
       *
       * <code>string pay_req = 1;</code>
       * @param value The payReq to set.
       * @return This builder for chaining.
       */
      public Builder setPayReq(
          java.lang.String value) {
        copyOnWrite();
        instance.setPayReq(value);
        return this;
      }
      /**
       * <pre>
       * The payment request string to be decoded
       * </pre>
       *
       * <code>string pay_req = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPayReq() {
        copyOnWrite();
        instance.clearPayReq();
        return this;
      }
      /**
       * <pre>
       * The payment request string to be decoded
       * </pre>
       *
       * <code>string pay_req = 1;</code>
       * @param value The bytes for payReq to set.
       * @return This builder for chaining.
       */
      public Builder setPayReqBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPayReqBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.PayReqString)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.PayReqString();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "payReq_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u0208";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.PayReqString> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.PayReqString.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.PayReqString>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.PayReqString)
    private static final co.anode.anodium.Rpc.PayReqString DEFAULT_INSTANCE;
    static {
      PayReqString defaultInstance = new PayReqString();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        PayReqString.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.PayReqString getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<PayReqString> PARSER;

    public static com.google.protobuf.Parser<PayReqString> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PayReqOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.PayReq)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>string destination = 1;</code>
     * @return The destination.
     */
    java.lang.String getDestination();
    /**
     * <code>string destination = 1;</code>
     * @return The bytes for destination.
     */
    com.google.protobuf.ByteString
        getDestinationBytes();

    /**
     * <code>string payment_hash = 2;</code>
     * @return The paymentHash.
     */
    java.lang.String getPaymentHash();
    /**
     * <code>string payment_hash = 2;</code>
     * @return The bytes for paymentHash.
     */
    com.google.protobuf.ByteString
        getPaymentHashBytes();

    /**
     * <code>int64 num_satoshis = 3;</code>
     * @return The numSatoshis.
     */
    long getNumSatoshis();

    /**
     * <code>int64 timestamp = 4;</code>
     * @return The timestamp.
     */
    long getTimestamp();

    /**
     * <code>int64 expiry = 5;</code>
     * @return The expiry.
     */
    long getExpiry();

    /**
     * <code>string description = 6;</code>
     * @return The description.
     */
    java.lang.String getDescription();
    /**
     * <code>string description = 6;</code>
     * @return The bytes for description.
     */
    com.google.protobuf.ByteString
        getDescriptionBytes();

    /**
     * <code>string description_hash = 7;</code>
     * @return The descriptionHash.
     */
    java.lang.String getDescriptionHash();
    /**
     * <code>string description_hash = 7;</code>
     * @return The bytes for descriptionHash.
     */
    com.google.protobuf.ByteString
        getDescriptionHashBytes();

    /**
     * <code>string fallback_addr = 8;</code>
     * @return The fallbackAddr.
     */
    java.lang.String getFallbackAddr();
    /**
     * <code>string fallback_addr = 8;</code>
     * @return The bytes for fallbackAddr.
     */
    com.google.protobuf.ByteString
        getFallbackAddrBytes();

    /**
     * <code>int64 cltv_expiry = 9;</code>
     * @return The cltvExpiry.
     */
    long getCltvExpiry();

    /**
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
     */
    java.util.List<co.anode.anodium.Rpc.RouteHint> 
        getRouteHintsList();
    /**
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
     */
    co.anode.anodium.Rpc.RouteHint getRouteHints(int index);
    /**
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
     */
    int getRouteHintsCount();

    /**
     * <code>bytes payment_addr = 11;</code>
     * @return The paymentAddr.
     */
    com.google.protobuf.ByteString getPaymentAddr();

    /**
     * <code>int64 num_msat = 12;</code>
     * @return The numMsat.
     */
    long getNumMsat();

    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 13;</code>
     */
    int getFeaturesCount();
    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 13;</code>
     */
    boolean containsFeatures(
        int key);
    /**
     * Use {@link #getFeaturesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    getFeatures();
    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 13;</code>
     */
    java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    getFeaturesMap();
    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 13;</code>
     */

    co.anode.anodium.Rpc.Feature getFeaturesOrDefault(
        int key,
        co.anode.anodium.Rpc.Feature defaultValue);
    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 13;</code>
     */

    co.anode.anodium.Rpc.Feature getFeaturesOrThrow(
        int key);
  }
  /**
   * Protobuf type {@code co.anode.anodium.PayReq}
   */
  public  static final class PayReq extends
      com.google.protobuf.GeneratedMessageLite<
          PayReq, PayReq.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.PayReq)
      PayReqOrBuilder {
    private PayReq() {
      destination_ = "";
      paymentHash_ = "";
      description_ = "";
      descriptionHash_ = "";
      fallbackAddr_ = "";
      routeHints_ = emptyProtobufList();
      paymentAddr_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int DESTINATION_FIELD_NUMBER = 1;
    private java.lang.String destination_;
    /**
     * <code>string destination = 1;</code>
     * @return The destination.
     */
    @java.lang.Override
    public java.lang.String getDestination() {
      return destination_;
    }
    /**
     * <code>string destination = 1;</code>
     * @return The bytes for destination.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDestinationBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(destination_);
    }
    /**
     * <code>string destination = 1;</code>
     * @param value The destination to set.
     */
    private void setDestination(
        java.lang.String value) {
      value.getClass();
  
      destination_ = value;
    }
    /**
     * <code>string destination = 1;</code>
     */
    private void clearDestination() {
      
      destination_ = getDefaultInstance().getDestination();
    }
    /**
     * <code>string destination = 1;</code>
     * @param value The bytes for destination to set.
     */
    private void setDestinationBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      destination_ = value.toStringUtf8();
      
    }

    public static final int PAYMENT_HASH_FIELD_NUMBER = 2;
    private java.lang.String paymentHash_;
    /**
     * <code>string payment_hash = 2;</code>
     * @return The paymentHash.
     */
    @java.lang.Override
    public java.lang.String getPaymentHash() {
      return paymentHash_;
    }
    /**
     * <code>string payment_hash = 2;</code>
     * @return The bytes for paymentHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPaymentHashBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(paymentHash_);
    }
    /**
     * <code>string payment_hash = 2;</code>
     * @param value The paymentHash to set.
     */
    private void setPaymentHash(
        java.lang.String value) {
      value.getClass();
  
      paymentHash_ = value;
    }
    /**
     * <code>string payment_hash = 2;</code>
     */
    private void clearPaymentHash() {
      
      paymentHash_ = getDefaultInstance().getPaymentHash();
    }
    /**
     * <code>string payment_hash = 2;</code>
     * @param value The bytes for paymentHash to set.
     */
    private void setPaymentHashBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      paymentHash_ = value.toStringUtf8();
      
    }

    public static final int NUM_SATOSHIS_FIELD_NUMBER = 3;
    private long numSatoshis_;
    /**
     * <code>int64 num_satoshis = 3;</code>
     * @return The numSatoshis.
     */
    @java.lang.Override
    public long getNumSatoshis() {
      return numSatoshis_;
    }
    /**
     * <code>int64 num_satoshis = 3;</code>
     * @param value The numSatoshis to set.
     */
    private void setNumSatoshis(long value) {
      
      numSatoshis_ = value;
    }
    /**
     * <code>int64 num_satoshis = 3;</code>
     */
    private void clearNumSatoshis() {
      
      numSatoshis_ = 0L;
    }

    public static final int TIMESTAMP_FIELD_NUMBER = 4;
    private long timestamp_;
    /**
     * <code>int64 timestamp = 4;</code>
     * @return The timestamp.
     */
    @java.lang.Override
    public long getTimestamp() {
      return timestamp_;
    }
    /**
     * <code>int64 timestamp = 4;</code>
     * @param value The timestamp to set.
     */
    private void setTimestamp(long value) {
      
      timestamp_ = value;
    }
    /**
     * <code>int64 timestamp = 4;</code>
     */
    private void clearTimestamp() {
      
      timestamp_ = 0L;
    }

    public static final int EXPIRY_FIELD_NUMBER = 5;
    private long expiry_;
    /**
     * <code>int64 expiry = 5;</code>
     * @return The expiry.
     */
    @java.lang.Override
    public long getExpiry() {
      return expiry_;
    }
    /**
     * <code>int64 expiry = 5;</code>
     * @param value The expiry to set.
     */
    private void setExpiry(long value) {
      
      expiry_ = value;
    }
    /**
     * <code>int64 expiry = 5;</code>
     */
    private void clearExpiry() {
      
      expiry_ = 0L;
    }

    public static final int DESCRIPTION_FIELD_NUMBER = 6;
    private java.lang.String description_;
    /**
     * <code>string description = 6;</code>
     * @return The description.
     */
    @java.lang.Override
    public java.lang.String getDescription() {
      return description_;
    }
    /**
     * <code>string description = 6;</code>
     * @return The bytes for description.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDescriptionBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(description_);
    }
    /**
     * <code>string description = 6;</code>
     * @param value The description to set.
     */
    private void setDescription(
        java.lang.String value) {
      value.getClass();
  
      description_ = value;
    }
    /**
     * <code>string description = 6;</code>
     */
    private void clearDescription() {
      
      description_ = getDefaultInstance().getDescription();
    }
    /**
     * <code>string description = 6;</code>
     * @param value The bytes for description to set.
     */
    private void setDescriptionBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      description_ = value.toStringUtf8();
      
    }

    public static final int DESCRIPTION_HASH_FIELD_NUMBER = 7;
    private java.lang.String descriptionHash_;
    /**
     * <code>string description_hash = 7;</code>
     * @return The descriptionHash.
     */
    @java.lang.Override
    public java.lang.String getDescriptionHash() {
      return descriptionHash_;
    }
    /**
     * <code>string description_hash = 7;</code>
     * @return The bytes for descriptionHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDescriptionHashBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(descriptionHash_);
    }
    /**
     * <code>string description_hash = 7;</code>
     * @param value The descriptionHash to set.
     */
    private void setDescriptionHash(
        java.lang.String value) {
      value.getClass();
  
      descriptionHash_ = value;
    }
    /**
     * <code>string description_hash = 7;</code>
     */
    private void clearDescriptionHash() {
      
      descriptionHash_ = getDefaultInstance().getDescriptionHash();
    }
    /**
     * <code>string description_hash = 7;</code>
     * @param value The bytes for descriptionHash to set.
     */
    private void setDescriptionHashBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      descriptionHash_ = value.toStringUtf8();
      
    }

    public static final int FALLBACK_ADDR_FIELD_NUMBER = 8;
    private java.lang.String fallbackAddr_;
    /**
     * <code>string fallback_addr = 8;</code>
     * @return The fallbackAddr.
     */
    @java.lang.Override
    public java.lang.String getFallbackAddr() {
      return fallbackAddr_;
    }
    /**
     * <code>string fallback_addr = 8;</code>
     * @return The bytes for fallbackAddr.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFallbackAddrBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(fallbackAddr_);
    }
    /**
     * <code>string fallback_addr = 8;</code>
     * @param value The fallbackAddr to set.
     */
    private void setFallbackAddr(
        java.lang.String value) {
      value.getClass();
  
      fallbackAddr_ = value;
    }
    /**
     * <code>string fallback_addr = 8;</code>
     */
    private void clearFallbackAddr() {
      
      fallbackAddr_ = getDefaultInstance().getFallbackAddr();
    }
    /**
     * <code>string fallback_addr = 8;</code>
     * @param value The bytes for fallbackAddr to set.
     */
    private void setFallbackAddrBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      fallbackAddr_ = value.toStringUtf8();
      
    }

    public static final int CLTV_EXPIRY_FIELD_NUMBER = 9;
    private long cltvExpiry_;
    /**
     * <code>int64 cltv_expiry = 9;</code>
     * @return The cltvExpiry.
     */
    @java.lang.Override
    public long getCltvExpiry() {
      return cltvExpiry_;
    }
    /**
     * <code>int64 cltv_expiry = 9;</code>
     * @param value The cltvExpiry to set.
     */
    private void setCltvExpiry(long value) {
      
      cltvExpiry_ = value;
    }
    /**
     * <code>int64 cltv_expiry = 9;</code>
     */
    private void clearCltvExpiry() {
      
      cltvExpiry_ = 0L;
    }

    public static final int ROUTE_HINTS_FIELD_NUMBER = 10;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.RouteHint> routeHints_;
    /**
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.RouteHint> getRouteHintsList() {
      return routeHints_;
    }
    /**
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.RouteHintOrBuilder> 
        getRouteHintsOrBuilderList() {
      return routeHints_;
    }
    /**
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
     */
    @java.lang.Override
    public int getRouteHintsCount() {
      return routeHints_.size();
    }
    /**
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.RouteHint getRouteHints(int index) {
      return routeHints_.get(index);
    }
    /**
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
     */
    public co.anode.anodium.Rpc.RouteHintOrBuilder getRouteHintsOrBuilder(
        int index) {
      return routeHints_.get(index);
    }
    private void ensureRouteHintsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.RouteHint> tmp = routeHints_;
      if (!tmp.isModifiable()) {
        routeHints_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
     */
    private void setRouteHints(
        int index, co.anode.anodium.Rpc.RouteHint value) {
      value.getClass();
  ensureRouteHintsIsMutable();
      routeHints_.set(index, value);
    }
    /**
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
     */
    private void addRouteHints(co.anode.anodium.Rpc.RouteHint value) {
      value.getClass();
  ensureRouteHintsIsMutable();
      routeHints_.add(value);
    }
    /**
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
     */
    private void addRouteHints(
        int index, co.anode.anodium.Rpc.RouteHint value) {
      value.getClass();
  ensureRouteHintsIsMutable();
      routeHints_.add(index, value);
    }
    /**
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
     */
    private void addAllRouteHints(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.RouteHint> values) {
      ensureRouteHintsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, routeHints_);
    }
    /**
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
     */
    private void clearRouteHints() {
      routeHints_ = emptyProtobufList();
    }
    /**
     * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
     */
    private void removeRouteHints(int index) {
      ensureRouteHintsIsMutable();
      routeHints_.remove(index);
    }

    public static final int PAYMENT_ADDR_FIELD_NUMBER = 11;
    private com.google.protobuf.ByteString paymentAddr_;
    /**
     * <code>bytes payment_addr = 11;</code>
     * @return The paymentAddr.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPaymentAddr() {
      return paymentAddr_;
    }
    /**
     * <code>bytes payment_addr = 11;</code>
     * @param value The paymentAddr to set.
     */
    private void setPaymentAddr(com.google.protobuf.ByteString value) {
      value.getClass();
  
      paymentAddr_ = value;
    }
    /**
     * <code>bytes payment_addr = 11;</code>
     */
    private void clearPaymentAddr() {
      
      paymentAddr_ = getDefaultInstance().getPaymentAddr();
    }

    public static final int NUM_MSAT_FIELD_NUMBER = 12;
    private long numMsat_;
    /**
     * <code>int64 num_msat = 12;</code>
     * @return The numMsat.
     */
    @java.lang.Override
    public long getNumMsat() {
      return numMsat_;
    }
    /**
     * <code>int64 num_msat = 12;</code>
     * @param value The numMsat to set.
     */
    private void setNumMsat(long value) {
      
      numMsat_ = value;
    }
    /**
     * <code>int64 num_msat = 12;</code>
     */
    private void clearNumMsat() {
      
      numMsat_ = 0L;
    }

    public static final int FEATURES_FIELD_NUMBER = 13;
    private static final class FeaturesDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Integer, co.anode.anodium.Rpc.Feature> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Integer, co.anode.anodium.Rpc.Feature>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.UINT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  co.anode.anodium.Rpc.Feature.getDefaultInstance());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Integer, co.anode.anodium.Rpc.Feature> features_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    internalGetFeatures() {
      return features_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    internalGetMutableFeatures() {
      if (!features_.isMutable()) {
        features_ = features_.mutableCopy();
      }
      return features_;
    }
    @java.lang.Override

    public int getFeaturesCount() {
      return internalGetFeatures().size();
    }
    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 13;</code>
     */
    @java.lang.Override

    public boolean containsFeatures(
        int key) {
      
      return internalGetFeatures().containsKey(key);
    }
    /**
     * Use {@link #getFeaturesMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeatures() {
      return getFeaturesMap();
    }
    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 13;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeaturesMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetFeatures());
    }
    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 13;</code>
     */
    @java.lang.Override

    public co.anode.anodium.Rpc.Feature getFeaturesOrDefault(
        int key,
        co.anode.anodium.Rpc.Feature defaultValue) {
      
      java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
          internalGetFeatures();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 13;</code>
     */
    @java.lang.Override

    public co.anode.anodium.Rpc.Feature getFeaturesOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
          internalGetFeatures();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 13;</code>
     */
    private java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature>
    getMutableFeaturesMap() {
      return internalGetMutableFeatures();
    }

    public static co.anode.anodium.Rpc.PayReq parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PayReq parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PayReq parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PayReq parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PayReq parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PayReq parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PayReq parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PayReq parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PayReq parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PayReq parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PayReq parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PayReq parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.PayReq prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.PayReq}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.PayReq, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.PayReq)
        co.anode.anodium.Rpc.PayReqOrBuilder {
      // Construct using co.anode.anodium.Rpc.PayReq.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>string destination = 1;</code>
       * @return The destination.
       */
      @java.lang.Override
      public java.lang.String getDestination() {
        return instance.getDestination();
      }
      /**
       * <code>string destination = 1;</code>
       * @return The bytes for destination.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getDestinationBytes() {
        return instance.getDestinationBytes();
      }
      /**
       * <code>string destination = 1;</code>
       * @param value The destination to set.
       * @return This builder for chaining.
       */
      public Builder setDestination(
          java.lang.String value) {
        copyOnWrite();
        instance.setDestination(value);
        return this;
      }
      /**
       * <code>string destination = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearDestination() {
        copyOnWrite();
        instance.clearDestination();
        return this;
      }
      /**
       * <code>string destination = 1;</code>
       * @param value The bytes for destination to set.
       * @return This builder for chaining.
       */
      public Builder setDestinationBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setDestinationBytes(value);
        return this;
      }

      /**
       * <code>string payment_hash = 2;</code>
       * @return The paymentHash.
       */
      @java.lang.Override
      public java.lang.String getPaymentHash() {
        return instance.getPaymentHash();
      }
      /**
       * <code>string payment_hash = 2;</code>
       * @return The bytes for paymentHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPaymentHashBytes() {
        return instance.getPaymentHashBytes();
      }
      /**
       * <code>string payment_hash = 2;</code>
       * @param value The paymentHash to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentHash(
          java.lang.String value) {
        copyOnWrite();
        instance.setPaymentHash(value);
        return this;
      }
      /**
       * <code>string payment_hash = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaymentHash() {
        copyOnWrite();
        instance.clearPaymentHash();
        return this;
      }
      /**
       * <code>string payment_hash = 2;</code>
       * @param value The bytes for paymentHash to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentHashBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPaymentHashBytes(value);
        return this;
      }

      /**
       * <code>int64 num_satoshis = 3;</code>
       * @return The numSatoshis.
       */
      @java.lang.Override
      public long getNumSatoshis() {
        return instance.getNumSatoshis();
      }
      /**
       * <code>int64 num_satoshis = 3;</code>
       * @param value The numSatoshis to set.
       * @return This builder for chaining.
       */
      public Builder setNumSatoshis(long value) {
        copyOnWrite();
        instance.setNumSatoshis(value);
        return this;
      }
      /**
       * <code>int64 num_satoshis = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumSatoshis() {
        copyOnWrite();
        instance.clearNumSatoshis();
        return this;
      }

      /**
       * <code>int64 timestamp = 4;</code>
       * @return The timestamp.
       */
      @java.lang.Override
      public long getTimestamp() {
        return instance.getTimestamp();
      }
      /**
       * <code>int64 timestamp = 4;</code>
       * @param value The timestamp to set.
       * @return This builder for chaining.
       */
      public Builder setTimestamp(long value) {
        copyOnWrite();
        instance.setTimestamp(value);
        return this;
      }
      /**
       * <code>int64 timestamp = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimestamp() {
        copyOnWrite();
        instance.clearTimestamp();
        return this;
      }

      /**
       * <code>int64 expiry = 5;</code>
       * @return The expiry.
       */
      @java.lang.Override
      public long getExpiry() {
        return instance.getExpiry();
      }
      /**
       * <code>int64 expiry = 5;</code>
       * @param value The expiry to set.
       * @return This builder for chaining.
       */
      public Builder setExpiry(long value) {
        copyOnWrite();
        instance.setExpiry(value);
        return this;
      }
      /**
       * <code>int64 expiry = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearExpiry() {
        copyOnWrite();
        instance.clearExpiry();
        return this;
      }

      /**
       * <code>string description = 6;</code>
       * @return The description.
       */
      @java.lang.Override
      public java.lang.String getDescription() {
        return instance.getDescription();
      }
      /**
       * <code>string description = 6;</code>
       * @return The bytes for description.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getDescriptionBytes() {
        return instance.getDescriptionBytes();
      }
      /**
       * <code>string description = 6;</code>
       * @param value The description to set.
       * @return This builder for chaining.
       */
      public Builder setDescription(
          java.lang.String value) {
        copyOnWrite();
        instance.setDescription(value);
        return this;
      }
      /**
       * <code>string description = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearDescription() {
        copyOnWrite();
        instance.clearDescription();
        return this;
      }
      /**
       * <code>string description = 6;</code>
       * @param value The bytes for description to set.
       * @return This builder for chaining.
       */
      public Builder setDescriptionBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setDescriptionBytes(value);
        return this;
      }

      /**
       * <code>string description_hash = 7;</code>
       * @return The descriptionHash.
       */
      @java.lang.Override
      public java.lang.String getDescriptionHash() {
        return instance.getDescriptionHash();
      }
      /**
       * <code>string description_hash = 7;</code>
       * @return The bytes for descriptionHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getDescriptionHashBytes() {
        return instance.getDescriptionHashBytes();
      }
      /**
       * <code>string description_hash = 7;</code>
       * @param value The descriptionHash to set.
       * @return This builder for chaining.
       */
      public Builder setDescriptionHash(
          java.lang.String value) {
        copyOnWrite();
        instance.setDescriptionHash(value);
        return this;
      }
      /**
       * <code>string description_hash = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearDescriptionHash() {
        copyOnWrite();
        instance.clearDescriptionHash();
        return this;
      }
      /**
       * <code>string description_hash = 7;</code>
       * @param value The bytes for descriptionHash to set.
       * @return This builder for chaining.
       */
      public Builder setDescriptionHashBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setDescriptionHashBytes(value);
        return this;
      }

      /**
       * <code>string fallback_addr = 8;</code>
       * @return The fallbackAddr.
       */
      @java.lang.Override
      public java.lang.String getFallbackAddr() {
        return instance.getFallbackAddr();
      }
      /**
       * <code>string fallback_addr = 8;</code>
       * @return The bytes for fallbackAddr.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getFallbackAddrBytes() {
        return instance.getFallbackAddrBytes();
      }
      /**
       * <code>string fallback_addr = 8;</code>
       * @param value The fallbackAddr to set.
       * @return This builder for chaining.
       */
      public Builder setFallbackAddr(
          java.lang.String value) {
        copyOnWrite();
        instance.setFallbackAddr(value);
        return this;
      }
      /**
       * <code>string fallback_addr = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearFallbackAddr() {
        copyOnWrite();
        instance.clearFallbackAddr();
        return this;
      }
      /**
       * <code>string fallback_addr = 8;</code>
       * @param value The bytes for fallbackAddr to set.
       * @return This builder for chaining.
       */
      public Builder setFallbackAddrBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setFallbackAddrBytes(value);
        return this;
      }

      /**
       * <code>int64 cltv_expiry = 9;</code>
       * @return The cltvExpiry.
       */
      @java.lang.Override
      public long getCltvExpiry() {
        return instance.getCltvExpiry();
      }
      /**
       * <code>int64 cltv_expiry = 9;</code>
       * @param value The cltvExpiry to set.
       * @return This builder for chaining.
       */
      public Builder setCltvExpiry(long value) {
        copyOnWrite();
        instance.setCltvExpiry(value);
        return this;
      }
      /**
       * <code>int64 cltv_expiry = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearCltvExpiry() {
        copyOnWrite();
        instance.clearCltvExpiry();
        return this;
      }

      /**
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.RouteHint> getRouteHintsList() {
        return java.util.Collections.unmodifiableList(
            instance.getRouteHintsList());
      }
      /**
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
       */
      @java.lang.Override
      public int getRouteHintsCount() {
        return instance.getRouteHintsCount();
      }/**
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.RouteHint getRouteHints(int index) {
        return instance.getRouteHints(index);
      }
      /**
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
       */
      public Builder setRouteHints(
          int index, co.anode.anodium.Rpc.RouteHint value) {
        copyOnWrite();
        instance.setRouteHints(index, value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
       */
      public Builder setRouteHints(
          int index, co.anode.anodium.Rpc.RouteHint.Builder builderForValue) {
        copyOnWrite();
        instance.setRouteHints(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
       */
      public Builder addRouteHints(co.anode.anodium.Rpc.RouteHint value) {
        copyOnWrite();
        instance.addRouteHints(value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
       */
      public Builder addRouteHints(
          int index, co.anode.anodium.Rpc.RouteHint value) {
        copyOnWrite();
        instance.addRouteHints(index, value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
       */
      public Builder addRouteHints(
          co.anode.anodium.Rpc.RouteHint.Builder builderForValue) {
        copyOnWrite();
        instance.addRouteHints(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
       */
      public Builder addRouteHints(
          int index, co.anode.anodium.Rpc.RouteHint.Builder builderForValue) {
        copyOnWrite();
        instance.addRouteHints(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
       */
      public Builder addAllRouteHints(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.RouteHint> values) {
        copyOnWrite();
        instance.addAllRouteHints(values);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
       */
      public Builder clearRouteHints() {
        copyOnWrite();
        instance.clearRouteHints();
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.RouteHint route_hints = 10;</code>
       */
      public Builder removeRouteHints(int index) {
        copyOnWrite();
        instance.removeRouteHints(index);
        return this;
      }

      /**
       * <code>bytes payment_addr = 11;</code>
       * @return The paymentAddr.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPaymentAddr() {
        return instance.getPaymentAddr();
      }
      /**
       * <code>bytes payment_addr = 11;</code>
       * @param value The paymentAddr to set.
       * @return This builder for chaining.
       */
      public Builder setPaymentAddr(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPaymentAddr(value);
        return this;
      }
      /**
       * <code>bytes payment_addr = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearPaymentAddr() {
        copyOnWrite();
        instance.clearPaymentAddr();
        return this;
      }

      /**
       * <code>int64 num_msat = 12;</code>
       * @return The numMsat.
       */
      @java.lang.Override
      public long getNumMsat() {
        return instance.getNumMsat();
      }
      /**
       * <code>int64 num_msat = 12;</code>
       * @param value The numMsat to set.
       * @return This builder for chaining.
       */
      public Builder setNumMsat(long value) {
        copyOnWrite();
        instance.setNumMsat(value);
        return this;
      }
      /**
       * <code>int64 num_msat = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumMsat() {
        copyOnWrite();
        instance.clearNumMsat();
        return this;
      }

      @java.lang.Override

      public int getFeaturesCount() {
        return instance.getFeaturesMap().size();
      }
      /**
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 13;</code>
       */
      @java.lang.Override

      public boolean containsFeatures(
          int key) {
        
        return instance.getFeaturesMap().containsKey(key);
      }

      public Builder clearFeatures() {
        copyOnWrite();
        instance.getMutableFeaturesMap().clear();
        return this;
      }
      /**
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 13;</code>
       */

      public Builder removeFeatures(
          int key) {
        
        copyOnWrite();
        instance.getMutableFeaturesMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getFeaturesMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeatures() {
        return getFeaturesMap();
      }
      /**
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 13;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> getFeaturesMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getFeaturesMap());
      }
      /**
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 13;</code>
       */
      @java.lang.Override

      public co.anode.anodium.Rpc.Feature getFeaturesOrDefault(
          int key,
          co.anode.anodium.Rpc.Feature defaultValue) {
        
        java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
            instance.getFeaturesMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 13;</code>
       */
      @java.lang.Override

      public co.anode.anodium.Rpc.Feature getFeaturesOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> map =
            instance.getFeaturesMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 13;</code>
       */
      public Builder putFeatures(
          int key,
          co.anode.anodium.Rpc.Feature value) {
        
        value.getClass();
        copyOnWrite();
        instance.getMutableFeaturesMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;uint32, .co.anode.anodium.Feature&gt; features = 13;</code>
       */
      public Builder putAllFeatures(
          java.util.Map<java.lang.Integer, co.anode.anodium.Rpc.Feature> values) {
        copyOnWrite();
        instance.getMutableFeaturesMap().putAll(values);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.PayReq)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.PayReq();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "destination_",
              "paymentHash_",
              "numSatoshis_",
              "timestamp_",
              "expiry_",
              "description_",
              "descriptionHash_",
              "fallbackAddr_",
              "cltvExpiry_",
              "routeHints_",
              co.anode.anodium.Rpc.RouteHint.class,
              "paymentAddr_",
              "numMsat_",
              "features_",
              FeaturesDefaultEntryHolder.defaultEntry,
            };
            java.lang.String info =
                "\u0000\r\u0000\u0000\u0001\r\r\u0001\u0001\u0000\u0001\u0208\u0002\u0208\u0003\u0002" +
                "\u0004\u0002\u0005\u0002\u0006\u0208\u0007\u0208\b\u0208\t\u0002\n\u001b\u000b\n" +
                "\f\u0002\r2";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.PayReq> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.PayReq.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.PayReq>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.PayReq)
    private static final co.anode.anodium.Rpc.PayReq DEFAULT_INSTANCE;
    static {
      PayReq defaultInstance = new PayReq();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        PayReq.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.PayReq getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<PayReq> PARSER;

    public static com.google.protobuf.Parser<PayReq> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FeatureOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.Feature)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>string name = 2;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <code>string name = 2;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <code>bool is_required = 3;</code>
     * @return The isRequired.
     */
    boolean getIsRequired();

    /**
     * <code>bool is_known = 4;</code>
     * @return The isKnown.
     */
    boolean getIsKnown();
  }
  /**
   * Protobuf type {@code co.anode.anodium.Feature}
   */
  public  static final class Feature extends
      com.google.protobuf.GeneratedMessageLite<
          Feature, Feature.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.Feature)
      FeatureOrBuilder {
    private Feature() {
      name_ = "";
    }
    public static final int NAME_FIELD_NUMBER = 2;
    private java.lang.String name_;
    /**
     * <code>string name = 2;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      return name_;
    }
    /**
     * <code>string name = 2;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(name_);
    }
    /**
     * <code>string name = 2;</code>
     * @param value The name to set.
     */
    private void setName(
        java.lang.String value) {
      value.getClass();
  
      name_ = value;
    }
    /**
     * <code>string name = 2;</code>
     */
    private void clearName() {
      
      name_ = getDefaultInstance().getName();
    }
    /**
     * <code>string name = 2;</code>
     * @param value The bytes for name to set.
     */
    private void setNameBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      name_ = value.toStringUtf8();
      
    }

    public static final int IS_REQUIRED_FIELD_NUMBER = 3;
    private boolean isRequired_;
    /**
     * <code>bool is_required = 3;</code>
     * @return The isRequired.
     */
    @java.lang.Override
    public boolean getIsRequired() {
      return isRequired_;
    }
    /**
     * <code>bool is_required = 3;</code>
     * @param value The isRequired to set.
     */
    private void setIsRequired(boolean value) {
      
      isRequired_ = value;
    }
    /**
     * <code>bool is_required = 3;</code>
     */
    private void clearIsRequired() {
      
      isRequired_ = false;
    }

    public static final int IS_KNOWN_FIELD_NUMBER = 4;
    private boolean isKnown_;
    /**
     * <code>bool is_known = 4;</code>
     * @return The isKnown.
     */
    @java.lang.Override
    public boolean getIsKnown() {
      return isKnown_;
    }
    /**
     * <code>bool is_known = 4;</code>
     * @param value The isKnown to set.
     */
    private void setIsKnown(boolean value) {
      
      isKnown_ = value;
    }
    /**
     * <code>bool is_known = 4;</code>
     */
    private void clearIsKnown() {
      
      isKnown_ = false;
    }

    public static co.anode.anodium.Rpc.Feature parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Feature parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Feature parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Feature parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Feature parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Feature parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Feature parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Feature parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Feature parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Feature parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Feature parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Feature parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.Feature prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.Feature}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.Feature, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.Feature)
        co.anode.anodium.Rpc.FeatureOrBuilder {
      // Construct using co.anode.anodium.Rpc.Feature.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>string name = 2;</code>
       * @return The name.
       */
      @java.lang.Override
      public java.lang.String getName() {
        return instance.getName();
      }
      /**
       * <code>string name = 2;</code>
       * @return The bytes for name.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNameBytes() {
        return instance.getNameBytes();
      }
      /**
       * <code>string name = 2;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        copyOnWrite();
        instance.setName(value);
        return this;
      }
      /**
       * <code>string name = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        copyOnWrite();
        instance.clearName();
        return this;
      }
      /**
       * <code>string name = 2;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNameBytes(value);
        return this;
      }

      /**
       * <code>bool is_required = 3;</code>
       * @return The isRequired.
       */
      @java.lang.Override
      public boolean getIsRequired() {
        return instance.getIsRequired();
      }
      /**
       * <code>bool is_required = 3;</code>
       * @param value The isRequired to set.
       * @return This builder for chaining.
       */
      public Builder setIsRequired(boolean value) {
        copyOnWrite();
        instance.setIsRequired(value);
        return this;
      }
      /**
       * <code>bool is_required = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearIsRequired() {
        copyOnWrite();
        instance.clearIsRequired();
        return this;
      }

      /**
       * <code>bool is_known = 4;</code>
       * @return The isKnown.
       */
      @java.lang.Override
      public boolean getIsKnown() {
        return instance.getIsKnown();
      }
      /**
       * <code>bool is_known = 4;</code>
       * @param value The isKnown to set.
       * @return This builder for chaining.
       */
      public Builder setIsKnown(boolean value) {
        copyOnWrite();
        instance.setIsKnown(value);
        return this;
      }
      /**
       * <code>bool is_known = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearIsKnown() {
        copyOnWrite();
        instance.clearIsKnown();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.Feature)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.Feature();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "name_",
              "isRequired_",
              "isKnown_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0002\u0004\u0003\u0000\u0000\u0000\u0002\u0208\u0003\u0007" +
                "\u0004\u0007";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.Feature> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.Feature.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.Feature>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.Feature)
    private static final co.anode.anodium.Rpc.Feature DEFAULT_INSTANCE;
    static {
      Feature defaultInstance = new Feature();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Feature.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.Feature getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Feature> PARSER;

    public static com.google.protobuf.Parser<Feature> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FeeReportRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.FeeReportRequest)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.FeeReportRequest}
   */
  public  static final class FeeReportRequest extends
      com.google.protobuf.GeneratedMessageLite<
          FeeReportRequest, FeeReportRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.FeeReportRequest)
      FeeReportRequestOrBuilder {
    private FeeReportRequest() {
    }
    public static co.anode.anodium.Rpc.FeeReportRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FeeReportRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FeeReportRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FeeReportRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FeeReportRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FeeReportRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FeeReportRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FeeReportRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FeeReportRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FeeReportRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FeeReportRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FeeReportRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.FeeReportRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.FeeReportRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.FeeReportRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.FeeReportRequest)
        co.anode.anodium.Rpc.FeeReportRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.FeeReportRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.FeeReportRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.FeeReportRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.FeeReportRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.FeeReportRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.FeeReportRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.FeeReportRequest)
    private static final co.anode.anodium.Rpc.FeeReportRequest DEFAULT_INSTANCE;
    static {
      FeeReportRequest defaultInstance = new FeeReportRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        FeeReportRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.FeeReportRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FeeReportRequest> PARSER;

    public static com.google.protobuf.Parser<FeeReportRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelFeeReportOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelFeeReport)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The short channel id that this fee report belongs to.
     * </pre>
     *
     * <code>uint64 chan_id = 5 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    long getChanId();

    /**
     * <pre>
     * The channel that this fee report belongs to.
     * </pre>
     *
     * <code>string channel_point = 1;</code>
     * @return The channelPoint.
     */
    java.lang.String getChannelPoint();
    /**
     * <pre>
     * The channel that this fee report belongs to.
     * </pre>
     *
     * <code>string channel_point = 1;</code>
     * @return The bytes for channelPoint.
     */
    com.google.protobuf.ByteString
        getChannelPointBytes();

    /**
     * <pre>
     * The base fee charged regardless of the number of milli-satoshis sent.
     * </pre>
     *
     * <code>int64 base_fee_msat = 2;</code>
     * @return The baseFeeMsat.
     */
    long getBaseFeeMsat();

    /**
     * <pre>
     * The amount charged per milli-satoshis transferred expressed in
     * millionths of a satoshi.
     * </pre>
     *
     * <code>int64 fee_per_mil = 3;</code>
     * @return The feePerMil.
     */
    long getFeePerMil();

    /**
     * <pre>
     * The effective fee rate in milli-satoshis. Computed by dividing the
     * fee_per_mil value by 1 million.
     * </pre>
     *
     * <code>double fee_rate = 4;</code>
     * @return The feeRate.
     */
    double getFeeRate();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChannelFeeReport}
   */
  public  static final class ChannelFeeReport extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelFeeReport, ChannelFeeReport.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelFeeReport)
      ChannelFeeReportOrBuilder {
    private ChannelFeeReport() {
      channelPoint_ = "";
    }
    public static final int CHAN_ID_FIELD_NUMBER = 5;
    private long chanId_;
    /**
     * <pre>
     * The short channel id that this fee report belongs to.
     * </pre>
     *
     * <code>uint64 chan_id = 5 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    @java.lang.Override
    public long getChanId() {
      return chanId_;
    }
    /**
     * <pre>
     * The short channel id that this fee report belongs to.
     * </pre>
     *
     * <code>uint64 chan_id = 5 [jstype = JS_STRING];</code>
     * @param value The chanId to set.
     */
    private void setChanId(long value) {
      
      chanId_ = value;
    }
    /**
     * <pre>
     * The short channel id that this fee report belongs to.
     * </pre>
     *
     * <code>uint64 chan_id = 5 [jstype = JS_STRING];</code>
     */
    private void clearChanId() {
      
      chanId_ = 0L;
    }

    public static final int CHANNEL_POINT_FIELD_NUMBER = 1;
    private java.lang.String channelPoint_;
    /**
     * <pre>
     * The channel that this fee report belongs to.
     * </pre>
     *
     * <code>string channel_point = 1;</code>
     * @return The channelPoint.
     */
    @java.lang.Override
    public java.lang.String getChannelPoint() {
      return channelPoint_;
    }
    /**
     * <pre>
     * The channel that this fee report belongs to.
     * </pre>
     *
     * <code>string channel_point = 1;</code>
     * @return The bytes for channelPoint.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getChannelPointBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(channelPoint_);
    }
    /**
     * <pre>
     * The channel that this fee report belongs to.
     * </pre>
     *
     * <code>string channel_point = 1;</code>
     * @param value The channelPoint to set.
     */
    private void setChannelPoint(
        java.lang.String value) {
      value.getClass();
  
      channelPoint_ = value;
    }
    /**
     * <pre>
     * The channel that this fee report belongs to.
     * </pre>
     *
     * <code>string channel_point = 1;</code>
     */
    private void clearChannelPoint() {
      
      channelPoint_ = getDefaultInstance().getChannelPoint();
    }
    /**
     * <pre>
     * The channel that this fee report belongs to.
     * </pre>
     *
     * <code>string channel_point = 1;</code>
     * @param value The bytes for channelPoint to set.
     */
    private void setChannelPointBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      channelPoint_ = value.toStringUtf8();
      
    }

    public static final int BASE_FEE_MSAT_FIELD_NUMBER = 2;
    private long baseFeeMsat_;
    /**
     * <pre>
     * The base fee charged regardless of the number of milli-satoshis sent.
     * </pre>
     *
     * <code>int64 base_fee_msat = 2;</code>
     * @return The baseFeeMsat.
     */
    @java.lang.Override
    public long getBaseFeeMsat() {
      return baseFeeMsat_;
    }
    /**
     * <pre>
     * The base fee charged regardless of the number of milli-satoshis sent.
     * </pre>
     *
     * <code>int64 base_fee_msat = 2;</code>
     * @param value The baseFeeMsat to set.
     */
    private void setBaseFeeMsat(long value) {
      
      baseFeeMsat_ = value;
    }
    /**
     * <pre>
     * The base fee charged regardless of the number of milli-satoshis sent.
     * </pre>
     *
     * <code>int64 base_fee_msat = 2;</code>
     */
    private void clearBaseFeeMsat() {
      
      baseFeeMsat_ = 0L;
    }

    public static final int FEE_PER_MIL_FIELD_NUMBER = 3;
    private long feePerMil_;
    /**
     * <pre>
     * The amount charged per milli-satoshis transferred expressed in
     * millionths of a satoshi.
     * </pre>
     *
     * <code>int64 fee_per_mil = 3;</code>
     * @return The feePerMil.
     */
    @java.lang.Override
    public long getFeePerMil() {
      return feePerMil_;
    }
    /**
     * <pre>
     * The amount charged per milli-satoshis transferred expressed in
     * millionths of a satoshi.
     * </pre>
     *
     * <code>int64 fee_per_mil = 3;</code>
     * @param value The feePerMil to set.
     */
    private void setFeePerMil(long value) {
      
      feePerMil_ = value;
    }
    /**
     * <pre>
     * The amount charged per milli-satoshis transferred expressed in
     * millionths of a satoshi.
     * </pre>
     *
     * <code>int64 fee_per_mil = 3;</code>
     */
    private void clearFeePerMil() {
      
      feePerMil_ = 0L;
    }

    public static final int FEE_RATE_FIELD_NUMBER = 4;
    private double feeRate_;
    /**
     * <pre>
     * The effective fee rate in milli-satoshis. Computed by dividing the
     * fee_per_mil value by 1 million.
     * </pre>
     *
     * <code>double fee_rate = 4;</code>
     * @return The feeRate.
     */
    @java.lang.Override
    public double getFeeRate() {
      return feeRate_;
    }
    /**
     * <pre>
     * The effective fee rate in milli-satoshis. Computed by dividing the
     * fee_per_mil value by 1 million.
     * </pre>
     *
     * <code>double fee_rate = 4;</code>
     * @param value The feeRate to set.
     */
    private void setFeeRate(double value) {
      
      feeRate_ = value;
    }
    /**
     * <pre>
     * The effective fee rate in milli-satoshis. Computed by dividing the
     * fee_per_mil value by 1 million.
     * </pre>
     *
     * <code>double fee_rate = 4;</code>
     */
    private void clearFeeRate() {
      
      feeRate_ = 0D;
    }

    public static co.anode.anodium.Rpc.ChannelFeeReport parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelFeeReport parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelFeeReport parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelFeeReport parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelFeeReport parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelFeeReport parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelFeeReport parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelFeeReport parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelFeeReport parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelFeeReport parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelFeeReport parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelFeeReport parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelFeeReport prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChannelFeeReport}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelFeeReport, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelFeeReport)
        co.anode.anodium.Rpc.ChannelFeeReportOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelFeeReport.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The short channel id that this fee report belongs to.
       * </pre>
       *
       * <code>uint64 chan_id = 5 [jstype = JS_STRING];</code>
       * @return The chanId.
       */
      @java.lang.Override
      public long getChanId() {
        return instance.getChanId();
      }
      /**
       * <pre>
       * The short channel id that this fee report belongs to.
       * </pre>
       *
       * <code>uint64 chan_id = 5 [jstype = JS_STRING];</code>
       * @param value The chanId to set.
       * @return This builder for chaining.
       */
      public Builder setChanId(long value) {
        copyOnWrite();
        instance.setChanId(value);
        return this;
      }
      /**
       * <pre>
       * The short channel id that this fee report belongs to.
       * </pre>
       *
       * <code>uint64 chan_id = 5 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearChanId() {
        copyOnWrite();
        instance.clearChanId();
        return this;
      }

      /**
       * <pre>
       * The channel that this fee report belongs to.
       * </pre>
       *
       * <code>string channel_point = 1;</code>
       * @return The channelPoint.
       */
      @java.lang.Override
      public java.lang.String getChannelPoint() {
        return instance.getChannelPoint();
      }
      /**
       * <pre>
       * The channel that this fee report belongs to.
       * </pre>
       *
       * <code>string channel_point = 1;</code>
       * @return The bytes for channelPoint.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getChannelPointBytes() {
        return instance.getChannelPointBytes();
      }
      /**
       * <pre>
       * The channel that this fee report belongs to.
       * </pre>
       *
       * <code>string channel_point = 1;</code>
       * @param value The channelPoint to set.
       * @return This builder for chaining.
       */
      public Builder setChannelPoint(
          java.lang.String value) {
        copyOnWrite();
        instance.setChannelPoint(value);
        return this;
      }
      /**
       * <pre>
       * The channel that this fee report belongs to.
       * </pre>
       *
       * <code>string channel_point = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearChannelPoint() {
        copyOnWrite();
        instance.clearChannelPoint();
        return this;
      }
      /**
       * <pre>
       * The channel that this fee report belongs to.
       * </pre>
       *
       * <code>string channel_point = 1;</code>
       * @param value The bytes for channelPoint to set.
       * @return This builder for chaining.
       */
      public Builder setChannelPointBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setChannelPointBytes(value);
        return this;
      }

      /**
       * <pre>
       * The base fee charged regardless of the number of milli-satoshis sent.
       * </pre>
       *
       * <code>int64 base_fee_msat = 2;</code>
       * @return The baseFeeMsat.
       */
      @java.lang.Override
      public long getBaseFeeMsat() {
        return instance.getBaseFeeMsat();
      }
      /**
       * <pre>
       * The base fee charged regardless of the number of milli-satoshis sent.
       * </pre>
       *
       * <code>int64 base_fee_msat = 2;</code>
       * @param value The baseFeeMsat to set.
       * @return This builder for chaining.
       */
      public Builder setBaseFeeMsat(long value) {
        copyOnWrite();
        instance.setBaseFeeMsat(value);
        return this;
      }
      /**
       * <pre>
       * The base fee charged regardless of the number of milli-satoshis sent.
       * </pre>
       *
       * <code>int64 base_fee_msat = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearBaseFeeMsat() {
        copyOnWrite();
        instance.clearBaseFeeMsat();
        return this;
      }

      /**
       * <pre>
       * The amount charged per milli-satoshis transferred expressed in
       * millionths of a satoshi.
       * </pre>
       *
       * <code>int64 fee_per_mil = 3;</code>
       * @return The feePerMil.
       */
      @java.lang.Override
      public long getFeePerMil() {
        return instance.getFeePerMil();
      }
      /**
       * <pre>
       * The amount charged per milli-satoshis transferred expressed in
       * millionths of a satoshi.
       * </pre>
       *
       * <code>int64 fee_per_mil = 3;</code>
       * @param value The feePerMil to set.
       * @return This builder for chaining.
       */
      public Builder setFeePerMil(long value) {
        copyOnWrite();
        instance.setFeePerMil(value);
        return this;
      }
      /**
       * <pre>
       * The amount charged per milli-satoshis transferred expressed in
       * millionths of a satoshi.
       * </pre>
       *
       * <code>int64 fee_per_mil = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearFeePerMil() {
        copyOnWrite();
        instance.clearFeePerMil();
        return this;
      }

      /**
       * <pre>
       * The effective fee rate in milli-satoshis. Computed by dividing the
       * fee_per_mil value by 1 million.
       * </pre>
       *
       * <code>double fee_rate = 4;</code>
       * @return The feeRate.
       */
      @java.lang.Override
      public double getFeeRate() {
        return instance.getFeeRate();
      }
      /**
       * <pre>
       * The effective fee rate in milli-satoshis. Computed by dividing the
       * fee_per_mil value by 1 million.
       * </pre>
       *
       * <code>double fee_rate = 4;</code>
       * @param value The feeRate to set.
       * @return This builder for chaining.
       */
      public Builder setFeeRate(double value) {
        copyOnWrite();
        instance.setFeeRate(value);
        return this;
      }
      /**
       * <pre>
       * The effective fee rate in milli-satoshis. Computed by dividing the
       * fee_per_mil value by 1 million.
       * </pre>
       *
       * <code>double fee_rate = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearFeeRate() {
        copyOnWrite();
        instance.clearFeeRate();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelFeeReport)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelFeeReport();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "channelPoint_",
              "baseFeeMsat_",
              "feePerMil_",
              "feeRate_",
              "chanId_",
            };
            java.lang.String info =
                "\u0000\u0005\u0000\u0000\u0001\u0005\u0005\u0000\u0000\u0000\u0001\u0208\u0002\u0002" +
                "\u0003\u0002\u0004\u0000\u0005\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelFeeReport> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelFeeReport.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelFeeReport>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelFeeReport)
    private static final co.anode.anodium.Rpc.ChannelFeeReport DEFAULT_INSTANCE;
    static {
      ChannelFeeReport defaultInstance = new ChannelFeeReport();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelFeeReport.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelFeeReport getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelFeeReport> PARSER;

    public static com.google.protobuf.Parser<ChannelFeeReport> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FeeReportResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.FeeReportResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * An array of channel fee reports which describes the current fee schedule
     * for each channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
     */
    java.util.List<co.anode.anodium.Rpc.ChannelFeeReport> 
        getChannelFeesList();
    /**
     * <pre>
     * An array of channel fee reports which describes the current fee schedule
     * for each channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
     */
    co.anode.anodium.Rpc.ChannelFeeReport getChannelFees(int index);
    /**
     * <pre>
     * An array of channel fee reports which describes the current fee schedule
     * for each channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
     */
    int getChannelFeesCount();

    /**
     * <pre>
     * The total amount of fee revenue (in satoshis) the switch has collected
     * over the past 24 hrs.
     * </pre>
     *
     * <code>uint64 day_fee_sum = 2;</code>
     * @return The dayFeeSum.
     */
    long getDayFeeSum();

    /**
     * <pre>
     * The total amount of fee revenue (in satoshis) the switch has collected
     * over the past 1 week.
     * </pre>
     *
     * <code>uint64 week_fee_sum = 3;</code>
     * @return The weekFeeSum.
     */
    long getWeekFeeSum();

    /**
     * <pre>
     * The total amount of fee revenue (in satoshis) the switch has collected
     * over the past 1 month.
     * </pre>
     *
     * <code>uint64 month_fee_sum = 4;</code>
     * @return The monthFeeSum.
     */
    long getMonthFeeSum();
  }
  /**
   * Protobuf type {@code co.anode.anodium.FeeReportResponse}
   */
  public  static final class FeeReportResponse extends
      com.google.protobuf.GeneratedMessageLite<
          FeeReportResponse, FeeReportResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.FeeReportResponse)
      FeeReportResponseOrBuilder {
    private FeeReportResponse() {
      channelFees_ = emptyProtobufList();
    }
    public static final int CHANNEL_FEES_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.ChannelFeeReport> channelFees_;
    /**
     * <pre>
     * An array of channel fee reports which describes the current fee schedule
     * for each channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.ChannelFeeReport> getChannelFeesList() {
      return channelFees_;
    }
    /**
     * <pre>
     * An array of channel fee reports which describes the current fee schedule
     * for each channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.ChannelFeeReportOrBuilder> 
        getChannelFeesOrBuilderList() {
      return channelFees_;
    }
    /**
     * <pre>
     * An array of channel fee reports which describes the current fee schedule
     * for each channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
     */
    @java.lang.Override
    public int getChannelFeesCount() {
      return channelFees_.size();
    }
    /**
     * <pre>
     * An array of channel fee reports which describes the current fee schedule
     * for each channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelFeeReport getChannelFees(int index) {
      return channelFees_.get(index);
    }
    /**
     * <pre>
     * An array of channel fee reports which describes the current fee schedule
     * for each channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
     */
    public co.anode.anodium.Rpc.ChannelFeeReportOrBuilder getChannelFeesOrBuilder(
        int index) {
      return channelFees_.get(index);
    }
    private void ensureChannelFeesIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.ChannelFeeReport> tmp = channelFees_;
      if (!tmp.isModifiable()) {
        channelFees_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * An array of channel fee reports which describes the current fee schedule
     * for each channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
     */
    private void setChannelFees(
        int index, co.anode.anodium.Rpc.ChannelFeeReport value) {
      value.getClass();
  ensureChannelFeesIsMutable();
      channelFees_.set(index, value);
    }
    /**
     * <pre>
     * An array of channel fee reports which describes the current fee schedule
     * for each channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
     */
    private void addChannelFees(co.anode.anodium.Rpc.ChannelFeeReport value) {
      value.getClass();
  ensureChannelFeesIsMutable();
      channelFees_.add(value);
    }
    /**
     * <pre>
     * An array of channel fee reports which describes the current fee schedule
     * for each channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
     */
    private void addChannelFees(
        int index, co.anode.anodium.Rpc.ChannelFeeReport value) {
      value.getClass();
  ensureChannelFeesIsMutable();
      channelFees_.add(index, value);
    }
    /**
     * <pre>
     * An array of channel fee reports which describes the current fee schedule
     * for each channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
     */
    private void addAllChannelFees(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.ChannelFeeReport> values) {
      ensureChannelFeesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, channelFees_);
    }
    /**
     * <pre>
     * An array of channel fee reports which describes the current fee schedule
     * for each channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
     */
    private void clearChannelFees() {
      channelFees_ = emptyProtobufList();
    }
    /**
     * <pre>
     * An array of channel fee reports which describes the current fee schedule
     * for each channel.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
     */
    private void removeChannelFees(int index) {
      ensureChannelFeesIsMutable();
      channelFees_.remove(index);
    }

    public static final int DAY_FEE_SUM_FIELD_NUMBER = 2;
    private long dayFeeSum_;
    /**
     * <pre>
     * The total amount of fee revenue (in satoshis) the switch has collected
     * over the past 24 hrs.
     * </pre>
     *
     * <code>uint64 day_fee_sum = 2;</code>
     * @return The dayFeeSum.
     */
    @java.lang.Override
    public long getDayFeeSum() {
      return dayFeeSum_;
    }
    /**
     * <pre>
     * The total amount of fee revenue (in satoshis) the switch has collected
     * over the past 24 hrs.
     * </pre>
     *
     * <code>uint64 day_fee_sum = 2;</code>
     * @param value The dayFeeSum to set.
     */
    private void setDayFeeSum(long value) {
      
      dayFeeSum_ = value;
    }
    /**
     * <pre>
     * The total amount of fee revenue (in satoshis) the switch has collected
     * over the past 24 hrs.
     * </pre>
     *
     * <code>uint64 day_fee_sum = 2;</code>
     */
    private void clearDayFeeSum() {
      
      dayFeeSum_ = 0L;
    }

    public static final int WEEK_FEE_SUM_FIELD_NUMBER = 3;
    private long weekFeeSum_;
    /**
     * <pre>
     * The total amount of fee revenue (in satoshis) the switch has collected
     * over the past 1 week.
     * </pre>
     *
     * <code>uint64 week_fee_sum = 3;</code>
     * @return The weekFeeSum.
     */
    @java.lang.Override
    public long getWeekFeeSum() {
      return weekFeeSum_;
    }
    /**
     * <pre>
     * The total amount of fee revenue (in satoshis) the switch has collected
     * over the past 1 week.
     * </pre>
     *
     * <code>uint64 week_fee_sum = 3;</code>
     * @param value The weekFeeSum to set.
     */
    private void setWeekFeeSum(long value) {
      
      weekFeeSum_ = value;
    }
    /**
     * <pre>
     * The total amount of fee revenue (in satoshis) the switch has collected
     * over the past 1 week.
     * </pre>
     *
     * <code>uint64 week_fee_sum = 3;</code>
     */
    private void clearWeekFeeSum() {
      
      weekFeeSum_ = 0L;
    }

    public static final int MONTH_FEE_SUM_FIELD_NUMBER = 4;
    private long monthFeeSum_;
    /**
     * <pre>
     * The total amount of fee revenue (in satoshis) the switch has collected
     * over the past 1 month.
     * </pre>
     *
     * <code>uint64 month_fee_sum = 4;</code>
     * @return The monthFeeSum.
     */
    @java.lang.Override
    public long getMonthFeeSum() {
      return monthFeeSum_;
    }
    /**
     * <pre>
     * The total amount of fee revenue (in satoshis) the switch has collected
     * over the past 1 month.
     * </pre>
     *
     * <code>uint64 month_fee_sum = 4;</code>
     * @param value The monthFeeSum to set.
     */
    private void setMonthFeeSum(long value) {
      
      monthFeeSum_ = value;
    }
    /**
     * <pre>
     * The total amount of fee revenue (in satoshis) the switch has collected
     * over the past 1 month.
     * </pre>
     *
     * <code>uint64 month_fee_sum = 4;</code>
     */
    private void clearMonthFeeSum() {
      
      monthFeeSum_ = 0L;
    }

    public static co.anode.anodium.Rpc.FeeReportResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FeeReportResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FeeReportResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FeeReportResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FeeReportResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.FeeReportResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FeeReportResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FeeReportResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FeeReportResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FeeReportResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.FeeReportResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.FeeReportResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.FeeReportResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.FeeReportResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.FeeReportResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.FeeReportResponse)
        co.anode.anodium.Rpc.FeeReportResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.FeeReportResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * An array of channel fee reports which describes the current fee schedule
       * for each channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.ChannelFeeReport> getChannelFeesList() {
        return java.util.Collections.unmodifiableList(
            instance.getChannelFeesList());
      }
      /**
       * <pre>
       * An array of channel fee reports which describes the current fee schedule
       * for each channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
       */
      @java.lang.Override
      public int getChannelFeesCount() {
        return instance.getChannelFeesCount();
      }/**
       * <pre>
       * An array of channel fee reports which describes the current fee schedule
       * for each channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelFeeReport getChannelFees(int index) {
        return instance.getChannelFees(index);
      }
      /**
       * <pre>
       * An array of channel fee reports which describes the current fee schedule
       * for each channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
       */
      public Builder setChannelFees(
          int index, co.anode.anodium.Rpc.ChannelFeeReport value) {
        copyOnWrite();
        instance.setChannelFees(index, value);
        return this;
      }
      /**
       * <pre>
       * An array of channel fee reports which describes the current fee schedule
       * for each channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
       */
      public Builder setChannelFees(
          int index, co.anode.anodium.Rpc.ChannelFeeReport.Builder builderForValue) {
        copyOnWrite();
        instance.setChannelFees(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * An array of channel fee reports which describes the current fee schedule
       * for each channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
       */
      public Builder addChannelFees(co.anode.anodium.Rpc.ChannelFeeReport value) {
        copyOnWrite();
        instance.addChannelFees(value);
        return this;
      }
      /**
       * <pre>
       * An array of channel fee reports which describes the current fee schedule
       * for each channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
       */
      public Builder addChannelFees(
          int index, co.anode.anodium.Rpc.ChannelFeeReport value) {
        copyOnWrite();
        instance.addChannelFees(index, value);
        return this;
      }
      /**
       * <pre>
       * An array of channel fee reports which describes the current fee schedule
       * for each channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
       */
      public Builder addChannelFees(
          co.anode.anodium.Rpc.ChannelFeeReport.Builder builderForValue) {
        copyOnWrite();
        instance.addChannelFees(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * An array of channel fee reports which describes the current fee schedule
       * for each channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
       */
      public Builder addChannelFees(
          int index, co.anode.anodium.Rpc.ChannelFeeReport.Builder builderForValue) {
        copyOnWrite();
        instance.addChannelFees(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * An array of channel fee reports which describes the current fee schedule
       * for each channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
       */
      public Builder addAllChannelFees(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.ChannelFeeReport> values) {
        copyOnWrite();
        instance.addAllChannelFees(values);
        return this;
      }
      /**
       * <pre>
       * An array of channel fee reports which describes the current fee schedule
       * for each channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
       */
      public Builder clearChannelFees() {
        copyOnWrite();
        instance.clearChannelFees();
        return this;
      }
      /**
       * <pre>
       * An array of channel fee reports which describes the current fee schedule
       * for each channel.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelFeeReport channel_fees = 1;</code>
       */
      public Builder removeChannelFees(int index) {
        copyOnWrite();
        instance.removeChannelFees(index);
        return this;
      }

      /**
       * <pre>
       * The total amount of fee revenue (in satoshis) the switch has collected
       * over the past 24 hrs.
       * </pre>
       *
       * <code>uint64 day_fee_sum = 2;</code>
       * @return The dayFeeSum.
       */
      @java.lang.Override
      public long getDayFeeSum() {
        return instance.getDayFeeSum();
      }
      /**
       * <pre>
       * The total amount of fee revenue (in satoshis) the switch has collected
       * over the past 24 hrs.
       * </pre>
       *
       * <code>uint64 day_fee_sum = 2;</code>
       * @param value The dayFeeSum to set.
       * @return This builder for chaining.
       */
      public Builder setDayFeeSum(long value) {
        copyOnWrite();
        instance.setDayFeeSum(value);
        return this;
      }
      /**
       * <pre>
       * The total amount of fee revenue (in satoshis) the switch has collected
       * over the past 24 hrs.
       * </pre>
       *
       * <code>uint64 day_fee_sum = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearDayFeeSum() {
        copyOnWrite();
        instance.clearDayFeeSum();
        return this;
      }

      /**
       * <pre>
       * The total amount of fee revenue (in satoshis) the switch has collected
       * over the past 1 week.
       * </pre>
       *
       * <code>uint64 week_fee_sum = 3;</code>
       * @return The weekFeeSum.
       */
      @java.lang.Override
      public long getWeekFeeSum() {
        return instance.getWeekFeeSum();
      }
      /**
       * <pre>
       * The total amount of fee revenue (in satoshis) the switch has collected
       * over the past 1 week.
       * </pre>
       *
       * <code>uint64 week_fee_sum = 3;</code>
       * @param value The weekFeeSum to set.
       * @return This builder for chaining.
       */
      public Builder setWeekFeeSum(long value) {
        copyOnWrite();
        instance.setWeekFeeSum(value);
        return this;
      }
      /**
       * <pre>
       * The total amount of fee revenue (in satoshis) the switch has collected
       * over the past 1 week.
       * </pre>
       *
       * <code>uint64 week_fee_sum = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearWeekFeeSum() {
        copyOnWrite();
        instance.clearWeekFeeSum();
        return this;
      }

      /**
       * <pre>
       * The total amount of fee revenue (in satoshis) the switch has collected
       * over the past 1 month.
       * </pre>
       *
       * <code>uint64 month_fee_sum = 4;</code>
       * @return The monthFeeSum.
       */
      @java.lang.Override
      public long getMonthFeeSum() {
        return instance.getMonthFeeSum();
      }
      /**
       * <pre>
       * The total amount of fee revenue (in satoshis) the switch has collected
       * over the past 1 month.
       * </pre>
       *
       * <code>uint64 month_fee_sum = 4;</code>
       * @param value The monthFeeSum to set.
       * @return This builder for chaining.
       */
      public Builder setMonthFeeSum(long value) {
        copyOnWrite();
        instance.setMonthFeeSum(value);
        return this;
      }
      /**
       * <pre>
       * The total amount of fee revenue (in satoshis) the switch has collected
       * over the past 1 month.
       * </pre>
       *
       * <code>uint64 month_fee_sum = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearMonthFeeSum() {
        copyOnWrite();
        instance.clearMonthFeeSum();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.FeeReportResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.FeeReportResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "channelFees_",
              co.anode.anodium.Rpc.ChannelFeeReport.class,
              "dayFeeSum_",
              "weekFeeSum_",
              "monthFeeSum_",
            };
            java.lang.String info =
                "\u0000\u0004\u0000\u0000\u0001\u0004\u0004\u0000\u0001\u0000\u0001\u001b\u0002\u0003" +
                "\u0003\u0003\u0004\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.FeeReportResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.FeeReportResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.FeeReportResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.FeeReportResponse)
    private static final co.anode.anodium.Rpc.FeeReportResponse DEFAULT_INSTANCE;
    static {
      FeeReportResponse defaultInstance = new FeeReportResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        FeeReportResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.FeeReportResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FeeReportResponse> PARSER;

    public static com.google.protobuf.Parser<FeeReportResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PolicyUpdateRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.PolicyUpdateRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * If set, then this update applies to all currently active channels.
     * </pre>
     *
     * <code>bool global = 1;</code>
     * @return Whether the global field is set.
     */
    boolean hasGlobal();
    /**
     * <pre>
     * If set, then this update applies to all currently active channels.
     * </pre>
     *
     * <code>bool global = 1;</code>
     * @return The global.
     */
    boolean getGlobal();

    /**
     * <pre>
     * If set, this update will target a specific channel.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     * @return Whether the chanPoint field is set.
     */
    boolean hasChanPoint();
    /**
     * <pre>
     * If set, this update will target a specific channel.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     * @return The chanPoint.
     */
    co.anode.anodium.Rpc.ChannelPoint getChanPoint();

    /**
     * <pre>
     * The base fee charged regardless of the number of milli-satoshis sent.
     * </pre>
     *
     * <code>int64 base_fee_msat = 3;</code>
     * @return The baseFeeMsat.
     */
    long getBaseFeeMsat();

    /**
     * <pre>
     * The effective fee rate in milli-satoshis. The precision of this value
     * goes up to 6 decimal places, so 1e-6.
     * </pre>
     *
     * <code>double fee_rate = 4;</code>
     * @return The feeRate.
     */
    double getFeeRate();

    /**
     * <pre>
     * The required timelock delta for HTLCs forwarded over the channel.
     * </pre>
     *
     * <code>uint32 time_lock_delta = 5;</code>
     * @return The timeLockDelta.
     */
    int getTimeLockDelta();

    /**
     * <pre>
     * If set, the maximum HTLC size in milli-satoshis. If unset, the maximum
     * HTLC will be unchanged.
     * </pre>
     *
     * <code>uint64 max_htlc_msat = 6;</code>
     * @return The maxHtlcMsat.
     */
    long getMaxHtlcMsat();

    /**
     * <pre>
     * The minimum HTLC size in milli-satoshis. Only applied if
     * min_htlc_msat_specified is true.
     * </pre>
     *
     * <code>uint64 min_htlc_msat = 7;</code>
     * @return The minHtlcMsat.
     */
    long getMinHtlcMsat();

    /**
     * <pre>
     * If true, min_htlc_msat is applied.
     * </pre>
     *
     * <code>bool min_htlc_msat_specified = 8;</code>
     * @return The minHtlcMsatSpecified.
     */
    boolean getMinHtlcMsatSpecified();

    public co.anode.anodium.Rpc.PolicyUpdateRequest.ScopeCase getScopeCase();
  }
  /**
   * Protobuf type {@code co.anode.anodium.PolicyUpdateRequest}
   */
  public  static final class PolicyUpdateRequest extends
      com.google.protobuf.GeneratedMessageLite<
          PolicyUpdateRequest, PolicyUpdateRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.PolicyUpdateRequest)
      PolicyUpdateRequestOrBuilder {
    private PolicyUpdateRequest() {
    }
    private int scopeCase_ = 0;
    private java.lang.Object scope_;
    public enum ScopeCase {
      GLOBAL(1),
      CHAN_POINT(2),
      SCOPE_NOT_SET(0);
      private final int value;
      private ScopeCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ScopeCase valueOf(int value) {
        return forNumber(value);
      }

      public static ScopeCase forNumber(int value) {
        switch (value) {
          case 1: return GLOBAL;
          case 2: return CHAN_POINT;
          case 0: return SCOPE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    @java.lang.Override
    public ScopeCase
    getScopeCase() {
      return ScopeCase.forNumber(
          scopeCase_);
    }

    private void clearScope() {
      scopeCase_ = 0;
      scope_ = null;
    }

    public static final int GLOBAL_FIELD_NUMBER = 1;
    /**
     * <pre>
     * If set, then this update applies to all currently active channels.
     * </pre>
     *
     * <code>bool global = 1;</code>
     * @return Whether the global field is set.
     */
    @java.lang.Override
    public boolean hasGlobal() {
      return scopeCase_ == 1;
    }
    /**
     * <pre>
     * If set, then this update applies to all currently active channels.
     * </pre>
     *
     * <code>bool global = 1;</code>
     * @return The global.
     */
    @java.lang.Override
    public boolean getGlobal() {
      if (scopeCase_ == 1) {
        return (java.lang.Boolean) scope_;
      }
      return false;
    }
    /**
     * <pre>
     * If set, then this update applies to all currently active channels.
     * </pre>
     *
     * <code>bool global = 1;</code>
     * @param value The global to set.
     */
    private void setGlobal(boolean value) {
      scopeCase_ = 1;
      scope_ = value;
    }
    /**
     * <pre>
     * If set, then this update applies to all currently active channels.
     * </pre>
     *
     * <code>bool global = 1;</code>
     */
    private void clearGlobal() {
      if (scopeCase_ == 1) {
        scopeCase_ = 0;
        scope_ = null;
      }
    }

    public static final int CHAN_POINT_FIELD_NUMBER = 2;
    /**
     * <pre>
     * If set, this update will target a specific channel.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     */
    @java.lang.Override
    public boolean hasChanPoint() {
      return scopeCase_ == 2;
    }
    /**
     * <pre>
     * If set, this update will target a specific channel.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelPoint getChanPoint() {
      if (scopeCase_ == 2) {
         return (co.anode.anodium.Rpc.ChannelPoint) scope_;
      }
      return co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance();
    }
    /**
     * <pre>
     * If set, this update will target a specific channel.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     */
    private void setChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  scope_ = value;
      scopeCase_ = 2;
    }
    /**
     * <pre>
     * If set, this update will target a specific channel.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     */
    private void mergeChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  if (scopeCase_ == 2 &&
          scope_ != co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance()) {
        scope_ = co.anode.anodium.Rpc.ChannelPoint.newBuilder((co.anode.anodium.Rpc.ChannelPoint) scope_)
            .mergeFrom(value).buildPartial();
      } else {
        scope_ = value;
      }
      scopeCase_ = 2;
    }
    /**
     * <pre>
     * If set, this update will target a specific channel.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
     */
    private void clearChanPoint() {
      if (scopeCase_ == 2) {
        scopeCase_ = 0;
        scope_ = null;
      }
    }

    public static final int BASE_FEE_MSAT_FIELD_NUMBER = 3;
    private long baseFeeMsat_;
    /**
     * <pre>
     * The base fee charged regardless of the number of milli-satoshis sent.
     * </pre>
     *
     * <code>int64 base_fee_msat = 3;</code>
     * @return The baseFeeMsat.
     */
    @java.lang.Override
    public long getBaseFeeMsat() {
      return baseFeeMsat_;
    }
    /**
     * <pre>
     * The base fee charged regardless of the number of milli-satoshis sent.
     * </pre>
     *
     * <code>int64 base_fee_msat = 3;</code>
     * @param value The baseFeeMsat to set.
     */
    private void setBaseFeeMsat(long value) {
      
      baseFeeMsat_ = value;
    }
    /**
     * <pre>
     * The base fee charged regardless of the number of milli-satoshis sent.
     * </pre>
     *
     * <code>int64 base_fee_msat = 3;</code>
     */
    private void clearBaseFeeMsat() {
      
      baseFeeMsat_ = 0L;
    }

    public static final int FEE_RATE_FIELD_NUMBER = 4;
    private double feeRate_;
    /**
     * <pre>
     * The effective fee rate in milli-satoshis. The precision of this value
     * goes up to 6 decimal places, so 1e-6.
     * </pre>
     *
     * <code>double fee_rate = 4;</code>
     * @return The feeRate.
     */
    @java.lang.Override
    public double getFeeRate() {
      return feeRate_;
    }
    /**
     * <pre>
     * The effective fee rate in milli-satoshis. The precision of this value
     * goes up to 6 decimal places, so 1e-6.
     * </pre>
     *
     * <code>double fee_rate = 4;</code>
     * @param value The feeRate to set.
     */
    private void setFeeRate(double value) {
      
      feeRate_ = value;
    }
    /**
     * <pre>
     * The effective fee rate in milli-satoshis. The precision of this value
     * goes up to 6 decimal places, so 1e-6.
     * </pre>
     *
     * <code>double fee_rate = 4;</code>
     */
    private void clearFeeRate() {
      
      feeRate_ = 0D;
    }

    public static final int TIME_LOCK_DELTA_FIELD_NUMBER = 5;
    private int timeLockDelta_;
    /**
     * <pre>
     * The required timelock delta for HTLCs forwarded over the channel.
     * </pre>
     *
     * <code>uint32 time_lock_delta = 5;</code>
     * @return The timeLockDelta.
     */
    @java.lang.Override
    public int getTimeLockDelta() {
      return timeLockDelta_;
    }
    /**
     * <pre>
     * The required timelock delta for HTLCs forwarded over the channel.
     * </pre>
     *
     * <code>uint32 time_lock_delta = 5;</code>
     * @param value The timeLockDelta to set.
     */
    private void setTimeLockDelta(int value) {
      
      timeLockDelta_ = value;
    }
    /**
     * <pre>
     * The required timelock delta for HTLCs forwarded over the channel.
     * </pre>
     *
     * <code>uint32 time_lock_delta = 5;</code>
     */
    private void clearTimeLockDelta() {
      
      timeLockDelta_ = 0;
    }

    public static final int MAX_HTLC_MSAT_FIELD_NUMBER = 6;
    private long maxHtlcMsat_;
    /**
     * <pre>
     * If set, the maximum HTLC size in milli-satoshis. If unset, the maximum
     * HTLC will be unchanged.
     * </pre>
     *
     * <code>uint64 max_htlc_msat = 6;</code>
     * @return The maxHtlcMsat.
     */
    @java.lang.Override
    public long getMaxHtlcMsat() {
      return maxHtlcMsat_;
    }
    /**
     * <pre>
     * If set, the maximum HTLC size in milli-satoshis. If unset, the maximum
     * HTLC will be unchanged.
     * </pre>
     *
     * <code>uint64 max_htlc_msat = 6;</code>
     * @param value The maxHtlcMsat to set.
     */
    private void setMaxHtlcMsat(long value) {
      
      maxHtlcMsat_ = value;
    }
    /**
     * <pre>
     * If set, the maximum HTLC size in milli-satoshis. If unset, the maximum
     * HTLC will be unchanged.
     * </pre>
     *
     * <code>uint64 max_htlc_msat = 6;</code>
     */
    private void clearMaxHtlcMsat() {
      
      maxHtlcMsat_ = 0L;
    }

    public static final int MIN_HTLC_MSAT_FIELD_NUMBER = 7;
    private long minHtlcMsat_;
    /**
     * <pre>
     * The minimum HTLC size in milli-satoshis. Only applied if
     * min_htlc_msat_specified is true.
     * </pre>
     *
     * <code>uint64 min_htlc_msat = 7;</code>
     * @return The minHtlcMsat.
     */
    @java.lang.Override
    public long getMinHtlcMsat() {
      return minHtlcMsat_;
    }
    /**
     * <pre>
     * The minimum HTLC size in milli-satoshis. Only applied if
     * min_htlc_msat_specified is true.
     * </pre>
     *
     * <code>uint64 min_htlc_msat = 7;</code>
     * @param value The minHtlcMsat to set.
     */
    private void setMinHtlcMsat(long value) {
      
      minHtlcMsat_ = value;
    }
    /**
     * <pre>
     * The minimum HTLC size in milli-satoshis. Only applied if
     * min_htlc_msat_specified is true.
     * </pre>
     *
     * <code>uint64 min_htlc_msat = 7;</code>
     */
    private void clearMinHtlcMsat() {
      
      minHtlcMsat_ = 0L;
    }

    public static final int MIN_HTLC_MSAT_SPECIFIED_FIELD_NUMBER = 8;
    private boolean minHtlcMsatSpecified_;
    /**
     * <pre>
     * If true, min_htlc_msat is applied.
     * </pre>
     *
     * <code>bool min_htlc_msat_specified = 8;</code>
     * @return The minHtlcMsatSpecified.
     */
    @java.lang.Override
    public boolean getMinHtlcMsatSpecified() {
      return minHtlcMsatSpecified_;
    }
    /**
     * <pre>
     * If true, min_htlc_msat is applied.
     * </pre>
     *
     * <code>bool min_htlc_msat_specified = 8;</code>
     * @param value The minHtlcMsatSpecified to set.
     */
    private void setMinHtlcMsatSpecified(boolean value) {
      
      minHtlcMsatSpecified_ = value;
    }
    /**
     * <pre>
     * If true, min_htlc_msat is applied.
     * </pre>
     *
     * <code>bool min_htlc_msat_specified = 8;</code>
     */
    private void clearMinHtlcMsatSpecified() {
      
      minHtlcMsatSpecified_ = false;
    }

    public static co.anode.anodium.Rpc.PolicyUpdateRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.PolicyUpdateRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.PolicyUpdateRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.PolicyUpdateRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.PolicyUpdateRequest)
        co.anode.anodium.Rpc.PolicyUpdateRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.PolicyUpdateRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }

      @java.lang.Override
      public ScopeCase
          getScopeCase() {
        return instance.getScopeCase();
      }

      public Builder clearScope() {
        copyOnWrite();
        instance.clearScope();
        return this;
      }


      /**
       * <pre>
       * If set, then this update applies to all currently active channels.
       * </pre>
       *
       * <code>bool global = 1;</code>
       * @return Whether the global field is set.
       */
      @java.lang.Override
      public boolean hasGlobal() {
        return instance.hasGlobal();
      }
      /**
       * <pre>
       * If set, then this update applies to all currently active channels.
       * </pre>
       *
       * <code>bool global = 1;</code>
       * @return The global.
       */
      @java.lang.Override
      public boolean getGlobal() {
        return instance.getGlobal();
      }
      /**
       * <pre>
       * If set, then this update applies to all currently active channels.
       * </pre>
       *
       * <code>bool global = 1;</code>
       * @param value The global to set.
       * @return This builder for chaining.
       */
      public Builder setGlobal(boolean value) {
        copyOnWrite();
        instance.setGlobal(value);
        return this;
      }
      /**
       * <pre>
       * If set, then this update applies to all currently active channels.
       * </pre>
       *
       * <code>bool global = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearGlobal() {
        copyOnWrite();
        instance.clearGlobal();
        return this;
      }

      /**
       * <pre>
       * If set, this update will target a specific channel.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
       */
      @java.lang.Override
      public boolean hasChanPoint() {
        return instance.hasChanPoint();
      }
      /**
       * <pre>
       * If set, this update will target a specific channel.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelPoint getChanPoint() {
        return instance.getChanPoint();
      }
      /**
       * <pre>
       * If set, this update will target a specific channel.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
       */
      public Builder setChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.setChanPoint(value);
        return this;
      }
      /**
       * <pre>
       * If set, this update will target a specific channel.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
       */
      public Builder setChanPoint(
          co.anode.anodium.Rpc.ChannelPoint.Builder builderForValue) {
        copyOnWrite();
        instance.setChanPoint(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * If set, this update will target a specific channel.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
       */
      public Builder mergeChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.mergeChanPoint(value);
        return this;
      }
      /**
       * <pre>
       * If set, this update will target a specific channel.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 2;</code>
       */
      public Builder clearChanPoint() {
        copyOnWrite();
        instance.clearChanPoint();
        return this;
      }

      /**
       * <pre>
       * The base fee charged regardless of the number of milli-satoshis sent.
       * </pre>
       *
       * <code>int64 base_fee_msat = 3;</code>
       * @return The baseFeeMsat.
       */
      @java.lang.Override
      public long getBaseFeeMsat() {
        return instance.getBaseFeeMsat();
      }
      /**
       * <pre>
       * The base fee charged regardless of the number of milli-satoshis sent.
       * </pre>
       *
       * <code>int64 base_fee_msat = 3;</code>
       * @param value The baseFeeMsat to set.
       * @return This builder for chaining.
       */
      public Builder setBaseFeeMsat(long value) {
        copyOnWrite();
        instance.setBaseFeeMsat(value);
        return this;
      }
      /**
       * <pre>
       * The base fee charged regardless of the number of milli-satoshis sent.
       * </pre>
       *
       * <code>int64 base_fee_msat = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearBaseFeeMsat() {
        copyOnWrite();
        instance.clearBaseFeeMsat();
        return this;
      }

      /**
       * <pre>
       * The effective fee rate in milli-satoshis. The precision of this value
       * goes up to 6 decimal places, so 1e-6.
       * </pre>
       *
       * <code>double fee_rate = 4;</code>
       * @return The feeRate.
       */
      @java.lang.Override
      public double getFeeRate() {
        return instance.getFeeRate();
      }
      /**
       * <pre>
       * The effective fee rate in milli-satoshis. The precision of this value
       * goes up to 6 decimal places, so 1e-6.
       * </pre>
       *
       * <code>double fee_rate = 4;</code>
       * @param value The feeRate to set.
       * @return This builder for chaining.
       */
      public Builder setFeeRate(double value) {
        copyOnWrite();
        instance.setFeeRate(value);
        return this;
      }
      /**
       * <pre>
       * The effective fee rate in milli-satoshis. The precision of this value
       * goes up to 6 decimal places, so 1e-6.
       * </pre>
       *
       * <code>double fee_rate = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearFeeRate() {
        copyOnWrite();
        instance.clearFeeRate();
        return this;
      }

      /**
       * <pre>
       * The required timelock delta for HTLCs forwarded over the channel.
       * </pre>
       *
       * <code>uint32 time_lock_delta = 5;</code>
       * @return The timeLockDelta.
       */
      @java.lang.Override
      public int getTimeLockDelta() {
        return instance.getTimeLockDelta();
      }
      /**
       * <pre>
       * The required timelock delta for HTLCs forwarded over the channel.
       * </pre>
       *
       * <code>uint32 time_lock_delta = 5;</code>
       * @param value The timeLockDelta to set.
       * @return This builder for chaining.
       */
      public Builder setTimeLockDelta(int value) {
        copyOnWrite();
        instance.setTimeLockDelta(value);
        return this;
      }
      /**
       * <pre>
       * The required timelock delta for HTLCs forwarded over the channel.
       * </pre>
       *
       * <code>uint32 time_lock_delta = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimeLockDelta() {
        copyOnWrite();
        instance.clearTimeLockDelta();
        return this;
      }

      /**
       * <pre>
       * If set, the maximum HTLC size in milli-satoshis. If unset, the maximum
       * HTLC will be unchanged.
       * </pre>
       *
       * <code>uint64 max_htlc_msat = 6;</code>
       * @return The maxHtlcMsat.
       */
      @java.lang.Override
      public long getMaxHtlcMsat() {
        return instance.getMaxHtlcMsat();
      }
      /**
       * <pre>
       * If set, the maximum HTLC size in milli-satoshis. If unset, the maximum
       * HTLC will be unchanged.
       * </pre>
       *
       * <code>uint64 max_htlc_msat = 6;</code>
       * @param value The maxHtlcMsat to set.
       * @return This builder for chaining.
       */
      public Builder setMaxHtlcMsat(long value) {
        copyOnWrite();
        instance.setMaxHtlcMsat(value);
        return this;
      }
      /**
       * <pre>
       * If set, the maximum HTLC size in milli-satoshis. If unset, the maximum
       * HTLC will be unchanged.
       * </pre>
       *
       * <code>uint64 max_htlc_msat = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxHtlcMsat() {
        copyOnWrite();
        instance.clearMaxHtlcMsat();
        return this;
      }

      /**
       * <pre>
       * The minimum HTLC size in milli-satoshis. Only applied if
       * min_htlc_msat_specified is true.
       * </pre>
       *
       * <code>uint64 min_htlc_msat = 7;</code>
       * @return The minHtlcMsat.
       */
      @java.lang.Override
      public long getMinHtlcMsat() {
        return instance.getMinHtlcMsat();
      }
      /**
       * <pre>
       * The minimum HTLC size in milli-satoshis. Only applied if
       * min_htlc_msat_specified is true.
       * </pre>
       *
       * <code>uint64 min_htlc_msat = 7;</code>
       * @param value The minHtlcMsat to set.
       * @return This builder for chaining.
       */
      public Builder setMinHtlcMsat(long value) {
        copyOnWrite();
        instance.setMinHtlcMsat(value);
        return this;
      }
      /**
       * <pre>
       * The minimum HTLC size in milli-satoshis. Only applied if
       * min_htlc_msat_specified is true.
       * </pre>
       *
       * <code>uint64 min_htlc_msat = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinHtlcMsat() {
        copyOnWrite();
        instance.clearMinHtlcMsat();
        return this;
      }

      /**
       * <pre>
       * If true, min_htlc_msat is applied.
       * </pre>
       *
       * <code>bool min_htlc_msat_specified = 8;</code>
       * @return The minHtlcMsatSpecified.
       */
      @java.lang.Override
      public boolean getMinHtlcMsatSpecified() {
        return instance.getMinHtlcMsatSpecified();
      }
      /**
       * <pre>
       * If true, min_htlc_msat is applied.
       * </pre>
       *
       * <code>bool min_htlc_msat_specified = 8;</code>
       * @param value The minHtlcMsatSpecified to set.
       * @return This builder for chaining.
       */
      public Builder setMinHtlcMsatSpecified(boolean value) {
        copyOnWrite();
        instance.setMinHtlcMsatSpecified(value);
        return this;
      }
      /**
       * <pre>
       * If true, min_htlc_msat is applied.
       * </pre>
       *
       * <code>bool min_htlc_msat_specified = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinHtlcMsatSpecified() {
        copyOnWrite();
        instance.clearMinHtlcMsatSpecified();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.PolicyUpdateRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.PolicyUpdateRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "scope_",
              "scopeCase_",
              co.anode.anodium.Rpc.ChannelPoint.class,
              "baseFeeMsat_",
              "feeRate_",
              "timeLockDelta_",
              "maxHtlcMsat_",
              "minHtlcMsat_",
              "minHtlcMsatSpecified_",
            };
            java.lang.String info =
                "\u0000\b\u0001\u0000\u0001\b\b\u0000\u0000\u0000\u0001:\u0000\u0002<\u0000\u0003" +
                "\u0002\u0004\u0000\u0005\u000b\u0006\u0003\u0007\u0003\b\u0007";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.PolicyUpdateRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.PolicyUpdateRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.PolicyUpdateRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.PolicyUpdateRequest)
    private static final co.anode.anodium.Rpc.PolicyUpdateRequest DEFAULT_INSTANCE;
    static {
      PolicyUpdateRequest defaultInstance = new PolicyUpdateRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        PolicyUpdateRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.PolicyUpdateRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<PolicyUpdateRequest> PARSER;

    public static com.google.protobuf.Parser<PolicyUpdateRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PolicyUpdateResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.PolicyUpdateResponse)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.PolicyUpdateResponse}
   */
  public  static final class PolicyUpdateResponse extends
      com.google.protobuf.GeneratedMessageLite<
          PolicyUpdateResponse, PolicyUpdateResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.PolicyUpdateResponse)
      PolicyUpdateResponseOrBuilder {
    private PolicyUpdateResponse() {
    }
    public static co.anode.anodium.Rpc.PolicyUpdateResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.PolicyUpdateResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.PolicyUpdateResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.PolicyUpdateResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.PolicyUpdateResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.PolicyUpdateResponse)
        co.anode.anodium.Rpc.PolicyUpdateResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.PolicyUpdateResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.PolicyUpdateResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.PolicyUpdateResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.PolicyUpdateResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.PolicyUpdateResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.PolicyUpdateResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.PolicyUpdateResponse)
    private static final co.anode.anodium.Rpc.PolicyUpdateResponse DEFAULT_INSTANCE;
    static {
      PolicyUpdateResponse defaultInstance = new PolicyUpdateResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        PolicyUpdateResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.PolicyUpdateResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<PolicyUpdateResponse> PARSER;

    public static com.google.protobuf.Parser<PolicyUpdateResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ForwardingHistoryRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ForwardingHistoryRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Start time is the starting point of the forwarding history request. All
     * records beyond this point will be included, respecting the end time, and
     * the index offset.
     * </pre>
     *
     * <code>uint64 start_time = 1;</code>
     * @return The startTime.
     */
    long getStartTime();

    /**
     * <pre>
     * End time is the end point of the forwarding history request. The
     * response will carry at most 50k records between the start time and the
     * end time. The index offset can be used to implement pagination.
     * </pre>
     *
     * <code>uint64 end_time = 2;</code>
     * @return The endTime.
     */
    long getEndTime();

    /**
     * <pre>
     * Index offset is the offset in the time series to start at. As each
     * response can only contain 50k records, callers can use this to skip
     * around within a packed time series.
     * </pre>
     *
     * <code>uint32 index_offset = 3;</code>
     * @return The indexOffset.
     */
    int getIndexOffset();

    /**
     * <pre>
     * The max number of events to return in the response to this query.
     * </pre>
     *
     * <code>uint32 num_max_events = 4;</code>
     * @return The numMaxEvents.
     */
    int getNumMaxEvents();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ForwardingHistoryRequest}
   */
  public  static final class ForwardingHistoryRequest extends
      com.google.protobuf.GeneratedMessageLite<
          ForwardingHistoryRequest, ForwardingHistoryRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ForwardingHistoryRequest)
      ForwardingHistoryRequestOrBuilder {
    private ForwardingHistoryRequest() {
    }
    public static final int START_TIME_FIELD_NUMBER = 1;
    private long startTime_;
    /**
     * <pre>
     * Start time is the starting point of the forwarding history request. All
     * records beyond this point will be included, respecting the end time, and
     * the index offset.
     * </pre>
     *
     * <code>uint64 start_time = 1;</code>
     * @return The startTime.
     */
    @java.lang.Override
    public long getStartTime() {
      return startTime_;
    }
    /**
     * <pre>
     * Start time is the starting point of the forwarding history request. All
     * records beyond this point will be included, respecting the end time, and
     * the index offset.
     * </pre>
     *
     * <code>uint64 start_time = 1;</code>
     * @param value The startTime to set.
     */
    private void setStartTime(long value) {
      
      startTime_ = value;
    }
    /**
     * <pre>
     * Start time is the starting point of the forwarding history request. All
     * records beyond this point will be included, respecting the end time, and
     * the index offset.
     * </pre>
     *
     * <code>uint64 start_time = 1;</code>
     */
    private void clearStartTime() {
      
      startTime_ = 0L;
    }

    public static final int END_TIME_FIELD_NUMBER = 2;
    private long endTime_;
    /**
     * <pre>
     * End time is the end point of the forwarding history request. The
     * response will carry at most 50k records between the start time and the
     * end time. The index offset can be used to implement pagination.
     * </pre>
     *
     * <code>uint64 end_time = 2;</code>
     * @return The endTime.
     */
    @java.lang.Override
    public long getEndTime() {
      return endTime_;
    }
    /**
     * <pre>
     * End time is the end point of the forwarding history request. The
     * response will carry at most 50k records between the start time and the
     * end time. The index offset can be used to implement pagination.
     * </pre>
     *
     * <code>uint64 end_time = 2;</code>
     * @param value The endTime to set.
     */
    private void setEndTime(long value) {
      
      endTime_ = value;
    }
    /**
     * <pre>
     * End time is the end point of the forwarding history request. The
     * response will carry at most 50k records between the start time and the
     * end time. The index offset can be used to implement pagination.
     * </pre>
     *
     * <code>uint64 end_time = 2;</code>
     */
    private void clearEndTime() {
      
      endTime_ = 0L;
    }

    public static final int INDEX_OFFSET_FIELD_NUMBER = 3;
    private int indexOffset_;
    /**
     * <pre>
     * Index offset is the offset in the time series to start at. As each
     * response can only contain 50k records, callers can use this to skip
     * around within a packed time series.
     * </pre>
     *
     * <code>uint32 index_offset = 3;</code>
     * @return The indexOffset.
     */
    @java.lang.Override
    public int getIndexOffset() {
      return indexOffset_;
    }
    /**
     * <pre>
     * Index offset is the offset in the time series to start at. As each
     * response can only contain 50k records, callers can use this to skip
     * around within a packed time series.
     * </pre>
     *
     * <code>uint32 index_offset = 3;</code>
     * @param value The indexOffset to set.
     */
    private void setIndexOffset(int value) {
      
      indexOffset_ = value;
    }
    /**
     * <pre>
     * Index offset is the offset in the time series to start at. As each
     * response can only contain 50k records, callers can use this to skip
     * around within a packed time series.
     * </pre>
     *
     * <code>uint32 index_offset = 3;</code>
     */
    private void clearIndexOffset() {
      
      indexOffset_ = 0;
    }

    public static final int NUM_MAX_EVENTS_FIELD_NUMBER = 4;
    private int numMaxEvents_;
    /**
     * <pre>
     * The max number of events to return in the response to this query.
     * </pre>
     *
     * <code>uint32 num_max_events = 4;</code>
     * @return The numMaxEvents.
     */
    @java.lang.Override
    public int getNumMaxEvents() {
      return numMaxEvents_;
    }
    /**
     * <pre>
     * The max number of events to return in the response to this query.
     * </pre>
     *
     * <code>uint32 num_max_events = 4;</code>
     * @param value The numMaxEvents to set.
     */
    private void setNumMaxEvents(int value) {
      
      numMaxEvents_ = value;
    }
    /**
     * <pre>
     * The max number of events to return in the response to this query.
     * </pre>
     *
     * <code>uint32 num_max_events = 4;</code>
     */
    private void clearNumMaxEvents() {
      
      numMaxEvents_ = 0;
    }

    public static co.anode.anodium.Rpc.ForwardingHistoryRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ForwardingHistoryRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ForwardingHistoryRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ForwardingHistoryRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ForwardingHistoryRequest)
        co.anode.anodium.Rpc.ForwardingHistoryRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.ForwardingHistoryRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Start time is the starting point of the forwarding history request. All
       * records beyond this point will be included, respecting the end time, and
       * the index offset.
       * </pre>
       *
       * <code>uint64 start_time = 1;</code>
       * @return The startTime.
       */
      @java.lang.Override
      public long getStartTime() {
        return instance.getStartTime();
      }
      /**
       * <pre>
       * Start time is the starting point of the forwarding history request. All
       * records beyond this point will be included, respecting the end time, and
       * the index offset.
       * </pre>
       *
       * <code>uint64 start_time = 1;</code>
       * @param value The startTime to set.
       * @return This builder for chaining.
       */
      public Builder setStartTime(long value) {
        copyOnWrite();
        instance.setStartTime(value);
        return this;
      }
      /**
       * <pre>
       * Start time is the starting point of the forwarding history request. All
       * records beyond this point will be included, respecting the end time, and
       * the index offset.
       * </pre>
       *
       * <code>uint64 start_time = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearStartTime() {
        copyOnWrite();
        instance.clearStartTime();
        return this;
      }

      /**
       * <pre>
       * End time is the end point of the forwarding history request. The
       * response will carry at most 50k records between the start time and the
       * end time. The index offset can be used to implement pagination.
       * </pre>
       *
       * <code>uint64 end_time = 2;</code>
       * @return The endTime.
       */
      @java.lang.Override
      public long getEndTime() {
        return instance.getEndTime();
      }
      /**
       * <pre>
       * End time is the end point of the forwarding history request. The
       * response will carry at most 50k records between the start time and the
       * end time. The index offset can be used to implement pagination.
       * </pre>
       *
       * <code>uint64 end_time = 2;</code>
       * @param value The endTime to set.
       * @return This builder for chaining.
       */
      public Builder setEndTime(long value) {
        copyOnWrite();
        instance.setEndTime(value);
        return this;
      }
      /**
       * <pre>
       * End time is the end point of the forwarding history request. The
       * response will carry at most 50k records between the start time and the
       * end time. The index offset can be used to implement pagination.
       * </pre>
       *
       * <code>uint64 end_time = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearEndTime() {
        copyOnWrite();
        instance.clearEndTime();
        return this;
      }

      /**
       * <pre>
       * Index offset is the offset in the time series to start at. As each
       * response can only contain 50k records, callers can use this to skip
       * around within a packed time series.
       * </pre>
       *
       * <code>uint32 index_offset = 3;</code>
       * @return The indexOffset.
       */
      @java.lang.Override
      public int getIndexOffset() {
        return instance.getIndexOffset();
      }
      /**
       * <pre>
       * Index offset is the offset in the time series to start at. As each
       * response can only contain 50k records, callers can use this to skip
       * around within a packed time series.
       * </pre>
       *
       * <code>uint32 index_offset = 3;</code>
       * @param value The indexOffset to set.
       * @return This builder for chaining.
       */
      public Builder setIndexOffset(int value) {
        copyOnWrite();
        instance.setIndexOffset(value);
        return this;
      }
      /**
       * <pre>
       * Index offset is the offset in the time series to start at. As each
       * response can only contain 50k records, callers can use this to skip
       * around within a packed time series.
       * </pre>
       *
       * <code>uint32 index_offset = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearIndexOffset() {
        copyOnWrite();
        instance.clearIndexOffset();
        return this;
      }

      /**
       * <pre>
       * The max number of events to return in the response to this query.
       * </pre>
       *
       * <code>uint32 num_max_events = 4;</code>
       * @return The numMaxEvents.
       */
      @java.lang.Override
      public int getNumMaxEvents() {
        return instance.getNumMaxEvents();
      }
      /**
       * <pre>
       * The max number of events to return in the response to this query.
       * </pre>
       *
       * <code>uint32 num_max_events = 4;</code>
       * @param value The numMaxEvents to set.
       * @return This builder for chaining.
       */
      public Builder setNumMaxEvents(int value) {
        copyOnWrite();
        instance.setNumMaxEvents(value);
        return this;
      }
      /**
       * <pre>
       * The max number of events to return in the response to this query.
       * </pre>
       *
       * <code>uint32 num_max_events = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumMaxEvents() {
        copyOnWrite();
        instance.clearNumMaxEvents();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ForwardingHistoryRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ForwardingHistoryRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "startTime_",
              "endTime_",
              "indexOffset_",
              "numMaxEvents_",
            };
            java.lang.String info =
                "\u0000\u0004\u0000\u0000\u0001\u0004\u0004\u0000\u0000\u0000\u0001\u0003\u0002\u0003" +
                "\u0003\u000b\u0004\u000b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ForwardingHistoryRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ForwardingHistoryRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ForwardingHistoryRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ForwardingHistoryRequest)
    private static final co.anode.anodium.Rpc.ForwardingHistoryRequest DEFAULT_INSTANCE;
    static {
      ForwardingHistoryRequest defaultInstance = new ForwardingHistoryRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ForwardingHistoryRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ForwardingHistoryRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ForwardingHistoryRequest> PARSER;

    public static com.google.protobuf.Parser<ForwardingHistoryRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ForwardingEventOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ForwardingEvent)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Timestamp is the time (unix epoch offset) that this circuit was
     * completed.
     * </pre>
     *
     * <code>uint64 timestamp = 1;</code>
     * @return The timestamp.
     */
    long getTimestamp();

    /**
     * <pre>
     * The incoming channel ID that carried the HTLC that created the circuit.
     * </pre>
     *
     * <code>uint64 chan_id_in = 2 [jstype = JS_STRING];</code>
     * @return The chanIdIn.
     */
    long getChanIdIn();

    /**
     * <pre>
     * The outgoing channel ID that carried the preimage that completed the
     * circuit.
     * </pre>
     *
     * <code>uint64 chan_id_out = 4 [jstype = JS_STRING];</code>
     * @return The chanIdOut.
     */
    long getChanIdOut();

    /**
     * <pre>
     * The total amount (in satoshis) of the incoming HTLC that created half
     * the circuit.
     * </pre>
     *
     * <code>uint64 amt_in = 5;</code>
     * @return The amtIn.
     */
    long getAmtIn();

    /**
     * <pre>
     * The total amount (in satoshis) of the outgoing HTLC that created the
     * second half of the circuit.
     * </pre>
     *
     * <code>uint64 amt_out = 6;</code>
     * @return The amtOut.
     */
    long getAmtOut();

    /**
     * <pre>
     * The total fee (in satoshis) that this payment circuit carried.
     * </pre>
     *
     * <code>uint64 fee = 7;</code>
     * @return The fee.
     */
    long getFee();

    /**
     * <pre>
     * The total fee (in milli-satoshis) that this payment circuit carried.
     * </pre>
     *
     * <code>uint64 fee_msat = 8;</code>
     * @return The feeMsat.
     */
    long getFeeMsat();

    /**
     * <pre>
     * The total amount (in milli-satoshis) of the incoming HTLC that created
     * half the circuit.
     * </pre>
     *
     * <code>uint64 amt_in_msat = 9;</code>
     * @return The amtInMsat.
     */
    long getAmtInMsat();

    /**
     * <pre>
     * The total amount (in milli-satoshis) of the outgoing HTLC that created
     * the second half of the circuit.
     * </pre>
     *
     * <code>uint64 amt_out_msat = 10;</code>
     * @return The amtOutMsat.
     */
    long getAmtOutMsat();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ForwardingEvent}
   */
  public  static final class ForwardingEvent extends
      com.google.protobuf.GeneratedMessageLite<
          ForwardingEvent, ForwardingEvent.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ForwardingEvent)
      ForwardingEventOrBuilder {
    private ForwardingEvent() {
    }
    public static final int TIMESTAMP_FIELD_NUMBER = 1;
    private long timestamp_;
    /**
     * <pre>
     * Timestamp is the time (unix epoch offset) that this circuit was
     * completed.
     * </pre>
     *
     * <code>uint64 timestamp = 1;</code>
     * @return The timestamp.
     */
    @java.lang.Override
    public long getTimestamp() {
      return timestamp_;
    }
    /**
     * <pre>
     * Timestamp is the time (unix epoch offset) that this circuit was
     * completed.
     * </pre>
     *
     * <code>uint64 timestamp = 1;</code>
     * @param value The timestamp to set.
     */
    private void setTimestamp(long value) {
      
      timestamp_ = value;
    }
    /**
     * <pre>
     * Timestamp is the time (unix epoch offset) that this circuit was
     * completed.
     * </pre>
     *
     * <code>uint64 timestamp = 1;</code>
     */
    private void clearTimestamp() {
      
      timestamp_ = 0L;
    }

    public static final int CHAN_ID_IN_FIELD_NUMBER = 2;
    private long chanIdIn_;
    /**
     * <pre>
     * The incoming channel ID that carried the HTLC that created the circuit.
     * </pre>
     *
     * <code>uint64 chan_id_in = 2 [jstype = JS_STRING];</code>
     * @return The chanIdIn.
     */
    @java.lang.Override
    public long getChanIdIn() {
      return chanIdIn_;
    }
    /**
     * <pre>
     * The incoming channel ID that carried the HTLC that created the circuit.
     * </pre>
     *
     * <code>uint64 chan_id_in = 2 [jstype = JS_STRING];</code>
     * @param value The chanIdIn to set.
     */
    private void setChanIdIn(long value) {
      
      chanIdIn_ = value;
    }
    /**
     * <pre>
     * The incoming channel ID that carried the HTLC that created the circuit.
     * </pre>
     *
     * <code>uint64 chan_id_in = 2 [jstype = JS_STRING];</code>
     */
    private void clearChanIdIn() {
      
      chanIdIn_ = 0L;
    }

    public static final int CHAN_ID_OUT_FIELD_NUMBER = 4;
    private long chanIdOut_;
    /**
     * <pre>
     * The outgoing channel ID that carried the preimage that completed the
     * circuit.
     * </pre>
     *
     * <code>uint64 chan_id_out = 4 [jstype = JS_STRING];</code>
     * @return The chanIdOut.
     */
    @java.lang.Override
    public long getChanIdOut() {
      return chanIdOut_;
    }
    /**
     * <pre>
     * The outgoing channel ID that carried the preimage that completed the
     * circuit.
     * </pre>
     *
     * <code>uint64 chan_id_out = 4 [jstype = JS_STRING];</code>
     * @param value The chanIdOut to set.
     */
    private void setChanIdOut(long value) {
      
      chanIdOut_ = value;
    }
    /**
     * <pre>
     * The outgoing channel ID that carried the preimage that completed the
     * circuit.
     * </pre>
     *
     * <code>uint64 chan_id_out = 4 [jstype = JS_STRING];</code>
     */
    private void clearChanIdOut() {
      
      chanIdOut_ = 0L;
    }

    public static final int AMT_IN_FIELD_NUMBER = 5;
    private long amtIn_;
    /**
     * <pre>
     * The total amount (in satoshis) of the incoming HTLC that created half
     * the circuit.
     * </pre>
     *
     * <code>uint64 amt_in = 5;</code>
     * @return The amtIn.
     */
    @java.lang.Override
    public long getAmtIn() {
      return amtIn_;
    }
    /**
     * <pre>
     * The total amount (in satoshis) of the incoming HTLC that created half
     * the circuit.
     * </pre>
     *
     * <code>uint64 amt_in = 5;</code>
     * @param value The amtIn to set.
     */
    private void setAmtIn(long value) {
      
      amtIn_ = value;
    }
    /**
     * <pre>
     * The total amount (in satoshis) of the incoming HTLC that created half
     * the circuit.
     * </pre>
     *
     * <code>uint64 amt_in = 5;</code>
     */
    private void clearAmtIn() {
      
      amtIn_ = 0L;
    }

    public static final int AMT_OUT_FIELD_NUMBER = 6;
    private long amtOut_;
    /**
     * <pre>
     * The total amount (in satoshis) of the outgoing HTLC that created the
     * second half of the circuit.
     * </pre>
     *
     * <code>uint64 amt_out = 6;</code>
     * @return The amtOut.
     */
    @java.lang.Override
    public long getAmtOut() {
      return amtOut_;
    }
    /**
     * <pre>
     * The total amount (in satoshis) of the outgoing HTLC that created the
     * second half of the circuit.
     * </pre>
     *
     * <code>uint64 amt_out = 6;</code>
     * @param value The amtOut to set.
     */
    private void setAmtOut(long value) {
      
      amtOut_ = value;
    }
    /**
     * <pre>
     * The total amount (in satoshis) of the outgoing HTLC that created the
     * second half of the circuit.
     * </pre>
     *
     * <code>uint64 amt_out = 6;</code>
     */
    private void clearAmtOut() {
      
      amtOut_ = 0L;
    }

    public static final int FEE_FIELD_NUMBER = 7;
    private long fee_;
    /**
     * <pre>
     * The total fee (in satoshis) that this payment circuit carried.
     * </pre>
     *
     * <code>uint64 fee = 7;</code>
     * @return The fee.
     */
    @java.lang.Override
    public long getFee() {
      return fee_;
    }
    /**
     * <pre>
     * The total fee (in satoshis) that this payment circuit carried.
     * </pre>
     *
     * <code>uint64 fee = 7;</code>
     * @param value The fee to set.
     */
    private void setFee(long value) {
      
      fee_ = value;
    }
    /**
     * <pre>
     * The total fee (in satoshis) that this payment circuit carried.
     * </pre>
     *
     * <code>uint64 fee = 7;</code>
     */
    private void clearFee() {
      
      fee_ = 0L;
    }

    public static final int FEE_MSAT_FIELD_NUMBER = 8;
    private long feeMsat_;
    /**
     * <pre>
     * The total fee (in milli-satoshis) that this payment circuit carried.
     * </pre>
     *
     * <code>uint64 fee_msat = 8;</code>
     * @return The feeMsat.
     */
    @java.lang.Override
    public long getFeeMsat() {
      return feeMsat_;
    }
    /**
     * <pre>
     * The total fee (in milli-satoshis) that this payment circuit carried.
     * </pre>
     *
     * <code>uint64 fee_msat = 8;</code>
     * @param value The feeMsat to set.
     */
    private void setFeeMsat(long value) {
      
      feeMsat_ = value;
    }
    /**
     * <pre>
     * The total fee (in milli-satoshis) that this payment circuit carried.
     * </pre>
     *
     * <code>uint64 fee_msat = 8;</code>
     */
    private void clearFeeMsat() {
      
      feeMsat_ = 0L;
    }

    public static final int AMT_IN_MSAT_FIELD_NUMBER = 9;
    private long amtInMsat_;
    /**
     * <pre>
     * The total amount (in milli-satoshis) of the incoming HTLC that created
     * half the circuit.
     * </pre>
     *
     * <code>uint64 amt_in_msat = 9;</code>
     * @return The amtInMsat.
     */
    @java.lang.Override
    public long getAmtInMsat() {
      return amtInMsat_;
    }
    /**
     * <pre>
     * The total amount (in milli-satoshis) of the incoming HTLC that created
     * half the circuit.
     * </pre>
     *
     * <code>uint64 amt_in_msat = 9;</code>
     * @param value The amtInMsat to set.
     */
    private void setAmtInMsat(long value) {
      
      amtInMsat_ = value;
    }
    /**
     * <pre>
     * The total amount (in milli-satoshis) of the incoming HTLC that created
     * half the circuit.
     * </pre>
     *
     * <code>uint64 amt_in_msat = 9;</code>
     */
    private void clearAmtInMsat() {
      
      amtInMsat_ = 0L;
    }

    public static final int AMT_OUT_MSAT_FIELD_NUMBER = 10;
    private long amtOutMsat_;
    /**
     * <pre>
     * The total amount (in milli-satoshis) of the outgoing HTLC that created
     * the second half of the circuit.
     * </pre>
     *
     * <code>uint64 amt_out_msat = 10;</code>
     * @return The amtOutMsat.
     */
    @java.lang.Override
    public long getAmtOutMsat() {
      return amtOutMsat_;
    }
    /**
     * <pre>
     * The total amount (in milli-satoshis) of the outgoing HTLC that created
     * the second half of the circuit.
     * </pre>
     *
     * <code>uint64 amt_out_msat = 10;</code>
     * @param value The amtOutMsat to set.
     */
    private void setAmtOutMsat(long value) {
      
      amtOutMsat_ = value;
    }
    /**
     * <pre>
     * The total amount (in milli-satoshis) of the outgoing HTLC that created
     * the second half of the circuit.
     * </pre>
     *
     * <code>uint64 amt_out_msat = 10;</code>
     */
    private void clearAmtOutMsat() {
      
      amtOutMsat_ = 0L;
    }

    public static co.anode.anodium.Rpc.ForwardingEvent parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ForwardingEvent parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ForwardingEvent parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ForwardingEvent parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ForwardingEvent parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ForwardingEvent parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ForwardingEvent parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ForwardingEvent parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ForwardingEvent parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ForwardingEvent parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ForwardingEvent parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ForwardingEvent parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ForwardingEvent prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ForwardingEvent}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ForwardingEvent, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ForwardingEvent)
        co.anode.anodium.Rpc.ForwardingEventOrBuilder {
      // Construct using co.anode.anodium.Rpc.ForwardingEvent.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Timestamp is the time (unix epoch offset) that this circuit was
       * completed.
       * </pre>
       *
       * <code>uint64 timestamp = 1;</code>
       * @return The timestamp.
       */
      @java.lang.Override
      public long getTimestamp() {
        return instance.getTimestamp();
      }
      /**
       * <pre>
       * Timestamp is the time (unix epoch offset) that this circuit was
       * completed.
       * </pre>
       *
       * <code>uint64 timestamp = 1;</code>
       * @param value The timestamp to set.
       * @return This builder for chaining.
       */
      public Builder setTimestamp(long value) {
        copyOnWrite();
        instance.setTimestamp(value);
        return this;
      }
      /**
       * <pre>
       * Timestamp is the time (unix epoch offset) that this circuit was
       * completed.
       * </pre>
       *
       * <code>uint64 timestamp = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimestamp() {
        copyOnWrite();
        instance.clearTimestamp();
        return this;
      }

      /**
       * <pre>
       * The incoming channel ID that carried the HTLC that created the circuit.
       * </pre>
       *
       * <code>uint64 chan_id_in = 2 [jstype = JS_STRING];</code>
       * @return The chanIdIn.
       */
      @java.lang.Override
      public long getChanIdIn() {
        return instance.getChanIdIn();
      }
      /**
       * <pre>
       * The incoming channel ID that carried the HTLC that created the circuit.
       * </pre>
       *
       * <code>uint64 chan_id_in = 2 [jstype = JS_STRING];</code>
       * @param value The chanIdIn to set.
       * @return This builder for chaining.
       */
      public Builder setChanIdIn(long value) {
        copyOnWrite();
        instance.setChanIdIn(value);
        return this;
      }
      /**
       * <pre>
       * The incoming channel ID that carried the HTLC that created the circuit.
       * </pre>
       *
       * <code>uint64 chan_id_in = 2 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearChanIdIn() {
        copyOnWrite();
        instance.clearChanIdIn();
        return this;
      }

      /**
       * <pre>
       * The outgoing channel ID that carried the preimage that completed the
       * circuit.
       * </pre>
       *
       * <code>uint64 chan_id_out = 4 [jstype = JS_STRING];</code>
       * @return The chanIdOut.
       */
      @java.lang.Override
      public long getChanIdOut() {
        return instance.getChanIdOut();
      }
      /**
       * <pre>
       * The outgoing channel ID that carried the preimage that completed the
       * circuit.
       * </pre>
       *
       * <code>uint64 chan_id_out = 4 [jstype = JS_STRING];</code>
       * @param value The chanIdOut to set.
       * @return This builder for chaining.
       */
      public Builder setChanIdOut(long value) {
        copyOnWrite();
        instance.setChanIdOut(value);
        return this;
      }
      /**
       * <pre>
       * The outgoing channel ID that carried the preimage that completed the
       * circuit.
       * </pre>
       *
       * <code>uint64 chan_id_out = 4 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearChanIdOut() {
        copyOnWrite();
        instance.clearChanIdOut();
        return this;
      }

      /**
       * <pre>
       * The total amount (in satoshis) of the incoming HTLC that created half
       * the circuit.
       * </pre>
       *
       * <code>uint64 amt_in = 5;</code>
       * @return The amtIn.
       */
      @java.lang.Override
      public long getAmtIn() {
        return instance.getAmtIn();
      }
      /**
       * <pre>
       * The total amount (in satoshis) of the incoming HTLC that created half
       * the circuit.
       * </pre>
       *
       * <code>uint64 amt_in = 5;</code>
       * @param value The amtIn to set.
       * @return This builder for chaining.
       */
      public Builder setAmtIn(long value) {
        copyOnWrite();
        instance.setAmtIn(value);
        return this;
      }
      /**
       * <pre>
       * The total amount (in satoshis) of the incoming HTLC that created half
       * the circuit.
       * </pre>
       *
       * <code>uint64 amt_in = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmtIn() {
        copyOnWrite();
        instance.clearAmtIn();
        return this;
      }

      /**
       * <pre>
       * The total amount (in satoshis) of the outgoing HTLC that created the
       * second half of the circuit.
       * </pre>
       *
       * <code>uint64 amt_out = 6;</code>
       * @return The amtOut.
       */
      @java.lang.Override
      public long getAmtOut() {
        return instance.getAmtOut();
      }
      /**
       * <pre>
       * The total amount (in satoshis) of the outgoing HTLC that created the
       * second half of the circuit.
       * </pre>
       *
       * <code>uint64 amt_out = 6;</code>
       * @param value The amtOut to set.
       * @return This builder for chaining.
       */
      public Builder setAmtOut(long value) {
        copyOnWrite();
        instance.setAmtOut(value);
        return this;
      }
      /**
       * <pre>
       * The total amount (in satoshis) of the outgoing HTLC that created the
       * second half of the circuit.
       * </pre>
       *
       * <code>uint64 amt_out = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmtOut() {
        copyOnWrite();
        instance.clearAmtOut();
        return this;
      }

      /**
       * <pre>
       * The total fee (in satoshis) that this payment circuit carried.
       * </pre>
       *
       * <code>uint64 fee = 7;</code>
       * @return The fee.
       */
      @java.lang.Override
      public long getFee() {
        return instance.getFee();
      }
      /**
       * <pre>
       * The total fee (in satoshis) that this payment circuit carried.
       * </pre>
       *
       * <code>uint64 fee = 7;</code>
       * @param value The fee to set.
       * @return This builder for chaining.
       */
      public Builder setFee(long value) {
        copyOnWrite();
        instance.setFee(value);
        return this;
      }
      /**
       * <pre>
       * The total fee (in satoshis) that this payment circuit carried.
       * </pre>
       *
       * <code>uint64 fee = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearFee() {
        copyOnWrite();
        instance.clearFee();
        return this;
      }

      /**
       * <pre>
       * The total fee (in milli-satoshis) that this payment circuit carried.
       * </pre>
       *
       * <code>uint64 fee_msat = 8;</code>
       * @return The feeMsat.
       */
      @java.lang.Override
      public long getFeeMsat() {
        return instance.getFeeMsat();
      }
      /**
       * <pre>
       * The total fee (in milli-satoshis) that this payment circuit carried.
       * </pre>
       *
       * <code>uint64 fee_msat = 8;</code>
       * @param value The feeMsat to set.
       * @return This builder for chaining.
       */
      public Builder setFeeMsat(long value) {
        copyOnWrite();
        instance.setFeeMsat(value);
        return this;
      }
      /**
       * <pre>
       * The total fee (in milli-satoshis) that this payment circuit carried.
       * </pre>
       *
       * <code>uint64 fee_msat = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearFeeMsat() {
        copyOnWrite();
        instance.clearFeeMsat();
        return this;
      }

      /**
       * <pre>
       * The total amount (in milli-satoshis) of the incoming HTLC that created
       * half the circuit.
       * </pre>
       *
       * <code>uint64 amt_in_msat = 9;</code>
       * @return The amtInMsat.
       */
      @java.lang.Override
      public long getAmtInMsat() {
        return instance.getAmtInMsat();
      }
      /**
       * <pre>
       * The total amount (in milli-satoshis) of the incoming HTLC that created
       * half the circuit.
       * </pre>
       *
       * <code>uint64 amt_in_msat = 9;</code>
       * @param value The amtInMsat to set.
       * @return This builder for chaining.
       */
      public Builder setAmtInMsat(long value) {
        copyOnWrite();
        instance.setAmtInMsat(value);
        return this;
      }
      /**
       * <pre>
       * The total amount (in milli-satoshis) of the incoming HTLC that created
       * half the circuit.
       * </pre>
       *
       * <code>uint64 amt_in_msat = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmtInMsat() {
        copyOnWrite();
        instance.clearAmtInMsat();
        return this;
      }

      /**
       * <pre>
       * The total amount (in milli-satoshis) of the outgoing HTLC that created
       * the second half of the circuit.
       * </pre>
       *
       * <code>uint64 amt_out_msat = 10;</code>
       * @return The amtOutMsat.
       */
      @java.lang.Override
      public long getAmtOutMsat() {
        return instance.getAmtOutMsat();
      }
      /**
       * <pre>
       * The total amount (in milli-satoshis) of the outgoing HTLC that created
       * the second half of the circuit.
       * </pre>
       *
       * <code>uint64 amt_out_msat = 10;</code>
       * @param value The amtOutMsat to set.
       * @return This builder for chaining.
       */
      public Builder setAmtOutMsat(long value) {
        copyOnWrite();
        instance.setAmtOutMsat(value);
        return this;
      }
      /**
       * <pre>
       * The total amount (in milli-satoshis) of the outgoing HTLC that created
       * the second half of the circuit.
       * </pre>
       *
       * <code>uint64 amt_out_msat = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearAmtOutMsat() {
        copyOnWrite();
        instance.clearAmtOutMsat();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ForwardingEvent)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ForwardingEvent();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "timestamp_",
              "chanIdIn_",
              "chanIdOut_",
              "amtIn_",
              "amtOut_",
              "fee_",
              "feeMsat_",
              "amtInMsat_",
              "amtOutMsat_",
            };
            java.lang.String info =
                "\u0000\t\u0000\u0000\u0001\n\t\u0000\u0000\u0000\u0001\u0003\u0002\u0003\u0004\u0003" +
                "\u0005\u0003\u0006\u0003\u0007\u0003\b\u0003\t\u0003\n\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ForwardingEvent> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ForwardingEvent.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ForwardingEvent>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ForwardingEvent)
    private static final co.anode.anodium.Rpc.ForwardingEvent DEFAULT_INSTANCE;
    static {
      ForwardingEvent defaultInstance = new ForwardingEvent();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ForwardingEvent.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ForwardingEvent getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ForwardingEvent> PARSER;

    public static com.google.protobuf.Parser<ForwardingEvent> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ForwardingHistoryResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ForwardingHistoryResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * A list of forwarding events from the time slice of the time series
     * specified in the request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
     */
    java.util.List<co.anode.anodium.Rpc.ForwardingEvent> 
        getForwardingEventsList();
    /**
     * <pre>
     * A list of forwarding events from the time slice of the time series
     * specified in the request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
     */
    co.anode.anodium.Rpc.ForwardingEvent getForwardingEvents(int index);
    /**
     * <pre>
     * A list of forwarding events from the time slice of the time series
     * specified in the request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
     */
    int getForwardingEventsCount();

    /**
     * <pre>
     * The index of the last time in the set of returned forwarding events. Can
     * be used to seek further, pagination style.
     * </pre>
     *
     * <code>uint32 last_offset_index = 2;</code>
     * @return The lastOffsetIndex.
     */
    int getLastOffsetIndex();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ForwardingHistoryResponse}
   */
  public  static final class ForwardingHistoryResponse extends
      com.google.protobuf.GeneratedMessageLite<
          ForwardingHistoryResponse, ForwardingHistoryResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ForwardingHistoryResponse)
      ForwardingHistoryResponseOrBuilder {
    private ForwardingHistoryResponse() {
      forwardingEvents_ = emptyProtobufList();
    }
    public static final int FORWARDING_EVENTS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.ForwardingEvent> forwardingEvents_;
    /**
     * <pre>
     * A list of forwarding events from the time slice of the time series
     * specified in the request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.ForwardingEvent> getForwardingEventsList() {
      return forwardingEvents_;
    }
    /**
     * <pre>
     * A list of forwarding events from the time slice of the time series
     * specified in the request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.ForwardingEventOrBuilder> 
        getForwardingEventsOrBuilderList() {
      return forwardingEvents_;
    }
    /**
     * <pre>
     * A list of forwarding events from the time slice of the time series
     * specified in the request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
     */
    @java.lang.Override
    public int getForwardingEventsCount() {
      return forwardingEvents_.size();
    }
    /**
     * <pre>
     * A list of forwarding events from the time slice of the time series
     * specified in the request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ForwardingEvent getForwardingEvents(int index) {
      return forwardingEvents_.get(index);
    }
    /**
     * <pre>
     * A list of forwarding events from the time slice of the time series
     * specified in the request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
     */
    public co.anode.anodium.Rpc.ForwardingEventOrBuilder getForwardingEventsOrBuilder(
        int index) {
      return forwardingEvents_.get(index);
    }
    private void ensureForwardingEventsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.ForwardingEvent> tmp = forwardingEvents_;
      if (!tmp.isModifiable()) {
        forwardingEvents_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * A list of forwarding events from the time slice of the time series
     * specified in the request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
     */
    private void setForwardingEvents(
        int index, co.anode.anodium.Rpc.ForwardingEvent value) {
      value.getClass();
  ensureForwardingEventsIsMutable();
      forwardingEvents_.set(index, value);
    }
    /**
     * <pre>
     * A list of forwarding events from the time slice of the time series
     * specified in the request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
     */
    private void addForwardingEvents(co.anode.anodium.Rpc.ForwardingEvent value) {
      value.getClass();
  ensureForwardingEventsIsMutable();
      forwardingEvents_.add(value);
    }
    /**
     * <pre>
     * A list of forwarding events from the time slice of the time series
     * specified in the request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
     */
    private void addForwardingEvents(
        int index, co.anode.anodium.Rpc.ForwardingEvent value) {
      value.getClass();
  ensureForwardingEventsIsMutable();
      forwardingEvents_.add(index, value);
    }
    /**
     * <pre>
     * A list of forwarding events from the time slice of the time series
     * specified in the request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
     */
    private void addAllForwardingEvents(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.ForwardingEvent> values) {
      ensureForwardingEventsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, forwardingEvents_);
    }
    /**
     * <pre>
     * A list of forwarding events from the time slice of the time series
     * specified in the request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
     */
    private void clearForwardingEvents() {
      forwardingEvents_ = emptyProtobufList();
    }
    /**
     * <pre>
     * A list of forwarding events from the time slice of the time series
     * specified in the request.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
     */
    private void removeForwardingEvents(int index) {
      ensureForwardingEventsIsMutable();
      forwardingEvents_.remove(index);
    }

    public static final int LAST_OFFSET_INDEX_FIELD_NUMBER = 2;
    private int lastOffsetIndex_;
    /**
     * <pre>
     * The index of the last time in the set of returned forwarding events. Can
     * be used to seek further, pagination style.
     * </pre>
     *
     * <code>uint32 last_offset_index = 2;</code>
     * @return The lastOffsetIndex.
     */
    @java.lang.Override
    public int getLastOffsetIndex() {
      return lastOffsetIndex_;
    }
    /**
     * <pre>
     * The index of the last time in the set of returned forwarding events. Can
     * be used to seek further, pagination style.
     * </pre>
     *
     * <code>uint32 last_offset_index = 2;</code>
     * @param value The lastOffsetIndex to set.
     */
    private void setLastOffsetIndex(int value) {
      
      lastOffsetIndex_ = value;
    }
    /**
     * <pre>
     * The index of the last time in the set of returned forwarding events. Can
     * be used to seek further, pagination style.
     * </pre>
     *
     * <code>uint32 last_offset_index = 2;</code>
     */
    private void clearLastOffsetIndex() {
      
      lastOffsetIndex_ = 0;
    }

    public static co.anode.anodium.Rpc.ForwardingHistoryResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ForwardingHistoryResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ForwardingHistoryResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ForwardingHistoryResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ForwardingHistoryResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ForwardingHistoryResponse)
        co.anode.anodium.Rpc.ForwardingHistoryResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.ForwardingHistoryResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * A list of forwarding events from the time slice of the time series
       * specified in the request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.ForwardingEvent> getForwardingEventsList() {
        return java.util.Collections.unmodifiableList(
            instance.getForwardingEventsList());
      }
      /**
       * <pre>
       * A list of forwarding events from the time slice of the time series
       * specified in the request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
       */
      @java.lang.Override
      public int getForwardingEventsCount() {
        return instance.getForwardingEventsCount();
      }/**
       * <pre>
       * A list of forwarding events from the time slice of the time series
       * specified in the request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ForwardingEvent getForwardingEvents(int index) {
        return instance.getForwardingEvents(index);
      }
      /**
       * <pre>
       * A list of forwarding events from the time slice of the time series
       * specified in the request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
       */
      public Builder setForwardingEvents(
          int index, co.anode.anodium.Rpc.ForwardingEvent value) {
        copyOnWrite();
        instance.setForwardingEvents(index, value);
        return this;
      }
      /**
       * <pre>
       * A list of forwarding events from the time slice of the time series
       * specified in the request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
       */
      public Builder setForwardingEvents(
          int index, co.anode.anodium.Rpc.ForwardingEvent.Builder builderForValue) {
        copyOnWrite();
        instance.setForwardingEvents(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A list of forwarding events from the time slice of the time series
       * specified in the request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
       */
      public Builder addForwardingEvents(co.anode.anodium.Rpc.ForwardingEvent value) {
        copyOnWrite();
        instance.addForwardingEvents(value);
        return this;
      }
      /**
       * <pre>
       * A list of forwarding events from the time slice of the time series
       * specified in the request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
       */
      public Builder addForwardingEvents(
          int index, co.anode.anodium.Rpc.ForwardingEvent value) {
        copyOnWrite();
        instance.addForwardingEvents(index, value);
        return this;
      }
      /**
       * <pre>
       * A list of forwarding events from the time slice of the time series
       * specified in the request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
       */
      public Builder addForwardingEvents(
          co.anode.anodium.Rpc.ForwardingEvent.Builder builderForValue) {
        copyOnWrite();
        instance.addForwardingEvents(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A list of forwarding events from the time slice of the time series
       * specified in the request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
       */
      public Builder addForwardingEvents(
          int index, co.anode.anodium.Rpc.ForwardingEvent.Builder builderForValue) {
        copyOnWrite();
        instance.addForwardingEvents(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A list of forwarding events from the time slice of the time series
       * specified in the request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
       */
      public Builder addAllForwardingEvents(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.ForwardingEvent> values) {
        copyOnWrite();
        instance.addAllForwardingEvents(values);
        return this;
      }
      /**
       * <pre>
       * A list of forwarding events from the time slice of the time series
       * specified in the request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
       */
      public Builder clearForwardingEvents() {
        copyOnWrite();
        instance.clearForwardingEvents();
        return this;
      }
      /**
       * <pre>
       * A list of forwarding events from the time slice of the time series
       * specified in the request.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ForwardingEvent forwarding_events = 1;</code>
       */
      public Builder removeForwardingEvents(int index) {
        copyOnWrite();
        instance.removeForwardingEvents(index);
        return this;
      }

      /**
       * <pre>
       * The index of the last time in the set of returned forwarding events. Can
       * be used to seek further, pagination style.
       * </pre>
       *
       * <code>uint32 last_offset_index = 2;</code>
       * @return The lastOffsetIndex.
       */
      @java.lang.Override
      public int getLastOffsetIndex() {
        return instance.getLastOffsetIndex();
      }
      /**
       * <pre>
       * The index of the last time in the set of returned forwarding events. Can
       * be used to seek further, pagination style.
       * </pre>
       *
       * <code>uint32 last_offset_index = 2;</code>
       * @param value The lastOffsetIndex to set.
       * @return This builder for chaining.
       */
      public Builder setLastOffsetIndex(int value) {
        copyOnWrite();
        instance.setLastOffsetIndex(value);
        return this;
      }
      /**
       * <pre>
       * The index of the last time in the set of returned forwarding events. Can
       * be used to seek further, pagination style.
       * </pre>
       *
       * <code>uint32 last_offset_index = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearLastOffsetIndex() {
        copyOnWrite();
        instance.clearLastOffsetIndex();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ForwardingHistoryResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ForwardingHistoryResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "forwardingEvents_",
              co.anode.anodium.Rpc.ForwardingEvent.class,
              "lastOffsetIndex_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0001\u0000\u0001\u001b\u0002\u000b" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ForwardingHistoryResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ForwardingHistoryResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ForwardingHistoryResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ForwardingHistoryResponse)
    private static final co.anode.anodium.Rpc.ForwardingHistoryResponse DEFAULT_INSTANCE;
    static {
      ForwardingHistoryResponse defaultInstance = new ForwardingHistoryResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ForwardingHistoryResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ForwardingHistoryResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ForwardingHistoryResponse> PARSER;

    public static com.google.protobuf.Parser<ForwardingHistoryResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ExportChannelBackupRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ExportChannelBackupRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The target channel point to obtain a back up for.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
     * @return Whether the chanPoint field is set.
     */
    boolean hasChanPoint();
    /**
     * <pre>
     * The target channel point to obtain a back up for.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
     * @return The chanPoint.
     */
    co.anode.anodium.Rpc.ChannelPoint getChanPoint();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ExportChannelBackupRequest}
   */
  public  static final class ExportChannelBackupRequest extends
      com.google.protobuf.GeneratedMessageLite<
          ExportChannelBackupRequest, ExportChannelBackupRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ExportChannelBackupRequest)
      ExportChannelBackupRequestOrBuilder {
    private ExportChannelBackupRequest() {
    }
    public static final int CHAN_POINT_FIELD_NUMBER = 1;
    private co.anode.anodium.Rpc.ChannelPoint chanPoint_;
    /**
     * <pre>
     * The target channel point to obtain a back up for.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
     */
    @java.lang.Override
    public boolean hasChanPoint() {
      return chanPoint_ != null;
    }
    /**
     * <pre>
     * The target channel point to obtain a back up for.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelPoint getChanPoint() {
      return chanPoint_ == null ? co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance() : chanPoint_;
    }
    /**
     * <pre>
     * The target channel point to obtain a back up for.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
     */
    private void setChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  chanPoint_ = value;
      
      }
    /**
     * <pre>
     * The target channel point to obtain a back up for.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  if (chanPoint_ != null &&
          chanPoint_ != co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance()) {
        chanPoint_ =
          co.anode.anodium.Rpc.ChannelPoint.newBuilder(chanPoint_).mergeFrom(value).buildPartial();
      } else {
        chanPoint_ = value;
      }
      
    }
    /**
     * <pre>
     * The target channel point to obtain a back up for.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
     */
    private void clearChanPoint() {  chanPoint_ = null;
      
    }

    public static co.anode.anodium.Rpc.ExportChannelBackupRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ExportChannelBackupRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ExportChannelBackupRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ExportChannelBackupRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ExportChannelBackupRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ExportChannelBackupRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ExportChannelBackupRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ExportChannelBackupRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ExportChannelBackupRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ExportChannelBackupRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ExportChannelBackupRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ExportChannelBackupRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ExportChannelBackupRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ExportChannelBackupRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ExportChannelBackupRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ExportChannelBackupRequest)
        co.anode.anodium.Rpc.ExportChannelBackupRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.ExportChannelBackupRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The target channel point to obtain a back up for.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
       */
      @java.lang.Override
      public boolean hasChanPoint() {
        return instance.hasChanPoint();
      }
      /**
       * <pre>
       * The target channel point to obtain a back up for.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelPoint getChanPoint() {
        return instance.getChanPoint();
      }
      /**
       * <pre>
       * The target channel point to obtain a back up for.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
       */
      public Builder setChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.setChanPoint(value);
        return this;
        }
      /**
       * <pre>
       * The target channel point to obtain a back up for.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
       */
      public Builder setChanPoint(
          co.anode.anodium.Rpc.ChannelPoint.Builder builderForValue) {
        copyOnWrite();
        instance.setChanPoint(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The target channel point to obtain a back up for.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
       */
      public Builder mergeChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.mergeChanPoint(value);
        return this;
      }
      /**
       * <pre>
       * The target channel point to obtain a back up for.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
       */
      public Builder clearChanPoint() {  copyOnWrite();
        instance.clearChanPoint();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ExportChannelBackupRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ExportChannelBackupRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "chanPoint_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\t";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ExportChannelBackupRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ExportChannelBackupRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ExportChannelBackupRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ExportChannelBackupRequest)
    private static final co.anode.anodium.Rpc.ExportChannelBackupRequest DEFAULT_INSTANCE;
    static {
      ExportChannelBackupRequest defaultInstance = new ExportChannelBackupRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ExportChannelBackupRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ExportChannelBackupRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ExportChannelBackupRequest> PARSER;

    public static com.google.protobuf.Parser<ExportChannelBackupRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelBackupOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelBackup)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *Identifies the channel that this backup belongs to.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
     * @return Whether the chanPoint field is set.
     */
    boolean hasChanPoint();
    /**
     * <pre>
     *Identifies the channel that this backup belongs to.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
     * @return The chanPoint.
     */
    co.anode.anodium.Rpc.ChannelPoint getChanPoint();

    /**
     * <pre>
     *Is an encrypted single-chan backup. this can be passed to
     *RestoreChannelBackups, or the WalletUnlocker Init and Unlock methods in
     *order to trigger the recovery protocol. When using REST, this field must be
     *encoded as base64.
     * </pre>
     *
     * <code>bytes chan_backup = 2;</code>
     * @return The chanBackup.
     */
    com.google.protobuf.ByteString getChanBackup();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChannelBackup}
   */
  public  static final class ChannelBackup extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelBackup, ChannelBackup.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelBackup)
      ChannelBackupOrBuilder {
    private ChannelBackup() {
      chanBackup_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int CHAN_POINT_FIELD_NUMBER = 1;
    private co.anode.anodium.Rpc.ChannelPoint chanPoint_;
    /**
     * <pre>
     *Identifies the channel that this backup belongs to.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
     */
    @java.lang.Override
    public boolean hasChanPoint() {
      return chanPoint_ != null;
    }
    /**
     * <pre>
     *Identifies the channel that this backup belongs to.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelPoint getChanPoint() {
      return chanPoint_ == null ? co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance() : chanPoint_;
    }
    /**
     * <pre>
     *Identifies the channel that this backup belongs to.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
     */
    private void setChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  chanPoint_ = value;
      
      }
    /**
     * <pre>
     *Identifies the channel that this backup belongs to.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  if (chanPoint_ != null &&
          chanPoint_ != co.anode.anodium.Rpc.ChannelPoint.getDefaultInstance()) {
        chanPoint_ =
          co.anode.anodium.Rpc.ChannelPoint.newBuilder(chanPoint_).mergeFrom(value).buildPartial();
      } else {
        chanPoint_ = value;
      }
      
    }
    /**
     * <pre>
     *Identifies the channel that this backup belongs to.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
     */
    private void clearChanPoint() {  chanPoint_ = null;
      
    }

    public static final int CHAN_BACKUP_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString chanBackup_;
    /**
     * <pre>
     *Is an encrypted single-chan backup. this can be passed to
     *RestoreChannelBackups, or the WalletUnlocker Init and Unlock methods in
     *order to trigger the recovery protocol. When using REST, this field must be
     *encoded as base64.
     * </pre>
     *
     * <code>bytes chan_backup = 2;</code>
     * @return The chanBackup.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getChanBackup() {
      return chanBackup_;
    }
    /**
     * <pre>
     *Is an encrypted single-chan backup. this can be passed to
     *RestoreChannelBackups, or the WalletUnlocker Init and Unlock methods in
     *order to trigger the recovery protocol. When using REST, this field must be
     *encoded as base64.
     * </pre>
     *
     * <code>bytes chan_backup = 2;</code>
     * @param value The chanBackup to set.
     */
    private void setChanBackup(com.google.protobuf.ByteString value) {
      value.getClass();
  
      chanBackup_ = value;
    }
    /**
     * <pre>
     *Is an encrypted single-chan backup. this can be passed to
     *RestoreChannelBackups, or the WalletUnlocker Init and Unlock methods in
     *order to trigger the recovery protocol. When using REST, this field must be
     *encoded as base64.
     * </pre>
     *
     * <code>bytes chan_backup = 2;</code>
     */
    private void clearChanBackup() {
      
      chanBackup_ = getDefaultInstance().getChanBackup();
    }

    public static co.anode.anodium.Rpc.ChannelBackup parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelBackup parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBackup parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelBackup parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBackup parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelBackup parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBackup parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelBackup parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBackup parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelBackup parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBackup parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelBackup parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelBackup prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChannelBackup}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelBackup, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelBackup)
        co.anode.anodium.Rpc.ChannelBackupOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelBackup.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *Identifies the channel that this backup belongs to.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
       */
      @java.lang.Override
      public boolean hasChanPoint() {
        return instance.hasChanPoint();
      }
      /**
       * <pre>
       *Identifies the channel that this backup belongs to.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelPoint getChanPoint() {
        return instance.getChanPoint();
      }
      /**
       * <pre>
       *Identifies the channel that this backup belongs to.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
       */
      public Builder setChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.setChanPoint(value);
        return this;
        }
      /**
       * <pre>
       *Identifies the channel that this backup belongs to.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
       */
      public Builder setChanPoint(
          co.anode.anodium.Rpc.ChannelPoint.Builder builderForValue) {
        copyOnWrite();
        instance.setChanPoint(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Identifies the channel that this backup belongs to.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
       */
      public Builder mergeChanPoint(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.mergeChanPoint(value);
        return this;
      }
      /**
       * <pre>
       *Identifies the channel that this backup belongs to.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelPoint chan_point = 1;</code>
       */
      public Builder clearChanPoint() {  copyOnWrite();
        instance.clearChanPoint();
        return this;
      }

      /**
       * <pre>
       *Is an encrypted single-chan backup. this can be passed to
       *RestoreChannelBackups, or the WalletUnlocker Init and Unlock methods in
       *order to trigger the recovery protocol. When using REST, this field must be
       *encoded as base64.
       * </pre>
       *
       * <code>bytes chan_backup = 2;</code>
       * @return The chanBackup.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getChanBackup() {
        return instance.getChanBackup();
      }
      /**
       * <pre>
       *Is an encrypted single-chan backup. this can be passed to
       *RestoreChannelBackups, or the WalletUnlocker Init and Unlock methods in
       *order to trigger the recovery protocol. When using REST, this field must be
       *encoded as base64.
       * </pre>
       *
       * <code>bytes chan_backup = 2;</code>
       * @param value The chanBackup to set.
       * @return This builder for chaining.
       */
      public Builder setChanBackup(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setChanBackup(value);
        return this;
      }
      /**
       * <pre>
       *Is an encrypted single-chan backup. this can be passed to
       *RestoreChannelBackups, or the WalletUnlocker Init and Unlock methods in
       *order to trigger the recovery protocol. When using REST, this field must be
       *encoded as base64.
       * </pre>
       *
       * <code>bytes chan_backup = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearChanBackup() {
        copyOnWrite();
        instance.clearChanBackup();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelBackup)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelBackup();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "chanPoint_",
              "chanBackup_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\t\u0002\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelBackup> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelBackup.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelBackup>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelBackup)
    private static final co.anode.anodium.Rpc.ChannelBackup DEFAULT_INSTANCE;
    static {
      ChannelBackup defaultInstance = new ChannelBackup();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelBackup.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelBackup getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelBackup> PARSER;

    public static com.google.protobuf.Parser<ChannelBackup> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface MultiChanBackupOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.MultiChanBackup)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *Is the set of all channels that are included in this multi-channel backup.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
     */
    java.util.List<co.anode.anodium.Rpc.ChannelPoint> 
        getChanPointsList();
    /**
     * <pre>
     *Is the set of all channels that are included in this multi-channel backup.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
     */
    co.anode.anodium.Rpc.ChannelPoint getChanPoints(int index);
    /**
     * <pre>
     *Is the set of all channels that are included in this multi-channel backup.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
     */
    int getChanPointsCount();

    /**
     * <pre>
     *A single encrypted blob containing all the static channel backups of the
     *channel listed above. This can be stored as a single file or blob, and
     *safely be replaced with any prior/future versions. When using REST, this
     *field must be encoded as base64.
     * </pre>
     *
     * <code>bytes multi_chan_backup = 2;</code>
     * @return The multiChanBackup.
     */
    com.google.protobuf.ByteString getMultiChanBackup();
  }
  /**
   * Protobuf type {@code co.anode.anodium.MultiChanBackup}
   */
  public  static final class MultiChanBackup extends
      com.google.protobuf.GeneratedMessageLite<
          MultiChanBackup, MultiChanBackup.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.MultiChanBackup)
      MultiChanBackupOrBuilder {
    private MultiChanBackup() {
      chanPoints_ = emptyProtobufList();
      multiChanBackup_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int CHAN_POINTS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.ChannelPoint> chanPoints_;
    /**
     * <pre>
     *Is the set of all channels that are included in this multi-channel backup.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.ChannelPoint> getChanPointsList() {
      return chanPoints_;
    }
    /**
     * <pre>
     *Is the set of all channels that are included in this multi-channel backup.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.ChannelPointOrBuilder> 
        getChanPointsOrBuilderList() {
      return chanPoints_;
    }
    /**
     * <pre>
     *Is the set of all channels that are included in this multi-channel backup.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
     */
    @java.lang.Override
    public int getChanPointsCount() {
      return chanPoints_.size();
    }
    /**
     * <pre>
     *Is the set of all channels that are included in this multi-channel backup.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelPoint getChanPoints(int index) {
      return chanPoints_.get(index);
    }
    /**
     * <pre>
     *Is the set of all channels that are included in this multi-channel backup.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
     */
    public co.anode.anodium.Rpc.ChannelPointOrBuilder getChanPointsOrBuilder(
        int index) {
      return chanPoints_.get(index);
    }
    private void ensureChanPointsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.ChannelPoint> tmp = chanPoints_;
      if (!tmp.isModifiable()) {
        chanPoints_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     *Is the set of all channels that are included in this multi-channel backup.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
     */
    private void setChanPoints(
        int index, co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  ensureChanPointsIsMutable();
      chanPoints_.set(index, value);
    }
    /**
     * <pre>
     *Is the set of all channels that are included in this multi-channel backup.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
     */
    private void addChanPoints(co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  ensureChanPointsIsMutable();
      chanPoints_.add(value);
    }
    /**
     * <pre>
     *Is the set of all channels that are included in this multi-channel backup.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
     */
    private void addChanPoints(
        int index, co.anode.anodium.Rpc.ChannelPoint value) {
      value.getClass();
  ensureChanPointsIsMutable();
      chanPoints_.add(index, value);
    }
    /**
     * <pre>
     *Is the set of all channels that are included in this multi-channel backup.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
     */
    private void addAllChanPoints(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.ChannelPoint> values) {
      ensureChanPointsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, chanPoints_);
    }
    /**
     * <pre>
     *Is the set of all channels that are included in this multi-channel backup.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
     */
    private void clearChanPoints() {
      chanPoints_ = emptyProtobufList();
    }
    /**
     * <pre>
     *Is the set of all channels that are included in this multi-channel backup.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
     */
    private void removeChanPoints(int index) {
      ensureChanPointsIsMutable();
      chanPoints_.remove(index);
    }

    public static final int MULTI_CHAN_BACKUP_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString multiChanBackup_;
    /**
     * <pre>
     *A single encrypted blob containing all the static channel backups of the
     *channel listed above. This can be stored as a single file or blob, and
     *safely be replaced with any prior/future versions. When using REST, this
     *field must be encoded as base64.
     * </pre>
     *
     * <code>bytes multi_chan_backup = 2;</code>
     * @return The multiChanBackup.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getMultiChanBackup() {
      return multiChanBackup_;
    }
    /**
     * <pre>
     *A single encrypted blob containing all the static channel backups of the
     *channel listed above. This can be stored as a single file or blob, and
     *safely be replaced with any prior/future versions. When using REST, this
     *field must be encoded as base64.
     * </pre>
     *
     * <code>bytes multi_chan_backup = 2;</code>
     * @param value The multiChanBackup to set.
     */
    private void setMultiChanBackup(com.google.protobuf.ByteString value) {
      value.getClass();
  
      multiChanBackup_ = value;
    }
    /**
     * <pre>
     *A single encrypted blob containing all the static channel backups of the
     *channel listed above. This can be stored as a single file or blob, and
     *safely be replaced with any prior/future versions. When using REST, this
     *field must be encoded as base64.
     * </pre>
     *
     * <code>bytes multi_chan_backup = 2;</code>
     */
    private void clearMultiChanBackup() {
      
      multiChanBackup_ = getDefaultInstance().getMultiChanBackup();
    }

    public static co.anode.anodium.Rpc.MultiChanBackup parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.MultiChanBackup parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MultiChanBackup parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.MultiChanBackup parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MultiChanBackup parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.MultiChanBackup parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MultiChanBackup parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.MultiChanBackup parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MultiChanBackup parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.MultiChanBackup parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MultiChanBackup parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.MultiChanBackup parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.MultiChanBackup prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.MultiChanBackup}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.MultiChanBackup, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.MultiChanBackup)
        co.anode.anodium.Rpc.MultiChanBackupOrBuilder {
      // Construct using co.anode.anodium.Rpc.MultiChanBackup.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *Is the set of all channels that are included in this multi-channel backup.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.ChannelPoint> getChanPointsList() {
        return java.util.Collections.unmodifiableList(
            instance.getChanPointsList());
      }
      /**
       * <pre>
       *Is the set of all channels that are included in this multi-channel backup.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
       */
      @java.lang.Override
      public int getChanPointsCount() {
        return instance.getChanPointsCount();
      }/**
       * <pre>
       *Is the set of all channels that are included in this multi-channel backup.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelPoint getChanPoints(int index) {
        return instance.getChanPoints(index);
      }
      /**
       * <pre>
       *Is the set of all channels that are included in this multi-channel backup.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
       */
      public Builder setChanPoints(
          int index, co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.setChanPoints(index, value);
        return this;
      }
      /**
       * <pre>
       *Is the set of all channels that are included in this multi-channel backup.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
       */
      public Builder setChanPoints(
          int index, co.anode.anodium.Rpc.ChannelPoint.Builder builderForValue) {
        copyOnWrite();
        instance.setChanPoints(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Is the set of all channels that are included in this multi-channel backup.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
       */
      public Builder addChanPoints(co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.addChanPoints(value);
        return this;
      }
      /**
       * <pre>
       *Is the set of all channels that are included in this multi-channel backup.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
       */
      public Builder addChanPoints(
          int index, co.anode.anodium.Rpc.ChannelPoint value) {
        copyOnWrite();
        instance.addChanPoints(index, value);
        return this;
      }
      /**
       * <pre>
       *Is the set of all channels that are included in this multi-channel backup.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
       */
      public Builder addChanPoints(
          co.anode.anodium.Rpc.ChannelPoint.Builder builderForValue) {
        copyOnWrite();
        instance.addChanPoints(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Is the set of all channels that are included in this multi-channel backup.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
       */
      public Builder addChanPoints(
          int index, co.anode.anodium.Rpc.ChannelPoint.Builder builderForValue) {
        copyOnWrite();
        instance.addChanPoints(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *Is the set of all channels that are included in this multi-channel backup.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
       */
      public Builder addAllChanPoints(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.ChannelPoint> values) {
        copyOnWrite();
        instance.addAllChanPoints(values);
        return this;
      }
      /**
       * <pre>
       *Is the set of all channels that are included in this multi-channel backup.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
       */
      public Builder clearChanPoints() {
        copyOnWrite();
        instance.clearChanPoints();
        return this;
      }
      /**
       * <pre>
       *Is the set of all channels that are included in this multi-channel backup.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelPoint chan_points = 1;</code>
       */
      public Builder removeChanPoints(int index) {
        copyOnWrite();
        instance.removeChanPoints(index);
        return this;
      }

      /**
       * <pre>
       *A single encrypted blob containing all the static channel backups of the
       *channel listed above. This can be stored as a single file or blob, and
       *safely be replaced with any prior/future versions. When using REST, this
       *field must be encoded as base64.
       * </pre>
       *
       * <code>bytes multi_chan_backup = 2;</code>
       * @return The multiChanBackup.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getMultiChanBackup() {
        return instance.getMultiChanBackup();
      }
      /**
       * <pre>
       *A single encrypted blob containing all the static channel backups of the
       *channel listed above. This can be stored as a single file or blob, and
       *safely be replaced with any prior/future versions. When using REST, this
       *field must be encoded as base64.
       * </pre>
       *
       * <code>bytes multi_chan_backup = 2;</code>
       * @param value The multiChanBackup to set.
       * @return This builder for chaining.
       */
      public Builder setMultiChanBackup(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setMultiChanBackup(value);
        return this;
      }
      /**
       * <pre>
       *A single encrypted blob containing all the static channel backups of the
       *channel listed above. This can be stored as a single file or blob, and
       *safely be replaced with any prior/future versions. When using REST, this
       *field must be encoded as base64.
       * </pre>
       *
       * <code>bytes multi_chan_backup = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearMultiChanBackup() {
        copyOnWrite();
        instance.clearMultiChanBackup();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.MultiChanBackup)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.MultiChanBackup();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "chanPoints_",
              co.anode.anodium.Rpc.ChannelPoint.class,
              "multiChanBackup_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0001\u0000\u0001\u001b\u0002\n" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.MultiChanBackup> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.MultiChanBackup.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.MultiChanBackup>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.MultiChanBackup)
    private static final co.anode.anodium.Rpc.MultiChanBackup DEFAULT_INSTANCE;
    static {
      MultiChanBackup defaultInstance = new MultiChanBackup();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        MultiChanBackup.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.MultiChanBackup getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<MultiChanBackup> PARSER;

    public static com.google.protobuf.Parser<MultiChanBackup> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChanBackupExportRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChanBackupExportRequest)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChanBackupExportRequest}
   */
  public  static final class ChanBackupExportRequest extends
      com.google.protobuf.GeneratedMessageLite<
          ChanBackupExportRequest, ChanBackupExportRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChanBackupExportRequest)
      ChanBackupExportRequestOrBuilder {
    private ChanBackupExportRequest() {
    }
    public static co.anode.anodium.Rpc.ChanBackupExportRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChanBackupExportRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanBackupExportRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChanBackupExportRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanBackupExportRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChanBackupExportRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanBackupExportRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChanBackupExportRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanBackupExportRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChanBackupExportRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanBackupExportRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChanBackupExportRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChanBackupExportRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChanBackupExportRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChanBackupExportRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChanBackupExportRequest)
        co.anode.anodium.Rpc.ChanBackupExportRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChanBackupExportRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChanBackupExportRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChanBackupExportRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChanBackupExportRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChanBackupExportRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChanBackupExportRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChanBackupExportRequest)
    private static final co.anode.anodium.Rpc.ChanBackupExportRequest DEFAULT_INSTANCE;
    static {
      ChanBackupExportRequest defaultInstance = new ChanBackupExportRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChanBackupExportRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChanBackupExportRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChanBackupExportRequest> PARSER;

    public static com.google.protobuf.Parser<ChanBackupExportRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChanBackupSnapshotOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChanBackupSnapshot)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The set of new channels that have been added since the last channel backup
     *snapshot was requested.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelBackups single_chan_backups = 1;</code>
     * @return Whether the singleChanBackups field is set.
     */
    boolean hasSingleChanBackups();
    /**
     * <pre>
     *The set of new channels that have been added since the last channel backup
     *snapshot was requested.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelBackups single_chan_backups = 1;</code>
     * @return The singleChanBackups.
     */
    co.anode.anodium.Rpc.ChannelBackups getSingleChanBackups();

    /**
     * <pre>
     *A multi-channel backup that covers all open channels currently known to
     *lnd.
     * </pre>
     *
     * <code>.co.anode.anodium.MultiChanBackup multi_chan_backup = 2;</code>
     * @return Whether the multiChanBackup field is set.
     */
    boolean hasMultiChanBackup();
    /**
     * <pre>
     *A multi-channel backup that covers all open channels currently known to
     *lnd.
     * </pre>
     *
     * <code>.co.anode.anodium.MultiChanBackup multi_chan_backup = 2;</code>
     * @return The multiChanBackup.
     */
    co.anode.anodium.Rpc.MultiChanBackup getMultiChanBackup();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChanBackupSnapshot}
   */
  public  static final class ChanBackupSnapshot extends
      com.google.protobuf.GeneratedMessageLite<
          ChanBackupSnapshot, ChanBackupSnapshot.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChanBackupSnapshot)
      ChanBackupSnapshotOrBuilder {
    private ChanBackupSnapshot() {
    }
    public static final int SINGLE_CHAN_BACKUPS_FIELD_NUMBER = 1;
    private co.anode.anodium.Rpc.ChannelBackups singleChanBackups_;
    /**
     * <pre>
     *The set of new channels that have been added since the last channel backup
     *snapshot was requested.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelBackups single_chan_backups = 1;</code>
     */
    @java.lang.Override
    public boolean hasSingleChanBackups() {
      return singleChanBackups_ != null;
    }
    /**
     * <pre>
     *The set of new channels that have been added since the last channel backup
     *snapshot was requested.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelBackups single_chan_backups = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelBackups getSingleChanBackups() {
      return singleChanBackups_ == null ? co.anode.anodium.Rpc.ChannelBackups.getDefaultInstance() : singleChanBackups_;
    }
    /**
     * <pre>
     *The set of new channels that have been added since the last channel backup
     *snapshot was requested.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelBackups single_chan_backups = 1;</code>
     */
    private void setSingleChanBackups(co.anode.anodium.Rpc.ChannelBackups value) {
      value.getClass();
  singleChanBackups_ = value;
      
      }
    /**
     * <pre>
     *The set of new channels that have been added since the last channel backup
     *snapshot was requested.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelBackups single_chan_backups = 1;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeSingleChanBackups(co.anode.anodium.Rpc.ChannelBackups value) {
      value.getClass();
  if (singleChanBackups_ != null &&
          singleChanBackups_ != co.anode.anodium.Rpc.ChannelBackups.getDefaultInstance()) {
        singleChanBackups_ =
          co.anode.anodium.Rpc.ChannelBackups.newBuilder(singleChanBackups_).mergeFrom(value).buildPartial();
      } else {
        singleChanBackups_ = value;
      }
      
    }
    /**
     * <pre>
     *The set of new channels that have been added since the last channel backup
     *snapshot was requested.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelBackups single_chan_backups = 1;</code>
     */
    private void clearSingleChanBackups() {  singleChanBackups_ = null;
      
    }

    public static final int MULTI_CHAN_BACKUP_FIELD_NUMBER = 2;
    private co.anode.anodium.Rpc.MultiChanBackup multiChanBackup_;
    /**
     * <pre>
     *A multi-channel backup that covers all open channels currently known to
     *lnd.
     * </pre>
     *
     * <code>.co.anode.anodium.MultiChanBackup multi_chan_backup = 2;</code>
     */
    @java.lang.Override
    public boolean hasMultiChanBackup() {
      return multiChanBackup_ != null;
    }
    /**
     * <pre>
     *A multi-channel backup that covers all open channels currently known to
     *lnd.
     * </pre>
     *
     * <code>.co.anode.anodium.MultiChanBackup multi_chan_backup = 2;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.MultiChanBackup getMultiChanBackup() {
      return multiChanBackup_ == null ? co.anode.anodium.Rpc.MultiChanBackup.getDefaultInstance() : multiChanBackup_;
    }
    /**
     * <pre>
     *A multi-channel backup that covers all open channels currently known to
     *lnd.
     * </pre>
     *
     * <code>.co.anode.anodium.MultiChanBackup multi_chan_backup = 2;</code>
     */
    private void setMultiChanBackup(co.anode.anodium.Rpc.MultiChanBackup value) {
      value.getClass();
  multiChanBackup_ = value;
      
      }
    /**
     * <pre>
     *A multi-channel backup that covers all open channels currently known to
     *lnd.
     * </pre>
     *
     * <code>.co.anode.anodium.MultiChanBackup multi_chan_backup = 2;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeMultiChanBackup(co.anode.anodium.Rpc.MultiChanBackup value) {
      value.getClass();
  if (multiChanBackup_ != null &&
          multiChanBackup_ != co.anode.anodium.Rpc.MultiChanBackup.getDefaultInstance()) {
        multiChanBackup_ =
          co.anode.anodium.Rpc.MultiChanBackup.newBuilder(multiChanBackup_).mergeFrom(value).buildPartial();
      } else {
        multiChanBackup_ = value;
      }
      
    }
    /**
     * <pre>
     *A multi-channel backup that covers all open channels currently known to
     *lnd.
     * </pre>
     *
     * <code>.co.anode.anodium.MultiChanBackup multi_chan_backup = 2;</code>
     */
    private void clearMultiChanBackup() {  multiChanBackup_ = null;
      
    }

    public static co.anode.anodium.Rpc.ChanBackupSnapshot parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChanBackupSnapshot parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanBackupSnapshot parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChanBackupSnapshot parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanBackupSnapshot parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChanBackupSnapshot parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanBackupSnapshot parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChanBackupSnapshot parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanBackupSnapshot parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChanBackupSnapshot parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChanBackupSnapshot parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChanBackupSnapshot parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChanBackupSnapshot prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChanBackupSnapshot}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChanBackupSnapshot, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChanBackupSnapshot)
        co.anode.anodium.Rpc.ChanBackupSnapshotOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChanBackupSnapshot.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The set of new channels that have been added since the last channel backup
       *snapshot was requested.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelBackups single_chan_backups = 1;</code>
       */
      @java.lang.Override
      public boolean hasSingleChanBackups() {
        return instance.hasSingleChanBackups();
      }
      /**
       * <pre>
       *The set of new channels that have been added since the last channel backup
       *snapshot was requested.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelBackups single_chan_backups = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelBackups getSingleChanBackups() {
        return instance.getSingleChanBackups();
      }
      /**
       * <pre>
       *The set of new channels that have been added since the last channel backup
       *snapshot was requested.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelBackups single_chan_backups = 1;</code>
       */
      public Builder setSingleChanBackups(co.anode.anodium.Rpc.ChannelBackups value) {
        copyOnWrite();
        instance.setSingleChanBackups(value);
        return this;
        }
      /**
       * <pre>
       *The set of new channels that have been added since the last channel backup
       *snapshot was requested.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelBackups single_chan_backups = 1;</code>
       */
      public Builder setSingleChanBackups(
          co.anode.anodium.Rpc.ChannelBackups.Builder builderForValue) {
        copyOnWrite();
        instance.setSingleChanBackups(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *The set of new channels that have been added since the last channel backup
       *snapshot was requested.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelBackups single_chan_backups = 1;</code>
       */
      public Builder mergeSingleChanBackups(co.anode.anodium.Rpc.ChannelBackups value) {
        copyOnWrite();
        instance.mergeSingleChanBackups(value);
        return this;
      }
      /**
       * <pre>
       *The set of new channels that have been added since the last channel backup
       *snapshot was requested.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelBackups single_chan_backups = 1;</code>
       */
      public Builder clearSingleChanBackups() {  copyOnWrite();
        instance.clearSingleChanBackups();
        return this;
      }

      /**
       * <pre>
       *A multi-channel backup that covers all open channels currently known to
       *lnd.
       * </pre>
       *
       * <code>.co.anode.anodium.MultiChanBackup multi_chan_backup = 2;</code>
       */
      @java.lang.Override
      public boolean hasMultiChanBackup() {
        return instance.hasMultiChanBackup();
      }
      /**
       * <pre>
       *A multi-channel backup that covers all open channels currently known to
       *lnd.
       * </pre>
       *
       * <code>.co.anode.anodium.MultiChanBackup multi_chan_backup = 2;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.MultiChanBackup getMultiChanBackup() {
        return instance.getMultiChanBackup();
      }
      /**
       * <pre>
       *A multi-channel backup that covers all open channels currently known to
       *lnd.
       * </pre>
       *
       * <code>.co.anode.anodium.MultiChanBackup multi_chan_backup = 2;</code>
       */
      public Builder setMultiChanBackup(co.anode.anodium.Rpc.MultiChanBackup value) {
        copyOnWrite();
        instance.setMultiChanBackup(value);
        return this;
        }
      /**
       * <pre>
       *A multi-channel backup that covers all open channels currently known to
       *lnd.
       * </pre>
       *
       * <code>.co.anode.anodium.MultiChanBackup multi_chan_backup = 2;</code>
       */
      public Builder setMultiChanBackup(
          co.anode.anodium.Rpc.MultiChanBackup.Builder builderForValue) {
        copyOnWrite();
        instance.setMultiChanBackup(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *A multi-channel backup that covers all open channels currently known to
       *lnd.
       * </pre>
       *
       * <code>.co.anode.anodium.MultiChanBackup multi_chan_backup = 2;</code>
       */
      public Builder mergeMultiChanBackup(co.anode.anodium.Rpc.MultiChanBackup value) {
        copyOnWrite();
        instance.mergeMultiChanBackup(value);
        return this;
      }
      /**
       * <pre>
       *A multi-channel backup that covers all open channels currently known to
       *lnd.
       * </pre>
       *
       * <code>.co.anode.anodium.MultiChanBackup multi_chan_backup = 2;</code>
       */
      public Builder clearMultiChanBackup() {  copyOnWrite();
        instance.clearMultiChanBackup();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChanBackupSnapshot)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChanBackupSnapshot();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "singleChanBackups_",
              "multiChanBackup_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\t\u0002\t";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChanBackupSnapshot> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChanBackupSnapshot.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChanBackupSnapshot>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChanBackupSnapshot)
    private static final co.anode.anodium.Rpc.ChanBackupSnapshot DEFAULT_INSTANCE;
    static {
      ChanBackupSnapshot defaultInstance = new ChanBackupSnapshot();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChanBackupSnapshot.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChanBackupSnapshot getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChanBackupSnapshot> PARSER;

    public static com.google.protobuf.Parser<ChanBackupSnapshot> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelBackupsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelBackups)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *A set of single-chan static channel backups.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
     */
    java.util.List<co.anode.anodium.Rpc.ChannelBackup> 
        getChanBackupsList();
    /**
     * <pre>
     *A set of single-chan static channel backups.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
     */
    co.anode.anodium.Rpc.ChannelBackup getChanBackups(int index);
    /**
     * <pre>
     *A set of single-chan static channel backups.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
     */
    int getChanBackupsCount();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChannelBackups}
   */
  public  static final class ChannelBackups extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelBackups, ChannelBackups.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelBackups)
      ChannelBackupsOrBuilder {
    private ChannelBackups() {
      chanBackups_ = emptyProtobufList();
    }
    public static final int CHAN_BACKUPS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.ChannelBackup> chanBackups_;
    /**
     * <pre>
     *A set of single-chan static channel backups.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.ChannelBackup> getChanBackupsList() {
      return chanBackups_;
    }
    /**
     * <pre>
     *A set of single-chan static channel backups.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.ChannelBackupOrBuilder> 
        getChanBackupsOrBuilderList() {
      return chanBackups_;
    }
    /**
     * <pre>
     *A set of single-chan static channel backups.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
     */
    @java.lang.Override
    public int getChanBackupsCount() {
      return chanBackups_.size();
    }
    /**
     * <pre>
     *A set of single-chan static channel backups.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelBackup getChanBackups(int index) {
      return chanBackups_.get(index);
    }
    /**
     * <pre>
     *A set of single-chan static channel backups.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
     */
    public co.anode.anodium.Rpc.ChannelBackupOrBuilder getChanBackupsOrBuilder(
        int index) {
      return chanBackups_.get(index);
    }
    private void ensureChanBackupsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.ChannelBackup> tmp = chanBackups_;
      if (!tmp.isModifiable()) {
        chanBackups_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     *A set of single-chan static channel backups.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
     */
    private void setChanBackups(
        int index, co.anode.anodium.Rpc.ChannelBackup value) {
      value.getClass();
  ensureChanBackupsIsMutable();
      chanBackups_.set(index, value);
    }
    /**
     * <pre>
     *A set of single-chan static channel backups.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
     */
    private void addChanBackups(co.anode.anodium.Rpc.ChannelBackup value) {
      value.getClass();
  ensureChanBackupsIsMutable();
      chanBackups_.add(value);
    }
    /**
     * <pre>
     *A set of single-chan static channel backups.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
     */
    private void addChanBackups(
        int index, co.anode.anodium.Rpc.ChannelBackup value) {
      value.getClass();
  ensureChanBackupsIsMutable();
      chanBackups_.add(index, value);
    }
    /**
     * <pre>
     *A set of single-chan static channel backups.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
     */
    private void addAllChanBackups(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.ChannelBackup> values) {
      ensureChanBackupsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, chanBackups_);
    }
    /**
     * <pre>
     *A set of single-chan static channel backups.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
     */
    private void clearChanBackups() {
      chanBackups_ = emptyProtobufList();
    }
    /**
     * <pre>
     *A set of single-chan static channel backups.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
     */
    private void removeChanBackups(int index) {
      ensureChanBackupsIsMutable();
      chanBackups_.remove(index);
    }

    public static co.anode.anodium.Rpc.ChannelBackups parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelBackups parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBackups parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelBackups parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBackups parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelBackups parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBackups parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelBackups parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBackups parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelBackups parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBackups parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelBackups parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelBackups prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChannelBackups}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelBackups, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelBackups)
        co.anode.anodium.Rpc.ChannelBackupsOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelBackups.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *A set of single-chan static channel backups.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.ChannelBackup> getChanBackupsList() {
        return java.util.Collections.unmodifiableList(
            instance.getChanBackupsList());
      }
      /**
       * <pre>
       *A set of single-chan static channel backups.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
       */
      @java.lang.Override
      public int getChanBackupsCount() {
        return instance.getChanBackupsCount();
      }/**
       * <pre>
       *A set of single-chan static channel backups.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelBackup getChanBackups(int index) {
        return instance.getChanBackups(index);
      }
      /**
       * <pre>
       *A set of single-chan static channel backups.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
       */
      public Builder setChanBackups(
          int index, co.anode.anodium.Rpc.ChannelBackup value) {
        copyOnWrite();
        instance.setChanBackups(index, value);
        return this;
      }
      /**
       * <pre>
       *A set of single-chan static channel backups.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
       */
      public Builder setChanBackups(
          int index, co.anode.anodium.Rpc.ChannelBackup.Builder builderForValue) {
        copyOnWrite();
        instance.setChanBackups(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *A set of single-chan static channel backups.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
       */
      public Builder addChanBackups(co.anode.anodium.Rpc.ChannelBackup value) {
        copyOnWrite();
        instance.addChanBackups(value);
        return this;
      }
      /**
       * <pre>
       *A set of single-chan static channel backups.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
       */
      public Builder addChanBackups(
          int index, co.anode.anodium.Rpc.ChannelBackup value) {
        copyOnWrite();
        instance.addChanBackups(index, value);
        return this;
      }
      /**
       * <pre>
       *A set of single-chan static channel backups.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
       */
      public Builder addChanBackups(
          co.anode.anodium.Rpc.ChannelBackup.Builder builderForValue) {
        copyOnWrite();
        instance.addChanBackups(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *A set of single-chan static channel backups.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
       */
      public Builder addChanBackups(
          int index, co.anode.anodium.Rpc.ChannelBackup.Builder builderForValue) {
        copyOnWrite();
        instance.addChanBackups(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *A set of single-chan static channel backups.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
       */
      public Builder addAllChanBackups(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.ChannelBackup> values) {
        copyOnWrite();
        instance.addAllChanBackups(values);
        return this;
      }
      /**
       * <pre>
       *A set of single-chan static channel backups.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
       */
      public Builder clearChanBackups() {
        copyOnWrite();
        instance.clearChanBackups();
        return this;
      }
      /**
       * <pre>
       *A set of single-chan static channel backups.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.ChannelBackup chan_backups = 1;</code>
       */
      public Builder removeChanBackups(int index) {
        copyOnWrite();
        instance.removeChanBackups(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelBackups)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelBackups();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "chanBackups_",
              co.anode.anodium.Rpc.ChannelBackup.class,
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0000\u0001\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelBackups> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelBackups.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelBackups>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelBackups)
    private static final co.anode.anodium.Rpc.ChannelBackups DEFAULT_INSTANCE;
    static {
      ChannelBackups defaultInstance = new ChannelBackups();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelBackups.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelBackups getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelBackups> PARSER;

    public static com.google.protobuf.Parser<ChannelBackups> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface RestoreChanBackupRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.RestoreChanBackupRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The channels to restore as a list of channel/backup pairs.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelBackups chan_backups = 1;</code>
     * @return Whether the chanBackups field is set.
     */
    boolean hasChanBackups();
    /**
     * <pre>
     *The channels to restore as a list of channel/backup pairs.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelBackups chan_backups = 1;</code>
     * @return The chanBackups.
     */
    co.anode.anodium.Rpc.ChannelBackups getChanBackups();

    /**
     * <pre>
     *The channels to restore in the packed multi backup format. When using
     *REST, this field must be encoded as base64.
     * </pre>
     *
     * <code>bytes multi_chan_backup = 2;</code>
     * @return Whether the multiChanBackup field is set.
     */
    boolean hasMultiChanBackup();
    /**
     * <pre>
     *The channels to restore in the packed multi backup format. When using
     *REST, this field must be encoded as base64.
     * </pre>
     *
     * <code>bytes multi_chan_backup = 2;</code>
     * @return The multiChanBackup.
     */
    com.google.protobuf.ByteString getMultiChanBackup();

    public co.anode.anodium.Rpc.RestoreChanBackupRequest.BackupCase getBackupCase();
  }
  /**
   * Protobuf type {@code co.anode.anodium.RestoreChanBackupRequest}
   */
  public  static final class RestoreChanBackupRequest extends
      com.google.protobuf.GeneratedMessageLite<
          RestoreChanBackupRequest, RestoreChanBackupRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.RestoreChanBackupRequest)
      RestoreChanBackupRequestOrBuilder {
    private RestoreChanBackupRequest() {
    }
    private int backupCase_ = 0;
    private java.lang.Object backup_;
    public enum BackupCase {
      CHAN_BACKUPS(1),
      MULTI_CHAN_BACKUP(2),
      BACKUP_NOT_SET(0);
      private final int value;
      private BackupCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static BackupCase valueOf(int value) {
        return forNumber(value);
      }

      public static BackupCase forNumber(int value) {
        switch (value) {
          case 1: return CHAN_BACKUPS;
          case 2: return MULTI_CHAN_BACKUP;
          case 0: return BACKUP_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    @java.lang.Override
    public BackupCase
    getBackupCase() {
      return BackupCase.forNumber(
          backupCase_);
    }

    private void clearBackup() {
      backupCase_ = 0;
      backup_ = null;
    }

    public static final int CHAN_BACKUPS_FIELD_NUMBER = 1;
    /**
     * <pre>
     *The channels to restore as a list of channel/backup pairs.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelBackups chan_backups = 1;</code>
     */
    @java.lang.Override
    public boolean hasChanBackups() {
      return backupCase_ == 1;
    }
    /**
     * <pre>
     *The channels to restore as a list of channel/backup pairs.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelBackups chan_backups = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelBackups getChanBackups() {
      if (backupCase_ == 1) {
         return (co.anode.anodium.Rpc.ChannelBackups) backup_;
      }
      return co.anode.anodium.Rpc.ChannelBackups.getDefaultInstance();
    }
    /**
     * <pre>
     *The channels to restore as a list of channel/backup pairs.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelBackups chan_backups = 1;</code>
     */
    private void setChanBackups(co.anode.anodium.Rpc.ChannelBackups value) {
      value.getClass();
  backup_ = value;
      backupCase_ = 1;
    }
    /**
     * <pre>
     *The channels to restore as a list of channel/backup pairs.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelBackups chan_backups = 1;</code>
     */
    private void mergeChanBackups(co.anode.anodium.Rpc.ChannelBackups value) {
      value.getClass();
  if (backupCase_ == 1 &&
          backup_ != co.anode.anodium.Rpc.ChannelBackups.getDefaultInstance()) {
        backup_ = co.anode.anodium.Rpc.ChannelBackups.newBuilder((co.anode.anodium.Rpc.ChannelBackups) backup_)
            .mergeFrom(value).buildPartial();
      } else {
        backup_ = value;
      }
      backupCase_ = 1;
    }
    /**
     * <pre>
     *The channels to restore as a list of channel/backup pairs.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelBackups chan_backups = 1;</code>
     */
    private void clearChanBackups() {
      if (backupCase_ == 1) {
        backupCase_ = 0;
        backup_ = null;
      }
    }

    public static final int MULTI_CHAN_BACKUP_FIELD_NUMBER = 2;
    /**
     * <pre>
     *The channels to restore in the packed multi backup format. When using
     *REST, this field must be encoded as base64.
     * </pre>
     *
     * <code>bytes multi_chan_backup = 2;</code>
     * @return Whether the multiChanBackup field is set.
     */
    @java.lang.Override
    public boolean hasMultiChanBackup() {
      return backupCase_ == 2;
    }
    /**
     * <pre>
     *The channels to restore in the packed multi backup format. When using
     *REST, this field must be encoded as base64.
     * </pre>
     *
     * <code>bytes multi_chan_backup = 2;</code>
     * @return The multiChanBackup.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getMultiChanBackup() {
      if (backupCase_ == 2) {
        return (com.google.protobuf.ByteString) backup_;
      }
      return com.google.protobuf.ByteString.EMPTY;
    }
    /**
     * <pre>
     *The channels to restore in the packed multi backup format. When using
     *REST, this field must be encoded as base64.
     * </pre>
     *
     * <code>bytes multi_chan_backup = 2;</code>
     * @param value The multiChanBackup to set.
     */
    private void setMultiChanBackup(com.google.protobuf.ByteString value) {
      value.getClass();
  backupCase_ = 2;
      backup_ = value;
    }
    /**
     * <pre>
     *The channels to restore in the packed multi backup format. When using
     *REST, this field must be encoded as base64.
     * </pre>
     *
     * <code>bytes multi_chan_backup = 2;</code>
     */
    private void clearMultiChanBackup() {
      if (backupCase_ == 2) {
        backupCase_ = 0;
        backup_ = null;
      }
    }

    public static co.anode.anodium.Rpc.RestoreChanBackupRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.RestoreChanBackupRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RestoreChanBackupRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.RestoreChanBackupRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RestoreChanBackupRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.RestoreChanBackupRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RestoreChanBackupRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.RestoreChanBackupRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RestoreChanBackupRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.RestoreChanBackupRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RestoreChanBackupRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.RestoreChanBackupRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.RestoreChanBackupRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.RestoreChanBackupRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.RestoreChanBackupRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.RestoreChanBackupRequest)
        co.anode.anodium.Rpc.RestoreChanBackupRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.RestoreChanBackupRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }

      @java.lang.Override
      public BackupCase
          getBackupCase() {
        return instance.getBackupCase();
      }

      public Builder clearBackup() {
        copyOnWrite();
        instance.clearBackup();
        return this;
      }


      /**
       * <pre>
       *The channels to restore as a list of channel/backup pairs.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelBackups chan_backups = 1;</code>
       */
      @java.lang.Override
      public boolean hasChanBackups() {
        return instance.hasChanBackups();
      }
      /**
       * <pre>
       *The channels to restore as a list of channel/backup pairs.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelBackups chan_backups = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelBackups getChanBackups() {
        return instance.getChanBackups();
      }
      /**
       * <pre>
       *The channels to restore as a list of channel/backup pairs.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelBackups chan_backups = 1;</code>
       */
      public Builder setChanBackups(co.anode.anodium.Rpc.ChannelBackups value) {
        copyOnWrite();
        instance.setChanBackups(value);
        return this;
      }
      /**
       * <pre>
       *The channels to restore as a list of channel/backup pairs.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelBackups chan_backups = 1;</code>
       */
      public Builder setChanBackups(
          co.anode.anodium.Rpc.ChannelBackups.Builder builderForValue) {
        copyOnWrite();
        instance.setChanBackups(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       *The channels to restore as a list of channel/backup pairs.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelBackups chan_backups = 1;</code>
       */
      public Builder mergeChanBackups(co.anode.anodium.Rpc.ChannelBackups value) {
        copyOnWrite();
        instance.mergeChanBackups(value);
        return this;
      }
      /**
       * <pre>
       *The channels to restore as a list of channel/backup pairs.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelBackups chan_backups = 1;</code>
       */
      public Builder clearChanBackups() {
        copyOnWrite();
        instance.clearChanBackups();
        return this;
      }

      /**
       * <pre>
       *The channels to restore in the packed multi backup format. When using
       *REST, this field must be encoded as base64.
       * </pre>
       *
       * <code>bytes multi_chan_backup = 2;</code>
       * @return Whether the multiChanBackup field is set.
       */
      @java.lang.Override
      public boolean hasMultiChanBackup() {
        return instance.hasMultiChanBackup();
      }
      /**
       * <pre>
       *The channels to restore in the packed multi backup format. When using
       *REST, this field must be encoded as base64.
       * </pre>
       *
       * <code>bytes multi_chan_backup = 2;</code>
       * @return The multiChanBackup.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getMultiChanBackup() {
        return instance.getMultiChanBackup();
      }
      /**
       * <pre>
       *The channels to restore in the packed multi backup format. When using
       *REST, this field must be encoded as base64.
       * </pre>
       *
       * <code>bytes multi_chan_backup = 2;</code>
       * @param value The multiChanBackup to set.
       * @return This builder for chaining.
       */
      public Builder setMultiChanBackup(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setMultiChanBackup(value);
        return this;
      }
      /**
       * <pre>
       *The channels to restore in the packed multi backup format. When using
       *REST, this field must be encoded as base64.
       * </pre>
       *
       * <code>bytes multi_chan_backup = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearMultiChanBackup() {
        copyOnWrite();
        instance.clearMultiChanBackup();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.RestoreChanBackupRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.RestoreChanBackupRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "backup_",
              "backupCase_",
              co.anode.anodium.Rpc.ChannelBackups.class,
            };
            java.lang.String info =
                "\u0000\u0002\u0001\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001<\u0000\u0002=" +
                "\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.RestoreChanBackupRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.RestoreChanBackupRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.RestoreChanBackupRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.RestoreChanBackupRequest)
    private static final co.anode.anodium.Rpc.RestoreChanBackupRequest DEFAULT_INSTANCE;
    static {
      RestoreChanBackupRequest defaultInstance = new RestoreChanBackupRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        RestoreChanBackupRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.RestoreChanBackupRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<RestoreChanBackupRequest> PARSER;

    public static com.google.protobuf.Parser<RestoreChanBackupRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface RestoreBackupResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.RestoreBackupResponse)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.RestoreBackupResponse}
   */
  public  static final class RestoreBackupResponse extends
      com.google.protobuf.GeneratedMessageLite<
          RestoreBackupResponse, RestoreBackupResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.RestoreBackupResponse)
      RestoreBackupResponseOrBuilder {
    private RestoreBackupResponse() {
    }
    public static co.anode.anodium.Rpc.RestoreBackupResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.RestoreBackupResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RestoreBackupResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.RestoreBackupResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RestoreBackupResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.RestoreBackupResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RestoreBackupResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.RestoreBackupResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RestoreBackupResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.RestoreBackupResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.RestoreBackupResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.RestoreBackupResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.RestoreBackupResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.RestoreBackupResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.RestoreBackupResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.RestoreBackupResponse)
        co.anode.anodium.Rpc.RestoreBackupResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.RestoreBackupResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.RestoreBackupResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.RestoreBackupResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.RestoreBackupResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.RestoreBackupResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.RestoreBackupResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.RestoreBackupResponse)
    private static final co.anode.anodium.Rpc.RestoreBackupResponse DEFAULT_INSTANCE;
    static {
      RestoreBackupResponse defaultInstance = new RestoreBackupResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        RestoreBackupResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.RestoreBackupResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<RestoreBackupResponse> PARSER;

    public static com.google.protobuf.Parser<RestoreBackupResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelBackupSubscriptionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelBackupSubscription)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChannelBackupSubscription}
   */
  public  static final class ChannelBackupSubscription extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelBackupSubscription, ChannelBackupSubscription.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelBackupSubscription)
      ChannelBackupSubscriptionOrBuilder {
    private ChannelBackupSubscription() {
    }
    public static co.anode.anodium.Rpc.ChannelBackupSubscription parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelBackupSubscription parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBackupSubscription parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelBackupSubscription parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBackupSubscription parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelBackupSubscription parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBackupSubscription parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelBackupSubscription parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBackupSubscription parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelBackupSubscription parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelBackupSubscription parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelBackupSubscription parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelBackupSubscription prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChannelBackupSubscription}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelBackupSubscription, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelBackupSubscription)
        co.anode.anodium.Rpc.ChannelBackupSubscriptionOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelBackupSubscription.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelBackupSubscription)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelBackupSubscription();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelBackupSubscription> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelBackupSubscription.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelBackupSubscription>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelBackupSubscription)
    private static final co.anode.anodium.Rpc.ChannelBackupSubscription DEFAULT_INSTANCE;
    static {
      ChannelBackupSubscription defaultInstance = new ChannelBackupSubscription();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelBackupSubscription.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelBackupSubscription getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelBackupSubscription> PARSER;

    public static com.google.protobuf.Parser<ChannelBackupSubscription> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface VerifyChanBackupResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.VerifyChanBackupResponse)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.VerifyChanBackupResponse}
   */
  public  static final class VerifyChanBackupResponse extends
      com.google.protobuf.GeneratedMessageLite<
          VerifyChanBackupResponse, VerifyChanBackupResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.VerifyChanBackupResponse)
      VerifyChanBackupResponseOrBuilder {
    private VerifyChanBackupResponse() {
    }
    public static co.anode.anodium.Rpc.VerifyChanBackupResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.VerifyChanBackupResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.VerifyChanBackupResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.VerifyChanBackupResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.VerifyChanBackupResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.VerifyChanBackupResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.VerifyChanBackupResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.VerifyChanBackupResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.VerifyChanBackupResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.VerifyChanBackupResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.VerifyChanBackupResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.VerifyChanBackupResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.VerifyChanBackupResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.VerifyChanBackupResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.VerifyChanBackupResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.VerifyChanBackupResponse)
        co.anode.anodium.Rpc.VerifyChanBackupResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.VerifyChanBackupResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.VerifyChanBackupResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.VerifyChanBackupResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.VerifyChanBackupResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.VerifyChanBackupResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.VerifyChanBackupResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.VerifyChanBackupResponse)
    private static final co.anode.anodium.Rpc.VerifyChanBackupResponse DEFAULT_INSTANCE;
    static {
      VerifyChanBackupResponse defaultInstance = new VerifyChanBackupResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        VerifyChanBackupResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.VerifyChanBackupResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<VerifyChanBackupResponse> PARSER;

    public static com.google.protobuf.Parser<VerifyChanBackupResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface MacaroonPermissionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.MacaroonPermission)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The entity a permission grants access to.
     * </pre>
     *
     * <code>string entity = 1;</code>
     * @return The entity.
     */
    java.lang.String getEntity();
    /**
     * <pre>
     * The entity a permission grants access to.
     * </pre>
     *
     * <code>string entity = 1;</code>
     * @return The bytes for entity.
     */
    com.google.protobuf.ByteString
        getEntityBytes();

    /**
     * <pre>
     * The action that is granted.
     * </pre>
     *
     * <code>string action = 2;</code>
     * @return The action.
     */
    java.lang.String getAction();
    /**
     * <pre>
     * The action that is granted.
     * </pre>
     *
     * <code>string action = 2;</code>
     * @return The bytes for action.
     */
    com.google.protobuf.ByteString
        getActionBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.MacaroonPermission}
   */
  public  static final class MacaroonPermission extends
      com.google.protobuf.GeneratedMessageLite<
          MacaroonPermission, MacaroonPermission.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.MacaroonPermission)
      MacaroonPermissionOrBuilder {
    private MacaroonPermission() {
      entity_ = "";
      action_ = "";
    }
    public static final int ENTITY_FIELD_NUMBER = 1;
    private java.lang.String entity_;
    /**
     * <pre>
     * The entity a permission grants access to.
     * </pre>
     *
     * <code>string entity = 1;</code>
     * @return The entity.
     */
    @java.lang.Override
    public java.lang.String getEntity() {
      return entity_;
    }
    /**
     * <pre>
     * The entity a permission grants access to.
     * </pre>
     *
     * <code>string entity = 1;</code>
     * @return The bytes for entity.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getEntityBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(entity_);
    }
    /**
     * <pre>
     * The entity a permission grants access to.
     * </pre>
     *
     * <code>string entity = 1;</code>
     * @param value The entity to set.
     */
    private void setEntity(
        java.lang.String value) {
      value.getClass();
  
      entity_ = value;
    }
    /**
     * <pre>
     * The entity a permission grants access to.
     * </pre>
     *
     * <code>string entity = 1;</code>
     */
    private void clearEntity() {
      
      entity_ = getDefaultInstance().getEntity();
    }
    /**
     * <pre>
     * The entity a permission grants access to.
     * </pre>
     *
     * <code>string entity = 1;</code>
     * @param value The bytes for entity to set.
     */
    private void setEntityBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      entity_ = value.toStringUtf8();
      
    }

    public static final int ACTION_FIELD_NUMBER = 2;
    private java.lang.String action_;
    /**
     * <pre>
     * The action that is granted.
     * </pre>
     *
     * <code>string action = 2;</code>
     * @return The action.
     */
    @java.lang.Override
    public java.lang.String getAction() {
      return action_;
    }
    /**
     * <pre>
     * The action that is granted.
     * </pre>
     *
     * <code>string action = 2;</code>
     * @return The bytes for action.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getActionBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(action_);
    }
    /**
     * <pre>
     * The action that is granted.
     * </pre>
     *
     * <code>string action = 2;</code>
     * @param value The action to set.
     */
    private void setAction(
        java.lang.String value) {
      value.getClass();
  
      action_ = value;
    }
    /**
     * <pre>
     * The action that is granted.
     * </pre>
     *
     * <code>string action = 2;</code>
     */
    private void clearAction() {
      
      action_ = getDefaultInstance().getAction();
    }
    /**
     * <pre>
     * The action that is granted.
     * </pre>
     *
     * <code>string action = 2;</code>
     * @param value The bytes for action to set.
     */
    private void setActionBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      action_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.MacaroonPermission parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.MacaroonPermission parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MacaroonPermission parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.MacaroonPermission parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MacaroonPermission parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.MacaroonPermission parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MacaroonPermission parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.MacaroonPermission parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MacaroonPermission parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.MacaroonPermission parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MacaroonPermission parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.MacaroonPermission parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.MacaroonPermission prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.MacaroonPermission}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.MacaroonPermission, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.MacaroonPermission)
        co.anode.anodium.Rpc.MacaroonPermissionOrBuilder {
      // Construct using co.anode.anodium.Rpc.MacaroonPermission.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The entity a permission grants access to.
       * </pre>
       *
       * <code>string entity = 1;</code>
       * @return The entity.
       */
      @java.lang.Override
      public java.lang.String getEntity() {
        return instance.getEntity();
      }
      /**
       * <pre>
       * The entity a permission grants access to.
       * </pre>
       *
       * <code>string entity = 1;</code>
       * @return The bytes for entity.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getEntityBytes() {
        return instance.getEntityBytes();
      }
      /**
       * <pre>
       * The entity a permission grants access to.
       * </pre>
       *
       * <code>string entity = 1;</code>
       * @param value The entity to set.
       * @return This builder for chaining.
       */
      public Builder setEntity(
          java.lang.String value) {
        copyOnWrite();
        instance.setEntity(value);
        return this;
      }
      /**
       * <pre>
       * The entity a permission grants access to.
       * </pre>
       *
       * <code>string entity = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearEntity() {
        copyOnWrite();
        instance.clearEntity();
        return this;
      }
      /**
       * <pre>
       * The entity a permission grants access to.
       * </pre>
       *
       * <code>string entity = 1;</code>
       * @param value The bytes for entity to set.
       * @return This builder for chaining.
       */
      public Builder setEntityBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setEntityBytes(value);
        return this;
      }

      /**
       * <pre>
       * The action that is granted.
       * </pre>
       *
       * <code>string action = 2;</code>
       * @return The action.
       */
      @java.lang.Override
      public java.lang.String getAction() {
        return instance.getAction();
      }
      /**
       * <pre>
       * The action that is granted.
       * </pre>
       *
       * <code>string action = 2;</code>
       * @return The bytes for action.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getActionBytes() {
        return instance.getActionBytes();
      }
      /**
       * <pre>
       * The action that is granted.
       * </pre>
       *
       * <code>string action = 2;</code>
       * @param value The action to set.
       * @return This builder for chaining.
       */
      public Builder setAction(
          java.lang.String value) {
        copyOnWrite();
        instance.setAction(value);
        return this;
      }
      /**
       * <pre>
       * The action that is granted.
       * </pre>
       *
       * <code>string action = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAction() {
        copyOnWrite();
        instance.clearAction();
        return this;
      }
      /**
       * <pre>
       * The action that is granted.
       * </pre>
       *
       * <code>string action = 2;</code>
       * @param value The bytes for action to set.
       * @return This builder for chaining.
       */
      public Builder setActionBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setActionBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.MacaroonPermission)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.MacaroonPermission();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "entity_",
              "action_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0208\u0002\u0208" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.MacaroonPermission> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.MacaroonPermission.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.MacaroonPermission>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.MacaroonPermission)
    private static final co.anode.anodium.Rpc.MacaroonPermission DEFAULT_INSTANCE;
    static {
      MacaroonPermission defaultInstance = new MacaroonPermission();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        MacaroonPermission.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.MacaroonPermission getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<MacaroonPermission> PARSER;

    public static com.google.protobuf.Parser<MacaroonPermission> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface BakeMacaroonRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.BakeMacaroonRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The list of permissions the new macaroon should grant.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    java.util.List<co.anode.anodium.Rpc.MacaroonPermission> 
        getPermissionsList();
    /**
     * <pre>
     * The list of permissions the new macaroon should grant.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    co.anode.anodium.Rpc.MacaroonPermission getPermissions(int index);
    /**
     * <pre>
     * The list of permissions the new macaroon should grant.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    int getPermissionsCount();

    /**
     * <pre>
     * The root key ID used to create the macaroon, must be a positive integer.
     * </pre>
     *
     * <code>uint64 root_key_id = 2;</code>
     * @return The rootKeyId.
     */
    long getRootKeyId();
  }
  /**
   * Protobuf type {@code co.anode.anodium.BakeMacaroonRequest}
   */
  public  static final class BakeMacaroonRequest extends
      com.google.protobuf.GeneratedMessageLite<
          BakeMacaroonRequest, BakeMacaroonRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.BakeMacaroonRequest)
      BakeMacaroonRequestOrBuilder {
    private BakeMacaroonRequest() {
      permissions_ = emptyProtobufList();
    }
    public static final int PERMISSIONS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.MacaroonPermission> permissions_;
    /**
     * <pre>
     * The list of permissions the new macaroon should grant.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.MacaroonPermission> getPermissionsList() {
      return permissions_;
    }
    /**
     * <pre>
     * The list of permissions the new macaroon should grant.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.MacaroonPermissionOrBuilder> 
        getPermissionsOrBuilderList() {
      return permissions_;
    }
    /**
     * <pre>
     * The list of permissions the new macaroon should grant.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    @java.lang.Override
    public int getPermissionsCount() {
      return permissions_.size();
    }
    /**
     * <pre>
     * The list of permissions the new macaroon should grant.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.MacaroonPermission getPermissions(int index) {
      return permissions_.get(index);
    }
    /**
     * <pre>
     * The list of permissions the new macaroon should grant.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    public co.anode.anodium.Rpc.MacaroonPermissionOrBuilder getPermissionsOrBuilder(
        int index) {
      return permissions_.get(index);
    }
    private void ensurePermissionsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.MacaroonPermission> tmp = permissions_;
      if (!tmp.isModifiable()) {
        permissions_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * The list of permissions the new macaroon should grant.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    private void setPermissions(
        int index, co.anode.anodium.Rpc.MacaroonPermission value) {
      value.getClass();
  ensurePermissionsIsMutable();
      permissions_.set(index, value);
    }
    /**
     * <pre>
     * The list of permissions the new macaroon should grant.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    private void addPermissions(co.anode.anodium.Rpc.MacaroonPermission value) {
      value.getClass();
  ensurePermissionsIsMutable();
      permissions_.add(value);
    }
    /**
     * <pre>
     * The list of permissions the new macaroon should grant.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    private void addPermissions(
        int index, co.anode.anodium.Rpc.MacaroonPermission value) {
      value.getClass();
  ensurePermissionsIsMutable();
      permissions_.add(index, value);
    }
    /**
     * <pre>
     * The list of permissions the new macaroon should grant.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    private void addAllPermissions(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.MacaroonPermission> values) {
      ensurePermissionsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, permissions_);
    }
    /**
     * <pre>
     * The list of permissions the new macaroon should grant.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    private void clearPermissions() {
      permissions_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The list of permissions the new macaroon should grant.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    private void removePermissions(int index) {
      ensurePermissionsIsMutable();
      permissions_.remove(index);
    }

    public static final int ROOT_KEY_ID_FIELD_NUMBER = 2;
    private long rootKeyId_;
    /**
     * <pre>
     * The root key ID used to create the macaroon, must be a positive integer.
     * </pre>
     *
     * <code>uint64 root_key_id = 2;</code>
     * @return The rootKeyId.
     */
    @java.lang.Override
    public long getRootKeyId() {
      return rootKeyId_;
    }
    /**
     * <pre>
     * The root key ID used to create the macaroon, must be a positive integer.
     * </pre>
     *
     * <code>uint64 root_key_id = 2;</code>
     * @param value The rootKeyId to set.
     */
    private void setRootKeyId(long value) {
      
      rootKeyId_ = value;
    }
    /**
     * <pre>
     * The root key ID used to create the macaroon, must be a positive integer.
     * </pre>
     *
     * <code>uint64 root_key_id = 2;</code>
     */
    private void clearRootKeyId() {
      
      rootKeyId_ = 0L;
    }

    public static co.anode.anodium.Rpc.BakeMacaroonRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.BakeMacaroonRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.BakeMacaroonRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.BakeMacaroonRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.BakeMacaroonRequest)
        co.anode.anodium.Rpc.BakeMacaroonRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.BakeMacaroonRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The list of permissions the new macaroon should grant.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.MacaroonPermission> getPermissionsList() {
        return java.util.Collections.unmodifiableList(
            instance.getPermissionsList());
      }
      /**
       * <pre>
       * The list of permissions the new macaroon should grant.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      @java.lang.Override
      public int getPermissionsCount() {
        return instance.getPermissionsCount();
      }/**
       * <pre>
       * The list of permissions the new macaroon should grant.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.MacaroonPermission getPermissions(int index) {
        return instance.getPermissions(index);
      }
      /**
       * <pre>
       * The list of permissions the new macaroon should grant.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      public Builder setPermissions(
          int index, co.anode.anodium.Rpc.MacaroonPermission value) {
        copyOnWrite();
        instance.setPermissions(index, value);
        return this;
      }
      /**
       * <pre>
       * The list of permissions the new macaroon should grant.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      public Builder setPermissions(
          int index, co.anode.anodium.Rpc.MacaroonPermission.Builder builderForValue) {
        copyOnWrite();
        instance.setPermissions(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of permissions the new macaroon should grant.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      public Builder addPermissions(co.anode.anodium.Rpc.MacaroonPermission value) {
        copyOnWrite();
        instance.addPermissions(value);
        return this;
      }
      /**
       * <pre>
       * The list of permissions the new macaroon should grant.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      public Builder addPermissions(
          int index, co.anode.anodium.Rpc.MacaroonPermission value) {
        copyOnWrite();
        instance.addPermissions(index, value);
        return this;
      }
      /**
       * <pre>
       * The list of permissions the new macaroon should grant.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      public Builder addPermissions(
          co.anode.anodium.Rpc.MacaroonPermission.Builder builderForValue) {
        copyOnWrite();
        instance.addPermissions(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of permissions the new macaroon should grant.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      public Builder addPermissions(
          int index, co.anode.anodium.Rpc.MacaroonPermission.Builder builderForValue) {
        copyOnWrite();
        instance.addPermissions(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The list of permissions the new macaroon should grant.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      public Builder addAllPermissions(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.MacaroonPermission> values) {
        copyOnWrite();
        instance.addAllPermissions(values);
        return this;
      }
      /**
       * <pre>
       * The list of permissions the new macaroon should grant.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      public Builder clearPermissions() {
        copyOnWrite();
        instance.clearPermissions();
        return this;
      }
      /**
       * <pre>
       * The list of permissions the new macaroon should grant.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      public Builder removePermissions(int index) {
        copyOnWrite();
        instance.removePermissions(index);
        return this;
      }

      /**
       * <pre>
       * The root key ID used to create the macaroon, must be a positive integer.
       * </pre>
       *
       * <code>uint64 root_key_id = 2;</code>
       * @return The rootKeyId.
       */
      @java.lang.Override
      public long getRootKeyId() {
        return instance.getRootKeyId();
      }
      /**
       * <pre>
       * The root key ID used to create the macaroon, must be a positive integer.
       * </pre>
       *
       * <code>uint64 root_key_id = 2;</code>
       * @param value The rootKeyId to set.
       * @return This builder for chaining.
       */
      public Builder setRootKeyId(long value) {
        copyOnWrite();
        instance.setRootKeyId(value);
        return this;
      }
      /**
       * <pre>
       * The root key ID used to create the macaroon, must be a positive integer.
       * </pre>
       *
       * <code>uint64 root_key_id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearRootKeyId() {
        copyOnWrite();
        instance.clearRootKeyId();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.BakeMacaroonRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.BakeMacaroonRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "permissions_",
              co.anode.anodium.Rpc.MacaroonPermission.class,
              "rootKeyId_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0001\u0000\u0001\u001b\u0002\u0003" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.BakeMacaroonRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.BakeMacaroonRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.BakeMacaroonRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.BakeMacaroonRequest)
    private static final co.anode.anodium.Rpc.BakeMacaroonRequest DEFAULT_INSTANCE;
    static {
      BakeMacaroonRequest defaultInstance = new BakeMacaroonRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        BakeMacaroonRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.BakeMacaroonRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<BakeMacaroonRequest> PARSER;

    public static com.google.protobuf.Parser<BakeMacaroonRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface BakeMacaroonResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.BakeMacaroonResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The hex encoded macaroon, serialized in binary format.
     * </pre>
     *
     * <code>string macaroon = 1;</code>
     * @return The macaroon.
     */
    java.lang.String getMacaroon();
    /**
     * <pre>
     * The hex encoded macaroon, serialized in binary format.
     * </pre>
     *
     * <code>string macaroon = 1;</code>
     * @return The bytes for macaroon.
     */
    com.google.protobuf.ByteString
        getMacaroonBytes();
  }
  /**
   * Protobuf type {@code co.anode.anodium.BakeMacaroonResponse}
   */
  public  static final class BakeMacaroonResponse extends
      com.google.protobuf.GeneratedMessageLite<
          BakeMacaroonResponse, BakeMacaroonResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.BakeMacaroonResponse)
      BakeMacaroonResponseOrBuilder {
    private BakeMacaroonResponse() {
      macaroon_ = "";
    }
    public static final int MACAROON_FIELD_NUMBER = 1;
    private java.lang.String macaroon_;
    /**
     * <pre>
     * The hex encoded macaroon, serialized in binary format.
     * </pre>
     *
     * <code>string macaroon = 1;</code>
     * @return The macaroon.
     */
    @java.lang.Override
    public java.lang.String getMacaroon() {
      return macaroon_;
    }
    /**
     * <pre>
     * The hex encoded macaroon, serialized in binary format.
     * </pre>
     *
     * <code>string macaroon = 1;</code>
     * @return The bytes for macaroon.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMacaroonBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(macaroon_);
    }
    /**
     * <pre>
     * The hex encoded macaroon, serialized in binary format.
     * </pre>
     *
     * <code>string macaroon = 1;</code>
     * @param value The macaroon to set.
     */
    private void setMacaroon(
        java.lang.String value) {
      value.getClass();
  
      macaroon_ = value;
    }
    /**
     * <pre>
     * The hex encoded macaroon, serialized in binary format.
     * </pre>
     *
     * <code>string macaroon = 1;</code>
     */
    private void clearMacaroon() {
      
      macaroon_ = getDefaultInstance().getMacaroon();
    }
    /**
     * <pre>
     * The hex encoded macaroon, serialized in binary format.
     * </pre>
     *
     * <code>string macaroon = 1;</code>
     * @param value The bytes for macaroon to set.
     */
    private void setMacaroonBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      macaroon_ = value.toStringUtf8();
      
    }

    public static co.anode.anodium.Rpc.BakeMacaroonResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.BakeMacaroonResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.BakeMacaroonResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.BakeMacaroonResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.BakeMacaroonResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.BakeMacaroonResponse)
        co.anode.anodium.Rpc.BakeMacaroonResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.BakeMacaroonResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The hex encoded macaroon, serialized in binary format.
       * </pre>
       *
       * <code>string macaroon = 1;</code>
       * @return The macaroon.
       */
      @java.lang.Override
      public java.lang.String getMacaroon() {
        return instance.getMacaroon();
      }
      /**
       * <pre>
       * The hex encoded macaroon, serialized in binary format.
       * </pre>
       *
       * <code>string macaroon = 1;</code>
       * @return The bytes for macaroon.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getMacaroonBytes() {
        return instance.getMacaroonBytes();
      }
      /**
       * <pre>
       * The hex encoded macaroon, serialized in binary format.
       * </pre>
       *
       * <code>string macaroon = 1;</code>
       * @param value The macaroon to set.
       * @return This builder for chaining.
       */
      public Builder setMacaroon(
          java.lang.String value) {
        copyOnWrite();
        instance.setMacaroon(value);
        return this;
      }
      /**
       * <pre>
       * The hex encoded macaroon, serialized in binary format.
       * </pre>
       *
       * <code>string macaroon = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearMacaroon() {
        copyOnWrite();
        instance.clearMacaroon();
        return this;
      }
      /**
       * <pre>
       * The hex encoded macaroon, serialized in binary format.
       * </pre>
       *
       * <code>string macaroon = 1;</code>
       * @param value The bytes for macaroon to set.
       * @return This builder for chaining.
       */
      public Builder setMacaroonBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setMacaroonBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.BakeMacaroonResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.BakeMacaroonResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "macaroon_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u0208";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.BakeMacaroonResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.BakeMacaroonResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.BakeMacaroonResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.BakeMacaroonResponse)
    private static final co.anode.anodium.Rpc.BakeMacaroonResponse DEFAULT_INSTANCE;
    static {
      BakeMacaroonResponse defaultInstance = new BakeMacaroonResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        BakeMacaroonResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.BakeMacaroonResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<BakeMacaroonResponse> PARSER;

    public static com.google.protobuf.Parser<BakeMacaroonResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ListMacaroonIDsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ListMacaroonIDsRequest)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.ListMacaroonIDsRequest}
   */
  public  static final class ListMacaroonIDsRequest extends
      com.google.protobuf.GeneratedMessageLite<
          ListMacaroonIDsRequest, ListMacaroonIDsRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ListMacaroonIDsRequest)
      ListMacaroonIDsRequestOrBuilder {
    private ListMacaroonIDsRequest() {
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ListMacaroonIDsRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ListMacaroonIDsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ListMacaroonIDsRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ListMacaroonIDsRequest)
        co.anode.anodium.Rpc.ListMacaroonIDsRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.ListMacaroonIDsRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ListMacaroonIDsRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ListMacaroonIDsRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ListMacaroonIDsRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ListMacaroonIDsRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ListMacaroonIDsRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ListMacaroonIDsRequest)
    private static final co.anode.anodium.Rpc.ListMacaroonIDsRequest DEFAULT_INSTANCE;
    static {
      ListMacaroonIDsRequest defaultInstance = new ListMacaroonIDsRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ListMacaroonIDsRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ListMacaroonIDsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ListMacaroonIDsRequest> PARSER;

    public static com.google.protobuf.Parser<ListMacaroonIDsRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ListMacaroonIDsResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ListMacaroonIDsResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The list of root key IDs that are in use.
     * </pre>
     *
     * <code>repeated uint64 root_key_ids = 1;</code>
     * @return A list containing the rootKeyIds.
     */
    java.util.List<java.lang.Long> getRootKeyIdsList();
    /**
     * <pre>
     * The list of root key IDs that are in use.
     * </pre>
     *
     * <code>repeated uint64 root_key_ids = 1;</code>
     * @return The count of rootKeyIds.
     */
    int getRootKeyIdsCount();
    /**
     * <pre>
     * The list of root key IDs that are in use.
     * </pre>
     *
     * <code>repeated uint64 root_key_ids = 1;</code>
     * @param index The index of the element to return.
     * @return The rootKeyIds at the given index.
     */
    long getRootKeyIds(int index);
  }
  /**
   * Protobuf type {@code co.anode.anodium.ListMacaroonIDsResponse}
   */
  public  static final class ListMacaroonIDsResponse extends
      com.google.protobuf.GeneratedMessageLite<
          ListMacaroonIDsResponse, ListMacaroonIDsResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ListMacaroonIDsResponse)
      ListMacaroonIDsResponseOrBuilder {
    private ListMacaroonIDsResponse() {
      rootKeyIds_ = emptyLongList();
    }
    public static final int ROOT_KEY_IDS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.LongList rootKeyIds_;
    /**
     * <pre>
     * The list of root key IDs that are in use.
     * </pre>
     *
     * <code>repeated uint64 root_key_ids = 1;</code>
     * @return A list containing the rootKeyIds.
     */
    @java.lang.Override
    public java.util.List<java.lang.Long>
        getRootKeyIdsList() {
      return rootKeyIds_;
    }
    /**
     * <pre>
     * The list of root key IDs that are in use.
     * </pre>
     *
     * <code>repeated uint64 root_key_ids = 1;</code>
     * @return The count of rootKeyIds.
     */
    @java.lang.Override
    public int getRootKeyIdsCount() {
      return rootKeyIds_.size();
    }
    /**
     * <pre>
     * The list of root key IDs that are in use.
     * </pre>
     *
     * <code>repeated uint64 root_key_ids = 1;</code>
     * @param index The index of the element to return.
     * @return The rootKeyIds at the given index.
     */
    @java.lang.Override
    public long getRootKeyIds(int index) {
      return rootKeyIds_.getLong(index);
    }
    private int rootKeyIdsMemoizedSerializedSize = -1;
    private void ensureRootKeyIdsIsMutable() {
      com.google.protobuf.Internal.LongList tmp = rootKeyIds_;
      if (!tmp.isModifiable()) {
        rootKeyIds_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * The list of root key IDs that are in use.
     * </pre>
     *
     * <code>repeated uint64 root_key_ids = 1;</code>
     * @param index The index to set the value at.
     * @param value The rootKeyIds to set.
     */
    private void setRootKeyIds(
        int index, long value) {
      ensureRootKeyIdsIsMutable();
      rootKeyIds_.setLong(index, value);
    }
    /**
     * <pre>
     * The list of root key IDs that are in use.
     * </pre>
     *
     * <code>repeated uint64 root_key_ids = 1;</code>
     * @param value The rootKeyIds to add.
     */
    private void addRootKeyIds(long value) {
      ensureRootKeyIdsIsMutable();
      rootKeyIds_.addLong(value);
    }
    /**
     * <pre>
     * The list of root key IDs that are in use.
     * </pre>
     *
     * <code>repeated uint64 root_key_ids = 1;</code>
     * @param values The rootKeyIds to add.
     */
    private void addAllRootKeyIds(
        java.lang.Iterable<? extends java.lang.Long> values) {
      ensureRootKeyIdsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, rootKeyIds_);
    }
    /**
     * <pre>
     * The list of root key IDs that are in use.
     * </pre>
     *
     * <code>repeated uint64 root_key_ids = 1;</code>
     */
    private void clearRootKeyIds() {
      rootKeyIds_ = emptyLongList();
    }

    public static co.anode.anodium.Rpc.ListMacaroonIDsResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListMacaroonIDsResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ListMacaroonIDsResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ListMacaroonIDsResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ListMacaroonIDsResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ListMacaroonIDsResponse)
        co.anode.anodium.Rpc.ListMacaroonIDsResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.ListMacaroonIDsResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The list of root key IDs that are in use.
       * </pre>
       *
       * <code>repeated uint64 root_key_ids = 1;</code>
       * @return A list containing the rootKeyIds.
       */
      @java.lang.Override
      public java.util.List<java.lang.Long>
          getRootKeyIdsList() {
        return java.util.Collections.unmodifiableList(
            instance.getRootKeyIdsList());
      }
      /**
       * <pre>
       * The list of root key IDs that are in use.
       * </pre>
       *
       * <code>repeated uint64 root_key_ids = 1;</code>
       * @return The count of rootKeyIds.
       */
      @java.lang.Override
      public int getRootKeyIdsCount() {
        return instance.getRootKeyIdsCount();
      }
      /**
       * <pre>
       * The list of root key IDs that are in use.
       * </pre>
       *
       * <code>repeated uint64 root_key_ids = 1;</code>
       * @param index The index of the element to return.
       * @return The rootKeyIds at the given index.
       */
      @java.lang.Override
      public long getRootKeyIds(int index) {
        return instance.getRootKeyIds(index);
      }
      /**
       * <pre>
       * The list of root key IDs that are in use.
       * </pre>
       *
       * <code>repeated uint64 root_key_ids = 1;</code>
       * @param value The rootKeyIds to set.
       * @return This builder for chaining.
       */
      public Builder setRootKeyIds(
          int index, long value) {
        copyOnWrite();
        instance.setRootKeyIds(index, value);
        return this;
      }
      /**
       * <pre>
       * The list of root key IDs that are in use.
       * </pre>
       *
       * <code>repeated uint64 root_key_ids = 1;</code>
       * @param value The rootKeyIds to add.
       * @return This builder for chaining.
       */
      public Builder addRootKeyIds(long value) {
        copyOnWrite();
        instance.addRootKeyIds(value);
        return this;
      }
      /**
       * <pre>
       * The list of root key IDs that are in use.
       * </pre>
       *
       * <code>repeated uint64 root_key_ids = 1;</code>
       * @param values The rootKeyIds to add.
       * @return This builder for chaining.
       */
      public Builder addAllRootKeyIds(
          java.lang.Iterable<? extends java.lang.Long> values) {
        copyOnWrite();
        instance.addAllRootKeyIds(values);
        return this;
      }
      /**
       * <pre>
       * The list of root key IDs that are in use.
       * </pre>
       *
       * <code>repeated uint64 root_key_ids = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRootKeyIds() {
        copyOnWrite();
        instance.clearRootKeyIds();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ListMacaroonIDsResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ListMacaroonIDsResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "rootKeyIds_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0000\u0001&";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ListMacaroonIDsResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ListMacaroonIDsResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ListMacaroonIDsResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ListMacaroonIDsResponse)
    private static final co.anode.anodium.Rpc.ListMacaroonIDsResponse DEFAULT_INSTANCE;
    static {
      ListMacaroonIDsResponse defaultInstance = new ListMacaroonIDsResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ListMacaroonIDsResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ListMacaroonIDsResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ListMacaroonIDsResponse> PARSER;

    public static com.google.protobuf.Parser<ListMacaroonIDsResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface DeleteMacaroonIDRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.DeleteMacaroonIDRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The root key ID to be removed.
     * </pre>
     *
     * <code>uint64 root_key_id = 1;</code>
     * @return The rootKeyId.
     */
    long getRootKeyId();
  }
  /**
   * Protobuf type {@code co.anode.anodium.DeleteMacaroonIDRequest}
   */
  public  static final class DeleteMacaroonIDRequest extends
      com.google.protobuf.GeneratedMessageLite<
          DeleteMacaroonIDRequest, DeleteMacaroonIDRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.DeleteMacaroonIDRequest)
      DeleteMacaroonIDRequestOrBuilder {
    private DeleteMacaroonIDRequest() {
    }
    public static final int ROOT_KEY_ID_FIELD_NUMBER = 1;
    private long rootKeyId_;
    /**
     * <pre>
     * The root key ID to be removed.
     * </pre>
     *
     * <code>uint64 root_key_id = 1;</code>
     * @return The rootKeyId.
     */
    @java.lang.Override
    public long getRootKeyId() {
      return rootKeyId_;
    }
    /**
     * <pre>
     * The root key ID to be removed.
     * </pre>
     *
     * <code>uint64 root_key_id = 1;</code>
     * @param value The rootKeyId to set.
     */
    private void setRootKeyId(long value) {
      
      rootKeyId_ = value;
    }
    /**
     * <pre>
     * The root key ID to be removed.
     * </pre>
     *
     * <code>uint64 root_key_id = 1;</code>
     */
    private void clearRootKeyId() {
      
      rootKeyId_ = 0L;
    }

    public static co.anode.anodium.Rpc.DeleteMacaroonIDRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.DeleteMacaroonIDRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.DeleteMacaroonIDRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.DeleteMacaroonIDRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.DeleteMacaroonIDRequest)
        co.anode.anodium.Rpc.DeleteMacaroonIDRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.DeleteMacaroonIDRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The root key ID to be removed.
       * </pre>
       *
       * <code>uint64 root_key_id = 1;</code>
       * @return The rootKeyId.
       */
      @java.lang.Override
      public long getRootKeyId() {
        return instance.getRootKeyId();
      }
      /**
       * <pre>
       * The root key ID to be removed.
       * </pre>
       *
       * <code>uint64 root_key_id = 1;</code>
       * @param value The rootKeyId to set.
       * @return This builder for chaining.
       */
      public Builder setRootKeyId(long value) {
        copyOnWrite();
        instance.setRootKeyId(value);
        return this;
      }
      /**
       * <pre>
       * The root key ID to be removed.
       * </pre>
       *
       * <code>uint64 root_key_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRootKeyId() {
        copyOnWrite();
        instance.clearRootKeyId();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.DeleteMacaroonIDRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.DeleteMacaroonIDRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "rootKeyId_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.DeleteMacaroonIDRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.DeleteMacaroonIDRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.DeleteMacaroonIDRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.DeleteMacaroonIDRequest)
    private static final co.anode.anodium.Rpc.DeleteMacaroonIDRequest DEFAULT_INSTANCE;
    static {
      DeleteMacaroonIDRequest defaultInstance = new DeleteMacaroonIDRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        DeleteMacaroonIDRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.DeleteMacaroonIDRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<DeleteMacaroonIDRequest> PARSER;

    public static com.google.protobuf.Parser<DeleteMacaroonIDRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface DeleteMacaroonIDResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.DeleteMacaroonIDResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * A boolean indicates that the deletion is successful.
     * </pre>
     *
     * <code>bool deleted = 1;</code>
     * @return The deleted.
     */
    boolean getDeleted();
  }
  /**
   * Protobuf type {@code co.anode.anodium.DeleteMacaroonIDResponse}
   */
  public  static final class DeleteMacaroonIDResponse extends
      com.google.protobuf.GeneratedMessageLite<
          DeleteMacaroonIDResponse, DeleteMacaroonIDResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.DeleteMacaroonIDResponse)
      DeleteMacaroonIDResponseOrBuilder {
    private DeleteMacaroonIDResponse() {
    }
    public static final int DELETED_FIELD_NUMBER = 1;
    private boolean deleted_;
    /**
     * <pre>
     * A boolean indicates that the deletion is successful.
     * </pre>
     *
     * <code>bool deleted = 1;</code>
     * @return The deleted.
     */
    @java.lang.Override
    public boolean getDeleted() {
      return deleted_;
    }
    /**
     * <pre>
     * A boolean indicates that the deletion is successful.
     * </pre>
     *
     * <code>bool deleted = 1;</code>
     * @param value The deleted to set.
     */
    private void setDeleted(boolean value) {
      
      deleted_ = value;
    }
    /**
     * <pre>
     * A boolean indicates that the deletion is successful.
     * </pre>
     *
     * <code>bool deleted = 1;</code>
     */
    private void clearDeleted() {
      
      deleted_ = false;
    }

    public static co.anode.anodium.Rpc.DeleteMacaroonIDResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.DeleteMacaroonIDResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.DeleteMacaroonIDResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.DeleteMacaroonIDResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.DeleteMacaroonIDResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.DeleteMacaroonIDResponse)
        co.anode.anodium.Rpc.DeleteMacaroonIDResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.DeleteMacaroonIDResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * A boolean indicates that the deletion is successful.
       * </pre>
       *
       * <code>bool deleted = 1;</code>
       * @return The deleted.
       */
      @java.lang.Override
      public boolean getDeleted() {
        return instance.getDeleted();
      }
      /**
       * <pre>
       * A boolean indicates that the deletion is successful.
       * </pre>
       *
       * <code>bool deleted = 1;</code>
       * @param value The deleted to set.
       * @return This builder for chaining.
       */
      public Builder setDeleted(boolean value) {
        copyOnWrite();
        instance.setDeleted(value);
        return this;
      }
      /**
       * <pre>
       * A boolean indicates that the deletion is successful.
       * </pre>
       *
       * <code>bool deleted = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeleted() {
        copyOnWrite();
        instance.clearDeleted();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.DeleteMacaroonIDResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.DeleteMacaroonIDResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "deleted_",
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u0007";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.DeleteMacaroonIDResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.DeleteMacaroonIDResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.DeleteMacaroonIDResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.DeleteMacaroonIDResponse)
    private static final co.anode.anodium.Rpc.DeleteMacaroonIDResponse DEFAULT_INSTANCE;
    static {
      DeleteMacaroonIDResponse defaultInstance = new DeleteMacaroonIDResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        DeleteMacaroonIDResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.DeleteMacaroonIDResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<DeleteMacaroonIDResponse> PARSER;

    public static com.google.protobuf.Parser<DeleteMacaroonIDResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface MacaroonPermissionListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.MacaroonPermissionList)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * A list of macaroon permissions.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    java.util.List<co.anode.anodium.Rpc.MacaroonPermission> 
        getPermissionsList();
    /**
     * <pre>
     * A list of macaroon permissions.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    co.anode.anodium.Rpc.MacaroonPermission getPermissions(int index);
    /**
     * <pre>
     * A list of macaroon permissions.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    int getPermissionsCount();
  }
  /**
   * Protobuf type {@code co.anode.anodium.MacaroonPermissionList}
   */
  public  static final class MacaroonPermissionList extends
      com.google.protobuf.GeneratedMessageLite<
          MacaroonPermissionList, MacaroonPermissionList.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.MacaroonPermissionList)
      MacaroonPermissionListOrBuilder {
    private MacaroonPermissionList() {
      permissions_ = emptyProtobufList();
    }
    public static final int PERMISSIONS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.MacaroonPermission> permissions_;
    /**
     * <pre>
     * A list of macaroon permissions.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.MacaroonPermission> getPermissionsList() {
      return permissions_;
    }
    /**
     * <pre>
     * A list of macaroon permissions.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.MacaroonPermissionOrBuilder> 
        getPermissionsOrBuilderList() {
      return permissions_;
    }
    /**
     * <pre>
     * A list of macaroon permissions.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    @java.lang.Override
    public int getPermissionsCount() {
      return permissions_.size();
    }
    /**
     * <pre>
     * A list of macaroon permissions.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.MacaroonPermission getPermissions(int index) {
      return permissions_.get(index);
    }
    /**
     * <pre>
     * A list of macaroon permissions.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    public co.anode.anodium.Rpc.MacaroonPermissionOrBuilder getPermissionsOrBuilder(
        int index) {
      return permissions_.get(index);
    }
    private void ensurePermissionsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.MacaroonPermission> tmp = permissions_;
      if (!tmp.isModifiable()) {
        permissions_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * A list of macaroon permissions.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    private void setPermissions(
        int index, co.anode.anodium.Rpc.MacaroonPermission value) {
      value.getClass();
  ensurePermissionsIsMutable();
      permissions_.set(index, value);
    }
    /**
     * <pre>
     * A list of macaroon permissions.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    private void addPermissions(co.anode.anodium.Rpc.MacaroonPermission value) {
      value.getClass();
  ensurePermissionsIsMutable();
      permissions_.add(value);
    }
    /**
     * <pre>
     * A list of macaroon permissions.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    private void addPermissions(
        int index, co.anode.anodium.Rpc.MacaroonPermission value) {
      value.getClass();
  ensurePermissionsIsMutable();
      permissions_.add(index, value);
    }
    /**
     * <pre>
     * A list of macaroon permissions.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    private void addAllPermissions(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.MacaroonPermission> values) {
      ensurePermissionsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, permissions_);
    }
    /**
     * <pre>
     * A list of macaroon permissions.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    private void clearPermissions() {
      permissions_ = emptyProtobufList();
    }
    /**
     * <pre>
     * A list of macaroon permissions.
     * </pre>
     *
     * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
     */
    private void removePermissions(int index) {
      ensurePermissionsIsMutable();
      permissions_.remove(index);
    }

    public static co.anode.anodium.Rpc.MacaroonPermissionList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.MacaroonPermissionList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MacaroonPermissionList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.MacaroonPermissionList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MacaroonPermissionList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.MacaroonPermissionList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MacaroonPermissionList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.MacaroonPermissionList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MacaroonPermissionList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.MacaroonPermissionList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MacaroonPermissionList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.MacaroonPermissionList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.MacaroonPermissionList prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.MacaroonPermissionList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.MacaroonPermissionList, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.MacaroonPermissionList)
        co.anode.anodium.Rpc.MacaroonPermissionListOrBuilder {
      // Construct using co.anode.anodium.Rpc.MacaroonPermissionList.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * A list of macaroon permissions.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.MacaroonPermission> getPermissionsList() {
        return java.util.Collections.unmodifiableList(
            instance.getPermissionsList());
      }
      /**
       * <pre>
       * A list of macaroon permissions.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      @java.lang.Override
      public int getPermissionsCount() {
        return instance.getPermissionsCount();
      }/**
       * <pre>
       * A list of macaroon permissions.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.MacaroonPermission getPermissions(int index) {
        return instance.getPermissions(index);
      }
      /**
       * <pre>
       * A list of macaroon permissions.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      public Builder setPermissions(
          int index, co.anode.anodium.Rpc.MacaroonPermission value) {
        copyOnWrite();
        instance.setPermissions(index, value);
        return this;
      }
      /**
       * <pre>
       * A list of macaroon permissions.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      public Builder setPermissions(
          int index, co.anode.anodium.Rpc.MacaroonPermission.Builder builderForValue) {
        copyOnWrite();
        instance.setPermissions(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A list of macaroon permissions.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      public Builder addPermissions(co.anode.anodium.Rpc.MacaroonPermission value) {
        copyOnWrite();
        instance.addPermissions(value);
        return this;
      }
      /**
       * <pre>
       * A list of macaroon permissions.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      public Builder addPermissions(
          int index, co.anode.anodium.Rpc.MacaroonPermission value) {
        copyOnWrite();
        instance.addPermissions(index, value);
        return this;
      }
      /**
       * <pre>
       * A list of macaroon permissions.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      public Builder addPermissions(
          co.anode.anodium.Rpc.MacaroonPermission.Builder builderForValue) {
        copyOnWrite();
        instance.addPermissions(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A list of macaroon permissions.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      public Builder addPermissions(
          int index, co.anode.anodium.Rpc.MacaroonPermission.Builder builderForValue) {
        copyOnWrite();
        instance.addPermissions(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A list of macaroon permissions.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      public Builder addAllPermissions(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.MacaroonPermission> values) {
        copyOnWrite();
        instance.addAllPermissions(values);
        return this;
      }
      /**
       * <pre>
       * A list of macaroon permissions.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      public Builder clearPermissions() {
        copyOnWrite();
        instance.clearPermissions();
        return this;
      }
      /**
       * <pre>
       * A list of macaroon permissions.
       * </pre>
       *
       * <code>repeated .co.anode.anodium.MacaroonPermission permissions = 1;</code>
       */
      public Builder removePermissions(int index) {
        copyOnWrite();
        instance.removePermissions(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.MacaroonPermissionList)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.MacaroonPermissionList();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "permissions_",
              co.anode.anodium.Rpc.MacaroonPermission.class,
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0000\u0001\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.MacaroonPermissionList> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.MacaroonPermissionList.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.MacaroonPermissionList>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.MacaroonPermissionList)
    private static final co.anode.anodium.Rpc.MacaroonPermissionList DEFAULT_INSTANCE;
    static {
      MacaroonPermissionList defaultInstance = new MacaroonPermissionList();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        MacaroonPermissionList.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.MacaroonPermissionList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<MacaroonPermissionList> PARSER;

    public static com.google.protobuf.Parser<MacaroonPermissionList> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ListPermissionsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ListPermissionsRequest)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code co.anode.anodium.ListPermissionsRequest}
   */
  public  static final class ListPermissionsRequest extends
      com.google.protobuf.GeneratedMessageLite<
          ListPermissionsRequest, ListPermissionsRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ListPermissionsRequest)
      ListPermissionsRequestOrBuilder {
    private ListPermissionsRequest() {
    }
    public static co.anode.anodium.Rpc.ListPermissionsRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListPermissionsRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPermissionsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListPermissionsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPermissionsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListPermissionsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPermissionsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListPermissionsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPermissionsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListPermissionsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPermissionsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListPermissionsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ListPermissionsRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ListPermissionsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ListPermissionsRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ListPermissionsRequest)
        co.anode.anodium.Rpc.ListPermissionsRequestOrBuilder {
      // Construct using co.anode.anodium.Rpc.ListPermissionsRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ListPermissionsRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ListPermissionsRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ListPermissionsRequest> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ListPermissionsRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ListPermissionsRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ListPermissionsRequest)
    private static final co.anode.anodium.Rpc.ListPermissionsRequest DEFAULT_INSTANCE;
    static {
      ListPermissionsRequest defaultInstance = new ListPermissionsRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ListPermissionsRequest.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ListPermissionsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ListPermissionsRequest> PARSER;

    public static com.google.protobuf.Parser<ListPermissionsRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ListPermissionsResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ListPermissionsResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *A map between all RPC method URIs and their required macaroon permissions to
     *access them.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.MacaroonPermissionList&gt; method_permissions = 1;</code>
     */
    int getMethodPermissionsCount();
    /**
     * <pre>
     *A map between all RPC method URIs and their required macaroon permissions to
     *access them.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.MacaroonPermissionList&gt; method_permissions = 1;</code>
     */
    boolean containsMethodPermissions(
        java.lang.String key);
    /**
     * Use {@link #getMethodPermissionsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, co.anode.anodium.Rpc.MacaroonPermissionList>
    getMethodPermissions();
    /**
     * <pre>
     *A map between all RPC method URIs and their required macaroon permissions to
     *access them.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.MacaroonPermissionList&gt; method_permissions = 1;</code>
     */
    java.util.Map<java.lang.String, co.anode.anodium.Rpc.MacaroonPermissionList>
    getMethodPermissionsMap();
    /**
     * <pre>
     *A map between all RPC method URIs and their required macaroon permissions to
     *access them.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.MacaroonPermissionList&gt; method_permissions = 1;</code>
     */

    co.anode.anodium.Rpc.MacaroonPermissionList getMethodPermissionsOrDefault(
        java.lang.String key,
        co.anode.anodium.Rpc.MacaroonPermissionList defaultValue);
    /**
     * <pre>
     *A map between all RPC method URIs and their required macaroon permissions to
     *access them.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.MacaroonPermissionList&gt; method_permissions = 1;</code>
     */

    co.anode.anodium.Rpc.MacaroonPermissionList getMethodPermissionsOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code co.anode.anodium.ListPermissionsResponse}
   */
  public  static final class ListPermissionsResponse extends
      com.google.protobuf.GeneratedMessageLite<
          ListPermissionsResponse, ListPermissionsResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ListPermissionsResponse)
      ListPermissionsResponseOrBuilder {
    private ListPermissionsResponse() {
    }
    public static final int METHOD_PERMISSIONS_FIELD_NUMBER = 1;
    private static final class MethodPermissionsDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, co.anode.anodium.Rpc.MacaroonPermissionList> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, co.anode.anodium.Rpc.MacaroonPermissionList>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  co.anode.anodium.Rpc.MacaroonPermissionList.getDefaultInstance());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, co.anode.anodium.Rpc.MacaroonPermissionList> methodPermissions_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, co.anode.anodium.Rpc.MacaroonPermissionList>
    internalGetMethodPermissions() {
      return methodPermissions_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, co.anode.anodium.Rpc.MacaroonPermissionList>
    internalGetMutableMethodPermissions() {
      if (!methodPermissions_.isMutable()) {
        methodPermissions_ = methodPermissions_.mutableCopy();
      }
      return methodPermissions_;
    }
    @java.lang.Override

    public int getMethodPermissionsCount() {
      return internalGetMethodPermissions().size();
    }
    /**
     * <pre>
     *A map between all RPC method URIs and their required macaroon permissions to
     *access them.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.MacaroonPermissionList&gt; method_permissions = 1;</code>
     */
    @java.lang.Override

    public boolean containsMethodPermissions(
        java.lang.String key) {
      key.getClass();
      return internalGetMethodPermissions().containsKey(key);
    }
    /**
     * Use {@link #getMethodPermissionsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, co.anode.anodium.Rpc.MacaroonPermissionList> getMethodPermissions() {
      return getMethodPermissionsMap();
    }
    /**
     * <pre>
     *A map between all RPC method URIs and their required macaroon permissions to
     *access them.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.MacaroonPermissionList&gt; method_permissions = 1;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, co.anode.anodium.Rpc.MacaroonPermissionList> getMethodPermissionsMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetMethodPermissions());
    }
    /**
     * <pre>
     *A map between all RPC method URIs and their required macaroon permissions to
     *access them.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.MacaroonPermissionList&gt; method_permissions = 1;</code>
     */
    @java.lang.Override

    public co.anode.anodium.Rpc.MacaroonPermissionList getMethodPermissionsOrDefault(
        java.lang.String key,
        co.anode.anodium.Rpc.MacaroonPermissionList defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, co.anode.anodium.Rpc.MacaroonPermissionList> map =
          internalGetMethodPermissions();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     *A map between all RPC method URIs and their required macaroon permissions to
     *access them.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.MacaroonPermissionList&gt; method_permissions = 1;</code>
     */
    @java.lang.Override

    public co.anode.anodium.Rpc.MacaroonPermissionList getMethodPermissionsOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, co.anode.anodium.Rpc.MacaroonPermissionList> map =
          internalGetMethodPermissions();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     *A map between all RPC method URIs and their required macaroon permissions to
     *access them.
     * </pre>
     *
     * <code>map&lt;string, .co.anode.anodium.MacaroonPermissionList&gt; method_permissions = 1;</code>
     */
    private java.util.Map<java.lang.String, co.anode.anodium.Rpc.MacaroonPermissionList>
    getMutableMethodPermissionsMap() {
      return internalGetMutableMethodPermissions();
    }

    public static co.anode.anodium.Rpc.ListPermissionsResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListPermissionsResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPermissionsResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListPermissionsResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPermissionsResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ListPermissionsResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPermissionsResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListPermissionsResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPermissionsResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListPermissionsResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ListPermissionsResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ListPermissionsResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ListPermissionsResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ListPermissionsResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ListPermissionsResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ListPermissionsResponse)
        co.anode.anodium.Rpc.ListPermissionsResponseOrBuilder {
      // Construct using co.anode.anodium.Rpc.ListPermissionsResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      @java.lang.Override

      public int getMethodPermissionsCount() {
        return instance.getMethodPermissionsMap().size();
      }
      /**
       * <pre>
       *A map between all RPC method URIs and their required macaroon permissions to
       *access them.
       * </pre>
       *
       * <code>map&lt;string, .co.anode.anodium.MacaroonPermissionList&gt; method_permissions = 1;</code>
       */
      @java.lang.Override

      public boolean containsMethodPermissions(
          java.lang.String key) {
        key.getClass();
        return instance.getMethodPermissionsMap().containsKey(key);
      }

      public Builder clearMethodPermissions() {
        copyOnWrite();
        instance.getMutableMethodPermissionsMap().clear();
        return this;
      }
      /**
       * <pre>
       *A map between all RPC method URIs and their required macaroon permissions to
       *access them.
       * </pre>
       *
       * <code>map&lt;string, .co.anode.anodium.MacaroonPermissionList&gt; method_permissions = 1;</code>
       */

      public Builder removeMethodPermissions(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableMethodPermissionsMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getMethodPermissionsMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, co.anode.anodium.Rpc.MacaroonPermissionList> getMethodPermissions() {
        return getMethodPermissionsMap();
      }
      /**
       * <pre>
       *A map between all RPC method URIs and their required macaroon permissions to
       *access them.
       * </pre>
       *
       * <code>map&lt;string, .co.anode.anodium.MacaroonPermissionList&gt; method_permissions = 1;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, co.anode.anodium.Rpc.MacaroonPermissionList> getMethodPermissionsMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getMethodPermissionsMap());
      }
      /**
       * <pre>
       *A map between all RPC method URIs and their required macaroon permissions to
       *access them.
       * </pre>
       *
       * <code>map&lt;string, .co.anode.anodium.MacaroonPermissionList&gt; method_permissions = 1;</code>
       */
      @java.lang.Override

      public co.anode.anodium.Rpc.MacaroonPermissionList getMethodPermissionsOrDefault(
          java.lang.String key,
          co.anode.anodium.Rpc.MacaroonPermissionList defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, co.anode.anodium.Rpc.MacaroonPermissionList> map =
            instance.getMethodPermissionsMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       *A map between all RPC method URIs and their required macaroon permissions to
       *access them.
       * </pre>
       *
       * <code>map&lt;string, .co.anode.anodium.MacaroonPermissionList&gt; method_permissions = 1;</code>
       */
      @java.lang.Override

      public co.anode.anodium.Rpc.MacaroonPermissionList getMethodPermissionsOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, co.anode.anodium.Rpc.MacaroonPermissionList> map =
            instance.getMethodPermissionsMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       *A map between all RPC method URIs and their required macaroon permissions to
       *access them.
       * </pre>
       *
       * <code>map&lt;string, .co.anode.anodium.MacaroonPermissionList&gt; method_permissions = 1;</code>
       */
      public Builder putMethodPermissions(
          java.lang.String key,
          co.anode.anodium.Rpc.MacaroonPermissionList value) {
        key.getClass();
        value.getClass();
        copyOnWrite();
        instance.getMutableMethodPermissionsMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       *A map between all RPC method URIs and their required macaroon permissions to
       *access them.
       * </pre>
       *
       * <code>map&lt;string, .co.anode.anodium.MacaroonPermissionList&gt; method_permissions = 1;</code>
       */
      public Builder putAllMethodPermissions(
          java.util.Map<java.lang.String, co.anode.anodium.Rpc.MacaroonPermissionList> values) {
        copyOnWrite();
        instance.getMutableMethodPermissionsMap().putAll(values);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ListPermissionsResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ListPermissionsResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "methodPermissions_",
              MethodPermissionsDefaultEntryHolder.defaultEntry,
            };
            java.lang.String info =
                "\u0000\u0001\u0000\u0000\u0001\u0001\u0001\u0001\u0000\u0000\u00012";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ListPermissionsResponse> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ListPermissionsResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ListPermissionsResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ListPermissionsResponse)
    private static final co.anode.anodium.Rpc.ListPermissionsResponse DEFAULT_INSTANCE;
    static {
      ListPermissionsResponse defaultInstance = new ListPermissionsResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ListPermissionsResponse.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ListPermissionsResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ListPermissionsResponse> PARSER;

    public static com.google.protobuf.Parser<ListPermissionsResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FailureOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.Failure)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Failure code as defined in the Lightning spec
     * </pre>
     *
     * <code>.co.anode.anodium.Failure.FailureCode code = 1;</code>
     * @return The enum numeric value on the wire for code.
     */
    int getCodeValue();
    /**
     * <pre>
     * Failure code as defined in the Lightning spec
     * </pre>
     *
     * <code>.co.anode.anodium.Failure.FailureCode code = 1;</code>
     * @return The code.
     */
    co.anode.anodium.Rpc.Failure.FailureCode getCode();

    /**
     * <pre>
     * An optional channel update message.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelUpdate channel_update = 3;</code>
     * @return Whether the channelUpdate field is set.
     */
    boolean hasChannelUpdate();
    /**
     * <pre>
     * An optional channel update message.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelUpdate channel_update = 3;</code>
     * @return The channelUpdate.
     */
    co.anode.anodium.Rpc.ChannelUpdate getChannelUpdate();

    /**
     * <pre>
     * A failure type-dependent htlc value.
     * </pre>
     *
     * <code>uint64 htlc_msat = 4;</code>
     * @return The htlcMsat.
     */
    long getHtlcMsat();

    /**
     * <pre>
     * The sha256 sum of the onion payload.
     * </pre>
     *
     * <code>bytes onion_sha_256 = 5;</code>
     * @return The onionSha256.
     */
    com.google.protobuf.ByteString getOnionSha256();

    /**
     * <pre>
     * A failure type-dependent cltv expiry value.
     * </pre>
     *
     * <code>uint32 cltv_expiry = 6;</code>
     * @return The cltvExpiry.
     */
    int getCltvExpiry();

    /**
     * <pre>
     * A failure type-dependent flags value.
     * </pre>
     *
     * <code>uint32 flags = 7;</code>
     * @return The flags.
     */
    int getFlags();

    /**
     * <pre>
     *The position in the path of the intermediate or final node that generated
     *the failure message. Position zero is the sender node.
     * </pre>
     *
     * <code>uint32 failure_source_index = 8;</code>
     * @return The failureSourceIndex.
     */
    int getFailureSourceIndex();

    /**
     * <pre>
     * A failure type-dependent block height.
     * </pre>
     *
     * <code>uint32 height = 9;</code>
     * @return The height.
     */
    int getHeight();
  }
  /**
   * Protobuf type {@code co.anode.anodium.Failure}
   */
  public  static final class Failure extends
      com.google.protobuf.GeneratedMessageLite<
          Failure, Failure.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.Failure)
      FailureOrBuilder {
    private Failure() {
      onionSha256_ = com.google.protobuf.ByteString.EMPTY;
    }
    /**
     * Protobuf enum {@code co.anode.anodium.Failure.FailureCode}
     */
    public enum FailureCode
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       *The numbers assigned in this enumeration match the failure codes as
       *defined in BOLT #4. Because protobuf 3 requires enums to start with 0,
       *a RESERVED value is added.
       * </pre>
       *
       * <code>RESERVED = 0;</code>
       */
      RESERVED(0),
      /**
       * <code>INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS = 1;</code>
       */
      INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS(1),
      /**
       * <code>INCORRECT_PAYMENT_AMOUNT = 2;</code>
       */
      INCORRECT_PAYMENT_AMOUNT(2),
      /**
       * <code>FINAL_INCORRECT_CLTV_EXPIRY = 3;</code>
       */
      FINAL_INCORRECT_CLTV_EXPIRY(3),
      /**
       * <code>FINAL_INCORRECT_HTLC_AMOUNT = 4;</code>
       */
      FINAL_INCORRECT_HTLC_AMOUNT(4),
      /**
       * <code>FINAL_EXPIRY_TOO_SOON = 5;</code>
       */
      FINAL_EXPIRY_TOO_SOON(5),
      /**
       * <code>INVALID_REALM = 6;</code>
       */
      INVALID_REALM(6),
      /**
       * <code>EXPIRY_TOO_SOON = 7;</code>
       */
      EXPIRY_TOO_SOON(7),
      /**
       * <code>INVALID_ONION_VERSION = 8;</code>
       */
      INVALID_ONION_VERSION(8),
      /**
       * <code>INVALID_ONION_HMAC = 9;</code>
       */
      INVALID_ONION_HMAC(9),
      /**
       * <code>INVALID_ONION_KEY = 10;</code>
       */
      INVALID_ONION_KEY(10),
      /**
       * <code>AMOUNT_BELOW_MINIMUM = 11;</code>
       */
      AMOUNT_BELOW_MINIMUM(11),
      /**
       * <code>FEE_INSUFFICIENT = 12;</code>
       */
      FEE_INSUFFICIENT(12),
      /**
       * <code>INCORRECT_CLTV_EXPIRY = 13;</code>
       */
      INCORRECT_CLTV_EXPIRY(13),
      /**
       * <code>CHANNEL_DISABLED = 14;</code>
       */
      CHANNEL_DISABLED(14),
      /**
       * <code>TEMPORARY_CHANNEL_FAILURE = 15;</code>
       */
      TEMPORARY_CHANNEL_FAILURE(15),
      /**
       * <code>REQUIRED_NODE_FEATURE_MISSING = 16;</code>
       */
      REQUIRED_NODE_FEATURE_MISSING(16),
      /**
       * <code>REQUIRED_CHANNEL_FEATURE_MISSING = 17;</code>
       */
      REQUIRED_CHANNEL_FEATURE_MISSING(17),
      /**
       * <code>UNKNOWN_NEXT_PEER = 18;</code>
       */
      UNKNOWN_NEXT_PEER(18),
      /**
       * <code>TEMPORARY_NODE_FAILURE = 19;</code>
       */
      TEMPORARY_NODE_FAILURE(19),
      /**
       * <code>PERMANENT_NODE_FAILURE = 20;</code>
       */
      PERMANENT_NODE_FAILURE(20),
      /**
       * <code>PERMANENT_CHANNEL_FAILURE = 21;</code>
       */
      PERMANENT_CHANNEL_FAILURE(21),
      /**
       * <code>EXPIRY_TOO_FAR = 22;</code>
       */
      EXPIRY_TOO_FAR(22),
      /**
       * <code>MPP_TIMEOUT = 23;</code>
       */
      MPP_TIMEOUT(23),
      /**
       * <pre>
       *An internal error occurred.
       * </pre>
       *
       * <code>INTERNAL_FAILURE = 997;</code>
       */
      INTERNAL_FAILURE(997),
      /**
       * <pre>
       *The error source is known, but the failure itself couldn't be decoded.
       * </pre>
       *
       * <code>UNKNOWN_FAILURE = 998;</code>
       */
      UNKNOWN_FAILURE(998),
      /**
       * <pre>
       *An unreadable failure result is returned if the received failure message
       *cannot be decrypted. In that case the error source is unknown.
       * </pre>
       *
       * <code>UNREADABLE_FAILURE = 999;</code>
       */
      UNREADABLE_FAILURE(999),
      UNRECOGNIZED(-1),
      ;

      /**
       * <pre>
       *The numbers assigned in this enumeration match the failure codes as
       *defined in BOLT #4. Because protobuf 3 requires enums to start with 0,
       *a RESERVED value is added.
       * </pre>
       *
       * <code>RESERVED = 0;</code>
       */
      public static final int RESERVED_VALUE = 0;
      /**
       * <code>INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS = 1;</code>
       */
      public static final int INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS_VALUE = 1;
      /**
       * <code>INCORRECT_PAYMENT_AMOUNT = 2;</code>
       */
      public static final int INCORRECT_PAYMENT_AMOUNT_VALUE = 2;
      /**
       * <code>FINAL_INCORRECT_CLTV_EXPIRY = 3;</code>
       */
      public static final int FINAL_INCORRECT_CLTV_EXPIRY_VALUE = 3;
      /**
       * <code>FINAL_INCORRECT_HTLC_AMOUNT = 4;</code>
       */
      public static final int FINAL_INCORRECT_HTLC_AMOUNT_VALUE = 4;
      /**
       * <code>FINAL_EXPIRY_TOO_SOON = 5;</code>
       */
      public static final int FINAL_EXPIRY_TOO_SOON_VALUE = 5;
      /**
       * <code>INVALID_REALM = 6;</code>
       */
      public static final int INVALID_REALM_VALUE = 6;
      /**
       * <code>EXPIRY_TOO_SOON = 7;</code>
       */
      public static final int EXPIRY_TOO_SOON_VALUE = 7;
      /**
       * <code>INVALID_ONION_VERSION = 8;</code>
       */
      public static final int INVALID_ONION_VERSION_VALUE = 8;
      /**
       * <code>INVALID_ONION_HMAC = 9;</code>
       */
      public static final int INVALID_ONION_HMAC_VALUE = 9;
      /**
       * <code>INVALID_ONION_KEY = 10;</code>
       */
      public static final int INVALID_ONION_KEY_VALUE = 10;
      /**
       * <code>AMOUNT_BELOW_MINIMUM = 11;</code>
       */
      public static final int AMOUNT_BELOW_MINIMUM_VALUE = 11;
      /**
       * <code>FEE_INSUFFICIENT = 12;</code>
       */
      public static final int FEE_INSUFFICIENT_VALUE = 12;
      /**
       * <code>INCORRECT_CLTV_EXPIRY = 13;</code>
       */
      public static final int INCORRECT_CLTV_EXPIRY_VALUE = 13;
      /**
       * <code>CHANNEL_DISABLED = 14;</code>
       */
      public static final int CHANNEL_DISABLED_VALUE = 14;
      /**
       * <code>TEMPORARY_CHANNEL_FAILURE = 15;</code>
       */
      public static final int TEMPORARY_CHANNEL_FAILURE_VALUE = 15;
      /**
       * <code>REQUIRED_NODE_FEATURE_MISSING = 16;</code>
       */
      public static final int REQUIRED_NODE_FEATURE_MISSING_VALUE = 16;
      /**
       * <code>REQUIRED_CHANNEL_FEATURE_MISSING = 17;</code>
       */
      public static final int REQUIRED_CHANNEL_FEATURE_MISSING_VALUE = 17;
      /**
       * <code>UNKNOWN_NEXT_PEER = 18;</code>
       */
      public static final int UNKNOWN_NEXT_PEER_VALUE = 18;
      /**
       * <code>TEMPORARY_NODE_FAILURE = 19;</code>
       */
      public static final int TEMPORARY_NODE_FAILURE_VALUE = 19;
      /**
       * <code>PERMANENT_NODE_FAILURE = 20;</code>
       */
      public static final int PERMANENT_NODE_FAILURE_VALUE = 20;
      /**
       * <code>PERMANENT_CHANNEL_FAILURE = 21;</code>
       */
      public static final int PERMANENT_CHANNEL_FAILURE_VALUE = 21;
      /**
       * <code>EXPIRY_TOO_FAR = 22;</code>
       */
      public static final int EXPIRY_TOO_FAR_VALUE = 22;
      /**
       * <code>MPP_TIMEOUT = 23;</code>
       */
      public static final int MPP_TIMEOUT_VALUE = 23;
      /**
       * <pre>
       *An internal error occurred.
       * </pre>
       *
       * <code>INTERNAL_FAILURE = 997;</code>
       */
      public static final int INTERNAL_FAILURE_VALUE = 997;
      /**
       * <pre>
       *The error source is known, but the failure itself couldn't be decoded.
       * </pre>
       *
       * <code>UNKNOWN_FAILURE = 998;</code>
       */
      public static final int UNKNOWN_FAILURE_VALUE = 998;
      /**
       * <pre>
       *An unreadable failure result is returned if the received failure message
       *cannot be decrypted. In that case the error source is unknown.
       * </pre>
       *
       * <code>UNREADABLE_FAILURE = 999;</code>
       */
      public static final int UNREADABLE_FAILURE_VALUE = 999;


      @java.lang.Override
      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static FailureCode valueOf(int value) {
        return forNumber(value);
      }

      public static FailureCode forNumber(int value) {
        switch (value) {
          case 0: return RESERVED;
          case 1: return INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS;
          case 2: return INCORRECT_PAYMENT_AMOUNT;
          case 3: return FINAL_INCORRECT_CLTV_EXPIRY;
          case 4: return FINAL_INCORRECT_HTLC_AMOUNT;
          case 5: return FINAL_EXPIRY_TOO_SOON;
          case 6: return INVALID_REALM;
          case 7: return EXPIRY_TOO_SOON;
          case 8: return INVALID_ONION_VERSION;
          case 9: return INVALID_ONION_HMAC;
          case 10: return INVALID_ONION_KEY;
          case 11: return AMOUNT_BELOW_MINIMUM;
          case 12: return FEE_INSUFFICIENT;
          case 13: return INCORRECT_CLTV_EXPIRY;
          case 14: return CHANNEL_DISABLED;
          case 15: return TEMPORARY_CHANNEL_FAILURE;
          case 16: return REQUIRED_NODE_FEATURE_MISSING;
          case 17: return REQUIRED_CHANNEL_FEATURE_MISSING;
          case 18: return UNKNOWN_NEXT_PEER;
          case 19: return TEMPORARY_NODE_FAILURE;
          case 20: return PERMANENT_NODE_FAILURE;
          case 21: return PERMANENT_CHANNEL_FAILURE;
          case 22: return EXPIRY_TOO_FAR;
          case 23: return MPP_TIMEOUT;
          case 997: return INTERNAL_FAILURE;
          case 998: return UNKNOWN_FAILURE;
          case 999: return UNREADABLE_FAILURE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<FailureCode>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          FailureCode> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<FailureCode>() {
              @java.lang.Override
              public FailureCode findValueByNumber(int number) {
                return FailureCode.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return FailureCodeVerifier.INSTANCE;
      }

      private static final class FailureCodeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new FailureCodeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return FailureCode.forNumber(number) != null;
              }
            };

      private final int value;

      private FailureCode(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:co.anode.anodium.Failure.FailureCode)
    }

    public static final int CODE_FIELD_NUMBER = 1;
    private int code_;
    /**
     * <pre>
     * Failure code as defined in the Lightning spec
     * </pre>
     *
     * <code>.co.anode.anodium.Failure.FailureCode code = 1;</code>
     * @return The enum numeric value on the wire for code.
     */
    @java.lang.Override
    public int getCodeValue() {
      return code_;
    }
    /**
     * <pre>
     * Failure code as defined in the Lightning spec
     * </pre>
     *
     * <code>.co.anode.anodium.Failure.FailureCode code = 1;</code>
     * @return The code.
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Failure.FailureCode getCode() {
      co.anode.anodium.Rpc.Failure.FailureCode result = co.anode.anodium.Rpc.Failure.FailureCode.forNumber(code_);
      return result == null ? co.anode.anodium.Rpc.Failure.FailureCode.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * Failure code as defined in the Lightning spec
     * </pre>
     *
     * <code>.co.anode.anodium.Failure.FailureCode code = 1;</code>
     * @param value The enum numeric value on the wire for code to set.
     */
    private void setCodeValue(int value) {
        code_ = value;
    }
    /**
     * <pre>
     * Failure code as defined in the Lightning spec
     * </pre>
     *
     * <code>.co.anode.anodium.Failure.FailureCode code = 1;</code>
     * @param value The code to set.
     */
    private void setCode(co.anode.anodium.Rpc.Failure.FailureCode value) {
      code_ = value.getNumber();
      
    }
    /**
     * <pre>
     * Failure code as defined in the Lightning spec
     * </pre>
     *
     * <code>.co.anode.anodium.Failure.FailureCode code = 1;</code>
     */
    private void clearCode() {
      
      code_ = 0;
    }

    public static final int CHANNEL_UPDATE_FIELD_NUMBER = 3;
    private co.anode.anodium.Rpc.ChannelUpdate channelUpdate_;
    /**
     * <pre>
     * An optional channel update message.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelUpdate channel_update = 3;</code>
     */
    @java.lang.Override
    public boolean hasChannelUpdate() {
      return channelUpdate_ != null;
    }
    /**
     * <pre>
     * An optional channel update message.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelUpdate channel_update = 3;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.ChannelUpdate getChannelUpdate() {
      return channelUpdate_ == null ? co.anode.anodium.Rpc.ChannelUpdate.getDefaultInstance() : channelUpdate_;
    }
    /**
     * <pre>
     * An optional channel update message.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelUpdate channel_update = 3;</code>
     */
    private void setChannelUpdate(co.anode.anodium.Rpc.ChannelUpdate value) {
      value.getClass();
  channelUpdate_ = value;
      
      }
    /**
     * <pre>
     * An optional channel update message.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelUpdate channel_update = 3;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeChannelUpdate(co.anode.anodium.Rpc.ChannelUpdate value) {
      value.getClass();
  if (channelUpdate_ != null &&
          channelUpdate_ != co.anode.anodium.Rpc.ChannelUpdate.getDefaultInstance()) {
        channelUpdate_ =
          co.anode.anodium.Rpc.ChannelUpdate.newBuilder(channelUpdate_).mergeFrom(value).buildPartial();
      } else {
        channelUpdate_ = value;
      }
      
    }
    /**
     * <pre>
     * An optional channel update message.
     * </pre>
     *
     * <code>.co.anode.anodium.ChannelUpdate channel_update = 3;</code>
     */
    private void clearChannelUpdate() {  channelUpdate_ = null;
      
    }

    public static final int HTLC_MSAT_FIELD_NUMBER = 4;
    private long htlcMsat_;
    /**
     * <pre>
     * A failure type-dependent htlc value.
     * </pre>
     *
     * <code>uint64 htlc_msat = 4;</code>
     * @return The htlcMsat.
     */
    @java.lang.Override
    public long getHtlcMsat() {
      return htlcMsat_;
    }
    /**
     * <pre>
     * A failure type-dependent htlc value.
     * </pre>
     *
     * <code>uint64 htlc_msat = 4;</code>
     * @param value The htlcMsat to set.
     */
    private void setHtlcMsat(long value) {
      
      htlcMsat_ = value;
    }
    /**
     * <pre>
     * A failure type-dependent htlc value.
     * </pre>
     *
     * <code>uint64 htlc_msat = 4;</code>
     */
    private void clearHtlcMsat() {
      
      htlcMsat_ = 0L;
    }

    public static final int ONION_SHA_256_FIELD_NUMBER = 5;
    private com.google.protobuf.ByteString onionSha256_;
    /**
     * <pre>
     * The sha256 sum of the onion payload.
     * </pre>
     *
     * <code>bytes onion_sha_256 = 5;</code>
     * @return The onionSha256.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getOnionSha256() {
      return onionSha256_;
    }
    /**
     * <pre>
     * The sha256 sum of the onion payload.
     * </pre>
     *
     * <code>bytes onion_sha_256 = 5;</code>
     * @param value The onionSha256 to set.
     */
    private void setOnionSha256(com.google.protobuf.ByteString value) {
      value.getClass();
  
      onionSha256_ = value;
    }
    /**
     * <pre>
     * The sha256 sum of the onion payload.
     * </pre>
     *
     * <code>bytes onion_sha_256 = 5;</code>
     */
    private void clearOnionSha256() {
      
      onionSha256_ = getDefaultInstance().getOnionSha256();
    }

    public static final int CLTV_EXPIRY_FIELD_NUMBER = 6;
    private int cltvExpiry_;
    /**
     * <pre>
     * A failure type-dependent cltv expiry value.
     * </pre>
     *
     * <code>uint32 cltv_expiry = 6;</code>
     * @return The cltvExpiry.
     */
    @java.lang.Override
    public int getCltvExpiry() {
      return cltvExpiry_;
    }
    /**
     * <pre>
     * A failure type-dependent cltv expiry value.
     * </pre>
     *
     * <code>uint32 cltv_expiry = 6;</code>
     * @param value The cltvExpiry to set.
     */
    private void setCltvExpiry(int value) {
      
      cltvExpiry_ = value;
    }
    /**
     * <pre>
     * A failure type-dependent cltv expiry value.
     * </pre>
     *
     * <code>uint32 cltv_expiry = 6;</code>
     */
    private void clearCltvExpiry() {
      
      cltvExpiry_ = 0;
    }

    public static final int FLAGS_FIELD_NUMBER = 7;
    private int flags_;
    /**
     * <pre>
     * A failure type-dependent flags value.
     * </pre>
     *
     * <code>uint32 flags = 7;</code>
     * @return The flags.
     */
    @java.lang.Override
    public int getFlags() {
      return flags_;
    }
    /**
     * <pre>
     * A failure type-dependent flags value.
     * </pre>
     *
     * <code>uint32 flags = 7;</code>
     * @param value The flags to set.
     */
    private void setFlags(int value) {
      
      flags_ = value;
    }
    /**
     * <pre>
     * A failure type-dependent flags value.
     * </pre>
     *
     * <code>uint32 flags = 7;</code>
     */
    private void clearFlags() {
      
      flags_ = 0;
    }

    public static final int FAILURE_SOURCE_INDEX_FIELD_NUMBER = 8;
    private int failureSourceIndex_;
    /**
     * <pre>
     *The position in the path of the intermediate or final node that generated
     *the failure message. Position zero is the sender node.
     * </pre>
     *
     * <code>uint32 failure_source_index = 8;</code>
     * @return The failureSourceIndex.
     */
    @java.lang.Override
    public int getFailureSourceIndex() {
      return failureSourceIndex_;
    }
    /**
     * <pre>
     *The position in the path of the intermediate or final node that generated
     *the failure message. Position zero is the sender node.
     * </pre>
     *
     * <code>uint32 failure_source_index = 8;</code>
     * @param value The failureSourceIndex to set.
     */
    private void setFailureSourceIndex(int value) {
      
      failureSourceIndex_ = value;
    }
    /**
     * <pre>
     *The position in the path of the intermediate or final node that generated
     *the failure message. Position zero is the sender node.
     * </pre>
     *
     * <code>uint32 failure_source_index = 8;</code>
     */
    private void clearFailureSourceIndex() {
      
      failureSourceIndex_ = 0;
    }

    public static final int HEIGHT_FIELD_NUMBER = 9;
    private int height_;
    /**
     * <pre>
     * A failure type-dependent block height.
     * </pre>
     *
     * <code>uint32 height = 9;</code>
     * @return The height.
     */
    @java.lang.Override
    public int getHeight() {
      return height_;
    }
    /**
     * <pre>
     * A failure type-dependent block height.
     * </pre>
     *
     * <code>uint32 height = 9;</code>
     * @param value The height to set.
     */
    private void setHeight(int value) {
      
      height_ = value;
    }
    /**
     * <pre>
     * A failure type-dependent block height.
     * </pre>
     *
     * <code>uint32 height = 9;</code>
     */
    private void clearHeight() {
      
      height_ = 0;
    }

    public static co.anode.anodium.Rpc.Failure parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Failure parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Failure parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Failure parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Failure parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Failure parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Failure parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Failure parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Failure parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Failure parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Failure parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Failure parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.Failure prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.Failure}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.Failure, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.Failure)
        co.anode.anodium.Rpc.FailureOrBuilder {
      // Construct using co.anode.anodium.Rpc.Failure.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Failure code as defined in the Lightning spec
       * </pre>
       *
       * <code>.co.anode.anodium.Failure.FailureCode code = 1;</code>
       * @return The enum numeric value on the wire for code.
       */
      @java.lang.Override
      public int getCodeValue() {
        return instance.getCodeValue();
      }
      /**
       * <pre>
       * Failure code as defined in the Lightning spec
       * </pre>
       *
       * <code>.co.anode.anodium.Failure.FailureCode code = 1;</code>
       * @param value The code to set.
       * @return This builder for chaining.
       */
      public Builder setCodeValue(int value) {
        copyOnWrite();
        instance.setCodeValue(value);
        return this;
      }
      /**
       * <pre>
       * Failure code as defined in the Lightning spec
       * </pre>
       *
       * <code>.co.anode.anodium.Failure.FailureCode code = 1;</code>
       * @return The code.
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Failure.FailureCode getCode() {
        return instance.getCode();
      }
      /**
       * <pre>
       * Failure code as defined in the Lightning spec
       * </pre>
       *
       * <code>.co.anode.anodium.Failure.FailureCode code = 1;</code>
       * @param value The enum numeric value on the wire for code to set.
       * @return This builder for chaining.
       */
      public Builder setCode(co.anode.anodium.Rpc.Failure.FailureCode value) {
        copyOnWrite();
        instance.setCode(value);
        return this;
      }
      /**
       * <pre>
       * Failure code as defined in the Lightning spec
       * </pre>
       *
       * <code>.co.anode.anodium.Failure.FailureCode code = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearCode() {
        copyOnWrite();
        instance.clearCode();
        return this;
      }

      /**
       * <pre>
       * An optional channel update message.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelUpdate channel_update = 3;</code>
       */
      @java.lang.Override
      public boolean hasChannelUpdate() {
        return instance.hasChannelUpdate();
      }
      /**
       * <pre>
       * An optional channel update message.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelUpdate channel_update = 3;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.ChannelUpdate getChannelUpdate() {
        return instance.getChannelUpdate();
      }
      /**
       * <pre>
       * An optional channel update message.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelUpdate channel_update = 3;</code>
       */
      public Builder setChannelUpdate(co.anode.anodium.Rpc.ChannelUpdate value) {
        copyOnWrite();
        instance.setChannelUpdate(value);
        return this;
        }
      /**
       * <pre>
       * An optional channel update message.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelUpdate channel_update = 3;</code>
       */
      public Builder setChannelUpdate(
          co.anode.anodium.Rpc.ChannelUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.setChannelUpdate(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * An optional channel update message.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelUpdate channel_update = 3;</code>
       */
      public Builder mergeChannelUpdate(co.anode.anodium.Rpc.ChannelUpdate value) {
        copyOnWrite();
        instance.mergeChannelUpdate(value);
        return this;
      }
      /**
       * <pre>
       * An optional channel update message.
       * </pre>
       *
       * <code>.co.anode.anodium.ChannelUpdate channel_update = 3;</code>
       */
      public Builder clearChannelUpdate() {  copyOnWrite();
        instance.clearChannelUpdate();
        return this;
      }

      /**
       * <pre>
       * A failure type-dependent htlc value.
       * </pre>
       *
       * <code>uint64 htlc_msat = 4;</code>
       * @return The htlcMsat.
       */
      @java.lang.Override
      public long getHtlcMsat() {
        return instance.getHtlcMsat();
      }
      /**
       * <pre>
       * A failure type-dependent htlc value.
       * </pre>
       *
       * <code>uint64 htlc_msat = 4;</code>
       * @param value The htlcMsat to set.
       * @return This builder for chaining.
       */
      public Builder setHtlcMsat(long value) {
        copyOnWrite();
        instance.setHtlcMsat(value);
        return this;
      }
      /**
       * <pre>
       * A failure type-dependent htlc value.
       * </pre>
       *
       * <code>uint64 htlc_msat = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearHtlcMsat() {
        copyOnWrite();
        instance.clearHtlcMsat();
        return this;
      }

      /**
       * <pre>
       * The sha256 sum of the onion payload.
       * </pre>
       *
       * <code>bytes onion_sha_256 = 5;</code>
       * @return The onionSha256.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getOnionSha256() {
        return instance.getOnionSha256();
      }
      /**
       * <pre>
       * The sha256 sum of the onion payload.
       * </pre>
       *
       * <code>bytes onion_sha_256 = 5;</code>
       * @param value The onionSha256 to set.
       * @return This builder for chaining.
       */
      public Builder setOnionSha256(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setOnionSha256(value);
        return this;
      }
      /**
       * <pre>
       * The sha256 sum of the onion payload.
       * </pre>
       *
       * <code>bytes onion_sha_256 = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearOnionSha256() {
        copyOnWrite();
        instance.clearOnionSha256();
        return this;
      }

      /**
       * <pre>
       * A failure type-dependent cltv expiry value.
       * </pre>
       *
       * <code>uint32 cltv_expiry = 6;</code>
       * @return The cltvExpiry.
       */
      @java.lang.Override
      public int getCltvExpiry() {
        return instance.getCltvExpiry();
      }
      /**
       * <pre>
       * A failure type-dependent cltv expiry value.
       * </pre>
       *
       * <code>uint32 cltv_expiry = 6;</code>
       * @param value The cltvExpiry to set.
       * @return This builder for chaining.
       */
      public Builder setCltvExpiry(int value) {
        copyOnWrite();
        instance.setCltvExpiry(value);
        return this;
      }
      /**
       * <pre>
       * A failure type-dependent cltv expiry value.
       * </pre>
       *
       * <code>uint32 cltv_expiry = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearCltvExpiry() {
        copyOnWrite();
        instance.clearCltvExpiry();
        return this;
      }

      /**
       * <pre>
       * A failure type-dependent flags value.
       * </pre>
       *
       * <code>uint32 flags = 7;</code>
       * @return The flags.
       */
      @java.lang.Override
      public int getFlags() {
        return instance.getFlags();
      }
      /**
       * <pre>
       * A failure type-dependent flags value.
       * </pre>
       *
       * <code>uint32 flags = 7;</code>
       * @param value The flags to set.
       * @return This builder for chaining.
       */
      public Builder setFlags(int value) {
        copyOnWrite();
        instance.setFlags(value);
        return this;
      }
      /**
       * <pre>
       * A failure type-dependent flags value.
       * </pre>
       *
       * <code>uint32 flags = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearFlags() {
        copyOnWrite();
        instance.clearFlags();
        return this;
      }

      /**
       * <pre>
       *The position in the path of the intermediate or final node that generated
       *the failure message. Position zero is the sender node.
       * </pre>
       *
       * <code>uint32 failure_source_index = 8;</code>
       * @return The failureSourceIndex.
       */
      @java.lang.Override
      public int getFailureSourceIndex() {
        return instance.getFailureSourceIndex();
      }
      /**
       * <pre>
       *The position in the path of the intermediate or final node that generated
       *the failure message. Position zero is the sender node.
       * </pre>
       *
       * <code>uint32 failure_source_index = 8;</code>
       * @param value The failureSourceIndex to set.
       * @return This builder for chaining.
       */
      public Builder setFailureSourceIndex(int value) {
        copyOnWrite();
        instance.setFailureSourceIndex(value);
        return this;
      }
      /**
       * <pre>
       *The position in the path of the intermediate or final node that generated
       *the failure message. Position zero is the sender node.
       * </pre>
       *
       * <code>uint32 failure_source_index = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearFailureSourceIndex() {
        copyOnWrite();
        instance.clearFailureSourceIndex();
        return this;
      }

      /**
       * <pre>
       * A failure type-dependent block height.
       * </pre>
       *
       * <code>uint32 height = 9;</code>
       * @return The height.
       */
      @java.lang.Override
      public int getHeight() {
        return instance.getHeight();
      }
      /**
       * <pre>
       * A failure type-dependent block height.
       * </pre>
       *
       * <code>uint32 height = 9;</code>
       * @param value The height to set.
       * @return This builder for chaining.
       */
      public Builder setHeight(int value) {
        copyOnWrite();
        instance.setHeight(value);
        return this;
      }
      /**
       * <pre>
       * A failure type-dependent block height.
       * </pre>
       *
       * <code>uint32 height = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearHeight() {
        copyOnWrite();
        instance.clearHeight();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.Failure)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.Failure();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "code_",
              "channelUpdate_",
              "htlcMsat_",
              "onionSha256_",
              "cltvExpiry_",
              "flags_",
              "failureSourceIndex_",
              "height_",
            };
            java.lang.String info =
                "\u0000\b\u0000\u0000\u0001\t\b\u0000\u0000\u0000\u0001\f\u0003\t\u0004\u0003\u0005" +
                "\n\u0006\u000b\u0007\u000b\b\u000b\t\u000b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.Failure> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.Failure.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.Failure>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.Failure)
    private static final co.anode.anodium.Rpc.Failure DEFAULT_INSTANCE;
    static {
      Failure defaultInstance = new Failure();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Failure.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.Failure getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Failure> PARSER;

    public static com.google.protobuf.Parser<Failure> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ChannelUpdateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.ChannelUpdate)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     *The signature that validates the announced data and proves the ownership
     *of node id.
     * </pre>
     *
     * <code>bytes signature = 1;</code>
     * @return The signature.
     */
    com.google.protobuf.ByteString getSignature();

    /**
     * <pre>
     *The target chain that this channel was opened within. This value
     *should be the genesis hash of the target chain. Along with the short
     *channel ID, this uniquely identifies the channel globally in a
     *blockchain.
     * </pre>
     *
     * <code>bytes chain_hash = 2;</code>
     * @return The chainHash.
     */
    com.google.protobuf.ByteString getChainHash();

    /**
     * <pre>
     *The unique description of the funding transaction.
     * </pre>
     *
     * <code>uint64 chan_id = 3 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    long getChanId();

    /**
     * <pre>
     *A timestamp that allows ordering in the case of multiple announcements.
     *We should ignore the message if timestamp is not greater than the
     *last-received.
     * </pre>
     *
     * <code>uint32 timestamp = 4;</code>
     * @return The timestamp.
     */
    int getTimestamp();

    /**
     * <pre>
     *The bitfield that describes whether optional fields are present in this
     *update. Currently, the least-significant bit must be set to 1 if the
     *optional field MaxHtlc is present.
     * </pre>
     *
     * <code>uint32 message_flags = 10;</code>
     * @return The messageFlags.
     */
    int getMessageFlags();

    /**
     * <pre>
     *The bitfield that describes additional meta-data concerning how the
     *update is to be interpreted. Currently, the least-significant bit must be
     *set to 0 if the creating node corresponds to the first node in the
     *previously sent channel announcement and 1 otherwise. If the second bit
     *is set, then the channel is set to be disabled.
     * </pre>
     *
     * <code>uint32 channel_flags = 5;</code>
     * @return The channelFlags.
     */
    int getChannelFlags();

    /**
     * <pre>
     *The minimum number of blocks this node requires to be added to the expiry
     *of HTLCs. This is a security parameter determined by the node operator.
     *This value represents the required gap between the time locks of the
     *incoming and outgoing HTLC's set to this node.
     * </pre>
     *
     * <code>uint32 time_lock_delta = 6;</code>
     * @return The timeLockDelta.
     */
    int getTimeLockDelta();

    /**
     * <pre>
     *The minimum HTLC value which will be accepted.
     * </pre>
     *
     * <code>uint64 htlc_minimum_msat = 7;</code>
     * @return The htlcMinimumMsat.
     */
    long getHtlcMinimumMsat();

    /**
     * <pre>
     *The base fee that must be used for incoming HTLC's to this particular
     *channel. This value will be tacked onto the required for a payment
     *independent of the size of the payment.
     * </pre>
     *
     * <code>uint32 base_fee = 8;</code>
     * @return The baseFee.
     */
    int getBaseFee();

    /**
     * <pre>
     *The fee rate that will be charged per millionth of a satoshi.
     * </pre>
     *
     * <code>uint32 fee_rate = 9;</code>
     * @return The feeRate.
     */
    int getFeeRate();

    /**
     * <pre>
     *The maximum HTLC value which will be accepted.
     * </pre>
     *
     * <code>uint64 htlc_maximum_msat = 11;</code>
     * @return The htlcMaximumMsat.
     */
    long getHtlcMaximumMsat();

    /**
     * <pre>
     *The set of data that was appended to this message, some of which we may
     *not actually know how to iterate or parse. By holding onto this data, we
     *ensure that we're able to properly validate the set of signatures that
     *cover these new fields, and ensure we're able to make upgrades to the
     *network in a forwards compatible manner.
     * </pre>
     *
     * <code>bytes extra_opaque_data = 12;</code>
     * @return The extraOpaqueData.
     */
    com.google.protobuf.ByteString getExtraOpaqueData();
  }
  /**
   * Protobuf type {@code co.anode.anodium.ChannelUpdate}
   */
  public  static final class ChannelUpdate extends
      com.google.protobuf.GeneratedMessageLite<
          ChannelUpdate, ChannelUpdate.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.ChannelUpdate)
      ChannelUpdateOrBuilder {
    private ChannelUpdate() {
      signature_ = com.google.protobuf.ByteString.EMPTY;
      chainHash_ = com.google.protobuf.ByteString.EMPTY;
      extraOpaqueData_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int SIGNATURE_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString signature_;
    /**
     * <pre>
     *The signature that validates the announced data and proves the ownership
     *of node id.
     * </pre>
     *
     * <code>bytes signature = 1;</code>
     * @return The signature.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSignature() {
      return signature_;
    }
    /**
     * <pre>
     *The signature that validates the announced data and proves the ownership
     *of node id.
     * </pre>
     *
     * <code>bytes signature = 1;</code>
     * @param value The signature to set.
     */
    private void setSignature(com.google.protobuf.ByteString value) {
      value.getClass();
  
      signature_ = value;
    }
    /**
     * <pre>
     *The signature that validates the announced data and proves the ownership
     *of node id.
     * </pre>
     *
     * <code>bytes signature = 1;</code>
     */
    private void clearSignature() {
      
      signature_ = getDefaultInstance().getSignature();
    }

    public static final int CHAIN_HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString chainHash_;
    /**
     * <pre>
     *The target chain that this channel was opened within. This value
     *should be the genesis hash of the target chain. Along with the short
     *channel ID, this uniquely identifies the channel globally in a
     *blockchain.
     * </pre>
     *
     * <code>bytes chain_hash = 2;</code>
     * @return The chainHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getChainHash() {
      return chainHash_;
    }
    /**
     * <pre>
     *The target chain that this channel was opened within. This value
     *should be the genesis hash of the target chain. Along with the short
     *channel ID, this uniquely identifies the channel globally in a
     *blockchain.
     * </pre>
     *
     * <code>bytes chain_hash = 2;</code>
     * @param value The chainHash to set.
     */
    private void setChainHash(com.google.protobuf.ByteString value) {
      value.getClass();
  
      chainHash_ = value;
    }
    /**
     * <pre>
     *The target chain that this channel was opened within. This value
     *should be the genesis hash of the target chain. Along with the short
     *channel ID, this uniquely identifies the channel globally in a
     *blockchain.
     * </pre>
     *
     * <code>bytes chain_hash = 2;</code>
     */
    private void clearChainHash() {
      
      chainHash_ = getDefaultInstance().getChainHash();
    }

    public static final int CHAN_ID_FIELD_NUMBER = 3;
    private long chanId_;
    /**
     * <pre>
     *The unique description of the funding transaction.
     * </pre>
     *
     * <code>uint64 chan_id = 3 [jstype = JS_STRING];</code>
     * @return The chanId.
     */
    @java.lang.Override
    public long getChanId() {
      return chanId_;
    }
    /**
     * <pre>
     *The unique description of the funding transaction.
     * </pre>
     *
     * <code>uint64 chan_id = 3 [jstype = JS_STRING];</code>
     * @param value The chanId to set.
     */
    private void setChanId(long value) {
      
      chanId_ = value;
    }
    /**
     * <pre>
     *The unique description of the funding transaction.
     * </pre>
     *
     * <code>uint64 chan_id = 3 [jstype = JS_STRING];</code>
     */
    private void clearChanId() {
      
      chanId_ = 0L;
    }

    public static final int TIMESTAMP_FIELD_NUMBER = 4;
    private int timestamp_;
    /**
     * <pre>
     *A timestamp that allows ordering in the case of multiple announcements.
     *We should ignore the message if timestamp is not greater than the
     *last-received.
     * </pre>
     *
     * <code>uint32 timestamp = 4;</code>
     * @return The timestamp.
     */
    @java.lang.Override
    public int getTimestamp() {
      return timestamp_;
    }
    /**
     * <pre>
     *A timestamp that allows ordering in the case of multiple announcements.
     *We should ignore the message if timestamp is not greater than the
     *last-received.
     * </pre>
     *
     * <code>uint32 timestamp = 4;</code>
     * @param value The timestamp to set.
     */
    private void setTimestamp(int value) {
      
      timestamp_ = value;
    }
    /**
     * <pre>
     *A timestamp that allows ordering in the case of multiple announcements.
     *We should ignore the message if timestamp is not greater than the
     *last-received.
     * </pre>
     *
     * <code>uint32 timestamp = 4;</code>
     */
    private void clearTimestamp() {
      
      timestamp_ = 0;
    }

    public static final int MESSAGE_FLAGS_FIELD_NUMBER = 10;
    private int messageFlags_;
    /**
     * <pre>
     *The bitfield that describes whether optional fields are present in this
     *update. Currently, the least-significant bit must be set to 1 if the
     *optional field MaxHtlc is present.
     * </pre>
     *
     * <code>uint32 message_flags = 10;</code>
     * @return The messageFlags.
     */
    @java.lang.Override
    public int getMessageFlags() {
      return messageFlags_;
    }
    /**
     * <pre>
     *The bitfield that describes whether optional fields are present in this
     *update. Currently, the least-significant bit must be set to 1 if the
     *optional field MaxHtlc is present.
     * </pre>
     *
     * <code>uint32 message_flags = 10;</code>
     * @param value The messageFlags to set.
     */
    private void setMessageFlags(int value) {
      
      messageFlags_ = value;
    }
    /**
     * <pre>
     *The bitfield that describes whether optional fields are present in this
     *update. Currently, the least-significant bit must be set to 1 if the
     *optional field MaxHtlc is present.
     * </pre>
     *
     * <code>uint32 message_flags = 10;</code>
     */
    private void clearMessageFlags() {
      
      messageFlags_ = 0;
    }

    public static final int CHANNEL_FLAGS_FIELD_NUMBER = 5;
    private int channelFlags_;
    /**
     * <pre>
     *The bitfield that describes additional meta-data concerning how the
     *update is to be interpreted. Currently, the least-significant bit must be
     *set to 0 if the creating node corresponds to the first node in the
     *previously sent channel announcement and 1 otherwise. If the second bit
     *is set, then the channel is set to be disabled.
     * </pre>
     *
     * <code>uint32 channel_flags = 5;</code>
     * @return The channelFlags.
     */
    @java.lang.Override
    public int getChannelFlags() {
      return channelFlags_;
    }
    /**
     * <pre>
     *The bitfield that describes additional meta-data concerning how the
     *update is to be interpreted. Currently, the least-significant bit must be
     *set to 0 if the creating node corresponds to the first node in the
     *previously sent channel announcement and 1 otherwise. If the second bit
     *is set, then the channel is set to be disabled.
     * </pre>
     *
     * <code>uint32 channel_flags = 5;</code>
     * @param value The channelFlags to set.
     */
    private void setChannelFlags(int value) {
      
      channelFlags_ = value;
    }
    /**
     * <pre>
     *The bitfield that describes additional meta-data concerning how the
     *update is to be interpreted. Currently, the least-significant bit must be
     *set to 0 if the creating node corresponds to the first node in the
     *previously sent channel announcement and 1 otherwise. If the second bit
     *is set, then the channel is set to be disabled.
     * </pre>
     *
     * <code>uint32 channel_flags = 5;</code>
     */
    private void clearChannelFlags() {
      
      channelFlags_ = 0;
    }

    public static final int TIME_LOCK_DELTA_FIELD_NUMBER = 6;
    private int timeLockDelta_;
    /**
     * <pre>
     *The minimum number of blocks this node requires to be added to the expiry
     *of HTLCs. This is a security parameter determined by the node operator.
     *This value represents the required gap between the time locks of the
     *incoming and outgoing HTLC's set to this node.
     * </pre>
     *
     * <code>uint32 time_lock_delta = 6;</code>
     * @return The timeLockDelta.
     */
    @java.lang.Override
    public int getTimeLockDelta() {
      return timeLockDelta_;
    }
    /**
     * <pre>
     *The minimum number of blocks this node requires to be added to the expiry
     *of HTLCs. This is a security parameter determined by the node operator.
     *This value represents the required gap between the time locks of the
     *incoming and outgoing HTLC's set to this node.
     * </pre>
     *
     * <code>uint32 time_lock_delta = 6;</code>
     * @param value The timeLockDelta to set.
     */
    private void setTimeLockDelta(int value) {
      
      timeLockDelta_ = value;
    }
    /**
     * <pre>
     *The minimum number of blocks this node requires to be added to the expiry
     *of HTLCs. This is a security parameter determined by the node operator.
     *This value represents the required gap between the time locks of the
     *incoming and outgoing HTLC's set to this node.
     * </pre>
     *
     * <code>uint32 time_lock_delta = 6;</code>
     */
    private void clearTimeLockDelta() {
      
      timeLockDelta_ = 0;
    }

    public static final int HTLC_MINIMUM_MSAT_FIELD_NUMBER = 7;
    private long htlcMinimumMsat_;
    /**
     * <pre>
     *The minimum HTLC value which will be accepted.
     * </pre>
     *
     * <code>uint64 htlc_minimum_msat = 7;</code>
     * @return The htlcMinimumMsat.
     */
    @java.lang.Override
    public long getHtlcMinimumMsat() {
      return htlcMinimumMsat_;
    }
    /**
     * <pre>
     *The minimum HTLC value which will be accepted.
     * </pre>
     *
     * <code>uint64 htlc_minimum_msat = 7;</code>
     * @param value The htlcMinimumMsat to set.
     */
    private void setHtlcMinimumMsat(long value) {
      
      htlcMinimumMsat_ = value;
    }
    /**
     * <pre>
     *The minimum HTLC value which will be accepted.
     * </pre>
     *
     * <code>uint64 htlc_minimum_msat = 7;</code>
     */
    private void clearHtlcMinimumMsat() {
      
      htlcMinimumMsat_ = 0L;
    }

    public static final int BASE_FEE_FIELD_NUMBER = 8;
    private int baseFee_;
    /**
     * <pre>
     *The base fee that must be used for incoming HTLC's to this particular
     *channel. This value will be tacked onto the required for a payment
     *independent of the size of the payment.
     * </pre>
     *
     * <code>uint32 base_fee = 8;</code>
     * @return The baseFee.
     */
    @java.lang.Override
    public int getBaseFee() {
      return baseFee_;
    }
    /**
     * <pre>
     *The base fee that must be used for incoming HTLC's to this particular
     *channel. This value will be tacked onto the required for a payment
     *independent of the size of the payment.
     * </pre>
     *
     * <code>uint32 base_fee = 8;</code>
     * @param value The baseFee to set.
     */
    private void setBaseFee(int value) {
      
      baseFee_ = value;
    }
    /**
     * <pre>
     *The base fee that must be used for incoming HTLC's to this particular
     *channel. This value will be tacked onto the required for a payment
     *independent of the size of the payment.
     * </pre>
     *
     * <code>uint32 base_fee = 8;</code>
     */
    private void clearBaseFee() {
      
      baseFee_ = 0;
    }

    public static final int FEE_RATE_FIELD_NUMBER = 9;
    private int feeRate_;
    /**
     * <pre>
     *The fee rate that will be charged per millionth of a satoshi.
     * </pre>
     *
     * <code>uint32 fee_rate = 9;</code>
     * @return The feeRate.
     */
    @java.lang.Override
    public int getFeeRate() {
      return feeRate_;
    }
    /**
     * <pre>
     *The fee rate that will be charged per millionth of a satoshi.
     * </pre>
     *
     * <code>uint32 fee_rate = 9;</code>
     * @param value The feeRate to set.
     */
    private void setFeeRate(int value) {
      
      feeRate_ = value;
    }
    /**
     * <pre>
     *The fee rate that will be charged per millionth of a satoshi.
     * </pre>
     *
     * <code>uint32 fee_rate = 9;</code>
     */
    private void clearFeeRate() {
      
      feeRate_ = 0;
    }

    public static final int HTLC_MAXIMUM_MSAT_FIELD_NUMBER = 11;
    private long htlcMaximumMsat_;
    /**
     * <pre>
     *The maximum HTLC value which will be accepted.
     * </pre>
     *
     * <code>uint64 htlc_maximum_msat = 11;</code>
     * @return The htlcMaximumMsat.
     */
    @java.lang.Override
    public long getHtlcMaximumMsat() {
      return htlcMaximumMsat_;
    }
    /**
     * <pre>
     *The maximum HTLC value which will be accepted.
     * </pre>
     *
     * <code>uint64 htlc_maximum_msat = 11;</code>
     * @param value The htlcMaximumMsat to set.
     */
    private void setHtlcMaximumMsat(long value) {
      
      htlcMaximumMsat_ = value;
    }
    /**
     * <pre>
     *The maximum HTLC value which will be accepted.
     * </pre>
     *
     * <code>uint64 htlc_maximum_msat = 11;</code>
     */
    private void clearHtlcMaximumMsat() {
      
      htlcMaximumMsat_ = 0L;
    }

    public static final int EXTRA_OPAQUE_DATA_FIELD_NUMBER = 12;
    private com.google.protobuf.ByteString extraOpaqueData_;
    /**
     * <pre>
     *The set of data that was appended to this message, some of which we may
     *not actually know how to iterate or parse. By holding onto this data, we
     *ensure that we're able to properly validate the set of signatures that
     *cover these new fields, and ensure we're able to make upgrades to the
     *network in a forwards compatible manner.
     * </pre>
     *
     * <code>bytes extra_opaque_data = 12;</code>
     * @return The extraOpaqueData.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getExtraOpaqueData() {
      return extraOpaqueData_;
    }
    /**
     * <pre>
     *The set of data that was appended to this message, some of which we may
     *not actually know how to iterate or parse. By holding onto this data, we
     *ensure that we're able to properly validate the set of signatures that
     *cover these new fields, and ensure we're able to make upgrades to the
     *network in a forwards compatible manner.
     * </pre>
     *
     * <code>bytes extra_opaque_data = 12;</code>
     * @param value The extraOpaqueData to set.
     */
    private void setExtraOpaqueData(com.google.protobuf.ByteString value) {
      value.getClass();
  
      extraOpaqueData_ = value;
    }
    /**
     * <pre>
     *The set of data that was appended to this message, some of which we may
     *not actually know how to iterate or parse. By holding onto this data, we
     *ensure that we're able to properly validate the set of signatures that
     *cover these new fields, and ensure we're able to make upgrades to the
     *network in a forwards compatible manner.
     * </pre>
     *
     * <code>bytes extra_opaque_data = 12;</code>
     */
    private void clearExtraOpaqueData() {
      
      extraOpaqueData_ = getDefaultInstance().getExtraOpaqueData();
    }

    public static co.anode.anodium.Rpc.ChannelUpdate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelUpdate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelUpdate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelUpdate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelUpdate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.ChannelUpdate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelUpdate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelUpdate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelUpdate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelUpdate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.ChannelUpdate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.ChannelUpdate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.ChannelUpdate prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.ChannelUpdate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.ChannelUpdate, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.ChannelUpdate)
        co.anode.anodium.Rpc.ChannelUpdateOrBuilder {
      // Construct using co.anode.anodium.Rpc.ChannelUpdate.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       *The signature that validates the announced data and proves the ownership
       *of node id.
       * </pre>
       *
       * <code>bytes signature = 1;</code>
       * @return The signature.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSignature() {
        return instance.getSignature();
      }
      /**
       * <pre>
       *The signature that validates the announced data and proves the ownership
       *of node id.
       * </pre>
       *
       * <code>bytes signature = 1;</code>
       * @param value The signature to set.
       * @return This builder for chaining.
       */
      public Builder setSignature(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSignature(value);
        return this;
      }
      /**
       * <pre>
       *The signature that validates the announced data and proves the ownership
       *of node id.
       * </pre>
       *
       * <code>bytes signature = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignature() {
        copyOnWrite();
        instance.clearSignature();
        return this;
      }

      /**
       * <pre>
       *The target chain that this channel was opened within. This value
       *should be the genesis hash of the target chain. Along with the short
       *channel ID, this uniquely identifies the channel globally in a
       *blockchain.
       * </pre>
       *
       * <code>bytes chain_hash = 2;</code>
       * @return The chainHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getChainHash() {
        return instance.getChainHash();
      }
      /**
       * <pre>
       *The target chain that this channel was opened within. This value
       *should be the genesis hash of the target chain. Along with the short
       *channel ID, this uniquely identifies the channel globally in a
       *blockchain.
       * </pre>
       *
       * <code>bytes chain_hash = 2;</code>
       * @param value The chainHash to set.
       * @return This builder for chaining.
       */
      public Builder setChainHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setChainHash(value);
        return this;
      }
      /**
       * <pre>
       *The target chain that this channel was opened within. This value
       *should be the genesis hash of the target chain. Along with the short
       *channel ID, this uniquely identifies the channel globally in a
       *blockchain.
       * </pre>
       *
       * <code>bytes chain_hash = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearChainHash() {
        copyOnWrite();
        instance.clearChainHash();
        return this;
      }

      /**
       * <pre>
       *The unique description of the funding transaction.
       * </pre>
       *
       * <code>uint64 chan_id = 3 [jstype = JS_STRING];</code>
       * @return The chanId.
       */
      @java.lang.Override
      public long getChanId() {
        return instance.getChanId();
      }
      /**
       * <pre>
       *The unique description of the funding transaction.
       * </pre>
       *
       * <code>uint64 chan_id = 3 [jstype = JS_STRING];</code>
       * @param value The chanId to set.
       * @return This builder for chaining.
       */
      public Builder setChanId(long value) {
        copyOnWrite();
        instance.setChanId(value);
        return this;
      }
      /**
       * <pre>
       *The unique description of the funding transaction.
       * </pre>
       *
       * <code>uint64 chan_id = 3 [jstype = JS_STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearChanId() {
        copyOnWrite();
        instance.clearChanId();
        return this;
      }

      /**
       * <pre>
       *A timestamp that allows ordering in the case of multiple announcements.
       *We should ignore the message if timestamp is not greater than the
       *last-received.
       * </pre>
       *
       * <code>uint32 timestamp = 4;</code>
       * @return The timestamp.
       */
      @java.lang.Override
      public int getTimestamp() {
        return instance.getTimestamp();
      }
      /**
       * <pre>
       *A timestamp that allows ordering in the case of multiple announcements.
       *We should ignore the message if timestamp is not greater than the
       *last-received.
       * </pre>
       *
       * <code>uint32 timestamp = 4;</code>
       * @param value The timestamp to set.
       * @return This builder for chaining.
       */
      public Builder setTimestamp(int value) {
        copyOnWrite();
        instance.setTimestamp(value);
        return this;
      }
      /**
       * <pre>
       *A timestamp that allows ordering in the case of multiple announcements.
       *We should ignore the message if timestamp is not greater than the
       *last-received.
       * </pre>
       *
       * <code>uint32 timestamp = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimestamp() {
        copyOnWrite();
        instance.clearTimestamp();
        return this;
      }

      /**
       * <pre>
       *The bitfield that describes whether optional fields are present in this
       *update. Currently, the least-significant bit must be set to 1 if the
       *optional field MaxHtlc is present.
       * </pre>
       *
       * <code>uint32 message_flags = 10;</code>
       * @return The messageFlags.
       */
      @java.lang.Override
      public int getMessageFlags() {
        return instance.getMessageFlags();
      }
      /**
       * <pre>
       *The bitfield that describes whether optional fields are present in this
       *update. Currently, the least-significant bit must be set to 1 if the
       *optional field MaxHtlc is present.
       * </pre>
       *
       * <code>uint32 message_flags = 10;</code>
       * @param value The messageFlags to set.
       * @return This builder for chaining.
       */
      public Builder setMessageFlags(int value) {
        copyOnWrite();
        instance.setMessageFlags(value);
        return this;
      }
      /**
       * <pre>
       *The bitfield that describes whether optional fields are present in this
       *update. Currently, the least-significant bit must be set to 1 if the
       *optional field MaxHtlc is present.
       * </pre>
       *
       * <code>uint32 message_flags = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearMessageFlags() {
        copyOnWrite();
        instance.clearMessageFlags();
        return this;
      }

      /**
       * <pre>
       *The bitfield that describes additional meta-data concerning how the
       *update is to be interpreted. Currently, the least-significant bit must be
       *set to 0 if the creating node corresponds to the first node in the
       *previously sent channel announcement and 1 otherwise. If the second bit
       *is set, then the channel is set to be disabled.
       * </pre>
       *
       * <code>uint32 channel_flags = 5;</code>
       * @return The channelFlags.
       */
      @java.lang.Override
      public int getChannelFlags() {
        return instance.getChannelFlags();
      }
      /**
       * <pre>
       *The bitfield that describes additional meta-data concerning how the
       *update is to be interpreted. Currently, the least-significant bit must be
       *set to 0 if the creating node corresponds to the first node in the
       *previously sent channel announcement and 1 otherwise. If the second bit
       *is set, then the channel is set to be disabled.
       * </pre>
       *
       * <code>uint32 channel_flags = 5;</code>
       * @param value The channelFlags to set.
       * @return This builder for chaining.
       */
      public Builder setChannelFlags(int value) {
        copyOnWrite();
        instance.setChannelFlags(value);
        return this;
      }
      /**
       * <pre>
       *The bitfield that describes additional meta-data concerning how the
       *update is to be interpreted. Currently, the least-significant bit must be
       *set to 0 if the creating node corresponds to the first node in the
       *previously sent channel announcement and 1 otherwise. If the second bit
       *is set, then the channel is set to be disabled.
       * </pre>
       *
       * <code>uint32 channel_flags = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearChannelFlags() {
        copyOnWrite();
        instance.clearChannelFlags();
        return this;
      }

      /**
       * <pre>
       *The minimum number of blocks this node requires to be added to the expiry
       *of HTLCs. This is a security parameter determined by the node operator.
       *This value represents the required gap between the time locks of the
       *incoming and outgoing HTLC's set to this node.
       * </pre>
       *
       * <code>uint32 time_lock_delta = 6;</code>
       * @return The timeLockDelta.
       */
      @java.lang.Override
      public int getTimeLockDelta() {
        return instance.getTimeLockDelta();
      }
      /**
       * <pre>
       *The minimum number of blocks this node requires to be added to the expiry
       *of HTLCs. This is a security parameter determined by the node operator.
       *This value represents the required gap between the time locks of the
       *incoming and outgoing HTLC's set to this node.
       * </pre>
       *
       * <code>uint32 time_lock_delta = 6;</code>
       * @param value The timeLockDelta to set.
       * @return This builder for chaining.
       */
      public Builder setTimeLockDelta(int value) {
        copyOnWrite();
        instance.setTimeLockDelta(value);
        return this;
      }
      /**
       * <pre>
       *The minimum number of blocks this node requires to be added to the expiry
       *of HTLCs. This is a security parameter determined by the node operator.
       *This value represents the required gap between the time locks of the
       *incoming and outgoing HTLC's set to this node.
       * </pre>
       *
       * <code>uint32 time_lock_delta = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimeLockDelta() {
        copyOnWrite();
        instance.clearTimeLockDelta();
        return this;
      }

      /**
       * <pre>
       *The minimum HTLC value which will be accepted.
       * </pre>
       *
       * <code>uint64 htlc_minimum_msat = 7;</code>
       * @return The htlcMinimumMsat.
       */
      @java.lang.Override
      public long getHtlcMinimumMsat() {
        return instance.getHtlcMinimumMsat();
      }
      /**
       * <pre>
       *The minimum HTLC value which will be accepted.
       * </pre>
       *
       * <code>uint64 htlc_minimum_msat = 7;</code>
       * @param value The htlcMinimumMsat to set.
       * @return This builder for chaining.
       */
      public Builder setHtlcMinimumMsat(long value) {
        copyOnWrite();
        instance.setHtlcMinimumMsat(value);
        return this;
      }
      /**
       * <pre>
       *The minimum HTLC value which will be accepted.
       * </pre>
       *
       * <code>uint64 htlc_minimum_msat = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearHtlcMinimumMsat() {
        copyOnWrite();
        instance.clearHtlcMinimumMsat();
        return this;
      }

      /**
       * <pre>
       *The base fee that must be used for incoming HTLC's to this particular
       *channel. This value will be tacked onto the required for a payment
       *independent of the size of the payment.
       * </pre>
       *
       * <code>uint32 base_fee = 8;</code>
       * @return The baseFee.
       */
      @java.lang.Override
      public int getBaseFee() {
        return instance.getBaseFee();
      }
      /**
       * <pre>
       *The base fee that must be used for incoming HTLC's to this particular
       *channel. This value will be tacked onto the required for a payment
       *independent of the size of the payment.
       * </pre>
       *
       * <code>uint32 base_fee = 8;</code>
       * @param value The baseFee to set.
       * @return This builder for chaining.
       */
      public Builder setBaseFee(int value) {
        copyOnWrite();
        instance.setBaseFee(value);
        return this;
      }
      /**
       * <pre>
       *The base fee that must be used for incoming HTLC's to this particular
       *channel. This value will be tacked onto the required for a payment
       *independent of the size of the payment.
       * </pre>
       *
       * <code>uint32 base_fee = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearBaseFee() {
        copyOnWrite();
        instance.clearBaseFee();
        return this;
      }

      /**
       * <pre>
       *The fee rate that will be charged per millionth of a satoshi.
       * </pre>
       *
       * <code>uint32 fee_rate = 9;</code>
       * @return The feeRate.
       */
      @java.lang.Override
      public int getFeeRate() {
        return instance.getFeeRate();
      }
      /**
       * <pre>
       *The fee rate that will be charged per millionth of a satoshi.
       * </pre>
       *
       * <code>uint32 fee_rate = 9;</code>
       * @param value The feeRate to set.
       * @return This builder for chaining.
       */
      public Builder setFeeRate(int value) {
        copyOnWrite();
        instance.setFeeRate(value);
        return this;
      }
      /**
       * <pre>
       *The fee rate that will be charged per millionth of a satoshi.
       * </pre>
       *
       * <code>uint32 fee_rate = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearFeeRate() {
        copyOnWrite();
        instance.clearFeeRate();
        return this;
      }

      /**
       * <pre>
       *The maximum HTLC value which will be accepted.
       * </pre>
       *
       * <code>uint64 htlc_maximum_msat = 11;</code>
       * @return The htlcMaximumMsat.
       */
      @java.lang.Override
      public long getHtlcMaximumMsat() {
        return instance.getHtlcMaximumMsat();
      }
      /**
       * <pre>
       *The maximum HTLC value which will be accepted.
       * </pre>
       *
       * <code>uint64 htlc_maximum_msat = 11;</code>
       * @param value The htlcMaximumMsat to set.
       * @return This builder for chaining.
       */
      public Builder setHtlcMaximumMsat(long value) {
        copyOnWrite();
        instance.setHtlcMaximumMsat(value);
        return this;
      }
      /**
       * <pre>
       *The maximum HTLC value which will be accepted.
       * </pre>
       *
       * <code>uint64 htlc_maximum_msat = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearHtlcMaximumMsat() {
        copyOnWrite();
        instance.clearHtlcMaximumMsat();
        return this;
      }

      /**
       * <pre>
       *The set of data that was appended to this message, some of which we may
       *not actually know how to iterate or parse. By holding onto this data, we
       *ensure that we're able to properly validate the set of signatures that
       *cover these new fields, and ensure we're able to make upgrades to the
       *network in a forwards compatible manner.
       * </pre>
       *
       * <code>bytes extra_opaque_data = 12;</code>
       * @return The extraOpaqueData.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getExtraOpaqueData() {
        return instance.getExtraOpaqueData();
      }
      /**
       * <pre>
       *The set of data that was appended to this message, some of which we may
       *not actually know how to iterate or parse. By holding onto this data, we
       *ensure that we're able to properly validate the set of signatures that
       *cover these new fields, and ensure we're able to make upgrades to the
       *network in a forwards compatible manner.
       * </pre>
       *
       * <code>bytes extra_opaque_data = 12;</code>
       * @param value The extraOpaqueData to set.
       * @return This builder for chaining.
       */
      public Builder setExtraOpaqueData(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setExtraOpaqueData(value);
        return this;
      }
      /**
       * <pre>
       *The set of data that was appended to this message, some of which we may
       *not actually know how to iterate or parse. By holding onto this data, we
       *ensure that we're able to properly validate the set of signatures that
       *cover these new fields, and ensure we're able to make upgrades to the
       *network in a forwards compatible manner.
       * </pre>
       *
       * <code>bytes extra_opaque_data = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearExtraOpaqueData() {
        copyOnWrite();
        instance.clearExtraOpaqueData();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.ChannelUpdate)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.ChannelUpdate();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "signature_",
              "chainHash_",
              "chanId_",
              "timestamp_",
              "channelFlags_",
              "timeLockDelta_",
              "htlcMinimumMsat_",
              "baseFee_",
              "feeRate_",
              "messageFlags_",
              "htlcMaximumMsat_",
              "extraOpaqueData_",
            };
            java.lang.String info =
                "\u0000\f\u0000\u0000\u0001\f\f\u0000\u0000\u0000\u0001\n\u0002\n\u0003\u0003\u0004" +
                "\u000b\u0005\u000b\u0006\u000b\u0007\u0003\b\u000b\t\u000b\n\u000b\u000b\u0003\f" +
                "\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.ChannelUpdate> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.ChannelUpdate.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.ChannelUpdate>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.ChannelUpdate)
    private static final co.anode.anodium.Rpc.ChannelUpdate DEFAULT_INSTANCE;
    static {
      ChannelUpdate defaultInstance = new ChannelUpdate();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ChannelUpdate.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.ChannelUpdate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ChannelUpdate> PARSER;

    public static com.google.protobuf.Parser<ChannelUpdate> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface MacaroonIdOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.MacaroonId)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>bytes nonce = 1;</code>
     * @return The nonce.
     */
    com.google.protobuf.ByteString getNonce();

    /**
     * <code>bytes storageId = 2;</code>
     * @return The storageId.
     */
    com.google.protobuf.ByteString getStorageId();

    /**
     * <code>repeated .co.anode.anodium.Op ops = 3;</code>
     */
    java.util.List<co.anode.anodium.Rpc.Op> 
        getOpsList();
    /**
     * <code>repeated .co.anode.anodium.Op ops = 3;</code>
     */
    co.anode.anodium.Rpc.Op getOps(int index);
    /**
     * <code>repeated .co.anode.anodium.Op ops = 3;</code>
     */
    int getOpsCount();
  }
  /**
   * Protobuf type {@code co.anode.anodium.MacaroonId}
   */
  public  static final class MacaroonId extends
      com.google.protobuf.GeneratedMessageLite<
          MacaroonId, MacaroonId.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.MacaroonId)
      MacaroonIdOrBuilder {
    private MacaroonId() {
      nonce_ = com.google.protobuf.ByteString.EMPTY;
      storageId_ = com.google.protobuf.ByteString.EMPTY;
      ops_ = emptyProtobufList();
    }
    public static final int NONCE_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString nonce_;
    /**
     * <code>bytes nonce = 1;</code>
     * @return The nonce.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getNonce() {
      return nonce_;
    }
    /**
     * <code>bytes nonce = 1;</code>
     * @param value The nonce to set.
     */
    private void setNonce(com.google.protobuf.ByteString value) {
      value.getClass();
  
      nonce_ = value;
    }
    /**
     * <code>bytes nonce = 1;</code>
     */
    private void clearNonce() {
      
      nonce_ = getDefaultInstance().getNonce();
    }

    public static final int STORAGEID_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString storageId_;
    /**
     * <code>bytes storageId = 2;</code>
     * @return The storageId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getStorageId() {
      return storageId_;
    }
    /**
     * <code>bytes storageId = 2;</code>
     * @param value The storageId to set.
     */
    private void setStorageId(com.google.protobuf.ByteString value) {
      value.getClass();
  
      storageId_ = value;
    }
    /**
     * <code>bytes storageId = 2;</code>
     */
    private void clearStorageId() {
      
      storageId_ = getDefaultInstance().getStorageId();
    }

    public static final int OPS_FIELD_NUMBER = 3;
    private com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Op> ops_;
    /**
     * <code>repeated .co.anode.anodium.Op ops = 3;</code>
     */
    @java.lang.Override
    public java.util.List<co.anode.anodium.Rpc.Op> getOpsList() {
      return ops_;
    }
    /**
     * <code>repeated .co.anode.anodium.Op ops = 3;</code>
     */
    public java.util.List<? extends co.anode.anodium.Rpc.OpOrBuilder> 
        getOpsOrBuilderList() {
      return ops_;
    }
    /**
     * <code>repeated .co.anode.anodium.Op ops = 3;</code>
     */
    @java.lang.Override
    public int getOpsCount() {
      return ops_.size();
    }
    /**
     * <code>repeated .co.anode.anodium.Op ops = 3;</code>
     */
    @java.lang.Override
    public co.anode.anodium.Rpc.Op getOps(int index) {
      return ops_.get(index);
    }
    /**
     * <code>repeated .co.anode.anodium.Op ops = 3;</code>
     */
    public co.anode.anodium.Rpc.OpOrBuilder getOpsOrBuilder(
        int index) {
      return ops_.get(index);
    }
    private void ensureOpsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<co.anode.anodium.Rpc.Op> tmp = ops_;
      if (!tmp.isModifiable()) {
        ops_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .co.anode.anodium.Op ops = 3;</code>
     */
    private void setOps(
        int index, co.anode.anodium.Rpc.Op value) {
      value.getClass();
  ensureOpsIsMutable();
      ops_.set(index, value);
    }
    /**
     * <code>repeated .co.anode.anodium.Op ops = 3;</code>
     */
    private void addOps(co.anode.anodium.Rpc.Op value) {
      value.getClass();
  ensureOpsIsMutable();
      ops_.add(value);
    }
    /**
     * <code>repeated .co.anode.anodium.Op ops = 3;</code>
     */
    private void addOps(
        int index, co.anode.anodium.Rpc.Op value) {
      value.getClass();
  ensureOpsIsMutable();
      ops_.add(index, value);
    }
    /**
     * <code>repeated .co.anode.anodium.Op ops = 3;</code>
     */
    private void addAllOps(
        java.lang.Iterable<? extends co.anode.anodium.Rpc.Op> values) {
      ensureOpsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, ops_);
    }
    /**
     * <code>repeated .co.anode.anodium.Op ops = 3;</code>
     */
    private void clearOps() {
      ops_ = emptyProtobufList();
    }
    /**
     * <code>repeated .co.anode.anodium.Op ops = 3;</code>
     */
    private void removeOps(int index) {
      ensureOpsIsMutable();
      ops_.remove(index);
    }

    public static co.anode.anodium.Rpc.MacaroonId parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.MacaroonId parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MacaroonId parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.MacaroonId parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MacaroonId parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.MacaroonId parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MacaroonId parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.MacaroonId parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MacaroonId parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.MacaroonId parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.MacaroonId parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.MacaroonId parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.MacaroonId prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.MacaroonId}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.MacaroonId, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.MacaroonId)
        co.anode.anodium.Rpc.MacaroonIdOrBuilder {
      // Construct using co.anode.anodium.Rpc.MacaroonId.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>bytes nonce = 1;</code>
       * @return The nonce.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getNonce() {
        return instance.getNonce();
      }
      /**
       * <code>bytes nonce = 1;</code>
       * @param value The nonce to set.
       * @return This builder for chaining.
       */
      public Builder setNonce(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNonce(value);
        return this;
      }
      /**
       * <code>bytes nonce = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearNonce() {
        copyOnWrite();
        instance.clearNonce();
        return this;
      }

      /**
       * <code>bytes storageId = 2;</code>
       * @return The storageId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getStorageId() {
        return instance.getStorageId();
      }
      /**
       * <code>bytes storageId = 2;</code>
       * @param value The storageId to set.
       * @return This builder for chaining.
       */
      public Builder setStorageId(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setStorageId(value);
        return this;
      }
      /**
       * <code>bytes storageId = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearStorageId() {
        copyOnWrite();
        instance.clearStorageId();
        return this;
      }

      /**
       * <code>repeated .co.anode.anodium.Op ops = 3;</code>
       */
      @java.lang.Override
      public java.util.List<co.anode.anodium.Rpc.Op> getOpsList() {
        return java.util.Collections.unmodifiableList(
            instance.getOpsList());
      }
      /**
       * <code>repeated .co.anode.anodium.Op ops = 3;</code>
       */
      @java.lang.Override
      public int getOpsCount() {
        return instance.getOpsCount();
      }/**
       * <code>repeated .co.anode.anodium.Op ops = 3;</code>
       */
      @java.lang.Override
      public co.anode.anodium.Rpc.Op getOps(int index) {
        return instance.getOps(index);
      }
      /**
       * <code>repeated .co.anode.anodium.Op ops = 3;</code>
       */
      public Builder setOps(
          int index, co.anode.anodium.Rpc.Op value) {
        copyOnWrite();
        instance.setOps(index, value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.Op ops = 3;</code>
       */
      public Builder setOps(
          int index, co.anode.anodium.Rpc.Op.Builder builderForValue) {
        copyOnWrite();
        instance.setOps(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.Op ops = 3;</code>
       */
      public Builder addOps(co.anode.anodium.Rpc.Op value) {
        copyOnWrite();
        instance.addOps(value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.Op ops = 3;</code>
       */
      public Builder addOps(
          int index, co.anode.anodium.Rpc.Op value) {
        copyOnWrite();
        instance.addOps(index, value);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.Op ops = 3;</code>
       */
      public Builder addOps(
          co.anode.anodium.Rpc.Op.Builder builderForValue) {
        copyOnWrite();
        instance.addOps(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.Op ops = 3;</code>
       */
      public Builder addOps(
          int index, co.anode.anodium.Rpc.Op.Builder builderForValue) {
        copyOnWrite();
        instance.addOps(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.Op ops = 3;</code>
       */
      public Builder addAllOps(
          java.lang.Iterable<? extends co.anode.anodium.Rpc.Op> values) {
        copyOnWrite();
        instance.addAllOps(values);
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.Op ops = 3;</code>
       */
      public Builder clearOps() {
        copyOnWrite();
        instance.clearOps();
        return this;
      }
      /**
       * <code>repeated .co.anode.anodium.Op ops = 3;</code>
       */
      public Builder removeOps(int index) {
        copyOnWrite();
        instance.removeOps(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.MacaroonId)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.MacaroonId();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "nonce_",
              "storageId_",
              "ops_",
              co.anode.anodium.Rpc.Op.class,
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0003\u0003\u0000\u0001\u0000\u0001\n\u0002\n\u0003" +
                "\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.MacaroonId> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.MacaroonId.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.MacaroonId>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.MacaroonId)
    private static final co.anode.anodium.Rpc.MacaroonId DEFAULT_INSTANCE;
    static {
      MacaroonId defaultInstance = new MacaroonId();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        MacaroonId.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.MacaroonId getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<MacaroonId> PARSER;

    public static com.google.protobuf.Parser<MacaroonId> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface OpOrBuilder extends
      // @@protoc_insertion_point(interface_extends:co.anode.anodium.Op)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>string entity = 1;</code>
     * @return The entity.
     */
    java.lang.String getEntity();
    /**
     * <code>string entity = 1;</code>
     * @return The bytes for entity.
     */
    com.google.protobuf.ByteString
        getEntityBytes();

    /**
     * <code>repeated string actions = 2;</code>
     * @return A list containing the actions.
     */
    java.util.List<java.lang.String>
        getActionsList();
    /**
     * <code>repeated string actions = 2;</code>
     * @return The count of actions.
     */
    int getActionsCount();
    /**
     * <code>repeated string actions = 2;</code>
     * @param index The index of the element to return.
     * @return The actions at the given index.
     */
    java.lang.String getActions(int index);
    /**
     * <code>repeated string actions = 2;</code>
     * @param index The index of the element to return.
     * @return The actions at the given index.
     */
    com.google.protobuf.ByteString
        getActionsBytes(int index);
  }
  /**
   * Protobuf type {@code co.anode.anodium.Op}
   */
  public  static final class Op extends
      com.google.protobuf.GeneratedMessageLite<
          Op, Op.Builder> implements
      // @@protoc_insertion_point(message_implements:co.anode.anodium.Op)
      OpOrBuilder {
    private Op() {
      entity_ = "";
      actions_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    public static final int ENTITY_FIELD_NUMBER = 1;
    private java.lang.String entity_;
    /**
     * <code>string entity = 1;</code>
     * @return The entity.
     */
    @java.lang.Override
    public java.lang.String getEntity() {
      return entity_;
    }
    /**
     * <code>string entity = 1;</code>
     * @return The bytes for entity.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getEntityBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(entity_);
    }
    /**
     * <code>string entity = 1;</code>
     * @param value The entity to set.
     */
    private void setEntity(
        java.lang.String value) {
      value.getClass();
  
      entity_ = value;
    }
    /**
     * <code>string entity = 1;</code>
     */
    private void clearEntity() {
      
      entity_ = getDefaultInstance().getEntity();
    }
    /**
     * <code>string entity = 1;</code>
     * @param value The bytes for entity to set.
     */
    private void setEntityBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      entity_ = value.toStringUtf8();
      
    }

    public static final int ACTIONS_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<java.lang.String> actions_;
    /**
     * <code>repeated string actions = 2;</code>
     * @return A list containing the actions.
     */
    @java.lang.Override
    public java.util.List<java.lang.String> getActionsList() {
      return actions_;
    }
    /**
     * <code>repeated string actions = 2;</code>
     * @return The count of actions.
     */
    @java.lang.Override
    public int getActionsCount() {
      return actions_.size();
    }
    /**
     * <code>repeated string actions = 2;</code>
     * @param index The index of the element to return.
     * @return The actions at the given index.
     */
    @java.lang.Override
    public java.lang.String getActions(int index) {
      return actions_.get(index);
    }
    /**
     * <code>repeated string actions = 2;</code>
     * @param index The index of the value to return.
     * @return The bytes of the actions at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getActionsBytes(int index) {
      return com.google.protobuf.ByteString.copyFromUtf8(
          actions_.get(index));
    }
    private void ensureActionsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<java.lang.String> tmp =
          actions_;  if (!tmp.isModifiable()) {
        actions_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <code>repeated string actions = 2;</code>
     * @param index The index to set the value at.
     * @param value The actions to set.
     */
    private void setActions(
        int index, java.lang.String value) {
      value.getClass();
  ensureActionsIsMutable();
      actions_.set(index, value);
    }
    /**
     * <code>repeated string actions = 2;</code>
     * @param value The actions to add.
     */
    private void addActions(
        java.lang.String value) {
      value.getClass();
  ensureActionsIsMutable();
      actions_.add(value);
    }
    /**
     * <code>repeated string actions = 2;</code>
     * @param values The actions to add.
     */
    private void addAllActions(
        java.lang.Iterable<java.lang.String> values) {
      ensureActionsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, actions_);
    }
    /**
     * <code>repeated string actions = 2;</code>
     */
    private void clearActions() {
      actions_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    /**
     * <code>repeated string actions = 2;</code>
     * @param value The bytes of the actions to add.
     */
    private void addActionsBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      ensureActionsIsMutable();
      actions_.add(value.toStringUtf8());
    }

    public static co.anode.anodium.Rpc.Op parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Op parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Op parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Op parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Op parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static co.anode.anodium.Rpc.Op parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Op parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Op parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Op parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Op parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static co.anode.anodium.Rpc.Op parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static co.anode.anodium.Rpc.Op parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(co.anode.anodium.Rpc.Op prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code co.anode.anodium.Op}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          co.anode.anodium.Rpc.Op, Builder> implements
        // @@protoc_insertion_point(builder_implements:co.anode.anodium.Op)
        co.anode.anodium.Rpc.OpOrBuilder {
      // Construct using co.anode.anodium.Rpc.Op.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>string entity = 1;</code>
       * @return The entity.
       */
      @java.lang.Override
      public java.lang.String getEntity() {
        return instance.getEntity();
      }
      /**
       * <code>string entity = 1;</code>
       * @return The bytes for entity.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getEntityBytes() {
        return instance.getEntityBytes();
      }
      /**
       * <code>string entity = 1;</code>
       * @param value The entity to set.
       * @return This builder for chaining.
       */
      public Builder setEntity(
          java.lang.String value) {
        copyOnWrite();
        instance.setEntity(value);
        return this;
      }
      /**
       * <code>string entity = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearEntity() {
        copyOnWrite();
        instance.clearEntity();
        return this;
      }
      /**
       * <code>string entity = 1;</code>
       * @param value The bytes for entity to set.
       * @return This builder for chaining.
       */
      public Builder setEntityBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setEntityBytes(value);
        return this;
      }

      /**
       * <code>repeated string actions = 2;</code>
       * @return A list containing the actions.
       */
      @java.lang.Override
      public java.util.List<java.lang.String>
          getActionsList() {
        return java.util.Collections.unmodifiableList(
            instance.getActionsList());
      }
      /**
       * <code>repeated string actions = 2;</code>
       * @return The count of actions.
       */
      @java.lang.Override
      public int getActionsCount() {
        return instance.getActionsCount();
      }
      /**
       * <code>repeated string actions = 2;</code>
       * @param index The index of the element to return.
       * @return The actions at the given index.
       */
      @java.lang.Override
      public java.lang.String getActions(int index) {
        return instance.getActions(index);
      }
      /**
       * <code>repeated string actions = 2;</code>
       * @param index The index of the value to return.
       * @return The bytes of the actions at the given index.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getActionsBytes(int index) {
        return instance.getActionsBytes(index);
      }
      /**
       * <code>repeated string actions = 2;</code>
       * @param index The index to set the value at.
       * @param value The actions to set.
       * @return This builder for chaining.
       */
      public Builder setActions(
          int index, java.lang.String value) {
        copyOnWrite();
        instance.setActions(index, value);
        return this;
      }
      /**
       * <code>repeated string actions = 2;</code>
       * @param value The actions to add.
       * @return This builder for chaining.
       */
      public Builder addActions(
          java.lang.String value) {
        copyOnWrite();
        instance.addActions(value);
        return this;
      }
      /**
       * <code>repeated string actions = 2;</code>
       * @param values The actions to add.
       * @return This builder for chaining.
       */
      public Builder addAllActions(
          java.lang.Iterable<java.lang.String> values) {
        copyOnWrite();
        instance.addAllActions(values);
        return this;
      }
      /**
       * <code>repeated string actions = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearActions() {
        copyOnWrite();
        instance.clearActions();
        return this;
      }
      /**
       * <code>repeated string actions = 2;</code>
       * @param value The bytes of the actions to add.
       * @return This builder for chaining.
       */
      public Builder addActionsBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addActionsBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:co.anode.anodium.Op)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new co.anode.anodium.Rpc.Op();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "entity_",
              "actions_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0001\u0000\u0001\u0208\u0002\u021a" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<co.anode.anodium.Rpc.Op> parser = PARSER;
          if (parser == null) {
            synchronized (co.anode.anodium.Rpc.Op.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<co.anode.anodium.Rpc.Op>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:co.anode.anodium.Op)
    private static final co.anode.anodium.Rpc.Op DEFAULT_INSTANCE;
    static {
      Op defaultInstance = new Op();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Op.class, defaultInstance);
    }

    public static co.anode.anodium.Rpc.Op getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Op> PARSER;

    public static com.google.protobuf.Parser<Op> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
